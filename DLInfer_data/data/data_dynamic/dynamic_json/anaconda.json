{
 "1": {
  "name": "context",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/arguments.py",
  "lineno": "136",
  "column": "4",
  "context": "s AbstractArguments(_AbstractArgumentsMixin):\n    context = None\n    argument_node = None\n    trailer = None\n\n\ndef ",
  "context_lines": "        raise NotImplementedError\n\n    def get_calling_nodes(self):\n        return []\n\n\nclass AbstractArguments(_AbstractArgumentsMixin):\n    context = None\n    argument_node = None\n    trailer = None\n\n\ndef unpack_arglist(arglist):\n    if arglist is None:\n",
  "slicing": [
   "    context = None\n",
   "        self.context = context\n",
   "            analysis.add(context, 'type-error-star', input_node, message=m)\n",
   "            analysis.add(context, 'type-error-star-star', input_node, message=m)\n"
  ]
 },
 "2": {
  "name": "argument_node",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/arguments.py",
  "lineno": "137",
  "column": "4",
  "context": "(_AbstractArgumentsMixin):\n    context = None\n    argument_node = None\n    trailer = None\n\n\ndef unpack_arglist(arglist):\n",
  "context_lines": "    def get_calling_nodes(self):\n        return []\n\n\nclass AbstractArguments(_AbstractArgumentsMixin):\n    context = None\n    argument_node = None\n    trailer = None\n\n\ndef unpack_arglist(arglist):\n    if arglist is None:\n        return\n\n",
  "slicing": [
   "    argument_node = None\n",
   "        self.argument_node = argument_node\n"
  ]
 },
 "3": {
  "name": "trailer",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/arguments.py",
  "lineno": "138",
  "column": "4",
  "context": ":\n    context = None\n    argument_node = None\n    trailer = None\n\n\ndef unpack_arglist(arglist):\n    if arglist is N",
  "context_lines": "        return []\n\n\nclass AbstractArguments(_AbstractArgumentsMixin):\n    context = None\n    argument_node = None\n    trailer = None\n\n\ndef unpack_arglist(arglist):\n    if arglist is None:\n        return\n\n",
  "slicing": [
   "    trailer = None\n",
   "        self.trailer = trailer  # Can be None, e.g. in a class definition.\n"
  ]
 },
 "4": {
  "name": "tree_node",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/base_value.py",
  "lineno": "142",
  "column": "4",
  "context": "\n    To be implemented by subclasses.\n    \"\"\"\n    tree_node = None\n    # Possible values: None, tuple, list, dict and",
  "context_lines": "class Value(HelperValueMixin):\n    \"\"\"\n    To be implemented by subclasses.\n    \"\"\"\n    tree_node = None\n    # Possible values: None, tuple, list, dict and set. Here to deal with these\n    # very important containers.\n    array_type = None\n\n    def __init__(self, inference_state, parent_context=None):\n",
  "slicing": [
   "    tree_node = None\n",
   "        self.tree_node = tree_node\n"
  ]
 },
 "5": {
  "name": "array_type",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/base_value.py",
  "lineno": "145",
  "column": "4",
  "context": "l with these\n    # very important containers.\n    array_type = None\n\n    def __init__(self, inference_state, parent_co",
  "context_lines": "    \"\"\"\n    tree_node = None\n    # Possible values: None, tuple, list, dict and set. Here to deal with these\n    # very important containers.\n    array_type = None\n\n    def __init__(self, inference_state, parent_context=None):\n        self.inference_state = inference_state\n        self.parent_context = parent_context\n\n",
  "slicing": "    array_type = None\n"
 },
 "6": {
  "name": "start_pos",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/names.py",
  "lineno": "27",
  "column": "4",
  "context": "n doc\n\n\nclass AbstractNameDefinition(object):\n    start_pos = None\n    string_name = None\n    parent_context = None\n ",
  "context_lines": "            doc += '\\n' + '-' * 30 + '\\n'\n        doc += name.py__doc__()\n    return doc\n\n\nclass AbstractNameDefinition(object):\n    start_pos = None\n    string_name = None\n    parent_context = None\n    tree_name = None\n    is_value_name = True\n",
  "slicing": "    start_pos = None\n"
 },
 "7": {
  "name": "string_name",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/names.py",
  "lineno": "28",
  "column": "4",
  "context": "tNameDefinition(object):\n    start_pos = None\n    string_name = None\n    parent_context = None\n    tree_name = None\n   ",
  "context_lines": "        doc += name.py__doc__()\n    return doc\n\n\nclass AbstractNameDefinition(object):\n    start_pos = None\n    string_name = None\n    parent_context = None\n    tree_name = None\n    is_value_name = True\n    \"\"\"\n",
  "slicing": [
   "    string_name = None\n",
   "        self.string_name = string_name\n"
  ]
 },
 "8": {
  "name": "parent_context",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/names.py",
  "lineno": "29",
  "column": "4",
  "context": ":\n    start_pos = None\n    string_name = None\n    parent_context = None\n    tree_name = None\n    is_value_name = True\n    ",
  "context_lines": "    return doc\n\n\nclass AbstractNameDefinition(object):\n    start_pos = None\n    string_name = None\n    parent_context = None\n    tree_name = None\n    is_value_name = True\n    \"\"\"\n    Used for the Jedi API to know if it's a keyword or an actual name.\n",
  "slicing": [
   "    parent_context = None\n",
   "        self.parent_context = parent_context\n",
   "        self._from_module_context = parent_context\n"
  ]
 },
 "9": {
  "name": "tree_name",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/names.py",
  "lineno": "30",
  "column": "4",
  "context": " string_name = None\n    parent_context = None\n    tree_name = None\n    is_value_name = True\n    \"\"\"\n    Used for the ",
  "context_lines": "class AbstractNameDefinition(object):\n    start_pos = None\n    string_name = None\n    parent_context = None\n    tree_name = None\n    is_value_name = True\n    \"\"\"\n    Used for the Jedi API to know if it's a keyword or an actual name.\n    \"\"\"\n\n",
  "slicing": [
   "    tree_name = None\n",
   "        self.tree_name = tree_name\n",
   "        super(ValueName, self).__init__(value.parent_context, tree_name)\n",
   "            function_value.get_default_param_context(), tree_name)\n",
   "        super(ParamName, self).__init__(function_value, tree_name)\n"
  ]
 },
 "10": {
  "name": "annotation_node",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/names.py",
  "lineno": "405",
  "column": "4",
  "context": "amName(ParamNameInterface, AbstractTreeName):\n    annotation_node = None\n    default_node = None\n\n    def to_string(self):\n",
  "context_lines": "        if kind == Parameter.VAR_KEYWORD:\n            return 2\n        return 0\n\n\nclass BaseTreeParamName(ParamNameInterface, AbstractTreeName):\n    annotation_node = None\n    default_node = None\n\n    def to_string(self):\n        output = self._kind_string() + self.get_public_name()\n        annotation = self.annotation_node\n",
  "slicing": "    annotation_node = None\n"
 },
 "11": {
  "name": "default_node",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/names.py",
  "lineno": "406",
  "column": "4",
  "context": "AbstractTreeName):\n    annotation_node = None\n    default_node = None\n\n    def to_string(self):\n        output = self._k",
  "context_lines": "            return 2\n        return 0\n\n\nclass BaseTreeParamName(ParamNameInterface, AbstractTreeName):\n    annotation_node = None\n    default_node = None\n\n    def to_string(self):\n        output = self._kind_string() + self.get_public_name()\n        annotation = self.annotation_node\n",
  "slicing": "    default_node = None\n"
 },
 "12": {
  "name": "code_lines",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/context.py",
  "lineno": "401",
  "column": "4",
  "context": "class CompiledModuleContext(CompiledContext):\n    code_lines = None\n\n    def get_value(self):\n        return self._val",
  "context_lines": "class CompiledContext(ValueContext):\n    def get_filters(self, until_position=None, origin_scope=None):\n        return self._value.get_filters()\n\n\nclass CompiledModuleContext(CompiledContext):\n    code_lines = None\n\n    def get_value(self):\n        return self._value\n\n    @property\n",
  "slicing": "    code_lines = None\n"
 },
 "13": {
  "name": "_until_position",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/filters.py",
  "lineno": "23",
  "column": "4",
  "context": "yDictionary()\n\n\nclass AbstractFilter(object):\n    _until_position = None\n\n    def _filter(self, names):\n        if self._un",
  "context_lines": "from jedi.inference.names import TreeNameDefinition, ParamName, \\\n    AnonymousParamName, AbstractNameDefinition\n\n_definition_name_cache = weakref.WeakKeyDictionary()\n\n\nclass AbstractFilter(object):\n    _until_position = None\n\n    def _filter(self, names):\n        if self._until_position is not None:\n            return [n for n in names if n.start_pos < self._until_position]\n",
  "slicing": "    _until_position = None\n"
 },
 "14": {
  "name": "name_wrapper_class",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/filters.py",
  "lineno": "40",
  "column": "4",
  "context": "plementedError\n\n\nclass FilterWrapper(object):\n    name_wrapper_class = None\n\n    def __init__(self, wrapped_filter):\n        s",
  "context_lines": "    @abstractmethod\n    def values(self):\n        raise NotImplementedError\n\n\nclass FilterWrapper(object):\n    name_wrapper_class = None\n\n    def __init__(self, wrapped_filter):\n        self._wrapped_filter = wrapped_filter\n\n    def wrap_names(self, names):\n",
  "slicing": "    name_wrapper_class = None\n"
 },
 "15": {
  "name": "dct",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/jedi/inference/filters.py",
  "lineno": "350",
  "column": "8",
  "context": "ion_match=None):\n    def decorator(func):\n        dct = func.__dict__.setdefault('registered_overwritten_methods', {})\n        dct[method_name] = func, python_version_ma",
  "context_lines": "                                       ValueWrapper)):\n    pass\n\n\ndef publish_method(method_name, python_version_match=None):\n    def decorator(func):\n        dct = func.__dict__.setdefault('registered_overwritten_methods', {})\n        dct[method_name] = func, python_version_match\n        return func\n",
  "slicing": [
   "        dct = func.__dict__.setdefault('registered_overwritten_methods', {})\n",
   "        dct[method_name] = func, python_version_match\n"
  ]
 },
 "16": {
  "name": "file_io",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/compiled/value.py",
  "lineno": "295",
  "column": "4",
  "context": "n None\n\n\nclass CompiledModule(CompiledValue):\n    file_io = None  # For modules\n\n    def _as_context(self):\n        return Compile",
  "context_lines": "        if self.access_handle.get_repr() in ('None', \"<class 'NoneType'>\"):\n            return 'None'\n        return None\n\n\nclass CompiledModule(CompiledValue):\n    file_io = None  # For modules\n\n    def _as_context(self):\n        return CompiledModuleContext(self)\n\n    def py__path__(self):\n",
  "slicing": "    file_io = None  # For modules\n"
 },
 "17": {
  "name": "_arguments",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/value/instance.py",
  "lineno": "402",
  "column": "4",
  "context": "\n\nclass AnonymousInstance(_BaseTreeInstance):\n    _arguments = None\n\n\nclass CompiledInstanceName(compiled.CompiledName",
  "context_lines": "    def __repr__(self):\n        return \"<%s of %s(%s)>\" % (self.__class__.__name__, self.class_value,\n                                   self._arguments)\n\n\nclass AnonymousInstance(_BaseTreeInstance):\n    _arguments = None\n\n\nclass CompiledInstanceName(compiled.CompiledName):\n    def __init__(self, inference_state, instance, klass, name):\n        parent_value = klass.parent_context.get_value()\n",
  "slicing": "    _arguments = None\n"
 },
 "18": {
  "name": "get_safe_value",
  "type": "function",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/jedi/inference/value/iterable.py",
  "lineno": "42",
  "column": "8",
  "context": "elf)\n            return default\n    else:\n        get_safe_value = Value.get_safe_value\n\n\nclass GeneratorBase(LazyAttributeOverwrite, Iter",
  "context_lines": "            if default is sentinel:\n                raise ValueError(\"There exists no safe value for value %s\" % self)\n            return default\n    else:\n        get_safe_value = Value.get_safe_value\n\n\nclass GeneratorBase(LazyAttributeOverwrite, IterableMixin):\n    array_type = None\n\n    def _get_wrapped_value(self):\n",
  "slicing": "        get_safe_value = Value.get_safe_value\n"
 },
 "19": {
  "name": "array_type",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/inference/value/iterable.py",
  "lineno": "46",
  "column": "4",
  "context": "rBase(LazyAttributeOverwrite, IterableMixin):\n    array_type = None\n\n    def _get_wrapped_value(self):\n        generat",
  "context_lines": "            return default\n    else:\n        get_safe_value = Value.get_safe_value\n\n\nclass GeneratorBase(LazyAttributeOverwrite, IterableMixin):\n    array_type = None\n\n    def _get_wrapped_value(self):\n        generator, = self.inference_state.typing_module \\\n            .py__getattribute__('Generator') \\\n",
  "slicing": "    array_type = None\n"
 },
 "20": {
  "name": "_environment",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/api/project.py",
  "lineno": "74",
  "column": "4",
  "context": " functions to search a whole project.\n    \"\"\"\n    _environment = None\n\n    @staticmethod\n    def _get_config_folder_path",
  "context_lines": "    Projects are a simple way to manage Python folders and define how Jedi does\n    import resolution. It is mostly used as a parameter to :class:`.Script`.\n    Additionally there are functions to search a whole project.\n    \"\"\"\n    _environment = None\n\n    @staticmethod\n    def _get_config_folder_path(base_path):\n        return os.path.join(base_path, _CONFIG_FOLDER)\n\n",
  "slicing": "    _environment = None\n"
 },
 "21": {
  "name": "_subprocess",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/jedi/api/environment.py",
  "lineno": "62",
  "column": "4",
  "context": "It is then returned by that function.\n    \"\"\"\n    _subprocess = None\n\n    def __init__(self, executable):\n        self.",
  "context_lines": "    This class is supposed to be created by internal Jedi architecture. You\n    should not create it directly. Please use create_environment or the other\n    functions instead. It is then returned by that function.\n    \"\"\"\n    _subprocess = None\n\n    def __init__(self, executable):\n        self._start_executable = executable\n        # Initialize the environment\n",
  "slicing": "    _subprocess = None\n"
 },
 "22": {
  "name": "_error_normalizer_config",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/grammar.py",
  "lineno": "28",
  "column": "4",
  "context": "m text: A BNF representation of your grammar.\n    _error_normalizer_config = None\n    _token_namespace = None\n    _default_normalize",
  "context_lines": "    :py:func:`parso.load_grammar` returns instances of this class.\n\n    Creating custom none-python grammars by calling this is not supported, yet.\n    \"\"\"\n    #:param text: A BNF representation of your grammar.\n    _error_normalizer_config = None\n    _token_namespace = None\n    _default_normalizer_config = pep8.PEP8NormalizerConfig()\n\n    def __init__(self, text, tokenizer, parser=BaseParser, diff_parser=None):\n        self._pgen_grammar = generate_grammar(\n",
  "slicing": "    _error_normalizer_config = None\n"
 },
 "23": {
  "name": "_token_namespace",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/grammar.py",
  "lineno": "29",
  "column": "4",
  "context": " grammar.\n    _error_normalizer_config = None\n    _token_namespace = None\n    _default_normalizer_config = pep8.PEP8Normaliz",
  "context_lines": "    Creating custom none-python grammars by calling this is not supported, yet.\n    \"\"\"\n    #:param text: A BNF representation of your grammar.\n    _error_normalizer_config = None\n    _token_namespace = None\n    _default_normalizer_config = pep8.PEP8NormalizerConfig()\n\n    def __init__(self, text, tokenizer, parser=BaseParser, diff_parser=None):\n        self._pgen_grammar = generate_grammar(\n            text,\n",
  "slicing": "    _token_namespace = None\n"
 },
 "24": {
  "name": "_default_normalizer_config",
  "type": "PEP8NormalizerConfig",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/parso/grammar.py",
  "lineno": "30",
  "column": "4",
  "context": "zer_config = None\n    _token_namespace = None\n    _default_normalizer_config = pep8.PEP8NormalizerConfig()\n\n    def __init__(self, text, tokenizer, parser=Ba",
  "context_lines": "    \"\"\"\n    #:param text: A BNF representation of your grammar.\n    _error_normalizer_config = None\n    _token_namespace = None\n    _default_normalizer_config = pep8.PEP8NormalizerConfig()\n\n    def __init__(self, text, tokenizer, parser=BaseParser, diff_parser=None):\n        self._pgen_grammar = generate_grammar(\n            text,\n",
  "slicing": "    _default_normalizer_config = pep8.PEP8NormalizerConfig()\n"
 },
 "25": {
  "name": "type",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/tree.py",
  "lineno": "28",
  "column": "4",
  "context": " nodes and leaves.\n    \"\"\"\n    __slots__ = ()\n    type = None\n    '''\n    The type is a string that typically ma",
  "context_lines": "    \"\"\"\n    The base class for nodes and leaves.\n    \"\"\"\n    __slots__ = ()\n    type = None\n    '''\n    The type is a string that typically matches the types of the grammar file.\n    '''\n\n    def get_root_node(self):\n",
  "slicing": [
   "    type = None\n",
   "        return \"<%s: %s>\" % (type(self).__name__, value)\n",
   "        self.type = type\n",
   "            (type(self).__name__, code, self.start_pos[0], self.start_pos[1])\n",
   "        self.type = type\n",
   "            (type(self).__name__, self.token_type, repr(self.value), self.start_pos)\n"
  ]
 },
 "26": {
  "name": "type",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/tree.py",
  "lineno": "263",
  "column": "4",
  "context": "   \"\"\"\n    __slots__ = ('children', 'parent')\n    type = None\n\n    def __init__(self, children):\n        self.ch",
  "context_lines": "    The super class for all nodes.\n    A node has children, a type and possibly a parent node.\n    \"\"\"\n    __slots__ = ('children', 'parent')\n    type = None\n\n    def __init__(self, children):\n        self.children = children\n        \"\"\"\n",
  "slicing": [
   "    type = None\n",
   "            (type(self).__name__, code, self.start_pos[0], self.start_pos[1])\n",
   "        self.type = type\n",
   "            (type(self).__name__, self.token_type, repr(self.value), self.start_pos)\n"
  ]
 },
 "27": {
  "name": "new_cls",
  "type": "_NormalizerMeta",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/parso/normalizer.py",
  "lineno": "8",
  "column": "8",
  "context": ":\n    def __new__(cls, name, bases, dct):\n        new_cls = type.__new__(cls, name, bases, dct)\n        new_cls.rule_value_classes = {}\n        ne",
  "context_lines": "from contextlib import contextmanager\n\nfrom parso._compatibility import use_metaclass\n\n\nclass _NormalizerMeta(type):\n    def __new__(cls, name, bases, dct):\n        new_cls = type.__new__(cls, name, bases, dct)\n        new_cls.rule_value_classes = {}\n        new_cls.rule_type_classes = {}\n        return new_cls\n\n\nclass Normalizer(use_metaclass(_NormalizerMeta)):\n",
  "slicing": [
   "        new_cls = type.__new__(cls, name, bases, dct)\n",
   "        new_cls.rule_value_classes = {}\n",
   "        new_cls.rule_type_classes = {}\n",
   "        return new_cls\n"
  ]
 },
 "28": {
  "name": "code",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/normalizer.py",
  "lineno": "154",
  "column": "4",
  "context": "__.__name__, self.code)\n\n\nclass Rule(object):\n    code = None\n    message = None\n\n    def __init__(self, normali",
  "context_lines": "        return hash((self.code, self.start_pos))\n\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__, self.code)\n\n\nclass Rule(object):\n    code = None\n    message = None\n\n    def __init__(self, normalizer):\n        self._normalizer = normalizer\n\n    def is_issue(self, node):\n",
  "slicing": [
   "    code = None\n",
   "        if code is None:\n",
   "            if code is None:\n",
   "        self._normalizer.add_issue(node, code, message)\n"
  ]
 },
 "29": {
  "name": "message",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/normalizer.py",
  "lineno": "155",
  "column": "4",
  "context": "f.code)\n\n\nclass Rule(object):\n    code = None\n    message = None\n\n    def __init__(self, normalizer):\n        self.",
  "context_lines": "    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__, self.code)\n\n\nclass Rule(object):\n    code = None\n    message = None\n\n    def __init__(self, normalizer):\n        self._normalizer = normalizer\n\n    def is_issue(self, node):\n",
  "slicing": [
   "    message = None\n",
   "        if message is None:\n",
   "            if message is None:\n",
   "        return message\n",
   "        message = self._get_message(message)\n",
   "        self._normalizer.add_issue(node, code, message)\n"
  ]
 },
 "30": {
  "name": "default_node",
  "type": "type",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/parso/parser.py",
  "lineno": "112",
  "column": "4",
  "context": "overy() is called.\n    \"\"\"\n\n    node_map = {}\n    default_node = tree.Node\n\n    leaf_map = {\n    }\n    default_leaf = tree.Le",
  "context_lines": "    See python/tokenize.py for how to get input tokens by a string.\n\n    When a syntax error occurs, error_recovery() is called.\n    \"\"\"\n\n    node_map = {}\n    default_node = tree.Node\n\n    leaf_map = {\n    }\n    default_leaf = tree.Leaf\n\n",
  "slicing": "    default_node = tree.Node\n"
 },
 "31": {
  "name": "default_leaf",
  "type": "type",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/parso/parser.py",
  "lineno": "116",
  "column": "4",
  "context": "ault_node = tree.Node\n\n    leaf_map = {\n    }\n    default_leaf = tree.Leaf\n\n    def __init__(self, pgen_grammar, start_nonter",
  "context_lines": "    node_map = {}\n    default_node = tree.Node\n\n    leaf_map = {\n    }\n    default_leaf = tree.Leaf\n\n    def __init__(self, pgen_grammar, start_nonterminal='file_input', error_recovery=False):\n        self._pgen_grammar = pgen_grammar\n        self._start_nonterminal = start_nonterminal\n",
  "slicing": "    default_leaf = tree.Leaf\n"
 },
 "32": {
  "name": "__hash__",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/pgen2/generator.py",
  "lineno": "114",
  "column": "4",
  "context": "            return False\n        return True\n\n    __hash__ = None  # For Py3 compatibility.\n\n    def __repr__(self):\n        return '<%s: %s i",
  "context_lines": "        for label, next_ in self.arcs.items():\n            if next_ is not other.arcs.get(label):\n                return False\n        return True\n\n    __hash__ = None  # For Py3 compatibility.\n\n    def __repr__(self):\n        return '<%s: %s is_final=%s>' % (\n            self.__class__.__name__, self.from_rule, self.is_final\n",
  "slicing": "    __hash__ = None  # For Py3 compatibility.\n"
 },
 "33": {
  "name": "VERTICAL_BRACKET",
  "type": "object",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/python/pep8.py",
  "lineno": "28",
  "column": "4",
  "context": " 'sliceop')\n\n\nclass IndentationTypes(object):\n    VERTICAL_BRACKET = object()\n    HANGING_BRACKET = object()\n    BACKSLASH = obj",
  "context_lines": "_NEEDS_SPACE += _BITWISE_OPERATOR\n_IMPLICIT_INDENTATION_TYPES = ('dictorsetmaker', 'argument')\n_POSSIBLE_SLICE_PARENTS = ('subscript', 'subscriptlist', 'sliceop')\n\n\nclass IndentationTypes(object):\n    VERTICAL_BRACKET = object()\n    HANGING_BRACKET = object()\n    BACKSLASH = object()\n    SUITE = object()\n    IMPLICIT = object()\n\n\n",
  "slicing": "    VERTICAL_BRACKET = object()\n"
 },
 "34": {
  "name": "HANGING_BRACKET",
  "type": "object",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/python/pep8.py",
  "lineno": "29",
  "column": "4",
  "context": "ypes(object):\n    VERTICAL_BRACKET = object()\n    HANGING_BRACKET = object()\n    BACKSLASH = object()\n    SUITE = object()\n    ",
  "context_lines": "_IMPLICIT_INDENTATION_TYPES = ('dictorsetmaker', 'argument')\n_POSSIBLE_SLICE_PARENTS = ('subscript', 'subscriptlist', 'sliceop')\n\n\nclass IndentationTypes(object):\n    VERTICAL_BRACKET = object()\n    HANGING_BRACKET = object()\n    BACKSLASH = object()\n    SUITE = object()\n    IMPLICIT = object()\n\n\nclass IndentationNode(object):\n",
  "slicing": "    HANGING_BRACKET = object()\n"
 },
 "35": {
  "name": "BACKSLASH",
  "type": "object",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/python/pep8.py",
  "lineno": "30",
  "column": "4",
  "context": "KET = object()\n    HANGING_BRACKET = object()\n    BACKSLASH = object()\n    SUITE = object()\n    IMPLICIT = object()\n\n\ncla",
  "context_lines": "_POSSIBLE_SLICE_PARENTS = ('subscript', 'subscriptlist', 'sliceop')\n\n\nclass IndentationTypes(object):\n    VERTICAL_BRACKET = object()\n    HANGING_BRACKET = object()\n    BACKSLASH = object()\n    SUITE = object()\n    IMPLICIT = object()\n\n\nclass IndentationNode(object):\n    type = IndentationTypes.SUITE\n\n",
  "slicing": "    BACKSLASH = object()\n"
 },
 "36": {
  "name": "SUITE",
  "type": "object",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/python/pep8.py",
  "lineno": "31",
  "column": "4",
  "context": "G_BRACKET = object()\n    BACKSLASH = object()\n    SUITE = object()\n    IMPLICIT = object()\n\n\nclass IndentationNode(ob",
  "context_lines": "class IndentationTypes(object):\n    VERTICAL_BRACKET = object()\n    HANGING_BRACKET = object()\n    BACKSLASH = object()\n    SUITE = object()\n    IMPLICIT = object()\n\n\nclass IndentationNode(object):\n    type = IndentationTypes.SUITE\n\n    def __init__(self, config, indentation, parent=None):\n",
  "slicing": "    SUITE = object()\n"
 },
 "37": {
  "name": "IMPLICIT",
  "type": "object",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/python/pep8.py",
  "lineno": "32",
  "column": "4",
  "context": "    BACKSLASH = object()\n    SUITE = object()\n    IMPLICIT = object()\n\n\nclass IndentationNode(object):\n    type = Indent",
  "context_lines": "    VERTICAL_BRACKET = object()\n    HANGING_BRACKET = object()\n    BACKSLASH = object()\n    SUITE = object()\n    IMPLICIT = object()\n\n\nclass IndentationNode(object):\n    type = IndentationTypes.SUITE\n\n    def __init__(self, config, indentation, parent=None):\n",
  "slicing": "    IMPLICIT = object()\n"
 },
 "38": {
  "name": "type",
  "type": "object",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/parso/python/pep8.py",
  "lineno": "36",
  "column": "4",
  "context": "T = object()\n\n\nclass IndentationNode(object):\n    type = IndentationTypes.SUITE\n\n    def __init__(self, config, indentation, paren",
  "context_lines": "    BACKSLASH = object()\n    SUITE = object()\n    IMPLICIT = object()\n\n\nclass IndentationNode(object):\n    type = IndentationTypes.SUITE\n\n    def __init__(self, config, indentation, parent=None):\n        self.bracket_indentation = self.indentation = indentation\n        self.parent = parent\n\n",
  "slicing": "    type = IndentationTypes.SUITE\n"
 },
 "39": {
  "name": "type",
  "type": "object",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/parso/python/pep8.py",
  "lineno": "123",
  "column": "4",
  "context": "= ' '\n\n\nclass BackslashNode(IndentationNode):\n    type = IndentationTypes.BACKSLASH\n\n    def __init__(self, config, parent_indentation",
  "context_lines": "        next_leaf = leaf.get_next_leaf()\n        if leaf == ':' and '\\n' not in next_leaf.prefix:\n            self.indentation += ' '\n\n\nclass BackslashNode(IndentationNode):\n    type = IndentationTypes.BACKSLASH\n\n    def __init__(self, config, parent_indentation, containing_leaf, spacing, parent=None):\n        expr_stmt = search_ancestor(containing_leaf, 'expr_stmt')\n        if expr_stmt is not None:\n",
  "slicing": "    type = IndentationTypes.BACKSLASH\n"
 },
 "40": {
  "name": "hanging_indentation",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/python/pep8.py",
  "lineno": "712",
  "column": "12",
  "context": "      if hanging_indentation is None:\n            hanging_indentation = indentation\n        self.hanging_indentation = hanging_indenta",
  "context_lines": "    def __init__(self, indentation=' ' * 4, hanging_indentation=None,\n                 max_characters=79, spaces_before_comment=2):\n        self.indentation = indentation\n        if hanging_indentation is None:\n            hanging_indentation = indentation\n        self.hanging_indentation = hanging_indentation\n        self.closing_bracket_hanging_indentation = ''\n        self.break_after_binary = False\n        self.max_characters = max_characters\n",
  "slicing": [
   "            hanging_indentation = indentation\n",
   "        self.hanging_indentation = hanging_indentation\n"
  ]
 },
 "41": {
  "name": "_fstring_grammar",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/parso/python/errors.py",
  "lineno": "865",
  "column": "4",
  "context": "pe='fstring')\nclass _FStringRule(SyntaxRule):\n    _fstring_grammar = None\n    message_expr = \"f-string expression part canno",
  "context_lines": "            elif default_except is not None:\n                self.add_issue(default_except, message=self.message)\n\n\n@ErrorFinder.register_rule(type='fstring')\nclass _FStringRule(SyntaxRule):\n    _fstring_grammar = None\n    message_expr = \"f-string expression part cannot include a backslash\"\n    message_nested = \"f-string: expressions nested too deeply\"\n    message_conversion = \"f-string: invalid conversion character: expected 's', 'r', or 'a'\"\n\n    def _check_format_spec(self, format_spec, depth):\n",
  "slicing": "    _fstring_grammar = None\n"
 },
 "42": {
  "name": "capture",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/parso/python/tokenize.py",
  "lineno": "65",
  "column": "4",
  "context": " return True\n\n\ndef group(*choices, **kwargs):\n    capture = kwargs.pop('capture', False)  # Python 2, arrghhhhh :(\n    assert not kwargs\n\n    start = '('\n    if not ",
  "context_lines": "    # but that doesn't really matter.\n    def is_identifier(s):\n        return True\n\n\ndef group(*choices, **kwargs):\n    capture = kwargs.pop('capture', False)  # Python 2, arrghhhhh :(\n    assert not kwargs\n\n    start = '('\n    if not capture:\n        start += '?:'\n",
  "slicing": [
   "    capture = kwargs.pop('capture', False)  # Python 2, arrghhhhh :(\n",
   "    if not capture:\n"
  ]
 },
 "43": {
  "name": "default_node",
  "type": "type",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/parso/python/parser.py",
  "lineno": "52",
  "column": "4",
  "context": "\n        'lambdef_nocond': tree.Lambda,\n    }\n    default_node = tree.PythonNode\n\n    # Names/Keywords are handled separately\n    _",
  "context_lines": "        'lambdef': tree.Lambda,\n        'old_lambdef': tree.Lambda,\n        'lambdef_nocond': tree.Lambda,\n    }\n    default_node = tree.PythonNode\n\n    # Names/Keywords are handled separately\n    _leaf_map = {\n        PythonTokenTypes.STRING: tree.String,\n",
  "slicing": "    default_node = tree.PythonNode\n"
 },
 "44": {
  "name": "VERSION",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/anaconda_mypy.py",
  "lineno": "41",
  "column": "4",
  "context": "ject):\n    \"\"\"MyPy class for Anaconda\n    \"\"\"\n    VERSION = parse_mypy_version()\n\n    def __init__(self, code, filename, mypypath, ",
  "context_lines": "        return None\n\n\nclass MyPy(object):\n    \"\"\"MyPy class for Anaconda\n    \"\"\"\n    VERSION = parse_mypy_version()\n\n    def __init__(self, code, filename, mypypath, settings):\n        self.code = code\n        self.filename = filename\n",
  "slicing": "    VERSION = parse_mypy_version()\n"
 },
 "45": {
  "name": "visitAssert",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "156",
  "column": "4",
  "context": "\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = vi",
  "context_lines": "        else:\n            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n",
  "slicing": "    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n"
 },
 "46": {
  "name": "visitAssign",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "156",
  "column": "18",
  "context": "     self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = vi",
  "context_lines": "        else:\n            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n",
  "slicing": "    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n"
 },
 "47": {
  "name": "visitAugAssign",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "156",
  "column": "32",
  "context": "ndPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = vi",
  "context_lines": "        else:\n            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n",
  "slicing": "    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n"
 },
 "48": {
  "name": "visitDelete",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "156",
  "column": "49",
  "context": "\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = vi",
  "context_lines": "        else:\n            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n",
  "slicing": "    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n"
 },
 "49": {
  "name": "visitPrint",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "156",
  "column": "63",
  "context": "rt = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = vi",
  "context_lines": "        else:\n            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n",
  "slicing": "    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n"
 },
 "50": {
  "name": "visitRaise",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "157",
  "column": "8",
  "context": "tAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = v",
  "context_lines": "            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n",
  "slicing": "        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n"
 },
 "51": {
  "name": "visitYield",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "157",
  "column": "21",
  "context": "visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = v",
  "context_lines": "            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n",
  "slicing": "        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n"
 },
 "52": {
  "name": "visitImport",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "157",
  "column": "34",
  "context": " visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = v",
  "context_lines": "            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n",
  "slicing": "        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n"
 },
 "53": {
  "name": "visitCall",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "157",
  "column": "48",
  "context": "\\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = v",
  "context_lines": "            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n",
  "slicing": "        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n"
 },
 "54": {
  "name": "visitSubscript",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "157",
  "column": "60",
  "context": "sitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = v",
  "context_lines": "            lineno = node.lineno\n        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n",
  "slicing": "        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n"
 },
 "55": {
  "name": "visitPass",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "158",
  "column": "8",
  "context": "itImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(se",
  "context_lines": "        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n        if self.graph is None:\n",
  "slicing": "        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n"
 },
 "56": {
  "name": "visitContinue",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "158",
  "column": "20",
  "context": "isitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(se",
  "context_lines": "        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n        if self.graph is None:\n",
  "slicing": "        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n"
 },
 "57": {
  "name": "visitBreak",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "158",
  "column": "36",
  "context": "Subscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(se",
  "context_lines": "        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n        if self.graph is None:\n",
  "slicing": "        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n"
 },
 "58": {
  "name": "visitGlobal",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "158",
  "column": "49",
  "context": "\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(se",
  "context_lines": "        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n        if self.graph is None:\n",
  "slicing": "        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n"
 },
 "59": {
  "name": "visitReturn",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "158",
  "column": "63",
  "context": "Pass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(se",
  "context_lines": "        name = \"Stmt %d\" % lineno\n        self.appendPathNode(name)\n\n    visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = \\\n        visitRaise = visitYield = visitImport = visitCall = visitSubscript = \\\n        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n        visitSimpleStatement\n\n    def visitLoop(self, node):\n        name = \"Loop %d\" % node.lineno\n\n        if self.graph is None:\n",
  "slicing": "        visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = \\\n"
 },
 "60": {
  "name": "visitFor",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "183",
  "column": "4",
  "context": "\n\n        # TODO: else clause in node.orelse\n\n    visitFor = visitWhile = visitLoop\n\n    def visitIf(self, node):\n        name = \"If %",
  "context_lines": "            self.graph.connect(self.tail, bottom)\n            self.graph.connect(pathnode, bottom)\n            self.tail = bottom\n\n        # TODO: else clause in node.orelse\n\n    visitFor = visitWhile = visitLoop\n\n    def visitIf(self, node):\n        name = \"If %d\" % node.lineno\n        pathnode = self.appendPathNode(name)\n",
  "slicing": "    visitFor = visitWhile = visitLoop\n"
 },
 "61": {
  "name": "visitWhile",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/mccabe.py",
  "lineno": "183",
  "column": "15",
  "context": " TODO: else clause in node.orelse\n\n    visitFor = visitWhile = visitLoop\n\n    def visitIf(self, node):\n        name = \"If %",
  "context_lines": "            self.graph.connect(self.tail, bottom)\n            self.graph.connect(pathnode, bottom)\n            self.tail = bottom\n\n        # TODO: else clause in node.orelse\n\n    visitFor = visitWhile = visitLoop\n\n    def visitIf(self, node):\n        name = \"If %d\" % node.lineno\n        pathnode = self.appendPathNode(name)\n",
  "slicing": "    visitFor = visitWhile = visitLoop\n"
 },
 "62": {
  "name": "args",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pycodestyle.py",
  "lineno": "186",
  "column": "8",
  "context": ", args)\n    if inspect.isfunction(check):\n        args = _get_parameters(check)\n        if args and args[0] in ('physical_line', '",
  "context_lines": "            _checks[kind][check][0].extend(codes or [])\n        else:\n            _checks[kind][check] = (codes or [''], args)\n    if inspect.isfunction(check):\n        args = _get_parameters(check)\n        if args and args[0] in ('physical_line', 'logical_line'):\n            if codes is None:\n                codes = ERRORCODE_REGEX.findall(check.__doc__ or '')\n            _add_check(check, args[0], codes, args)\n",
  "slicing": [
   "        args = _get_parameters(check)\n",
   "        if args and args[0] in ('physical_line', 'logical_line'):\n",
   "            _add_check(check, args[0], codes, args)\n",
   "        options_dict = dict(*args, **kwargs)\n",
   "        arglist = None if parse_argv else options_dict.get('paths', None)\n",
   "        verbose = options_dict.get('verbose', None)\n",
   "            arglist, parse_argv, config_file, parser, verbose)\n",
   "        if options_dict:\n",
   "            options.__dict__.update(options_dict)\n",
   "            if 'paths' in options_dict:\n",
   "                self.paths = options_dict['paths']\n",
   "            if verbose:\n",
   "                checks.append((check.__name__, check, args))\n",
   "    parent = tail = args and os.path.abspath(os.path.commonprefix(args))\n",
   "    while tail:\n",
   "        if config.read(os.path.join(parent, fn) for fn in PROJECT_CONFIG):\n",
   "            local_dir = parent\n",
   "                print('local configuration: in %s' % parent)\n",
   "        (parent, tail) = os.path.split(parent)\n",
   "                    value = normalize_paths(value, local_dir)\n",
   "            setattr(new_options, normalized_opt, value)\n",
   "        (options, __) = parser.parse_args(arglist, values=new_options)\n",
   "    options.doctest = options.testsuite = False\n",
   "    return options\n",
   "    if not arglist and not parse_argv:\n",
   "    (options, args) = parser.parse_args(arglist)\n",
   "    options.reporter = None\n",
   "    if verbose is not None:\n",
   "        options.verbose = verbose\n",
   "    if options.ensure_value('testsuite', False):\n",
   "        args.append(options.testsuite)\n",
   "    elif not options.ensure_value('doctest', False):\n",
   "        if parse_argv and not args:\n",
   "            if options.diff or any(os.path.exists(name)\n",
   "        options = read_config(options, args, arglist, parser)\n",
   "        options.reporter = parse_argv and options.quiet == 1 and FileReport\n",
   "    options.filename = _parse_multi_options(options.filename)\n",
   "    options.exclude = normalize_paths(options.exclude)\n",
   "    options.select = _parse_multi_options(options.select)\n",
   "    options.ignore = _parse_multi_options(options.ignore)\n",
   "    if options.diff:\n",
   "        options.reporter = DiffReport\n",
   "        options.selected_lines = parse_udiff(stdin, options.filename, args[0])\n",
   "        args = sorted(options.selected_lines)\n",
   "    return options, args\n",
   "    if options:\n",
   "        return [o.strip() for o in options.split(split_token) if o.strip()]\n",
   "        return options\n",
   "    if options.doctest or options.testsuite:\n",
   "    if options.statistics:\n",
   "    if options.benchmark:\n",
   "    if options.testsuite and not options.quiet:\n",
   "        if options.count:\n"
  ]
 },
 "63": {
  "name": "codes",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/linting/pycodestyle.py",
  "lineno": "189",
  "column": "16",
  "context": "'):\n            if codes is None:\n                codes = ERRORCODE_REGEX.findall(check.__doc__ or '')\n            _add_check(check, args[0], codes, args",
  "context_lines": "    if inspect.isfunction(check):\n        args = _get_parameters(check)\n        if args and args[0] in ('physical_line', 'logical_line'):\n            if codes is None:\n                codes = ERRORCODE_REGEX.findall(check.__doc__ or '')\n            _add_check(check, args[0], codes, args)\n    elif inspect.isclass(check):\n        if _get_parameters(check.__init__)[:2] == ['self', 'tree']:\n            _add_check(check, 'tree', codes, None)\n",
  "slicing": [
   "                codes = ERRORCODE_REGEX.findall(check.__doc__ or '')\n",
   "            _add_check(check, args[0], codes, args)\n",
   "            _add_check(check, 'tree', codes, None)\n",
   "            if any(not (code and self.ignore_code(code)) for code in codes):\n"
  ]
 },
 "64": {
  "name": "filename",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/violations.py",
  "lineno": "40",
  "column": "4",
  "context": "ition\n        self.explanation = explanation\n\n    filename = property(lambda self: self.definition.module.name)\n    line = property(lambda self: self.definition.s",
  "context_lines": "    def set_context(self, definition, explanation):\n        \"\"\"Set the source code context for this error.\"\"\"\n        self.definition = definition\n        self.explanation = explanation\n\n    filename = property(lambda self: self.definition.module.name)\n    line = property(lambda self: self.definition.start)\n\n    @property\n    def message(self):\n        \"\"\"Return the message to print to the user.\"\"\"\n",
  "slicing": "    filename = property(lambda self: self.definition.module.name)\n"
 },
 "65": {
  "name": "line",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/violations.py",
  "lineno": "41",
  "column": "4",
  "context": "rty(lambda self: self.definition.module.name)\n    line = property(lambda self: self.definition.start)\n\n    @property\n    def message(self):\n        \"\"\"R",
  "context_lines": "        \"\"\"Set the source code context for this error.\"\"\"\n        self.definition = definition\n        self.explanation = explanation\n\n    filename = property(lambda self: self.definition.module.name)\n    line = property(lambda self: self.definition.start)\n\n    @property\n    def message(self):\n        \"\"\"Return the message to print to the user.\"\"\"\n",
  "slicing": [
   "    line = property(lambda self: self.definition.start)\n",
   "            if line:\n",
   "                line = ' ' + line\n",
   "            source += line_format.format(n + offset, line)\n",
   "        return source\n"
  ]
 },
 "66": {
  "name": "error_params",
  "type": "pydocstyle",
  "class": "imported",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/violations.py",
  "lineno": "116",
  "column": "12",
  "context": "\"\"\"\n            # TODO: check prefix\n\n            error_params = ErrorParams(error_code, error_desc, error_context)\n            factory = partial(Error, *error_params",
  "context_lines": "            self.errors = []\n\n        def create_error(self, error_code, error_desc, error_context=None):\n            \"\"\"Create an error, register it to this group and return it.\"\"\"\n            # TODO: check prefix\n\n            error_params = ErrorParams(error_code, error_desc, error_context)\n            factory = partial(Error, *error_params)\n            self.errors.append(error_params)\n            return factory\n\n    @classmethod\n",
  "slicing": [
   "            error_params = ErrorParams(error_code, error_desc, error_context)\n",
   "            factory = partial(Error, *error_params)\n",
   "            self.errors.append(error_params)\n",
   "            return factory\n"
  ]
 },
 "67": {
  "name": "DEFAULT_CONVENTION",
  "type": "set",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/config.py",
  "lineno": "75",
  "column": "4",
  "context": "^\\.].*'\n    DEFAULT_IGNORE_DECORATORS_RE = ''\n    DEFAULT_CONVENTION = conventions.pep257\n\n    PROJECT_CONFIG_FILES = (\n        'setup.cfg',",
  "context_lines": "    BASE_ERROR_SELECTION_OPTIONS = ('ignore', 'select', 'convention')\n\n    DEFAULT_MATCH_RE = '(?!test_).*\\.py'\n    DEFAULT_MATCH_DIR_RE = '[^\\.].*'\n    DEFAULT_IGNORE_DECORATORS_RE = ''\n    DEFAULT_CONVENTION = conventions.pep257\n\n    PROJECT_CONFIG_FILES = (\n        'setup.cfg',\n        'tox.ini',\n",
  "slicing": "    DEFAULT_CONVENTION = conventions.pep257\n"
 },
 "68": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/wordlists.py",
  "lineno": "28",
  "column": "4",
  "context": "omments are stripped from each line.\n\n    \"\"\"\n    text = pkgutil.get_data('pydocstyle', 'data/' + name).decode('utf8')\n    for line in text.splitlines():\n        line = ",
  "context_lines": "    `name` should be the name of a package data file within the data/\n    directory.\n\n    Whitespace and #-prefixed comments are stripped from each line.\n\n    \"\"\"\n    text = pkgutil.get_data('pydocstyle', 'data/' + name).decode('utf8')\n    for line in text.splitlines():\n        line = COMMENT_RE.sub('', line).strip()\n        if line:\n            yield line\n\n\n",
  "slicing": [
   "    text = pkgutil.get_data('pydocstyle', 'data/' + name).decode('utf8')\n",
   "    for line in text.splitlines():\n",
   "        line = COMMENT_RE.sub('', line).strip()\n",
   "        if line:\n",
   "            yield line\n"
  ]
 },
 "69": {
  "name": "line",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/wordlists.py",
  "lineno": "30",
  "column": "8",
  "context": "utf8')\n    for line in text.splitlines():\n        line = COMMENT_RE.sub('', line).strip()\n        if line:\n            yield line\n\n\n#: A dic",
  "context_lines": "    Whitespace and #-prefixed comments are stripped from each line.\n\n    \"\"\"\n    text = pkgutil.get_data('pydocstyle', 'data/' + name).decode('utf8')\n    for line in text.splitlines():\n        line = COMMENT_RE.sub('', line).strip()\n        if line:\n            yield line\n\n\n#: A dict mapping stemmed verbs to the imperative form\nIMPERATIVE_VERBS = {stem(v): v for v in load_wordlist('imperatives.txt')}\n\n",
  "slicing": [
   "        line = COMMENT_RE.sub('', line).strip()\n",
   "        if line:\n",
   "            yield line\n"
  ]
 },
 "70": {
  "name": "_human",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "73",
  "column": "4",
  "context": "'children', 'parent', 'skipped_error_codes')\n\n    _human = property(lambda self: humanize(type(self).__name__))\n    kind = property(lambda self: self._human.split",
  "context_lines": "class Definition(Value):\n    \"\"\"A Python source code definition (could be class, function, etc).\"\"\"\n\n    _fields = ('name', '_source', 'start', 'end', 'decorators', 'docstring',\n               'children', 'parent', 'skipped_error_codes')\n\n    _human = property(lambda self: humanize(type(self).__name__))\n    kind = property(lambda self: self._human.split()[-1])\n    module = property(lambda self: self.parent.module)\n    all = property(lambda self: self.module.all)\n    _slice = property(lambda self: slice(self.start - 1, self.end))\n",
  "slicing": "    _human = property(lambda self: humanize(type(self).__name__))\n"
 },
 "71": {
  "name": "kind",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "74",
  "column": "4",
  "context": "y(lambda self: humanize(type(self).__name__))\n    kind = property(lambda self: self._human.split()[-1])\n    module = property(lambda self: self.parent.mod",
  "context_lines": "    \"\"\"A Python source code definition (could be class, function, etc).\"\"\"\n\n    _fields = ('name', '_source', 'start', 'end', 'decorators', 'docstring',\n               'children', 'parent', 'skipped_error_codes')\n\n    _human = property(lambda self: humanize(type(self).__name__))\n    kind = property(lambda self: self._human.split()[-1])\n    module = property(lambda self: self.parent.module)\n    all = property(lambda self: self.module.all)\n    _slice = property(lambda self: slice(self.start - 1, self.end))\n    is_class = False\n\n",
  "slicing": [
   "    kind = property(lambda self: self._human.split()[-1])\n",
   "        assert next_token.kind == kind\n",
   "            if (self.current.kind == kind and\n",
   "                self.consume(kind)\n",
   "        kind_valid = self.current.kind == kind if kind else True\n",
   "        assert kind_valid and value_valid, msg\n"
  ]
 },
 "72": {
  "name": "module",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "75",
  "column": "4",
  "context": "roperty(lambda self: self._human.split()[-1])\n    module = property(lambda self: self.parent.module)\n    all = property(lambda self: self.module.all)\n ",
  "context_lines": "    _fields = ('name', '_source', 'start', 'end', 'decorators', 'docstring',\n               'children', 'parent', 'skipped_error_codes')\n\n    _human = property(lambda self: humanize(type(self).__name__))\n    kind = property(lambda self: self._human.split()[-1])\n    module = property(lambda self: self.parent.module)\n    all = property(lambda self: self.module.all)\n    _slice = property(lambda self: slice(self.start - 1, self.end))\n    is_class = False\n\n    def __iter__(self):\n",
  "slicing": [
   "    module = property(lambda self: self.parent.module)\n",
   "        for child in module.children:\n",
   "            child.parent = module\n",
   "        module.future_imports = self.future_imports\n",
   "        return module\n",
   "            child.parent = definition\n"
  ]
 },
 "73": {
  "name": "all",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "76",
  "column": "4",
  "context": "e = property(lambda self: self.parent.module)\n    all = property(lambda self: self.module.all)\n    _slice = property(lambda self: slice(self.star",
  "context_lines": "               'children', 'parent', 'skipped_error_codes')\n\n    _human = property(lambda self: humanize(type(self).__name__))\n    kind = property(lambda self: self._human.split()[-1])\n    module = property(lambda self: self.parent.module)\n    all = property(lambda self: self.module.all)\n    _slice = property(lambda self: slice(self.start - 1, self.end))\n    is_class = False\n\n    def __iter__(self):\n        return chain([self], *self.children)\n\n",
  "slicing": [
   "    all = property(lambda self: self.module.all)\n",
   "            if all and self.current.value == '__all__':\n"
  ]
 },
 "74": {
  "name": "_slice",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "77",
  "column": "4",
  "context": " all = property(lambda self: self.module.all)\n    _slice = property(lambda self: slice(self.start - 1, self.end))\n    is_class = False\n\n    def __iter__(self):\n    ",
  "context_lines": "    _human = property(lambda self: humanize(type(self).__name__))\n    kind = property(lambda self: self._human.split()[-1])\n    module = property(lambda self: self.parent.module)\n    all = property(lambda self: self.module.all)\n    _slice = property(lambda self: slice(self.start - 1, self.end))\n    is_class = False\n\n    def __iter__(self):\n        return chain([self], *self.children)\n\n    @property\n",
  "slicing": "    _slice = property(lambda self: slice(self.start - 1, self.end))\n"
 },
 "75": {
  "name": "_nest",
  "type": "staticmethod",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "111",
  "column": "4",
  "context": "ports',\n               'skipped_error_codes')\n    _nest = staticmethod(lambda s: {'def': Function, 'class': Class}[s])\n    module = property(lambda self: self)\n    all =",
  "context_lines": "    \"\"\"A Python source code module.\"\"\"\n\n    _fields = ('name', '_source', 'start', 'end', 'decorators', 'docstring',\n               'children', 'parent', '_all', 'future_imports',\n               'skipped_error_codes')\n    _nest = staticmethod(lambda s: {'def': Function, 'class': Class}[s])\n    module = property(lambda self: self)\n    all = property(lambda self: self._all)\n\n    @property\n    def is_public(self):\n",
  "slicing": "    _nest = staticmethod(lambda s: {'def': Function, 'class': Class}[s])\n"
 },
 "76": {
  "name": "module",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "112",
  "column": "4",
  "context": "mbda s: {'def': Function, 'class': Class}[s])\n    module = property(lambda self: self)\n    all = property(lambda self: self._all)\n\n    @p",
  "context_lines": "    _fields = ('name', '_source', 'start', 'end', 'decorators', 'docstring',\n               'children', 'parent', '_all', 'future_imports',\n               'skipped_error_codes')\n    _nest = staticmethod(lambda s: {'def': Function, 'class': Class}[s])\n    module = property(lambda self: self)\n    all = property(lambda self: self._all)\n\n    @property\n    def is_public(self):\n        return not self.name.startswith('_') or self.name.startswith('__')\n\n",
  "slicing": [
   "    module = property(lambda self: self)\n",
   "        for child in module.children:\n",
   "            child.parent = module\n",
   "        module.future_imports = self.future_imports\n",
   "        return module\n",
   "            child.parent = definition\n"
  ]
 },
 "77": {
  "name": "all",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "113",
  "column": "4",
  "context": "[s])\n    module = property(lambda self: self)\n    all = property(lambda self: self._all)\n\n    @property\n    def is_public(self):\n        re",
  "context_lines": "               'children', 'parent', '_all', 'future_imports',\n               'skipped_error_codes')\n    _nest = staticmethod(lambda s: {'def': Function, 'class': Class}[s])\n    module = property(lambda self: self)\n    all = property(lambda self: self._all)\n\n    @property\n    def is_public(self):\n        return not self.name.startswith('_') or self.name.startswith('__')\n\n",
  "slicing": [
   "    all = property(lambda self: self._all)\n",
   "            if all and self.current.value == '__all__':\n"
  ]
 },
 "78": {
  "name": "_nest",
  "type": "staticmethod",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "130",
  "column": "4",
  "context": "n):\n    \"\"\"A Python source code function.\"\"\"\n\n    _nest = staticmethod(lambda s: {'def': NestedFunction,\n                                    'class': Neste",
  "context_lines": "class Package(Module):\n    \"\"\"A package is a __init__.py module.\"\"\"\n\n\nclass Function(Definition):\n    \"\"\"A Python source code function.\"\"\"\n\n    _nest = staticmethod(lambda s: {'def': NestedFunction,\n                                    'class': NestedClass}[s])\n\n    @property\n    def is_public(self):\n        \"\"\"Return True iff this function should be considered public.\"\"\"\n",
  "slicing": "    _nest = staticmethod(lambda s: {'def': NestedFunction,\n"
 },
 "79": {
  "name": "_nest",
  "type": "staticmethod",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "186",
  "column": "4",
  "context": "tion):\n    \"\"\"A Python source code class.\"\"\"\n\n    _nest = staticmethod(lambda s: {'def': Method, 'class': NestedClass}[s])\n    is_public = Function.is_public\n    is_class = ",
  "context_lines": "                          self.is_magic)\n        return self.parent.is_public and name_is_public\n\n\nclass Class(Definition):\n    \"\"\"A Python source code class.\"\"\"\n\n    _nest = staticmethod(lambda s: {'def': Method, 'class': NestedClass}[s])\n    is_public = Function.is_public\n    is_class = True\n\n\nclass NestedClass(Class):\n    \"\"\"A Python source code nested class.\"\"\"\n\n",
  "slicing": "    _nest = staticmethod(lambda s: {'def': Method, 'class': NestedClass}[s])\n"
 },
 "80": {
  "name": "is_public",
  "type": "property",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "187",
  "column": "4",
  "context": " s: {'def': Method, 'class': NestedClass}[s])\n    is_public = Function.is_public\n    is_class = True\n\n\nclass NestedClass(Class):\n  ",
  "context_lines": "        return self.parent.is_public and name_is_public\n\n\nclass Class(Definition):\n    \"\"\"A Python source code class.\"\"\"\n\n    _nest = staticmethod(lambda s: {'def': Method, 'class': NestedClass}[s])\n    is_public = Function.is_public\n    is_class = True\n\n\nclass NestedClass(Class):\n    \"\"\"A Python source code nested class.\"\"\"\n\n    @property\n",
  "slicing": "    is_public = Function.is_public\n"
 },
 "81": {
  "name": "current",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "302",
  "column": "4",
  "context": "\"\n        return self.parse(*args, **kwargs)\n\n    current = property(lambda self: self.stream.current)\n    line = property(lambda self: self.stream.line)",
  "context_lines": "    # TODO: remove\n    def __call__(self, *args, **kwargs):\n        \"\"\"Call the parse method.\"\"\"\n        return self.parse(*args, **kwargs)\n\n    current = property(lambda self: self.stream.current)\n    line = property(lambda self: self.stream.line)\n\n    def consume(self, kind):\n        \"\"\"Consume one token and verify it is of the expected kind.\"\"\"\n        next_token = self.stream.move()\n",
  "slicing": "    current = property(lambda self: self.stream.current)\n"
 },
 "82": {
  "name": "line",
  "type": "property",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pydocstyle/parser.py",
  "lineno": "303",
  "column": "4",
  "context": " = property(lambda self: self.stream.current)\n    line = property(lambda self: self.stream.line)\n\n    def consume(self, kind):\n        \"\"\"Consume o",
  "context_lines": "    def __call__(self, *args, **kwargs):\n        \"\"\"Call the parse method.\"\"\"\n        return self.parse(*args, **kwargs)\n\n    current = property(lambda self: self.stream.current)\n    line = property(lambda self: self.stream.line)\n\n    def consume(self, kind):\n        \"\"\"Consume one token and verify it is of the expected kind.\"\"\"\n        next_token = self.stream.move()\n",
  "slicing": "    line = property(lambda self: self.stream.line)\n"
 },
 "83": {
  "name": "visit_Assign",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "769",
  "column": "4",
  "context": "no] = node\n\n        self.generic_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visi",
  "context_lines": "        # if there is more than one typeable thing on a line last one wins\n        self.typeable_lines.append(node.lineno)\n        self.typeable_nodes[node.lineno] = node\n\n        self.generic_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    visitor = _TypeableVisitor()\n    visitor.visit(tree)\n\n",
  "slicing": "    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n"
 },
 "84": {
  "name": "visit_For",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "769",
  "column": "19",
  "context": "     self.generic_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visi",
  "context_lines": "        # if there is more than one typeable thing on a line last one wins\n        self.typeable_lines.append(node.lineno)\n        self.typeable_nodes[node.lineno] = node\n\n        self.generic_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    visitor = _TypeableVisitor()\n    visitor.visit(tree)\n\n",
  "slicing": "    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n"
 },
 "85": {
  "name": "visit_FunctionDef",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "769",
  "column": "31",
  "context": "neric_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visi",
  "context_lines": "        # if there is more than one typeable thing on a line last one wins\n        self.typeable_lines.append(node.lineno)\n        self.typeable_nodes[node.lineno] = node\n\n        self.generic_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    visitor = _TypeableVisitor()\n    visitor.visit(tree)\n\n",
  "slicing": "    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n"
 },
 "86": {
  "name": "visit_With",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "769",
  "column": "51",
  "context": "   visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visi",
  "context_lines": "        # if there is more than one typeable thing on a line last one wins\n        self.typeable_lines.append(node.lineno)\n        self.typeable_nodes[node.lineno] = node\n\n        self.generic_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    visitor = _TypeableVisitor()\n    visitor.visit(tree)\n\n",
  "slicing": "    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n"
 },
 "87": {
  "name": "visit_AsyncFor",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "770",
  "column": "4",
  "context": " = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    vi",
  "context_lines": "        self.typeable_lines.append(node.lineno)\n        self.typeable_nodes[node.lineno] = node\n\n        self.generic_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    visitor = _TypeableVisitor()\n    visitor.visit(tree)\n\n",
  "slicing": "    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n"
 },
 "88": {
  "name": "visit_AsyncFunctionDef",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "770",
  "column": "21",
  "context": "Def = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    vi",
  "context_lines": "        self.typeable_lines.append(node.lineno)\n        self.typeable_nodes[node.lineno] = node\n\n        self.generic_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    visitor = _TypeableVisitor()\n    visitor.visit(tree)\n\n",
  "slicing": "    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n"
 },
 "89": {
  "name": "visit_AsyncWith",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "770",
  "column": "46",
  "context": "ble\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    vi",
  "context_lines": "        self.typeable_lines.append(node.lineno)\n        self.typeable_nodes[node.lineno] = node\n\n        self.generic_visit(node)\n\n    visit_Assign = visit_For = visit_FunctionDef = visit_With = _typeable\n    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n\n\ndef _collect_type_comments(tree, tokens):\n    visitor = _TypeableVisitor()\n    visitor.visit(tree)\n\n",
  "slicing": "    visit_AsyncFor = visit_AsyncFunctionDef = visit_AsyncWith = _typeable\n"
 },
 "90": {
  "name": "offset",
  "type": "NoneType",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "827",
  "column": "4",
  "context": "nctionDef] = FunctionScope\n\n    nodeDepth = 0\n    offset = None\n    traceTree = False\n    _in_annotation = False\n ",
  "context_lines": "    }\n    if PY35_PLUS:\n        _ast_node_scope[ast.AsyncFunctionDef] = FunctionScope\n\n    nodeDepth = 0\n    offset = None\n    traceTree = False\n    _in_annotation = False\n    _in_typing_literal = False\n    _in_deferred = False\n\n",
  "slicing": [
   "    offset = None\n",
   "            self.offset = offset\n"
  ]
 },
 "91": {
  "name": "builtIns",
  "type": "set",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "833",
  "column": "4",
  "context": "ing_literal = False\n    _in_deferred = False\n\n    builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)\n    _customBuiltIns = os.environ.get('PYFLAKES_BUI",
  "context_lines": "    traceTree = False\n    _in_annotation = False\n    _in_typing_literal = False\n    _in_deferred = False\n\n    builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)\n    _customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')\n    if _customBuiltIns:\n        builtIns.update(_customBuiltIns.split(','))\n    del _customBuiltIns\n\n",
  "slicing": [
   "    builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)\n",
   "        builtIns.update(_customBuiltIns.split(','))\n"
  ]
 },
 "92": {
  "name": "_customBuiltIns",
  "type": "NoneType",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "834",
  "column": "4",
  "context": "Ins = set(builtin_vars).union(_MAGIC_GLOBALS)\n    _customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')\n    if _customBuiltIns:\n        builtIns.update(_c",
  "context_lines": "    _in_annotation = False\n    _in_typing_literal = False\n    _in_deferred = False\n\n    builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)\n    _customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')\n    if _customBuiltIns:\n        builtIns.update(_customBuiltIns.split(','))\n    del _customBuiltIns\n\n    # TODO: file_tokens= is required to perform checks on type comments,\n",
  "slicing": [
   "    _customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')\n",
   "    if _customBuiltIns:\n",
   "        builtIns.update(_customBuiltIns.split(','))\n"
  ]
 },
 "93": {
  "name": "_getDoctestExamples",
  "type": "method",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1352",
  "column": "4",
  "context": "odeDepth + 'end ' + node.__class__.__name__)\n\n    _getDoctestExamples = doctest.DocTestParser().get_examples\n\n    def handleDoctests(self, node):\n        try:\n",
  "context_lines": "        finally:\n            self.nodeDepth -= 1\n        if self.traceTree:\n            print('  ' * self.nodeDepth + 'end ' + node.__class__.__name__)\n\n    _getDoctestExamples = doctest.DocTestParser().get_examples\n\n    def handleDoctests(self, node):\n        try:\n            if hasattr(node, 'docstring'):\n",
  "slicing": "    _getDoctestExamples = doctest.DocTestParser().get_examples\n"
 },
 "94": {
  "name": "DELETE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1448",
  "column": "4",
  "context": " node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = E",
  "context_lines": "            self.handleNode(annotation, node)\n\n    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n",
  "slicing": "    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n"
 },
 "95": {
  "name": "PRINT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1448",
  "column": "13",
  "context": "       pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = E",
  "context_lines": "            self.handleNode(annotation, node)\n\n    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n",
  "slicing": "    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n"
 },
 "96": {
  "name": "FOR",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1448",
  "column": "21",
  "context": "ass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = E",
  "context_lines": "            self.handleNode(annotation, node)\n\n    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n",
  "slicing": "    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n"
 },
 "97": {
  "name": "ASYNCFOR",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1448",
  "column": "27",
  "context": "   # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = E",
  "context_lines": "            self.handleNode(annotation, node)\n\n    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n",
  "slicing": "    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n"
 },
 "98": {
  "name": "WHILE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1448",
  "column": "38",
  "context": " type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = E",
  "context_lines": "            self.handleNode(annotation, node)\n\n    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n",
  "slicing": "    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n"
 },
 "99": {
  "name": "WITH",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1448",
  "column": "46",
  "context": "des\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = E",
  "context_lines": "            self.handleNode(annotation, node)\n\n    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n",
  "slicing": "    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n"
 },
 "100": {
  "name": "WITHITEM",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1448",
  "column": "53",
  "context": " DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = E",
  "context_lines": "            self.handleNode(annotation, node)\n\n    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n",
  "slicing": "    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n"
 },
 "101": {
  "name": "ASYNCWITH",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1449",
  "column": "8",
  "context": " = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS =",
  "context_lines": "    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n",
  "slicing": "        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n"
 },
 "102": {
  "name": "ASYNCWITHITEM",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1449",
  "column": "20",
  "context": "= WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS =",
  "context_lines": "    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n",
  "slicing": "        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n"
 },
 "103": {
  "name": "TRYFINALLY",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1449",
  "column": "36",
  "context": " WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS =",
  "context_lines": "    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n",
  "slicing": "        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n"
 },
 "104": {
  "name": "EXEC",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1449",
  "column": "49",
  "context": "\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS =",
  "context_lines": "    def ignore(self, node):\n        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n",
  "slicing": "        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n"
 },
 "105": {
  "name": "EXPR",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1450",
  "column": "8",
  "context": "H = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BO",
  "context_lines": "        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n",
  "slicing": "        EXPR = ASSIGN = handleChildren\n"
 },
 "106": {
  "name": "ASSIGN",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1450",
  "column": "15",
  "context": "NCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BO",
  "context_lines": "        pass\n\n    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n",
  "slicing": "        EXPR = ASSIGN = handleChildren\n"
 },
 "107": {
  "name": "PASS",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1452",
  "column": "4",
  "context": "C = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SE",
  "context_lines": "    # \"stmt\" type nodes\n    DELETE = PRINT = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = \\\n        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n",
  "slicing": "    PASS = ignore\n"
 },
 "108": {
  "name": "BOOLOP",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1455",
  "column": "4",
  "context": "n\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAM",
  "context_lines": "        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n",
  "slicing": "    BOOLOP = UNARYOP = SET = \\\n"
 },
 "109": {
  "name": "UNARYOP",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1455",
  "column": "13",
  "context": "SS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAM",
  "context_lines": "        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n",
  "slicing": "    BOOLOP = UNARYOP = SET = \\\n"
 },
 "110": {
  "name": "SET",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1455",
  "column": "23",
  "context": "e\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAM",
  "context_lines": "        ASYNCWITH = ASYNCWITHITEM = TRYFINALLY = EXEC = \\\n        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n",
  "slicing": "    BOOLOP = UNARYOP = SET = \\\n"
 },
 "111": {
  "name": "REPR",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1456",
  "column": "8",
  "context": "type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handl",
  "context_lines": "        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n                (\n",
  "slicing": "        REPR = ATTRIBUTE = \\\n"
 },
 "112": {
  "name": "ATTRIBUTE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1456",
  "column": "15",
  "context": "des\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handl",
  "context_lines": "        EXPR = ASSIGN = handleChildren\n\n    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n                (\n",
  "slicing": "        REPR = ATTRIBUTE = \\\n"
 },
 "113": {
  "name": "STARRED",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1457",
  "column": "8",
  "context": "OP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n     ",
  "context_lines": "    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n                (\n",
  "slicing": "        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n"
 },
 "114": {
  "name": "NAMECONSTANT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1457",
  "column": "18",
  "context": " \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n     ",
  "context_lines": "    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n                (\n",
  "slicing": "        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n"
 },
 "115": {
  "name": "NAMEDEXPR",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1457",
  "column": "33",
  "context": " = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n     ",
  "context_lines": "    PASS = ignore\n\n    # \"expr\" type nodes\n    BOOLOP = UNARYOP = SET = \\\n        REPR = ATTRIBUTE = \\\n        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n\n    def SUBSCRIPT(self, node):\n        if (\n                (\n",
  "slicing": "        STARRED = NAMECONSTANT = NAMEDEXPR = handleChildren\n"
 },
 "116": {
  "name": "NUM",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1750",
  "column": "8",
  "context": "          return self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = I",
  "context_lines": "        def CONSTANT(self, node):\n            if isinstance(node.value, str):\n                return self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n",
  "slicing": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n"
 },
 "117": {
  "name": "BYTES",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1750",
  "column": "14",
  "context": "    return self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = I",
  "context_lines": "        def CONSTANT(self, node):\n            if isinstance(node.value, str):\n                return self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n",
  "slicing": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n"
 },
 "118": {
  "name": "ELLIPSIS",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1750",
  "column": "22",
  "context": "rn self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = I",
  "context_lines": "        def CONSTANT(self, node):\n            if isinstance(node.value, str):\n                return self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n",
  "slicing": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n"
 },
 "119": {
  "name": "CONSTANT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1750",
  "column": "33",
  "context": "(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = I",
  "context_lines": "        def CONSTANT(self, node):\n            if isinstance(node.value, str):\n                return self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n",
  "slicing": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n"
 },
 "120": {
  "name": "SLICE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1753",
  "column": "4",
  "context": "= CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too,",
  "context_lines": "                return self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n",
  "slicing": "    SLICE = EXTSLICE = INDEX = handleChildren\n"
 },
 "121": {
  "name": "EXTSLICE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1753",
  "column": "12",
  "context": "NT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too,",
  "context_lines": "                return self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n",
  "slicing": "    SLICE = EXTSLICE = INDEX = handleChildren\n"
 },
 "122": {
  "name": "INDEX",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1753",
  "column": "23",
  "context": "\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too,",
  "context_lines": "                return self.STR(node)\n    else:\n        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n",
  "slicing": "    SLICE = EXTSLICE = INDEX = handleChildren\n"
 },
 "123": {
  "name": "LOAD",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1756",
  "column": "4",
  "context": "re node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB",
  "context_lines": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n",
  "slicing": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n"
 },
 "124": {
  "name": "STORE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1756",
  "column": "11",
  "context": " instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB",
  "context_lines": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n",
  "slicing": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n"
 },
 "125": {
  "name": "DEL",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1756",
  "column": "19",
  "context": "es too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB",
  "context_lines": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n",
  "slicing": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n"
 },
 "126": {
  "name": "AUGLOAD",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1756",
  "column": "25",
  "context": ", though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB",
  "context_lines": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n",
  "slicing": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n"
 },
 "127": {
  "name": "AUGSTORE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1756",
  "column": "35",
  "context": "eing constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB",
  "context_lines": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n",
  "slicing": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n"
 },
 "128": {
  "name": "PARAM",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1756",
  "column": "46",
  "context": "nts\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB",
  "context_lines": "        NUM = BYTES = ELLIPSIS = CONSTANT = ignore\n\n    # \"slice\" type nodes\n    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n",
  "slicing": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n"
 },
 "129": {
  "name": "AND",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "4",
  "context": "RE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "130": {
  "name": "OR",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "10",
  "context": "ARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "131": {
  "name": "ADD",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "15",
  "context": "= ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "132": {
  "name": "SUB",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "21",
  "context": "re\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "133": {
  "name": "MULT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "27",
  "context": "  # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "134": {
  "name": "DIV",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "34",
  "context": "e for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "135": {
  "name": "MOD",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "40",
  "context": "operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "136": {
  "name": "POW",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "46",
  "context": "ors\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "137": {
  "name": "LSHIFT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "52",
  "context": "  AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "138": {
  "name": "RSHIFT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1759",
  "column": "61",
  "context": "R = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVER",
  "context_lines": "    SLICE = EXTSLICE = INDEX = handleChildren\n\n    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n",
  "slicing": "    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n"
 },
 "139": {
  "name": "BITOR",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1760",
  "column": "8",
  "context": "T = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = IS",
  "context_lines": "    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n",
  "slicing": "        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n"
 },
 "140": {
  "name": "BITXOR",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1760",
  "column": "16",
  "context": "= MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = IS",
  "context_lines": "    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n",
  "slicing": "        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n"
 },
 "141": {
  "name": "BITAND",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1760",
  "column": "25",
  "context": "OW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = IS",
  "context_lines": "    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n",
  "slicing": "        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n"
 },
 "142": {
  "name": "FLOORDIV",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1760",
  "column": "34",
  "context": "FT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = IS",
  "context_lines": "    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n",
  "slicing": "        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n"
 },
 "143": {
  "name": "INVERT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1760",
  "column": "45",
  "context": " = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = IS",
  "context_lines": "    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n",
  "slicing": "        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n"
 },
 "144": {
  "name": "NOT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1760",
  "column": "54",
  "context": "    BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = IS",
  "context_lines": "    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n",
  "slicing": "        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n"
 },
 "145": {
  "name": "UADD",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1760",
  "column": "60",
  "context": "TOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = IS",
  "context_lines": "    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n",
  "slicing": "        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n"
 },
 "146": {
  "name": "USUB",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1760",
  "column": "67",
  "context": "ITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = IS",
  "context_lines": "    # expression contexts are node instances too, though being constants\n    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n",
  "slicing": "        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n"
 },
 "147": {
  "name": "EQ",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "8",
  "context": "FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "148": {
  "name": "NOTEQ",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "13",
  "context": "DIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "149": {
  "name": "LT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "21",
  "context": "VERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "150": {
  "name": "LTE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "26",
  "context": "= NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "151": {
  "name": "GT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "32",
  "context": "= UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "152": {
  "name": "GTE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "37",
  "context": "D = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "153": {
  "name": "IS",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "43",
  "context": "UB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "154": {
  "name": "ISNOT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "48",
  "context": "\\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "155": {
  "name": "IN",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "56",
  "context": "  EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "156": {
  "name": "NOTIN",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1761",
  "column": "61",
  "context": "= NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node",
  "context_lines": "    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore\n\n    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n"
 },
 "157": {
  "name": "MATMULT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1762",
  "column": "8",
  "context": " = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChi",
  "context_lines": "    # same for operators\n    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \\\n        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \\\n        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \\\n        MATMULT = ignore\n\n    def RAISE(self, node):\n        self.handleChildren(node)\n\n        arg = get_raise_argument(node)\n\n",
  "slicing": "        MATMULT = ignore\n"
 },
 "158": {
  "name": "COMPREHENSION",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1778",
  "column": "4",
  "context": "plemented, node)\n\n    # additional node types\n    COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren\n\n    _in_fstring = False\n\n    def JOINEDSTR(self, ",
  "context_lines": "        elif is_notimplemented_name_node(arg):\n            # Handle \"raise NotImplemented\"\n            self.report(messages.RaiseNotImplemented, node)\n\n    # additional node types\n    COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren\n\n    _in_fstring = False\n\n    def JOINEDSTR(self, node):\n        if (\n",
  "slicing": "    COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren\n"
 },
 "159": {
  "name": "KEYWORD",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1778",
  "column": "20",
  "context": "\n\n    # additional node types\n    COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren\n\n    _in_fstring = False\n\n    def JOINEDSTR(self, ",
  "context_lines": "        elif is_notimplemented_name_node(arg):\n            # Handle \"raise NotImplemented\"\n            self.report(messages.RaiseNotImplemented, node)\n\n    # additional node types\n    COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren\n\n    _in_fstring = False\n\n    def JOINEDSTR(self, node):\n        if (\n",
  "slicing": "    COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren\n"
 },
 "160": {
  "name": "FORMATTEDVALUE",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1778",
  "column": "30",
  "context": "ditional node types\n    COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren\n\n    _in_fstring = False\n\n    def JOINEDSTR(self, ",
  "context_lines": "        elif is_notimplemented_name_node(arg):\n            # Handle \"raise NotImplemented\"\n            self.report(messages.RaiseNotImplemented, node)\n\n    # additional node types\n    COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren\n\n    _in_fstring = False\n\n    def JOINEDSTR(self, node):\n        if (\n",
  "slicing": "    COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren\n"
 },
 "161": {
  "name": "IFEXP",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1838",
  "column": "4",
  "context": "ple, node)\n        self.handleChildren(node)\n\n    IFEXP = IF\n\n    def ASSERT(self, node):\n        if isinstance",
  "context_lines": "    def IF(self, node):\n        if isinstance(node.test, ast.Tuple) and node.test.elts != []:\n            self.report(messages.IfTuple, node)\n        self.handleChildren(node)\n\n    IFEXP = IF\n\n    def ASSERT(self, node):\n        if isinstance(node.test, ast.Tuple) and node.test.elts != []:\n            self.report(messages.AssertTuple, node)\n",
  "slicing": "    IFEXP = IF\n"
 },
 "162": {
  "name": "NONLOCAL",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1875",
  "column": "4",
  "context": "               scope[node_name] = node_value\n\n    NONLOCAL = GLOBAL\n\n    def GENERATOREXP(self, node):\n        self.pu",
  "context_lines": "                # Bind name to non-global scopes, but as already \"used\".\n                node_value.used = (global_scope, node)\n                for scope in self.scopeStack[global_scope_index + 1:]:\n                    scope[node_name] = node_value\n\n    NONLOCAL = GLOBAL\n\n    def GENERATOREXP(self, node):\n        self.pushScope(GeneratorScope)\n        self.handleChildren(node)\n",
  "slicing": "    NONLOCAL = GLOBAL\n"
 },
 "163": {
  "name": "LISTCOMP",
  "type": "function",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1882",
  "column": "4",
  "context": "handleChildren(node)\n        self.popScope()\n\n    LISTCOMP = handleChildren if PY2 else GENERATOREXP\n\n    DICTCOMP = SETCOMP = GENERATOREXP\n\n    def NA",
  "context_lines": "    def GENERATOREXP(self, node):\n        self.pushScope(GeneratorScope)\n        self.handleChildren(node)\n        self.popScope()\n\n    LISTCOMP = handleChildren if PY2 else GENERATOREXP\n\n    DICTCOMP = SETCOMP = GENERATOREXP\n\n    def NAME(self, node):\n        \"\"\"\n",
  "slicing": "    LISTCOMP = handleChildren if PY2 else GENERATOREXP\n"
 },
 "164": {
  "name": "DICTCOMP",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1884",
  "column": "4",
  "context": "MP = handleChildren if PY2 else GENERATOREXP\n\n    DICTCOMP = SETCOMP = GENERATOREXP\n\n    def NAME(self, node):\n        \"\"\"\n        Han",
  "context_lines": "        self.pushScope(GeneratorScope)\n        self.handleChildren(node)\n        self.popScope()\n\n    LISTCOMP = handleChildren if PY2 else GENERATOREXP\n\n    DICTCOMP = SETCOMP = GENERATOREXP\n\n    def NAME(self, node):\n        \"\"\"\n        Handle occurrence of Name (which can be a load/store/delete access.)\n",
  "slicing": "    DICTCOMP = SETCOMP = GENERATOREXP\n"
 },
 "165": {
  "name": "SETCOMP",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1884",
  "column": "15",
  "context": "Children if PY2 else GENERATOREXP\n\n    DICTCOMP = SETCOMP = GENERATOREXP\n\n    def NAME(self, node):\n        \"\"\"\n        Han",
  "context_lines": "        self.pushScope(GeneratorScope)\n        self.handleChildren(node)\n        self.popScope()\n\n    LISTCOMP = handleChildren if PY2 else GENERATOREXP\n\n    DICTCOMP = SETCOMP = GENERATOREXP\n\n    def NAME(self, node):\n        \"\"\"\n        Handle occurrence of Name (which can be a load/store/delete access.)\n",
  "slicing": "    DICTCOMP = SETCOMP = GENERATOREXP\n"
 },
 "166": {
  "name": "BREAK",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1930",
  "column": "4",
  "context": "self.report(messages.BreakOutsideLoop, node)\n\n    BREAK = CONTINUE\n\n    def RETURN(self, node):\n        if isinstance",
  "context_lines": "        if isinstance(node, ast.Continue):\n            self.report(messages.ContinueOutsideLoop, node)\n        else:  # ast.Break\n            self.report(messages.BreakOutsideLoop, node)\n\n    BREAK = CONTINUE\n\n    def RETURN(self, node):\n        if isinstance(self.scope, (ClassScope, ModuleScope)):\n            self.report(messages.ReturnOutsideFunction, node)\n",
  "slicing": "    BREAK = CONTINUE\n"
 },
 "167": {
  "name": "AWAIT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1953",
  "column": "4",
  "context": "ue\n        self.handleNode(node.value, node)\n\n    AWAIT = YIELDFROM = YIELD\n\n    def FUNCTIONDEF(self, node):\n        for deco",
  "context_lines": "            self.report(messages.YieldOutsideFunction, node)\n            return\n\n        self.scope.isGenerator = True\n        self.handleNode(node.value, node)\n\n    AWAIT = YIELDFROM = YIELD\n\n    def FUNCTIONDEF(self, node):\n        for deco in node.decorator_list:\n            self.handleNode(deco, node)\n",
  "slicing": "    AWAIT = YIELDFROM = YIELD\n"
 },
 "168": {
  "name": "YIELDFROM",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1953",
  "column": "12",
  "context": "   self.handleNode(node.value, node)\n\n    AWAIT = YIELDFROM = YIELD\n\n    def FUNCTIONDEF(self, node):\n        for deco",
  "context_lines": "            self.report(messages.YieldOutsideFunction, node)\n            return\n\n        self.scope.isGenerator = True\n        self.handleNode(node.value, node)\n\n    AWAIT = YIELDFROM = YIELD\n\n    def FUNCTIONDEF(self, node):\n        for deco in node.decorator_list:\n            self.handleNode(deco, node)\n",
  "slicing": "    AWAIT = YIELDFROM = YIELD\n"
 },
 "169": {
  "name": "ASYNCFUNCTIONDEF",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "1967",
  "column": "4",
  "context": "rFunction(lambda: self.handleDoctests(node))\n\n    ASYNCFUNCTIONDEF = FUNCTIONDEF\n\n    def LAMBDA(self, node):\n        args = []\n   ",
  "context_lines": "        if (self.withDoctest and\n                not self._in_doctest() and\n                not isinstance(self.scope, FunctionScope)):\n            self.deferFunction(lambda: self.handleDoctests(node))\n\n    ASYNCFUNCTIONDEF = FUNCTIONDEF\n\n    def LAMBDA(self, node):\n        args = []\n        annotations = []\n\n",
  "slicing": "    ASYNCFUNCTIONDEF = FUNCTIONDEF\n"
 },
 "170": {
  "name": "LIST",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "2114",
  "column": "4",
  "context": "ent, node)\n        self.handleChildren(node)\n\n    LIST = TUPLE\n\n    def IMPORT(self, node):\n        for alias in ",
  "context_lines": "                    star_loc = i\n            if star_loc >= 1 << 8 or len(node.elts) - star_loc - 1 >= 1 << 24:\n                self.report(messages.TooManyExpressionsInStarredAssignment, node)\n        self.handleChildren(node)\n\n    LIST = TUPLE\n\n    def IMPORT(self, node):\n        for alias in node.names:\n            if '.' in alias.name and not alias.asname:\n",
  "slicing": "    LIST = TUPLE\n"
 },
 "171": {
  "name": "TRYEXCEPT",
  "type": "function",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/linting/pyflakes/checker.py",
  "lineno": "2179",
  "column": "4",
  "context": "      self.handleChildren(node, omit='body')\n\n    TRYEXCEPT = TRY\n\n    def EXCEPTHANDLER(self, node):\n        if PY2",
  "context_lines": "            self.handleNode(child, node)\n        self.exceptHandlers.pop()\n        # Process the other nodes: \"except:\", \"else:\", \"finally:\"\n        self.handleChildren(node, omit='body')\n\n    TRYEXCEPT = TRY\n\n    def EXCEPTHANDLER(self, node):\n        if PY2 or node.name is None:\n            self.handleChildren(node)\n",
  "slicing": "    TRYEXCEPT = TRY\n"
 },
 "172": {
  "name": "ch",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "36",
  "column": "8",
  "context": "r >= self.limit:\n            return False\n        ch = ord(self.current[self.cursor])\n        if ch > max or ch < min:\n            retur",
  "context_lines": "        self.ket              = other.ket\n\n    def in_grouping(self, s, min, max):\n        if self.cursor >= self.limit:\n            return False\n        ch = ord(self.current[self.cursor])\n        if ch > max or ch < min:\n            return False\n        ch -= min\n        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n",
  "slicing": [
   "        ch = ord(self.current[self.cursor])\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if ch > max or ch < min:\n",
   "        if not (ch > max or ch < min):\n",
   "        if not (ch > max or ch < min):\n"
  ]
 },
 "173": {
  "name": "ch",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "39",
  "column": "8",
  "context": "max or ch < min:\n            return False\n        ch -= min\n        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0",
  "context_lines": "            return False\n        ch = ord(self.current[self.cursor])\n        if ch > max or ch < min:\n            return False\n        ch -= min\n        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n            return False\n        self.cursor += 1\n        return True\n\n",
  "slicing": [
   "        ch -= min\n",
   "        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if ch > max or ch < min:\n",
   "        if not (ch > max or ch < min):\n",
   "        if not (ch > max or ch < min):\n"
  ]
 },
 "174": {
  "name": "ch",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "48",
  "column": "8",
  "context": ".limit_backward:\n            return False\n        ch = ord(self.current[self.cursor - 1])\n        if ch > max or ch < min:\n            retur",
  "context_lines": "        return True\n\n    def in_grouping_b(self, s, min, max):\n        if self.cursor <= self.limit_backward:\n            return False\n        ch = ord(self.current[self.cursor - 1])\n        if ch > max or ch < min:\n            return False\n        ch -= min\n        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n",
  "slicing": [
   "        ch = ord(self.current[self.cursor - 1])\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if ch > max or ch < min:\n",
   "        if not (ch > max or ch < min):\n",
   "        if not (ch > max or ch < min):\n"
  ]
 },
 "175": {
  "name": "ch",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "51",
  "column": "8",
  "context": "max or ch < min:\n            return False\n        ch -= min\n        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0",
  "context_lines": "            return False\n        ch = ord(self.current[self.cursor - 1])\n        if ch > max or ch < min:\n            return False\n        ch -= min\n        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n            return False\n        self.cursor -= 1\n        return True\n\n",
  "slicing": [
   "        ch -= min\n",
   "        if (s[ch >> 3] & (0x1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if ch > max or ch < min:\n",
   "        if not (ch > max or ch < min):\n",
   "        if not (ch > max or ch < min):\n"
  ]
 },
 "176": {
  "name": "ch",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "60",
  "column": "8",
  "context": "r >= self.limit:\n            return False\n        ch = ord(self.current[self.cursor])\n        if ch > max or ch < min:\n            self.",
  "context_lines": "        return True\n\n    def out_grouping(self, s, min, max):\n        if self.cursor >= self.limit:\n            return False\n        ch = ord(self.current[self.cursor])\n        if ch > max or ch < min:\n            self.cursor += 1\n            return True\n        ch -= min\n",
  "slicing": [
   "        ch = ord(self.current[self.cursor])\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if ch > max or ch < min:\n",
   "        if not (ch > max or ch < min):\n",
   "        if not (ch > max or ch < min):\n"
  ]
 },
 "177": {
  "name": "ch",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "64",
  "column": "8",
  "context": " self.cursor += 1\n            return True\n        ch -= min\n        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0",
  "context_lines": "        ch = ord(self.current[self.cursor])\n        if ch > max or ch < min:\n            self.cursor += 1\n            return True\n        ch -= min\n        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n            self.cursor += 1\n            return True\n        return False\n\n",
  "slicing": [
   "        ch -= min\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if ch > max or ch < min:\n",
   "        if not (ch > max or ch < min):\n",
   "        if not (ch > max or ch < min):\n"
  ]
 },
 "178": {
  "name": "ch",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "73",
  "column": "8",
  "context": ".limit_backward:\n            return False\n        ch = ord(self.current[self.cursor - 1])\n        if ch > max or ch < min:\n            self.",
  "context_lines": "        return False\n\n    def out_grouping_b(self, s, min, max):\n        if self.cursor <= self.limit_backward:\n            return False\n        ch = ord(self.current[self.cursor - 1])\n        if ch > max or ch < min:\n            self.cursor -= 1\n            return True\n        ch -= min\n",
  "slicing": [
   "        ch = ord(self.current[self.cursor - 1])\n",
   "        if ch > max or ch < min:\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if ch > max or ch < min:\n",
   "        if not (ch > max or ch < min):\n",
   "        if not (ch > max or ch < min):\n"
  ]
 },
 "179": {
  "name": "ch",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "77",
  "column": "8",
  "context": " self.cursor -= 1\n            return True\n        ch -= min\n        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0",
  "context_lines": "        ch = ord(self.current[self.cursor - 1])\n        if ch > max or ch < min:\n            self.cursor -= 1\n            return True\n        ch -= min\n        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n            self.cursor -= 1\n            return True\n        return False\n\n",
  "slicing": [
   "        ch -= min\n",
   "        if (s[ch >> 3] & (0X1 << (ch & 0x7))) == 0:\n",
   "        if ch > max or ch < min:\n",
   "        if ch > max or ch < min:\n",
   "        if not (ch > max or ch < min):\n",
   "        if not (ch > max or ch < min):\n"
  ]
 },
 "180": {
  "name": "j",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "143",
  "column": "8",
  "context": "ind_among(self, v, v_size):\n        i = 0\n        j = v_size\n\n        c = self.cursor\n        l = self.limit\n\n ",
  "context_lines": "    def eq_v_b(self, s):\n        return self.eq_s_b(len(s), s)\n\n    def find_among(self, v, v_size):\n        i = 0\n        j = v_size\n\n        c = self.cursor\n        l = self.limit\n\n        common_i = 0\n",
  "slicing": [
   "        j = v_size\n",
   "            k = i + ((j - i) >> 1)\n",
   "            w = v[k]\n",
   "            for i2 in range(common, w.s_size):\n",
   "                diff = ord(self.current[c + common]) - ord(w.s[i2])\n",
   "                if diff != 0:\n",
   "            if diff < 0:\n",
   "                j = k\n",
   "                i = k\n",
   "            if j - i <= 1:\n",
   "                if i > 0:\n",
   "                if j == i:\n",
   "            w = v[i]\n",
   "            if common_i >= w.s_size:\n",
   "                self.cursor = c + w.s_size\n",
   "                if w.method is None:\n",
   "                    return w.result\n",
   "                method = getattr(self, w.method)\n",
   "                res = method()\n",
   "                self.cursor = c + w.s_size\n",
   "                if res:\n",
   "                    return w.result\n",
   "            i = w.substring_i\n",
   "            if i < 0:\n",
   "            k = i + ((j - i) >> 1)\n",
   "            w = v[k]\n",
   "            for i2 in range(w.s_size - 1 - common, -1, -1):\n",
   "                diff = ord(self.current[c - 1 - common]) - ord(w.s[i2])\n",
   "                if diff != 0:\n",
   "            if diff < 0:\n",
   "                j = k\n",
   "                i = k\n",
   "            if j - i <= 1:\n",
   "                if i > 0:\n",
   "                if j == i:\n",
   "            w = v[i]\n",
   "            if common_i >= w.s_size:\n",
   "                self.cursor = c - w.s_size\n",
   "                if w.method is None:\n",
   "                    return w.result\n",
   "                method = getattr(self, w.method)\n",
   "                res = method()\n",
   "                self.cursor = c - w.s_size\n",
   "                if res:\n",
   "                    return w.result\n",
   "            i = w.substring_i\n",
   "            if i < 0:\n"
  ]
 },
 "181": {
  "name": "l",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "146",
  "column": "8",
  "context": "      j = v_size\n\n        c = self.cursor\n        l = self.limit\n\n        common_i = 0\n        common_j = 0\n\n      ",
  "context_lines": "    def find_among(self, v, v_size):\n        i = 0\n        j = v_size\n\n        c = self.cursor\n        l = self.limit\n\n        common_i = 0\n        common_j = 0\n\n        first_key_inspected = False\n\n",
  "slicing": [
   "        l = self.limit\n",
   "                if c + common == l:\n"
  ]
 },
 "182": {
  "name": "common",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "156",
  "column": "12",
  "context": "+ ((j - i) >> 1)\n            diff = 0\n            common = min(common_i, common_j) # smalle\n            w = v[k]\n            for i2 in range(c",
  "context_lines": "        first_key_inspected = False\n\n        while True:\n            k = i + ((j - i) >> 1)\n            diff = 0\n            common = min(common_i, common_j) # smalle\n            w = v[k]\n            for i2 in range(common, w.s_size):\n                if c + common == l:\n                    diff = -1\n",
  "slicing": [
   "            common = min(common_i, common_j) # smalle\n",
   "            for i2 in range(common, w.s_size):\n",
   "                if c + common == l:\n",
   "                diff = ord(self.current[c + common]) - ord(w.s[i2])\n",
   "                if diff != 0:\n",
   "            if diff < 0:\n",
   "                common_j = common\n",
   "                common_i = common\n",
   "            if common_i >= w.s_size:\n",
   "            common = min(common_i, common_j)\n",
   "            for i2 in range(w.s_size - 1 - common, -1, -1):\n",
   "                if c - common == lb:\n",
   "                diff = ord(self.current[c - 1 - common]) - ord(w.s[i2])\n",
   "                if diff != 0:\n",
   "            if diff < 0:\n",
   "                common_j = common\n",
   "                common_i = common\n",
   "            if common_i >= w.s_size:\n"
  ]
 },
 "183": {
  "name": "j",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "167",
  "column": "16",
  "context": "mon += 1\n            if diff < 0:\n                j = k\n                common_j = common\n            else",
  "context_lines": "                if diff != 0:\n                    break\n                common += 1\n            if diff < 0:\n                j = k\n                common_j = common\n            else:\n                i = k\n                common_i = common\n",
  "slicing": [
   "                j = k\n",
   "            if j - i <= 1:\n",
   "                if j == i:\n",
   "            k = i + ((j - i) >> 1)\n",
   "            w = v[k]\n",
   "            for i2 in range(w.s_size - 1 - common, -1, -1):\n",
   "                diff = ord(self.current[c - 1 - common]) - ord(w.s[i2])\n",
   "                if diff != 0:\n",
   "            if diff < 0:\n",
   "                j = k\n",
   "                i = k\n",
   "            if j - i <= 1:\n",
   "                if i > 0:\n",
   "                if j == i:\n",
   "            w = v[i]\n",
   "            if common_i >= w.s_size:\n",
   "                self.cursor = c - w.s_size\n",
   "                if w.method is None:\n",
   "                    return w.result\n",
   "                method = getattr(self, w.method)\n",
   "                res = method()\n",
   "                self.cursor = c - w.s_size\n",
   "                if res:\n",
   "                    return w.result\n",
   "            i = w.substring_i\n",
   "            if i < 0:\n"
  ]
 },
 "184": {
  "name": "i",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "170",
  "column": "16",
  "context": "mmon_j = common\n            else:\n                i = k\n                common_i = common\n            if j",
  "context_lines": "            if diff < 0:\n                j = k\n                common_j = common\n            else:\n                i = k\n                common_i = common\n            if j - i <= 1:\n                if i > 0:\n                    break # v->s has been inspected\n",
  "slicing": [
   "                i = k\n",
   "            if j - i <= 1:\n",
   "                if i > 0:\n",
   "                if j == i:\n",
   "            w = v[i]\n",
   "            if common_i >= w.s_size:\n",
   "                self.cursor = c + w.s_size\n",
   "                if w.method is None:\n",
   "                    return w.result\n",
   "                method = getattr(self, w.method)\n",
   "                res = method()\n",
   "                self.cursor = c + w.s_size\n",
   "                if res:\n",
   "                    return w.result\n",
   "            i = w.substring_i\n",
   "            if i < 0:\n",
   "            k = i + ((j - i) >> 1)\n",
   "            w = v[k]\n",
   "            for i2 in range(w.s_size - 1 - common, -1, -1):\n",
   "                diff = ord(self.current[c - 1 - common]) - ord(w.s[i2])\n",
   "                if diff != 0:\n",
   "            if diff < 0:\n",
   "                j = k\n",
   "                i = k\n",
   "            if j - i <= 1:\n",
   "                if i > 0:\n",
   "                if j == i:\n",
   "            w = v[i]\n",
   "            if common_i >= w.s_size:\n",
   "                self.cursor = c - w.s_size\n",
   "                if w.method is None:\n",
   "                    return w.result\n",
   "                method = getattr(self, w.method)\n",
   "                res = method()\n",
   "                self.cursor = c - w.s_size\n",
   "                if res:\n",
   "                    return w.result\n",
   "            i = w.substring_i\n",
   "            if i < 0:\n"
  ]
 },
 "185": {
  "name": "j",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "204",
  "column": "8",
  "context": " comments apply\n        '''\n        i = 0\n        j = v_size\n\n        c = self.cursor\n        lb = self.limit_b",
  "context_lines": "        '''\n        find_among_b is for backwards processing. Same comments apply\n        '''\n        i = 0\n        j = v_size\n\n        c = self.cursor\n        lb = self.limit_backward;\n\n        common_i = 0\n",
  "slicing": [
   "        j = v_size\n",
   "            k = i + ((j - i) >> 1)\n",
   "            w = v[k]\n",
   "            for i2 in range(w.s_size - 1 - common, -1, -1):\n",
   "                diff = ord(self.current[c - 1 - common]) - ord(w.s[i2])\n",
   "                if diff != 0:\n",
   "            if diff < 0:\n",
   "                j = k\n",
   "                i = k\n",
   "            if j - i <= 1:\n",
   "                if i > 0:\n",
   "                if j == i:\n",
   "            w = v[i]\n",
   "            if common_i >= w.s_size:\n",
   "                self.cursor = c - w.s_size\n",
   "                if w.method is None:\n",
   "                    return w.result\n",
   "                method = getattr(self, w.method)\n",
   "                res = method()\n",
   "                self.cursor = c - w.s_size\n",
   "                if res:\n",
   "                    return w.result\n",
   "            i = w.substring_i\n",
   "            if i < 0:\n"
  ]
 },
 "186": {
  "name": "common",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "217",
  "column": "12",
  "context": "+ ((j - i) >> 1)\n            diff = 0\n            common = min(common_i, common_j)\n            w = v[k]\n            for i2 in range(w",
  "context_lines": "        first_key_inspected = False\n\n        while True:\n            k = i + ((j - i) >> 1)\n            diff = 0\n            common = min(common_i, common_j)\n            w = v[k]\n            for i2 in range(w.s_size - 1 - common, -1, -1):\n                if c - common == lb:\n                    diff = -1\n",
  "slicing": [
   "            common = min(common_i, common_j)\n",
   "            for i2 in range(w.s_size - 1 - common, -1, -1):\n",
   "                if c - common == lb:\n",
   "                diff = ord(self.current[c - 1 - common]) - ord(w.s[i2])\n",
   "                if diff != 0:\n",
   "            if diff < 0:\n",
   "                common_j = common\n",
   "                common_i = common\n",
   "            if common_i >= w.s_size:\n"
  ]
 },
 "187": {
  "name": "j",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "228",
  "column": "16",
  "context": "mon += 1\n            if diff < 0:\n                j = k\n                common_j = common\n            else",
  "context_lines": "                if diff != 0:\n                    break\n                common += 1\n            if diff < 0:\n                j = k\n                common_j = common\n            else:\n                i = k\n                common_i = common\n",
  "slicing": [
   "                j = k\n",
   "            if j - i <= 1:\n",
   "                if j == i:\n"
  ]
 },
 "188": {
  "name": "i",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "231",
  "column": "16",
  "context": "mmon_j = common\n            else:\n                i = k\n                common_i = common\n            if j",
  "context_lines": "            if diff < 0:\n                j = k\n                common_j = common\n            else:\n                i = k\n                common_i = common\n            if j - i <= 1:\n                if i > 0:\n                    break\n",
  "slicing": [
   "                i = k\n",
   "            if j - i <= 1:\n",
   "                if i > 0:\n",
   "                if j == i:\n",
   "            w = v[i]\n",
   "            if common_i >= w.s_size:\n",
   "                self.cursor = c - w.s_size\n",
   "                if w.method is None:\n",
   "                    return w.result\n",
   "                method = getattr(self, w.method)\n",
   "                res = method()\n",
   "                self.cursor = c - w.s_size\n",
   "                if res:\n",
   "                    return w.result\n",
   "            i = w.substring_i\n",
   "            if i < 0:\n"
  ]
 },
 "189": {
  "name": "cache",
  "type": "NoneType",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "anaconda/anaconda_lib/snowballstemmer/basestemmer.py",
  "lineno": "323",
  "column": "8",
  "context": "f.limit]\n\n    def _stem_word(self, word):\n        cache = self._cache.get(word)\n        if cache is None:\n            self.set_cur",
  "context_lines": "        @type s: string\n        '''\n        return self.current[0:self.limit]\n\n    def _stem_word(self, word):\n        cache = self._cache.get(word)\n        if cache is None:\n            self.set_current(word)\n            self._stem()\n            result = self.get_current()\n",
  "slicing": [
   "        cache = self._cache.get(word)\n",
   "        if cache is None:\n",
   "            cache[1] = self._counter\n",
   "            result = cache[0]\n",
   "        return result\n",
   "        oldcaches = sorted(self._cache.items(), key=lambda cache: cache[1][1])[0:removecount]\n",
   "        for key, value in oldcaches:\n",
   "            del self._cache[key]\n",
   "        return result\n",
   "        return result\n"
  ]
 }
}