{
 "1": {
  "name": "file_contents",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "25",
  "column": "8",
  "slicing": "[\"    with open('../pyproject.toml') as pyproject:\\n\", '        file_contents = pyproject.read()\\n', \"    return tomlkit.parse(file_contents)['tool']['poetry']\\n\"]",
  "context": "h open('../pyproject.toml') as pyproject:\n        file_contents = pyproject.read()\n\n    return tomlkit.parse(file_contents)['tool']['"
 },
 "2": {
  "name": "pkg_meta",
  "type": "_get_project_meta",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "30",
  "column": "0",
  "slicing": "[\"    with open('../pyproject.toml') as pyproject:\\n\", '        file_contents = pyproject.read()\\n', \"    return tomlkit.parse(file_contents)['tool']['poetry']\\n\", 'pkg_meta = _get_project_meta()\\n', \"project = str(pkg_meta['name'])\\n\", \"version = str(pkg_meta['version'])\\n\", 'release = version\\n']",
  "context": " tomlkit.parse(file_contents)['tool']['poetry']\n\n\npkg_meta = _get_project_meta()\nproject = str(pkg_meta['name'])\ncopyright = '2018,"
 },
 "3": {
  "name": "project",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "31",
  "column": "0",
  "slicing": "[\"    with open('../pyproject.toml') as pyproject:\\n\", '        file_contents = pyproject.read()\\n', \"    return tomlkit.parse(file_contents)['tool']['poetry']\\n\", 'pkg_meta = _get_project_meta()\\n', \"project = str(pkg_meta['name'])\\n\", \"version = str(pkg_meta['version'])\\n\", 'release = version\\n']",
  "context": "tool']['poetry']\n\n\npkg_meta = _get_project_meta()\nproject = str(pkg_meta['name'])\ncopyright = '2018, wemake.services'  # noqa: WPS12"
 },
 "4": {
  "name": "version",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "36",
  "column": "0",
  "slicing": "[\"    with open('../pyproject.toml') as pyproject:\\n\", '        file_contents = pyproject.read()\\n', \"    return tomlkit.parse(file_contents)['tool']['poetry']\\n\", 'pkg_meta = _get_project_meta()\\n', \"project = str(pkg_meta['name'])\\n\", \"version = str(pkg_meta['version'])\\n\", 'release = version\\n']",
  "context": "thor = 'wemake.services'\n\n# The short X.Y version\nversion = str(pkg_meta['version'])\n# The full version, including alpha/beta/rc tags\nr"
 },
 "5": {
  "name": "release",
  "type": "version",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "38",
  "column": "0",
  "slicing": "[\"    with open('../pyproject.toml') as pyproject:\\n\", '        file_contents = pyproject.read()\\n', \"    return tomlkit.parse(file_contents)['tool']['poetry']\\n\", 'pkg_meta = _get_project_meta()\\n', \"project = str(pkg_meta['name'])\\n\", \"version = str(pkg_meta['version'])\\n\", 'release = version\\n']",
  "context": "\n# The full version, including alpha/beta/rc tags\nrelease = version\n\n\n# -- General configuration ---------------------"
 },
 "6": {
  "name": "extensions",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "49",
  "column": "0",
  "slicing": "['extensions = [\\n']",
  "context": "inx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.doctest'"
 },
 "7": {
  "name": "autodoc_mock_imports",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "76",
  "column": "0",
  "slicing": "['autodoc_mock_imports = [\\n']",
  "context": "tent = 'class'\nautodoc_member_order = 'bysource'\n\nautodoc_mock_imports = [\n    'astor',\n    'pep8ext_naming',\n    'flake8_bui"
 },
 "8": {
  "name": "autodoc_default_options",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "84",
  "column": "0",
  "slicing": "['autodoc_default_options = {\\n']",
  "context": "ke8_quotes',\n]\n\nautodoc_member_order = 'bysource'\nautodoc_default_options = {\n    'members': True,\n    'undoc-members': True,\n  "
 },
 "9": {
  "name": "set_type_checking_flag",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "93",
  "column": "0",
  "slicing": "['set_type_checking_flag = False\\n']",
  "context": "ttps://pypi.org/project/sphinx-autodoc-typehints/\nset_type_checking_flag = False\nalways_document_param_types = False\n\n# Add any pat"
 },
 "10": {
  "name": "always_document_param_types",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "94",
  "column": "0",
  "slicing": "['always_document_param_types = False\\n']",
  "context": "autodoc-typehints/\nset_type_checking_flag = False\nalways_document_param_types = False\n\n# Add any paths that contain templates here, rela"
 },
 "11": {
  "name": "templates_path",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "97",
  "column": "0",
  "slicing": "[\"templates_path = ['_templates']\\n\"]",
  "context": "ntain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix(es) of source filenames.\n# You can s"
 },
 "12": {
  "name": "source_suffix",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "102",
  "column": "0",
  "slicing": "[\"source_suffix = ['.rst', '.md']\\n\"]",
  "context": "can specify multiple suffix as a list of string:\n\nsource_suffix = ['.rst', '.md']\n\n# The master toctree document.\nmaster_doc = 'inde"
 },
 "13": {
  "name": "language",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "112",
  "column": "0",
  "slicing": "['language = None\\n']",
  "context": "\"language\" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory,"
 },
 "14": {
  "name": "exclude_patterns",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "117",
  "column": "0",
  "slicing": "[\"exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\\n\"]",
  "context": "so affects html_static_path and html_extra_path .\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\n# The name of the Pygments (syntax highlighting) "
 },
 "15": {
  "name": "add_module_names",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "122",
  "column": "0",
  "slicing": "['add_module_names = False\\n']",
  "context": "ighting) style to use.\npygments_style = 'sphinx'\n\nadd_module_names = False\n\n\n# -- Options for HTML output -------------------"
 },
 "16": {
  "name": "html_theme_options",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "134",
  "column": "0",
  "slicing": "['html_theme_options = {\\n']",
  "context": "vailable for each theme, see the\n# documentation.\nhtml_theme_options = {\n    'sidebar_collapse': False,\n    'show_powered_b"
 },
 "17": {
  "name": "html_static_path",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "142",
  "column": "0",
  "slicing": "[\"html_static_path = ['_static']\\n\"]",
  "context": "lt.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# Custom sidebar templates, must be a dictionary "
 },
 "18": {
  "name": "html_sidebars",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "149",
  "column": "0",
  "slicing": "['html_sidebars = {\\n']",
  "context": "adthedocs.io/en/latest/installation.html#sidebars\nhtml_sidebars = {\n    '**': [\n        'about.html',\n        'badges."
 },
 "19": {
  "name": "latex_elements",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "169",
  "column": "0",
  "slicing": "['latex_elements = {}\\n']",
  "context": "------------------------------------------------\n\nlatex_elements = {}\n\n# Grouping the document tree into LaTeX files. Li"
 },
 "20": {
  "name": "latex_documents",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "174",
  "column": "0",
  "slicing": "['latex_documents = [\\n']",
  "context": "or, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (\n        master_doc,\n        'wemake-python-s"
 },
 "21": {
  "name": "man_pages",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "189",
  "column": "0",
  "slicing": "['man_pages = [\\n']",
  "context": "ile, name, description, authors, manual section).\nman_pages = [\n    (\n        master_doc,\n        'wemake-python-s"
 },
 "22": {
  "name": "texinfo_documents",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "205",
  "column": "0",
  "slicing": "['texinfo_documents = [\\n']",
  "context": "author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        'wemake-python-s"
 },
 "23": {
  "name": "napoleon_numpy_docstring",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "220",
  "column": "0",
  "slicing": "['napoleon_numpy_docstring = False\\n']",
  "context": "------------------------------------------------\n\nnapoleon_numpy_docstring = False\n\n# -- Options for todo extension -----------------"
 },
 "24": {
  "name": "todo_include_todos",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/docs/conf.py",
  "lineno": "225",
  "column": "0",
  "slicing": "['todo_include_todos = True\\n']",
  "context": "oList` produce output, else they produce nothing.\ntodo_include_todos = True\n"
 },
 "25": {
  "name": "pytest_plugins",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/conftest.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['pytest_plugins = [\\n']",
  "context": "n_styleguide.options.config import Configuration\n\npytest_plugins = [\n    'plugins.violations',\n    'plugins.ast_tree',\n"
 },
 "26": {
  "name": "dirname",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/tests/conftest.py",
  "lineno": "20",
  "column": "8",
  "slicing": "['        dirname = os.path.dirname(__file__)\\n', '        return os.path.join(dirname, *files)\\n']",
  "context": "e tests.\"\"\"\n    def factory(*files: str):\n        dirname = os.path.dirname(__file__)\n        return os.path.join(dirname, *files)\n    r"
 },
 "27": {
  "name": "default_values",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/conftest.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['        dirname = os.path.dirname(__file__)\\n', '        return os.path.join(dirname, *files)\\n', '    default_values = {\\n', '        for option in Configuration._options  # noqa: WPS437\\n', \"    Options = namedtuple('options', default_values.keys())\\n\", '        final_options = default_values.copy()\\n', '        final_options.update(kwargs)\\n', '        return Options(**final_options)\\n']",
  "context": "ons():\n    \"\"\"Returns the options builder.\"\"\"\n    default_values = {\n        option.long_option_name[2:].replace('-', '"
 },
 "28": {
  "name": "Options",
  "type": "collections.namedtuple",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/conftest.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['        dirname = os.path.dirname(__file__)\\n', '        return os.path.join(dirname, *files)\\n', '    default_values = {\\n', '        for option in Configuration._options  # noqa: WPS437\\n', \"    Options = namedtuple('options', default_values.keys())\\n\", '        final_options = default_values.copy()\\n', '        final_options.update(kwargs)\\n', '        return Options(**final_options)\\n']",
  "context": "Configuration._options  # noqa: WPS437\n    }\n\n    Options = namedtuple('options', default_values.keys())\n\n    def factory(**kwargs):\n        final_options "
 },
 "29": {
  "name": "PLUGINS",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_plugins.py",
  "lineno": "13",
  "column": "0",
  "slicing": "['PLUGINS = (\\n', '    for plugin_code in PLUGINS:\\n', '        assert output.count(plugin_code) > 0\\n']",
  "context": " not our responsibility.\n\"\"\"\n\n\nimport subprocess\n\nPLUGINS = (\n    'B002',  # flake8-bugbear\n    'C400',  # flake"
 },
 "30": {
  "name": "filename",
  "type": "absolute_path",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_plugins.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['PLUGINS = (\\n', '    for plugin_code in PLUGINS:\\n', '        assert output.count(plugin_code) > 0\\n', \"    filename = absolute_path('fixtures', 'external_plugins.py')\\n\", '            filename,\\n']",
  "context": "est to check that all plugins are enabled.\"\"\"\n    filename = absolute_path('fixtures', 'external_plugins.py')\n    process = subprocess.Popen(\n        [\n        "
 },
 "31": {
  "name": "parser",
  "type": "flake8.options.manager.OptionManager",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_options/conftest.py",
  "lineno": "11",
  "column": "4",
  "slicing": "['    parser = OptionManager(\\n', '    config.Configuration().register_options(parser)\\n', '    return parser\\n']",
  "context": " option parser that can be used for tests.\"\"\"\n    parser = OptionManager(\n        prog=version.pkg_name,\n        version=ver"
 },
 "32": {
  "name": "instance",
  "type": "_TestingFilenameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_base.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    instance = _TestingFilenameVisitor(\\n', '    instance.visit_filename = MagicMock()\\n', '    instance.run()\\n', '    instance.visit_filename.assert_not_called()\\n']",
  "context": " does not call `visit()` method for stdin.\"\"\"\n    instance = _TestingFilenameVisitor(\n        default_options,\n        filename=constant"
 },
 "33": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.base.BaseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/conftest.py",
  "lineno": "16",
  "column": "8",
  "slicing": "['        visitor: BaseVisitor,\\n']",
  "context": "t visitor violations.\"\"\"\n    def factory(\n        visitor: BaseVisitor,\n        errors: Sequence[str],\n        ignored_typ"
 },
 "34": {
  "name": "errors",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/conftest.py",
  "lineno": "17",
  "column": "8",
  "slicing": "['        errors: Sequence[str],\\n']",
  "context": "ef factory(\n        visitor: BaseVisitor,\n        errors: Sequence[str],\n        ignored_types=None,\n    ):\n        if igno"
 },
 "35": {
  "name": "real_errors",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/conftest.py",
  "lineno": "21",
  "column": "12",
  "slicing": "['            real_errors = [\\n', '        assert len(errors) == len(real_errors)\\n', '        for index, error in enumerate(real_errors):\\n', '            assert error.code == errors[index].code\\n', '            if isinstance(error, (ASTViolation, TokenizeViolation)):\\n', '                assert error._node is not None  # noqa: WPS437\\n', '                assert error._location() != (0, 0)  # noqa: WPS437\\n']",
  "context": "one,\n    ):\n        if ignored_types:\n            real_errors = [\n                error\n                for error in"
 },
 "36": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.base.BaseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/conftest.py",
  "lineno": "44",
  "column": "8",
  "slicing": "['        visitor: BaseVisitor,\\n']",
  "context": "tor violation's text.\"\"\"\n    def factory(\n        visitor: BaseVisitor,\n        text: str,\n        baseline: Optional[int]"
 },
 "37": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/conftest.py",
  "lineno": "45",
  "column": "8",
  "slicing": "['        text: str,\\n']",
  "context": "ef factory(\n        visitor: BaseVisitor,\n        text: str,\n        baseline: Optional[int] = None,\n        *,"
 },
 "38": {
  "name": "baseline",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/conftest.py",
  "lineno": "46",
  "column": "8",
  "slicing": "['        baseline: Optional[int] = None,\\n']",
  "context": " visitor: BaseVisitor,\n        text: str,\n        baseline: Optional[int] = None,\n        *,\n        multiple: bool = False,\n    ):\n"
 },
 "39": {
  "name": "violation",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/conftest.py",
  "lineno": "53",
  "column": "8",
  "slicing": "['            real_errors = [\\n', '                for error in visitor.violations\\n', '                if not isinstance(error, ignored_types)\\n', '            real_errors = visitor.violations\\n', '        assert len(errors) == len(real_errors)\\n', '        for index, error in enumerate(real_errors):\\n', '            assert error.code == errors[index].code\\n', '            if isinstance(error, (ASTViolation, TokenizeViolation)):\\n', '                assert error._node is not None  # noqa: WPS437\\n', '                assert error._location() != (0, 0)  # noqa: WPS437\\n', '        violation = visitor.violations[0]\\n', \"        error_format = ': {0}'\\n\", '        assert error_format in violation.error_template\\n', '        assert violation.error_template.endswith(error_format)\\n', '        reproduction = violation.__class__(\\n', '            node=violation._node,  # noqa: WPS437\\n', '        assert reproduction.message() == violation.message()\\n']",
  "context": "     assert len(visitor.violations) == 1\n\n        violation = visitor.violations[0]\n        error_format = ': {0}'\n\n        assert err"
 },
 "40": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_sign_negation.py",
  "lineno": "53",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OperationSignNegationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing that negated operations are forbidden.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_op"
 },
 "41": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.WrongMathOperatorVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_sign_negation.py",
  "lineno": "55",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OperationSignNegationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Ope"
 },
 "42": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_sign_negation.py",
  "lineno": "83",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OperationSignNegationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "g that non-negated operations are allowed.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_op"
 },
 "43": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.WrongMathOperatorVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_sign_negation.py",
  "lineno": "85",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OperationSignNegationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "44": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_string_concat.py",
  "lineno": "72",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExplicitStringConcatViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "Testing that string concats are forbidden.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_op"
 },
 "45": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.WrongMathOperatorVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_string_concat.py",
  "lineno": "74",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExplicitStringConcatViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Exp"
 },
 "46": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_string_concat.py",
  "lineno": "93",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExplicitStringConcatViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sting that regular operations are allowed.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_op"
 },
 "47": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.WrongMathOperatorVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_string_concat.py",
  "lineno": "95",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExplicitStringConcatViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "48": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_string_concat.py",
  "lineno": "115",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExplicitStringConcatViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "g that multiline string concat is allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongMathOperatorVisitor(default_op"
 },
 "49": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.WrongMathOperatorVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_string_concat.py",
  "lineno": "117",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExplicitStringConcatViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "50": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_zero_div.py",
  "lineno": "52",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ting that divisions by zero are forbidden.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "51": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_zero_div.py",
  "lineno": "54",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Zer"
 },
 "52": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_zero_div.py",
  "lineno": "97",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t useless modulus with zero are forbidden.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "53": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_zero_div.py",
  "lineno": "99",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Zer"
 },
 "54": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_zero_div.py",
  "lineno": "139",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sting that non-zero divisions are allowed.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "55": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_zero_div.py",
  "lineno": "141",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "56": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_zero_div.py",
  "lineno": "168",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t non-zero modulus operations are allowed.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "57": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_zero_div.py",
  "lineno": "170",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ZeroDivisionViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "58": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_bitwise_boolean_mixup.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(expression)\\n', '    visitor = BitwiseOpVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BitwiseAndBooleanMixupViolation])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = BitwiseOpVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ison between bitwise and boolean operator.\"\"\"\n    tree = parse_ast_tree(expression)\n\n    visitor = BitwiseOpVisitor(default_options, t"
 },
 "59": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.BitwiseOpVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_bitwise_boolean_mixup.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(expression)\\n', '    visitor = BitwiseOpVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BitwiseAndBooleanMixupViolation])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = BitwiseOpVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "or.\"\"\"\n    tree = parse_ast_tree(expression)\n\n    visitor = BitwiseOpVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Bit"
 },
 "60": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_bitwise_boolean_mixup.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(expression)\\n', '    visitor = BitwiseOpVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BitwiseAndBooleanMixupViolation])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = BitwiseOpVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "   \"\"\"Testing allowed bitwise comparisons.\"\"\"\n    tree = parse_ast_tree(expression)\n\n    visitor = BitwiseOpVisitor(default_options, t"
 },
 "61": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.BitwiseOpVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_bitwise_boolean_mixup.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(expression)\\n', '    visitor = BitwiseOpVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BitwiseAndBooleanMixupViolation])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = BitwiseOpVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ns.\"\"\"\n    tree = parse_ast_tree(expression)\n\n    visitor = BitwiseOpVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "62": {
  "name": "usages",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_operators_before_numbers.py",
  "lineno": "26",
  "column": "0",
  "slicing": "['usages = (\\n', \"@pytest.mark.parametrize('code', usages)\\n\", \"@pytest.mark.parametrize('code', usages)\\n\"]",
  "context": "t\", {0}, \"other\"}}'\ntuple_definition = '({0}, )'\n\nusages = (\n    assignment,\n    assignment_addition,\n    assig"
 },
 "63": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_operators_before_numbers.py",
  "lineno": "64",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_addition = 'constant = x + {0}'\\n\", \"assignment_increment = 'constant += {0}'\\n\", 'function_definition = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", 'usages = (\\n', '    assignment,\\n', '    assignment_addition,\\n', '    assignment_increment,\\n', '    function_definition,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', \"@pytest.mark.parametrize('code', usages)\\n\", '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessOperatorsViolation])\\n', \"@pytest.mark.parametrize('code', usages)\\n\", '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e is no useless plus sign before a number.\"\"\"\n    tree = parse_ast_tree(mode(code.format(number)))\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "64": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_operators_before_numbers.py",
  "lineno": "66",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_addition = 'constant = x + {0}'\\n\", \"assignment_increment = 'constant += {0}'\\n\", 'function_definition = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", 'usages = (\\n', '    assignment,\\n', '    assignment_addition,\\n', '    assignment_increment,\\n', '    function_definition,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', \"@pytest.mark.parametrize('code', usages)\\n\", '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessOperatorsViolation])\\n', \"@pytest.mark.parametrize('code', usages)\\n\", '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(mode(code.format(number)))\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "65": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_operators_before_numbers.py",
  "lineno": "89",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_addition = 'constant = x + {0}'\\n\", \"assignment_increment = 'constant += {0}'\\n\", 'function_definition = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", 'usages = (\\n', '    assignment,\\n', '    assignment_addition,\\n', '    assignment_increment,\\n', '    function_definition,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', \"@pytest.mark.parametrize('code', usages)\\n\", '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessOperatorsViolation])\\n', \"@pytest.mark.parametrize('code', usages)\\n\", '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e is no useless plus sign before a number.\"\"\"\n    tree = parse_ast_tree(mode(code.format(number)))\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "66": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_operators_before_numbers.py",
  "lineno": "91",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_addition = 'constant = x + {0}'\\n\", \"assignment_increment = 'constant += {0}'\\n\", 'function_definition = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", 'usages = (\\n', '    assignment,\\n', '    assignment_addition,\\n', '    assignment_increment,\\n', '    function_definition,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', \"@pytest.mark.parametrize('code', usages)\\n\", '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessOperatorsViolation])\\n', \"@pytest.mark.parametrize('code', usages)\\n\", '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(mode(code.format(number)))\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "67": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_math.py",
  "lineno": "59",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n']",
  "context": "aningless number operations are forbidden.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "68": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_math.py",
  "lineno": "61",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mea"
 },
 "69": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_math.py",
  "lineno": "105",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n']",
  "context": "g that useful math operations are allowed.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "70": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_math.py",
  "lineno": "107",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "71": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_math.py",
  "lineno": "127",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n']",
  "context": "1 / any number` is the correct expression.\"\"\"\n    tree = parse_ast_tree(expression)\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "72": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_math.py",
  "lineno": "129",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n']",
  "context": "on.\"\"\"\n    tree = parse_ast_tree(expression)\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "73": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_math.py",
  "lineno": "149",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n']",
  "context": "\"\"\"Testing an error when we divide by one.\"\"\"\n    tree = parse_ast_tree(expression)\n\n    visitor = UselessOperatorsVisitor(default_opt"
 },
 "74": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.UselessOperatorsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_useless_math.py",
  "lineno": "151",
  "column": "4",
  "slicing": "[\"usage_template = 'constant {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(expression)\\n', '    visitor = UselessOperatorsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MeaninglessNumberOperationViolation])\\n']",
  "context": "ne.\"\"\"\n    tree = parse_ast_tree(expression)\n\n    visitor = UselessOperatorsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mea"
 },
 "75": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_list_multiply.py",
  "lineno": "27",
  "column": "4",
  "slicing": "[\"usage_template = 'constant = {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ListMultiplyViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "esting that list multiplies are forbidden.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_op"
 },
 "76": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.WrongMathOperatorVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_list_multiply.py",
  "lineno": "29",
  "column": "4",
  "slicing": "[\"usage_template = 'constant = {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ListMultiplyViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Lis"
 },
 "77": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_list_multiply.py",
  "lineno": "49",
  "column": "4",
  "slicing": "[\"usage_template = 'constant = {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ListMultiplyViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    \"\"\"Testing that non lists are allowed.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_op"
 },
 "78": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.WrongMathOperatorVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_list_multiply.py",
  "lineno": "51",
  "column": "4",
  "slicing": "[\"usage_template = 'constant = {0}'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ListMultiplyViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = WrongMathOperatorVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "79": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_walrus.py",
  "lineno": "51",
  "column": "4",
  "slicing": "[\"correct_assignment = 'x = 1'\\n\", 'correct_if_condition = \"\"\"\\n', 'correct_comprehension = \"\"\"\\n', '    correct_assignment,\\n', '    correct_if_condition,\\n', '    correct_comprehension,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WalrusVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WalrusVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WalrusViolation])\\n']",
  "context": "  \"\"\"Testing that regular code is allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WalrusVisitor(default_options, tree"
 },
 "80": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.WalrusVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_walrus.py",
  "lineno": "53",
  "column": "4",
  "slicing": "[\"correct_assignment = 'x = 1'\\n\", 'correct_if_condition = \"\"\"\\n', 'correct_comprehension = \"\"\"\\n', '    correct_assignment,\\n', '    correct_if_condition,\\n', '    correct_comprehension,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WalrusVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WalrusVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WalrusViolation])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WalrusVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "81": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_walrus.py",
  "lineno": "72",
  "column": "4",
  "slicing": "[\"correct_assignment = 'x = 1'\\n\", 'correct_if_condition = \"\"\"\\n', 'correct_comprehension = \"\"\"\\n', '    correct_assignment,\\n', '    correct_if_condition,\\n', '    correct_comprehension,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WalrusVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WalrusVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WalrusViolation])\\n']",
  "context": "    \"\"\"Testing that ``:=`` is not allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WalrusVisitor(default_options, tree"
 },
 "82": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.operators.WalrusVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_operators/test_walrus.py",
  "lineno": "74",
  "column": "4",
  "slicing": "[\"correct_assignment = 'x = 1'\\n\", 'correct_if_condition = \"\"\"\\n', 'correct_comprehension = \"\"\"\\n', '    correct_assignment,\\n', '    correct_if_condition,\\n', '    correct_comprehension,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WalrusVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WalrusVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WalrusViolation])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WalrusVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wal"
 },
 "83": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_useless_node.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['for_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'try_template = \"\"\"\\n', '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', \"    assert_error_text(visitor, 'try')\\n\", '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"Ensures that useless nodes are forbidden.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement)))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "84": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_useless_node.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['for_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'try_template = \"\"\"\\n', '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', \"    assert_error_text(visitor, 'try')\\n\", '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(statement)))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "85": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_useless_node.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['for_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'try_template = \"\"\"\\n', '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', \"    assert_error_text(visitor, 'try')\\n\", '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "res that useless loop nodes are forbidden.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement)))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "86": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_useless_node.py",
  "lineno": "84",
  "column": "4",
  "slicing": "['for_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'try_template = \"\"\"\\n', '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', \"    assert_error_text(visitor, 'try')\\n\", '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(statement)))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "87": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_useless_node.py",
  "lineno": "106",
  "column": "4",
  "slicing": "['for_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'try_template = \"\"\"\\n', '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', \"    assert_error_text(visitor, 'try')\\n\", '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ures that useless try nodes are forbidden.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement)))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "88": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_useless_node.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['for_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'try_template = \"\"\"\\n', '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', \"    assert_error_text(visitor, 'try')\\n\", '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(statement)))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "89": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_useless_node.py",
  "lineno": "134",
  "column": "4",
  "slicing": "['for_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'try_template = \"\"\"\\n', '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', \"    assert_error_text(visitor, 'try')\\n\", '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Ensures that useful nodes are required.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement)))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "90": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_useless_node.py",
  "lineno": "136",
  "column": "4",
  "slicing": "['for_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'try_template = \"\"\"\\n', '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessNodeViolation])\\n', \"    assert_error_text(visitor, 'try')\\n\", '    for_template,\\n', '    while_template,\\n', '    with_template,\\n', '    try_template,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(statement)))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "91": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_not_tuple_argument.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(method, braces[0], braces[1]))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotATupleArgumentViolation])\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"Ensures that tuples arguments are passed.\"\"\"\n    tree = parse_ast_tree(code.format(method))\n\n    visitor = WrongMethodArgumentsVisitor(default"
 },
 "92": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongMethodArgumentsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_not_tuple_argument.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(method, braces[0], braces[1]))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotATupleArgumentViolation])\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  tree = parse_ast_tree(code.format(method))\n\n    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "93": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_not_tuple_argument.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(method, braces[0], braces[1]))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotATupleArgumentViolation])\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "es that non-tuples arguments are violated.\"\"\"\n    tree = parse_ast_tree(code.format(method, braces[0], braces[1]))\n\n    visitor = WrongMethodArgumentsVisitor(default"
 },
 "94": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongMethodArgumentsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_not_tuple_argument.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(method, braces[0], braces[1]))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotATupleArgumentViolation])\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e(code.format(method, braces[0], braces[1]))\n\n    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Not"
 },
 "95": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_not_tuple_argument.py",
  "lineno": "77",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(method, braces[0], braces[1]))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotATupleArgumentViolation])\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that non checkable situations are skipped.\"\"\"\n    tree = parse_ast_tree(code.format(method))\n\n    visitor = WrongMethodArgumentsVisitor(default"
 },
 "96": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongMethodArgumentsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_not_tuple_argument.py",
  "lineno": "79",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(method, braces[0], braces[1]))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotATupleArgumentViolation])\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  tree = parse_ast_tree(code.format(method))\n\n    visitor = WrongMethodArgumentsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "97": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_wrong_named_keyword.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongNamedKeywordViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " pointless starred expression is detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongNamedKeywordVisitor(default_op"
 },
 "98": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongNamedKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_wrong_named_keyword.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongNamedKeywordViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "99": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_wrong_named_keyword.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongNamedKeywordViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " pointless starred expression is detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongNamedKeywordVisitor(default_op"
 },
 "100": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongNamedKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_wrong_named_keyword.py",
  "lineno": "63",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongNamedKeywordViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongNamedKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "101": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_almost_swapped.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['wrong_swapped_variables = \"\"\"\\n', 'wrong_swapped_variables_with_temp = \"\"\"\\n', '    wrong_swapped_variables,\\n', '    wrong_swapped_variables_with_temp,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AlmostSwappedViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "correctly swapped variables are forbidden.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "102": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_almost_swapped.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['wrong_swapped_variables = \"\"\"\\n', 'wrong_swapped_variables_with_temp = \"\"\"\\n', '    wrong_swapped_variables,\\n', '    wrong_swapped_variables_with_temp,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AlmostSwappedViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "orbidden.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Alm"
 },
 "103": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_almost_swapped.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['wrong_swapped_variables = \"\"\"\\n', 'wrong_swapped_variables_with_temp = \"\"\"\\n', '    wrong_swapped_variables,\\n', '    wrong_swapped_variables_with_temp,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AlmostSwappedViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"Testing that correctly swapped variables.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "104": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_almost_swapped.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['wrong_swapped_variables = \"\"\"\\n', 'wrong_swapped_variables_with_temp = \"\"\"\\n', '    wrong_swapped_variables,\\n', '    wrong_swapped_variables_with_temp,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AlmostSwappedViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ariables.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "105": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_unreachable_code.py",
  "lineno": "197",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('print()', 'raise ValueError()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('raise ValueError()', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    function_template,\\n', '    async_function_template,\\n', \"    tree = parse_ast_tree(code.format('return', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    async_for_template,\\n', \"    tree = parse_ast_tree(code.format(keyword, 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n']",
  "context": "Testing correct order of lines is allowed.\"\"\"\n    tree = parse_ast_tree(code.format('print()', 'raise ValueError()'))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "106": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_unreachable_code.py",
  "lineno": "199",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('print()', 'raise ValueError()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('raise ValueError()', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    function_template,\\n', '    async_function_template,\\n', \"    tree = parse_ast_tree(code.format('return', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    async_for_template,\\n', \"    tree = parse_ast_tree(code.format(keyword, 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n']",
  "context": "ode.format('print()', 'raise ValueError()'))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "107": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_unreachable_code.py",
  "lineno": "239",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('print()', 'raise ValueError()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('raise ValueError()', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    function_template,\\n', '    async_function_template,\\n', \"    tree = parse_ast_tree(code.format('return', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    async_for_template,\\n', \"    tree = parse_ast_tree(code.format(keyword, 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n']",
  "context": "Testing that unreachable code is detected.\"\"\"\n    tree = parse_ast_tree(code.format('raise ValueError()', 'print()'))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "108": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_unreachable_code.py",
  "lineno": "241",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('print()', 'raise ValueError()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('raise ValueError()', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    function_template,\\n', '    async_function_template,\\n', \"    tree = parse_ast_tree(code.format('return', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    async_for_template,\\n', \"    tree = parse_ast_tree(code.format(keyword, 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n']",
  "context": "ode.format('raise ValueError()', 'print()'))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unr"
 },
 "109": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_unreachable_code.py",
  "lineno": "258",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('print()', 'raise ValueError()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('raise ValueError()', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    function_template,\\n', '    async_function_template,\\n', \"    tree = parse_ast_tree(code.format('return', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    async_for_template,\\n', \"    tree = parse_ast_tree(code.format(keyword, 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n']",
  "context": "Testing that unreachable code is detected.\"\"\"\n    tree = parse_ast_tree(code.format('return', 'print()'))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "110": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_unreachable_code.py",
  "lineno": "260",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('print()', 'raise ValueError()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('raise ValueError()', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    function_template,\\n', '    async_function_template,\\n', \"    tree = parse_ast_tree(code.format('return', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    async_for_template,\\n', \"    tree = parse_ast_tree(code.format(keyword, 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n']",
  "context": "e_ast_tree(code.format('return', 'print()'))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unr"
 },
 "111": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_unreachable_code.py",
  "lineno": "284",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('print()', 'raise ValueError()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('raise ValueError()', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    function_template,\\n', '    async_function_template,\\n', \"    tree = parse_ast_tree(code.format('return', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    async_for_template,\\n', \"    tree = parse_ast_tree(code.format(keyword, 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n']",
  "context": "Testing that unreachable code is detected.\"\"\"\n    tree = parse_ast_tree(code.format(keyword, 'print()'))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "112": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_unreachable_code.py",
  "lineno": "286",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('print()', 'raise ValueError()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', \"    tree = parse_ast_tree(code.format('raise ValueError()', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    function_template,\\n', '    async_function_template,\\n', \"    tree = parse_ast_tree(code.format('return', 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n', '    for_template,\\n', '    while_template,\\n', '    async_for_template,\\n', \"    tree = parse_ast_tree(code.format(keyword, 'print()'))\\n\", '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreachableCodeViolation])\\n']",
  "context": "se_ast_tree(code.format(keyword, 'print()'))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unr"
 },
 "113": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_pointless_starred.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PointlessStarredViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " pointless starred expression is detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = PointlessStarredVisitor(default_opt"
 },
 "114": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.PointlessStarredVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_pointless_starred.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PointlessStarredViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = PointlessStarredVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Poi"
 },
 "115": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_pointless_starred.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PointlessStarredViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " pointless starred expression is detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = PointlessStarredVisitor(default_opt"
 },
 "116": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.PointlessStarredVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_pointless_starred.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PointlessStarredViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = PointlessStarredVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "117": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_pointless_starred.py",
  "lineno": "81",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PointlessStarredViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " pointless starred expression is detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = PointlessStarredVisitor(default_opt"
 },
 "118": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.PointlessStarredVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_pointless_starred.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PointlessStarredViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = PointlessStarredVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "detected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = PointlessStarredVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "119": {
  "name": "OPERATIONS",
  "type": "frozenset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_augmented_assign.py",
  "lineno": "10",
  "column": "0",
  "slicing": "['OPERATIONS = frozenset((\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\"]",
  "context": "ements import (\n    AssignmentPatternsVisitor,\n)\n\nOPERATIONS = frozenset((\n    '+',\n    '-',\n    '*',\n    '/',\n    '%',\n    '"
 },
 "120": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_augmented_assign.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['OPERATIONS = frozenset((\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AugmentedAssignPatternViolation])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at augemented assignment are not violated.\"\"\"\n    tree = parse_ast_tree(mode(code.format(operation)))\n\n    visitor = AssignmentPatternsVisitor(default_o"
 },
 "121": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.AssignmentPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_augmented_assign.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['OPERATIONS = frozenset((\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AugmentedAssignPatternViolation])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(operation)))\n\n    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "122": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_augmented_assign.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['OPERATIONS = frozenset((\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AugmentedAssignPatternViolation])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "   \"\"\"Ensures force augmented assignments.\"\"\"\n    tree = parse_ast_tree(mode(code.format(operation)))\n\n    visitor = AssignmentPatternsVisitor(default_o"
 },
 "123": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.AssignmentPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_augmented_assign.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['OPERATIONS = frozenset((\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AugmentedAssignPatternViolation])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(operation)))\n\n    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Aug"
 },
 "124": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_augmented_assign.py",
  "lineno": "84",
  "column": "4",
  "slicing": "['OPERATIONS = frozenset((\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AugmentedAssignPatternViolation])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that complex expressions are not checked.\"\"\"\n    tree = parse_ast_tree(mode(code.format(operation)))\n\n    visitor = AssignmentPatternsVisitor(default_o"
 },
 "125": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.AssignmentPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_augmented_assign.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['OPERATIONS = frozenset((\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AugmentedAssignPatternViolation])\\n', \"@pytest.mark.parametrize('operation', OPERATIONS)\\n\", '    tree = parse_ast_tree(mode(code.format(operation)))\\n', '    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(operation)))\n\n    visitor = AssignmentPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "126": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "189",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "Testing that unreachable code is detected.\"\"\"\n    tree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "127": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "191",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "ree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sta"
 },
 "128": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "221",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "Testing that unreachable code is detected.\"\"\"\n    tree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "129": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "223",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "ree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mis"
 },
 "130": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "290",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": " functions, methods, and assignment works.\"\"\"\n    tree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "131": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "292",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "ree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "132": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "315",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "\"\"Testing that `return` and `yield` works.\"\"\"\n    tree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "133": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "317",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "ree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "134": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "340",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "ons,\n):\n    \"\"\"Testing that `await` works.\"\"\"\n    tree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "135": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "342",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "ree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "136": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "365",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "s,\n):\n    \"\"\"Testing that docstring works.\"\"\"\n    tree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "137": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "367",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "ree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "138": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "405",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "s,\n):\n    \"\"\"Testing that docstring works.\"\"\"\n    tree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default"
 },
 "139": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.StatementsWithBodiesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_statements_with_no_effect.py",
  "lineno": "407",
  "column": "4",
  "slicing": "['module_template = \"\"\"\\n', 'if_template = \"\"\"\\n', 'if_elif_template = \"\"\"\\n', 'if_else_template = \"\"\"\\n', 'for_template = \"\"\"\\n', 'for_else_template = \"\"\"\\n', 'while_template = \"\"\"\\n', 'while_else_template = \"\"\"\\n', 'try_template = \"\"\"\\n', 'try_except_template = \"\"\"\\n', 'try_else_template = \"\"\"\\n', 'try_finally_template = \"\"\"\\n', 'with_template = \"\"\"\\n', 'function_template = \"\"\"\\n', 'class_template = \"\"\"\\n', 'async_function_template = \"\"\"\\n', 'async_with_template = \"\"\"\\n', 'async_for_template = \"\"\"\\n', 'async_for_else_template = \"\"\"\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MisrefactoredAssignmentViolation])\\n', '    module_template,\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    function_template,\\n', '    class_template,\\n', '    async_function_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    async_function_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    async_function_template,\\n', '    class_template,\\n', '    module_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_template,\\n', '    if_elif_template,\\n', '    if_else_template,\\n', '    for_template,\\n', '    for_else_template,\\n', '    while_template,\\n', '    while_else_template,\\n', '    try_template,\\n', '    try_except_template,\\n', '    try_else_template,\\n', '    try_finally_template,\\n', '    with_template,\\n', '    async_with_template,\\n', '    async_for_template,\\n', '    async_for_else_template,\\n', '    tree = parse_ast_tree(code.format(statement))\\n', '    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StatementHasNoEffectViolation])\\n']",
  "context": "ree = parse_ast_tree(code.format(statement))\n\n    visitor = StatementsWithBodiesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sta"
 },
 "140": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_function_indentation.py",
  "lineno": "122",
  "column": "4",
  "slicing": "[\"correct_single_line_function = 'def test(arg, *args, kw, **kwargs): ...'\\n\", 'correct_multi_line_function = \"\"\"\\n', 'correct_multi_line_function_with_posonly = \"\"\"\\n', 'correct_multi_line_function_with_defaults = \"\"\"\\n', 'correct_next_line_function = \"\"\"\\n', '    correct_single_line_function,\\n', '    correct_multi_line_function,\\n', '    correct_multi_line_function_with_defaults,\\n', '    correct_next_line_function,\\n', '        correct_multi_line_function_with_posonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "ng that correctly indented functions work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(d"
 },
 "141": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongParametersIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_function_indentation.py",
  "lineno": "124",
  "column": "4",
  "slicing": "[\"correct_single_line_function = 'def test(arg, *args, kw, **kwargs): ...'\\n\", 'correct_multi_line_function = \"\"\"\\n', 'correct_multi_line_function_with_posonly = \"\"\"\\n', 'correct_multi_line_function_with_defaults = \"\"\"\\n', 'correct_next_line_function = \"\"\"\\n', '    correct_single_line_function,\\n', '    correct_multi_line_function,\\n', '    correct_multi_line_function_with_defaults,\\n', '    correct_next_line_function,\\n', '        correct_multi_line_function_with_posonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "ons work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "142": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_function_indentation.py",
  "lineno": "150",
  "column": "4",
  "slicing": "[\"correct_single_line_function = 'def test(arg, *args, kw, **kwargs): ...'\\n\", 'correct_multi_line_function = \"\"\"\\n', 'correct_multi_line_function_with_posonly = \"\"\"\\n', 'correct_multi_line_function_with_defaults = \"\"\"\\n', 'correct_next_line_function = \"\"\"\\n', '    correct_single_line_function,\\n', '    correct_multi_line_function,\\n', '    correct_multi_line_function_with_defaults,\\n', '    correct_next_line_function,\\n', '        correct_multi_line_function_with_posonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "hat poorly indented functions do not work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(d"
 },
 "143": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongParametersIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_function_indentation.py",
  "lineno": "152",
  "column": "4",
  "slicing": "[\"correct_single_line_function = 'def test(arg, *args, kw, **kwargs): ...'\\n\", 'correct_multi_line_function = \"\"\"\\n', 'correct_multi_line_function_with_posonly = \"\"\"\\n', 'correct_multi_line_function_with_defaults = \"\"\"\\n', 'correct_next_line_function = \"\"\"\\n', '    correct_single_line_function,\\n', '    correct_multi_line_function,\\n', '    correct_multi_line_function_with_defaults,\\n', '    correct_next_line_function,\\n', '        correct_multi_line_function_with_posonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "not work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Par"
 },
 "144": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_collection_indentation.py",
  "lineno": "245",
  "column": "4",
  "slicing": "[\"correct_single_line_tuple = 'xy = (1, 2, 3)'\\n\", \"correct_single_line_list = 'xy = [1, 2, 3]'\\n\", \"correct_single_line_set = 'xy = {1, 2, 3}'\\n\", 'correct_single_line_dict = \\'xy = {\"key\": [1, 2], \"other\": {1, 2}, \"w\": (1, 2)}\\'\\n', 'correct_multiline_string = \"\"\"\\n', 'correct_multi_line_tuple = \"\"\"\\n', 'correct_multi_line_list = \"\"\"\\n', 'correct_multi_line_set = \"\"\"\\n', 'correct_multi_line_dict = \"\"\"\\n', 'correct_next_line_tuple = \"\"\"\\n', 'correct_next_line_list = \"\"\"\\n', 'correct_next_line_set = \"\"\"\\n', 'correct_next_line_tuple = \"\"\"\\n', 'correct_nested_collections = \"\"\"\\n', 'correct_simple_regression450 = \"\"\"\\n', 'correct_multiline_regression450 = \"\"\"\\n', '    correct_multiline_string,\\n', '    correct_single_line_tuple,\\n', '    correct_single_line_list,\\n', '    correct_single_line_set,\\n', '    correct_single_line_dict,\\n', '    correct_multi_line_tuple,\\n', '    correct_multi_line_list,\\n', '    correct_multi_line_set,\\n', '    correct_multi_line_dict,\\n', '    correct_next_line_list,\\n', '    correct_next_line_set,\\n', '    correct_next_line_tuple,\\n', '    correct_nested_collections,\\n', '    correct_simple_regression450,\\n', '    correct_multiline_regression450,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": " that correctly indented collections work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(d"
 },
 "145": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongParametersIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_collection_indentation.py",
  "lineno": "247",
  "column": "4",
  "slicing": "[\"correct_single_line_tuple = 'xy = (1, 2, 3)'\\n\", \"correct_single_line_list = 'xy = [1, 2, 3]'\\n\", \"correct_single_line_set = 'xy = {1, 2, 3}'\\n\", 'correct_single_line_dict = \\'xy = {\"key\": [1, 2], \"other\": {1, 2}, \"w\": (1, 2)}\\'\\n', 'correct_multiline_string = \"\"\"\\n', 'correct_multi_line_tuple = \"\"\"\\n', 'correct_multi_line_list = \"\"\"\\n', 'correct_multi_line_set = \"\"\"\\n', 'correct_multi_line_dict = \"\"\"\\n', 'correct_next_line_tuple = \"\"\"\\n', 'correct_next_line_list = \"\"\"\\n', 'correct_next_line_set = \"\"\"\\n', 'correct_next_line_tuple = \"\"\"\\n', 'correct_nested_collections = \"\"\"\\n', 'correct_simple_regression450 = \"\"\"\\n', 'correct_multiline_regression450 = \"\"\"\\n', '    correct_multiline_string,\\n', '    correct_single_line_tuple,\\n', '    correct_single_line_list,\\n', '    correct_single_line_set,\\n', '    correct_single_line_dict,\\n', '    correct_multi_line_tuple,\\n', '    correct_multi_line_list,\\n', '    correct_multi_line_set,\\n', '    correct_multi_line_dict,\\n', '    correct_next_line_list,\\n', '    correct_next_line_set,\\n', '    correct_next_line_tuple,\\n', '    correct_nested_collections,\\n', '    correct_simple_regression450,\\n', '    correct_multiline_regression450,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "ons work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "146": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_collection_indentation.py",
  "lineno": "281",
  "column": "4",
  "slicing": "[\"correct_single_line_tuple = 'xy = (1, 2, 3)'\\n\", \"correct_single_line_list = 'xy = [1, 2, 3]'\\n\", \"correct_single_line_set = 'xy = {1, 2, 3}'\\n\", 'correct_single_line_dict = \\'xy = {\"key\": [1, 2], \"other\": {1, 2}, \"w\": (1, 2)}\\'\\n', 'correct_multiline_string = \"\"\"\\n', 'correct_multi_line_tuple = \"\"\"\\n', 'correct_multi_line_list = \"\"\"\\n', 'correct_multi_line_set = \"\"\"\\n', 'correct_multi_line_dict = \"\"\"\\n', 'correct_next_line_tuple = \"\"\"\\n', 'correct_next_line_list = \"\"\"\\n', 'correct_next_line_set = \"\"\"\\n', 'correct_next_line_tuple = \"\"\"\\n', 'correct_nested_collections = \"\"\"\\n', 'correct_simple_regression450 = \"\"\"\\n', 'correct_multiline_regression450 = \"\"\"\\n', '    correct_multiline_string,\\n', '    correct_single_line_tuple,\\n', '    correct_single_line_list,\\n', '    correct_single_line_set,\\n', '    correct_single_line_dict,\\n', '    correct_multi_line_tuple,\\n', '    correct_multi_line_list,\\n', '    correct_multi_line_set,\\n', '    correct_multi_line_dict,\\n', '    correct_next_line_list,\\n', '    correct_next_line_set,\\n', '    correct_next_line_tuple,\\n', '    correct_nested_collections,\\n', '    correct_simple_regression450,\\n', '    correct_multiline_regression450,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "t poorly indented collections do not work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(d"
 },
 "147": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongParametersIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_collection_indentation.py",
  "lineno": "283",
  "column": "4",
  "slicing": "[\"correct_single_line_tuple = 'xy = (1, 2, 3)'\\n\", \"correct_single_line_list = 'xy = [1, 2, 3]'\\n\", \"correct_single_line_set = 'xy = {1, 2, 3}'\\n\", 'correct_single_line_dict = \\'xy = {\"key\": [1, 2], \"other\": {1, 2}, \"w\": (1, 2)}\\'\\n', 'correct_multiline_string = \"\"\"\\n', 'correct_multi_line_tuple = \"\"\"\\n', 'correct_multi_line_list = \"\"\"\\n', 'correct_multi_line_set = \"\"\"\\n', 'correct_multi_line_dict = \"\"\"\\n', 'correct_next_line_tuple = \"\"\"\\n', 'correct_next_line_list = \"\"\"\\n', 'correct_next_line_set = \"\"\"\\n', 'correct_next_line_tuple = \"\"\"\\n', 'correct_nested_collections = \"\"\"\\n', 'correct_simple_regression450 = \"\"\"\\n', 'correct_multiline_regression450 = \"\"\"\\n', '    correct_multiline_string,\\n', '    correct_single_line_tuple,\\n', '    correct_single_line_list,\\n', '    correct_single_line_set,\\n', '    correct_single_line_dict,\\n', '    correct_multi_line_tuple,\\n', '    correct_multi_line_list,\\n', '    correct_multi_line_set,\\n', '    correct_multi_line_dict,\\n', '    correct_next_line_list,\\n', '    correct_next_line_set,\\n', '    correct_next_line_tuple,\\n', '    correct_nested_collections,\\n', '    correct_simple_regression450,\\n', '    correct_multiline_regression450,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "not work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Par"
 },
 "148": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_base_classes_indentation.py",
  "lineno": "90",
  "column": "4",
  "slicing": "[\"correct_single_line_class = 'class Test(First, Second, Third): ...'\\n\", 'correct_multi_line_class = \"\"\"\\n', 'correct_multi_line_class_with_keywords = \"\"\"\\n', 'correct_next_line_class = \"\"\"\\n', '    correct_single_line_class,\\n', '    correct_multi_line_class,\\n', '    correct_multi_line_class_with_keywords,\\n', '    correct_next_line_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "that correctly indented base classes work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(d"
 },
 "149": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongParametersIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_base_classes_indentation.py",
  "lineno": "92",
  "column": "4",
  "slicing": "[\"correct_single_line_class = 'class Test(First, Second, Third): ...'\\n\", 'correct_multi_line_class = \"\"\"\\n', 'correct_multi_line_class_with_keywords = \"\"\"\\n', 'correct_next_line_class = \"\"\"\\n', '    correct_single_line_class,\\n', '    correct_multi_line_class,\\n', '    correct_multi_line_class_with_keywords,\\n', '    correct_next_line_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "ses work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "150": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_base_classes_indentation.py",
  "lineno": "113",
  "column": "4",
  "slicing": "[\"correct_single_line_class = 'class Test(First, Second, Third): ...'\\n\", 'correct_multi_line_class = \"\"\"\\n', 'correct_multi_line_class_with_keywords = \"\"\"\\n', 'correct_next_line_class = \"\"\"\\n', '    correct_single_line_class,\\n', '    correct_multi_line_class,\\n', '    correct_multi_line_class_with_keywords,\\n', '    correct_next_line_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": " that poorly indented classes do not work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(d"
 },
 "151": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongParametersIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_base_classes_indentation.py",
  "lineno": "115",
  "column": "4",
  "slicing": "[\"correct_single_line_class = 'class Test(First, Second, Third): ...'\\n\", 'correct_multi_line_class = \"\"\"\\n', 'correct_multi_line_class_with_keywords = \"\"\"\\n', 'correct_next_line_class = \"\"\"\\n', '    correct_single_line_class,\\n', '    correct_multi_line_class,\\n', '    correct_multi_line_class_with_keywords,\\n', '    correct_next_line_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "not work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Par"
 },
 "152": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_call_indentation.py",
  "lineno": "143",
  "column": "4",
  "slicing": "[\"correct_single_line_call = 'print(1, 2, 3)'\\n\", 'correct_multi_line_call = \"\"\"\\n', 'correct_multi_line_call_with_keywords = \"\"\"\\n', 'correct_next_line_call = \"\"\"\\n', 'correct_next_line_call_with_keywords = \"\"\"\\n', 'correct_call_with_multi_line_tuple = \"\"\"\\n', 'correct_call_with_next_line_parameter = \"\"\"\\n', 'correct_call_with_multi_line_parameter = \"\"\"\\n', 'correct_call_all_multi_line = \"\"\"\\n', '    correct_single_line_call,\\n', '    correct_multi_line_call,\\n', '    correct_multi_line_call_with_keywords,\\n', '    correct_next_line_call,\\n', '    correct_next_line_call_with_keywords,\\n', '    correct_call_with_multi_line_tuple,\\n', '    correct_call_with_next_line_parameter,\\n', '    correct_call_with_multi_line_parameter,\\n', '    correct_call_all_multi_line,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "at correctly indented function calls work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(d"
 },
 "153": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongParametersIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_call_indentation.py",
  "lineno": "145",
  "column": "4",
  "slicing": "[\"correct_single_line_call = 'print(1, 2, 3)'\\n\", 'correct_multi_line_call = \"\"\"\\n', 'correct_multi_line_call_with_keywords = \"\"\"\\n', 'correct_next_line_call = \"\"\"\\n', 'correct_next_line_call_with_keywords = \"\"\"\\n', 'correct_call_with_multi_line_tuple = \"\"\"\\n', 'correct_call_with_next_line_parameter = \"\"\"\\n', 'correct_call_with_multi_line_parameter = \"\"\"\\n', 'correct_call_all_multi_line = \"\"\"\\n', '    correct_single_line_call,\\n', '    correct_multi_line_call,\\n', '    correct_multi_line_call_with_keywords,\\n', '    correct_next_line_call,\\n', '    correct_next_line_call_with_keywords,\\n', '    correct_call_with_multi_line_tuple,\\n', '    correct_call_with_next_line_parameter,\\n', '    correct_call_with_multi_line_parameter,\\n', '    correct_call_all_multi_line,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "lls work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "154": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_call_indentation.py",
  "lineno": "167",
  "column": "4",
  "slicing": "[\"correct_single_line_call = 'print(1, 2, 3)'\\n\", 'correct_multi_line_call = \"\"\"\\n', 'correct_multi_line_call_with_keywords = \"\"\"\\n', 'correct_next_line_call = \"\"\"\\n', 'correct_next_line_call_with_keywords = \"\"\"\\n', 'correct_call_with_multi_line_tuple = \"\"\"\\n', 'correct_call_with_next_line_parameter = \"\"\"\\n', 'correct_call_with_multi_line_parameter = \"\"\"\\n', 'correct_call_all_multi_line = \"\"\"\\n', '    correct_single_line_call,\\n', '    correct_multi_line_call,\\n', '    correct_multi_line_call_with_keywords,\\n', '    correct_next_line_call,\\n', '    correct_next_line_call_with_keywords,\\n', '    correct_call_with_multi_line_tuple,\\n', '    correct_call_with_next_line_parameter,\\n', '    correct_call_with_multi_line_parameter,\\n', '    correct_call_all_multi_line,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "oorly indented function calls do not work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(d"
 },
 "155": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.statements.WrongParametersIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_statements/test_parameters_indentation/test_call_indentation.py",
  "lineno": "169",
  "column": "4",
  "slicing": "[\"correct_single_line_call = 'print(1, 2, 3)'\\n\", 'correct_multi_line_call = \"\"\"\\n', 'correct_multi_line_call_with_keywords = \"\"\"\\n', 'correct_next_line_call = \"\"\"\\n', 'correct_next_line_call_with_keywords = \"\"\"\\n', 'correct_call_with_multi_line_tuple = \"\"\"\\n', 'correct_call_with_next_line_parameter = \"\"\"\\n', 'correct_call_with_multi_line_parameter = \"\"\"\\n', 'correct_call_all_multi_line = \"\"\"\\n', '    correct_single_line_call,\\n', '    correct_multi_line_call,\\n', '    correct_multi_line_call_with_keywords,\\n', '    correct_next_line_call,\\n', '    correct_next_line_call_with_keywords,\\n', '    correct_call_with_multi_line_tuple,\\n', '    correct_call_with_next_line_parameter,\\n', '    correct_call_with_multi_line_parameter,\\n', '    correct_call_all_multi_line,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ParametersIndentationViolation])\\n']",
  "context": "not work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongParametersIndentationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Par"
 },
 "156": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_method_order.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['correct_method_order = \"\"\"\\n', 'nested_functions = \"\"\"\\n', 'class_template = \"\"\"\\n', '    correct_method_order,\\n', '    nested_functions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(class_template.format(first, second)))\\n', '    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMethodOrderViolation])\\n']",
  "context": "ting that correct method order is allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ClassMethodOrderVisitor(default_opt"
 },
 "157": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.ClassMethodOrderVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_method_order.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['correct_method_order = \"\"\"\\n', 'nested_functions = \"\"\"\\n', 'class_template = \"\"\"\\n', '    correct_method_order,\\n', '    nested_functions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(class_template.format(first, second)))\\n', '    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMethodOrderViolation])\\n']",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "158": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_method_order.py",
  "lineno": "124",
  "column": "4",
  "slicing": "['correct_method_order = \"\"\"\\n', 'nested_functions = \"\"\"\\n', 'class_template = \"\"\"\\n', '    correct_method_order,\\n', '    nested_functions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(class_template.format(first, second)))\\n', '    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMethodOrderViolation])\\n']",
  "context": "that incorrect method order is prohibited.\"\"\"\n    tree = parse_ast_tree(mode(class_template.format(first, second)))\n\n    visitor = ClassMethodOrderVisitor(default_opt"
 },
 "159": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.ClassMethodOrderVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_method_order.py",
  "lineno": "126",
  "column": "4",
  "slicing": "['correct_method_order = \"\"\"\\n', 'nested_functions = \"\"\"\\n', 'class_template = \"\"\"\\n', '    correct_method_order,\\n', '    nested_functions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(class_template.format(first, second)))\\n', '    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMethodOrderViolation])\\n']",
  "context": "(mode(class_template.format(first, second)))\n\n    visitor = ClassMethodOrderVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "160": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_wrong_class_body.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', '    tree = parse_ast_tree(class_body_template.format(code))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongClassBodyContentViolation])\\n', '    tree = parse_ast_tree(mode(class_body_template.format(code)))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that incorrect body nodes are prohibited.\"\"\"\n    tree = parse_ast_tree(class_body_template.format(code))\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "161": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_wrong_class_body.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', '    tree = parse_ast_tree(class_body_template.format(code))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongClassBodyContentViolation])\\n', '    tree = parse_ast_tree(mode(class_body_template.format(code)))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e_ast_tree(class_body_template.format(code))\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "162": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_wrong_class_body.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', '    tree = parse_ast_tree(class_body_template.format(code))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongClassBodyContentViolation])\\n', '    tree = parse_ast_tree(mode(class_body_template.format(code)))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing correct body items are allowed.\"\"\"\n    tree = parse_ast_tree(mode(class_body_template.format(code)))\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "163": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_wrong_class_body.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', '    tree = parse_ast_tree(class_body_template.format(code))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongClassBodyContentViolation])\\n', '    tree = parse_ast_tree(mode(class_body_template.format(code)))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree(mode(class_body_template.format(code)))\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "164": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_yield_magic_method.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['method_template = \"\"\"\\n', 'classmethod_template = \"\"\"\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldMagicMethodViolation])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t magic method with `yield` is prohibited.\"\"\"\n    tree = parse_ast_tree(code.format(method, statement))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "165": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_yield_magic_method.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['method_template = \"\"\"\\n', 'classmethod_template = \"\"\"\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldMagicMethodViolation])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rse_ast_tree(code.format(method, statement))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Yie"
 },
 "166": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_yield_magic_method.py",
  "lineno": "79",
  "column": "4",
  "slicing": "['method_template = \"\"\"\\n', 'classmethod_template = \"\"\"\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldMagicMethodViolation])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at magic method with statement is allowed.\"\"\"\n    tree = parse_ast_tree(code.format(method, statement))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "167": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_yield_magic_method.py",
  "lineno": "81",
  "column": "4",
  "slicing": "['method_template = \"\"\"\\n', 'classmethod_template = \"\"\"\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldMagicMethodViolation])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rse_ast_tree(code.format(method, statement))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "168": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_yield_magic_method.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['method_template = \"\"\"\\n', 'classmethod_template = \"\"\"\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldMagicMethodViolation])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "d `call` methods with `yield` are allowed.\"\"\"\n    tree = parse_ast_tree(code.format(method, statement))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "169": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_yield_magic_method.py",
  "lineno": "112",
  "column": "4",
  "slicing": "['method_template = \"\"\"\\n', 'classmethod_template = \"\"\"\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldMagicMethodViolation])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_template,\\n', '    classmethod_template,\\n', '    tree = parse_ast_tree(code.format(method, statement))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rse_ast_tree(code.format(method, statement))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "170": {
  "name": "_MethodArgs",
  "type": "typing.NamedTuple",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "38",
  "column": "0",
  "slicing": "[\"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\"]",
  "context": "s}):\n        {statement}\n        return None\n\"\"\"\n\n_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\n\nvalid_method_args: List[_MethodArgs] = [\n    _Met"
 },
 "171": {
  "name": "valid_method_args",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "40",
  "column": "0",
  "slicing": "['valid_method_args: List[_MethodArgs] = [\\n', '    valid_method_args.extend([\\n', \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\"]",
  "context": "e('_MethodArgs', definition=str, invocation=str)\n\nvalid_method_args: List[_MethodArgs] = [\n    _MethodArgs('', ''),\n    _MethodArgs('a', 'a')"
 },
 "172": {
  "name": "valid_statements",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "63",
  "column": "0",
  "slicing": "['valid_statements = [\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('statements', valid_statements)\\n\"]",
  "context": "*arg, c, **kw', 'a, b, *arg, **kw, c=c'),\n    ])\n\nvalid_statements = [\n    '\"\"\"Valid docstring.\"\"\"',\n    '',\n]\n\nvalid_sup"
 },
 "173": {
  "name": "valid_super_args",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "68",
  "column": "0",
  "slicing": "['valid_super_args = (\\n', \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\"]",
  "context": "ents = [\n    '\"\"\"Valid docstring.\"\"\"',\n    '',\n]\n\nvalid_super_args = (\n    '',\n    'Useless, self',\n    'Useless, obj=sel"
 },
 "174": {
  "name": "invalid_method_args",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "77",
  "column": "0",
  "slicing": "['invalid_method_args: List[_MethodArgs] = [\\n', \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\"]",
  "context": "seless, obj=self',\n    'obj=self, t=Useless',\n)\n\n\ninvalid_method_args: List[_MethodArgs] = [\n    _MethodArgs('', 'a=1'),\n    _MethodArgs('', '1"
 },
 "175": {
  "name": "invalid_statements",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "108",
  "column": "0",
  "slicing": "['invalid_statements = [\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\"]",
  "context": "dArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\n]\n\ninvalid_statements = [\n    'print(1)',\n    'a = 1',\n    'self.other()',\n "
 },
 "176": {
  "name": "invalid_super_args",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "115",
  "column": "0",
  "slicing": "['invalid_super_args = (\\n', \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\"]",
  "context": "lf.other()',\n    '\"\"\"Docstring.\"\"\"; print(1)',\n]\n\ninvalid_super_args = (\n    'Useless',\n    'Useless, object',\n    'Useless"
 },
 "177": {
  "name": "formatted_code",
  "type": "mode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "146",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sting situations with useless overwriting.\"\"\"\n    formatted_code = mode(code.format(\n        decorator='',\n        args_definition=meth"
 },
 "178": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "154",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rgs_invocation=method_args.invocation,\n    ))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "179": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "156",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [oop"
 },
 "180": {
  "name": "formatted_code",
  "type": "mode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "184",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "eful overwriting due to invalid decorator.\"\"\"\n    formatted_code = mode(code.format(\n        decorator=decorator,\n        args_definiti"
 },
 "181": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "192",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rgs_invocation=method_args.invocation,\n    ))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "182": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "194",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "183": {
  "name": "formatted_code",
  "type": "mode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "218",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ful overwriting due to invalid statements.\"\"\"\n    formatted_code = mode(code.format(\n        decorator='',\n        args_definition=meth"
 },
 "184": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "226",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rgs_invocation=method_args.invocation,\n    ))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "185": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "228",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "186": {
  "name": "formatted_code",
  "type": "mode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "252",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ful overwriting due to invalid super args.\"\"\"\n    formatted_code = mode(code.format(\n        decorator='',\n        args_definition=meth"
 },
 "187": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "260",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rgs_invocation=method_args.invocation,\n    ))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "188": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "262",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "189": {
  "name": "formatted_code",
  "type": "mode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "286",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " useful overwriting due to invalid method.\"\"\"\n    formatted_code = mode(code.format(\n        decorator='',\n        args_definition=meth"
 },
 "190": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "294",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rgs_invocation=method_args.invocation,\n    ))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "191": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "296",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "192": {
  "name": "formatted_code",
  "type": "mode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "320",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ul overwriting due to invalid method args.\"\"\"\n    formatted_code = mode(code.format(\n        decorator='',\n        args_definition=meth"
 },
 "193": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "328",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rgs_invocation=method_args.invocation,\n    ))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "194": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "330",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "195": {
  "name": "formatted_code",
  "type": "mode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "358",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "overwriting due to totally different body.\"\"\"\n    formatted_code = mode(code.format(args=args, statement=statement))\n    tree = parse_ast_tree(formatted_code)\n\n    vis"
 },
 "196": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "359",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "(code.format(args=args, statement=statement))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "197": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_useless_overwriting_method.py",
  "lineno": "361",
  "column": "4",
  "slicing": "['regular_method_detailed = \"\"\"\\n', 'regular_method_detailed_with_return = \"\"\"\\n', \"_MethodArgs = NamedTuple('_MethodArgs', definition=str, invocation=str)\\n\", 'valid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', ''),\\n\", \"    _MethodArgs('a', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=b'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=a'),\\n\", \"    _MethodArgs('a, *args', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs, a=a'),\\n\", '    valid_method_args.extend([\\n', \"        _MethodArgs('/, a, b', 'a, b'),\\n\", \"        _MethodArgs('a, /, b', 'a, b'),\\n\", \"        _MethodArgs('a, b, /', 'a, b'),\\n\", \"        _MethodArgs('a, /, b, *, c', 'a, b, c=c'),\\n\", \"        _MethodArgs('a, /, b, *args, **kwargs', 'a, b, *args, **kwargs'),\\n\", \"        _MethodArgs('a, /, b, *arg, c, **kw', 'a, b, *arg, **kw, c=c'),\\n\", 'valid_statements = [\\n', 'valid_super_args = (\\n', 'invalid_method_args: List[_MethodArgs] = [\\n', \"    _MethodArgs('', 'a=1'),\\n\", \"    _MethodArgs('', '1'),\\n\", \"    _MethodArgs('a', ''),\\n\", \"    _MethodArgs('a', 'a, 1'),\\n\", \"    _MethodArgs('a, b', 'a'),\\n\", \"    _MethodArgs('a, b', 'a, b, 1'),\\n\", \"    _MethodArgs('a, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a'),\\n\", \"    _MethodArgs('a, *, b', '1, b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=1'),\\n\", \"    _MethodArgs('a, *, b', 'a=1, b=b'),\\n\", \"    _MethodArgs('a, *, b', 'a, b=b, c=1'),\\n\", \"    _MethodArgs('*, a, b', 'a=a, b=1'),\\n\", \"    _MethodArgs('*, a, b', 'b=b, a=1'),\\n\", \"    _MethodArgs('a, *args', 'a'),\\n\", \"    _MethodArgs('a, *args', 'a, 1, *args'),\\n\", \"    _MethodArgs('a, *args', 'a=1, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, **kwargs2'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args2, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, 1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', '1, *args, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a, *args, b=1, **kwargs'),\\n\", \"    _MethodArgs('a, *args, **kwargs', 'a=1, *args, **kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a'),\\n\", \"    _MethodArgs('*, a, **kwargs', '**kwargs'),\\n\", \"    _MethodArgs('*, a, **kwargs', 'a=a, b=1, **kwargs'),\\n\", 'invalid_statements = [\\n', 'invalid_super_args = (\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [oop.UselessOverwrittenMethodViolation])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', invalid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', invalid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', valid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_method_detailed,\\n', '    regular_method_detailed_with_return,\\n', \"@pytest.mark.parametrize('statements', valid_statements)\\n\", \"@pytest.mark.parametrize('method_args', invalid_method_args)\\n\", \"@pytest.mark.parametrize('super_args', valid_super_args)\\n\", '    formatted_code = mode(code.format(\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    formatted_code = mode(code.format(args=args, statement=statement))\\n', '    tree = parse_ast_tree(formatted_code)\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "))\n    tree = parse_ast_tree(formatted_code)\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "198": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_staticmethod.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['decorated_method = \"\"\"\\n', \"    tree = parse_ast_tree(mode(decorated_method.format('staticmethod')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StaticMethodViolation])\\n', '    tree = parse_ast_tree(mode(decorated_method.format(decorator)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "in functions are restricted as decorators.\"\"\"\n    tree = parse_ast_tree(mode(decorated_method.format('staticmethod')))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "199": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_staticmethod.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['decorated_method = \"\"\"\\n', \"    tree = parse_ast_tree(mode(decorated_method.format('staticmethod')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StaticMethodViolation])\\n', '    tree = parse_ast_tree(mode(decorated_method.format(decorator)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "de(decorated_method.format('staticmethod')))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sta"
 },
 "200": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_staticmethod.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['decorated_method = \"\"\"\\n', \"    tree = parse_ast_tree(mode(decorated_method.format('staticmethod')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StaticMethodViolation])\\n', '    tree = parse_ast_tree(mode(decorated_method.format(decorator)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "Testing that other decorators are allowed.\"\"\"\n    tree = parse_ast_tree(mode(decorated_method.format(decorator)))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "201": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_staticmethod.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['decorated_method = \"\"\"\\n', \"    tree = parse_ast_tree(mode(decorated_method.format('staticmethod')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StaticMethodViolation])\\n', '    tree = parse_ast_tree(mode(decorated_method.format(decorator)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee(mode(decorated_method.format(decorator)))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "202": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_method_without_arguments.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['method_inside_class = \"\"\"\\n', \"regular_function = 'def some_name({0}): ...'\\n\", \"    tree = parse_ast_tree(mode(method_inside_class.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MethodWithoutArgumentsViolation])\\n', \"    assert_error_text(visitor, 'some_name')\\n\", \"    tree = parse_ast_tree(mode(regular_function.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_inside_class,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(arguments)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "o arguments for method raises a violation.\"\"\"\n    tree = parse_ast_tree(mode(method_inside_class.format('')))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "203": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_method_without_arguments.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['method_inside_class = \"\"\"\\n', \"regular_function = 'def some_name({0}): ...'\\n\", \"    tree = parse_ast_tree(mode(method_inside_class.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MethodWithoutArgumentsViolation])\\n', \"    assert_error_text(visitor, 'some_name')\\n\", \"    tree = parse_ast_tree(mode(regular_function.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_inside_class,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(arguments)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t_tree(mode(method_inside_class.format('')))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Met"
 },
 "204": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_method_without_arguments.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['method_inside_class = \"\"\"\\n', \"regular_function = 'def some_name({0}): ...'\\n\", \"    tree = parse_ast_tree(mode(method_inside_class.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MethodWithoutArgumentsViolation])\\n', \"    assert_error_text(visitor, 'some_name')\\n\", \"    tree = parse_ast_tree(mode(regular_function.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_inside_class,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(arguments)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "o arguments for method raises a violation.\"\"\"\n    tree = parse_ast_tree(mode(regular_function.format('')))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "205": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_method_without_arguments.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['method_inside_class = \"\"\"\\n', \"regular_function = 'def some_name({0}): ...'\\n\", \"    tree = parse_ast_tree(mode(method_inside_class.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MethodWithoutArgumentsViolation])\\n', \"    assert_error_text(visitor, 'some_name')\\n\", \"    tree = parse_ast_tree(mode(regular_function.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_inside_class,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(arguments)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(mode(regular_function.format('')))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "206": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_method_without_arguments.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['method_inside_class = \"\"\"\\n', \"regular_function = 'def some_name({0}): ...'\\n\", \"    tree = parse_ast_tree(mode(method_inside_class.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MethodWithoutArgumentsViolation])\\n', \"    assert_error_text(visitor, 'some_name')\\n\", \"    tree = parse_ast_tree(mode(regular_function.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_inside_class,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(arguments)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sting that other methods are working fine.\"\"\"\n    tree = parse_ast_tree(mode(code.format(arguments)))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "207": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_method_without_arguments.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['method_inside_class = \"\"\"\\n', \"regular_function = 'def some_name({0}): ...'\\n\", \"    tree = parse_ast_tree(mode(method_inside_class.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MethodWithoutArgumentsViolation])\\n', \"    assert_error_text(visitor, 'some_name')\\n\", \"    tree = parse_ast_tree(mode(regular_function.format('')))\\n\", '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    method_inside_class,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(arguments)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(arguments)))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "208": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_async_magic_methods.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['sync_method = \"\"\"\\n', 'async_method = \"\"\"\\n', '    tree = parse_ast_tree(async_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AsyncMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    sync_method,\\n', '    async_method,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(sync_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(sync_method.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t some async magic methods are restricted.\"\"\"\n    tree = parse_ast_tree(async_method.format(method))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "209": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_async_magic_methods.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['sync_method = \"\"\"\\n', 'async_method = \"\"\"\\n', '    tree = parse_ast_tree(async_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AsyncMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    sync_method,\\n', '    async_method,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(sync_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(sync_method.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(async_method.format(method))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Asy"
 },
 "210": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_async_magic_methods.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['sync_method = \"\"\"\\n', 'async_method = \"\"\"\\n', '    tree = parse_ast_tree(async_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AsyncMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    sync_method,\\n', '    async_method,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(sync_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(sync_method.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "some async magic methods are working fine.\"\"\"\n    tree = parse_ast_tree(code.format(method))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "211": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_async_magic_methods.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['sync_method = \"\"\"\\n', 'async_method = \"\"\"\\n', '    tree = parse_ast_tree(async_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AsyncMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    sync_method,\\n', '    async_method,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(sync_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(sync_method.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  tree = parse_ast_tree(code.format(method))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "212": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_async_magic_methods.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['sync_method = \"\"\"\\n', 'async_method = \"\"\"\\n', '    tree = parse_ast_tree(async_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AsyncMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    sync_method,\\n', '    async_method,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(sync_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(sync_method.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t any sync magic methods are working fine.\"\"\"\n    tree = parse_ast_tree(sync_method.format(method))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "213": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_async_magic_methods.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['sync_method = \"\"\"\\n', 'async_method = \"\"\"\\n', '    tree = parse_ast_tree(async_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AsyncMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    sync_method,\\n', '    async_method,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(sync_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(sync_method.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "= parse_ast_tree(sync_method.format(method))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "214": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_async_magic_methods.py",
  "lineno": "104",
  "column": "4",
  "slicing": "['sync_method = \"\"\"\\n', 'async_method = \"\"\"\\n', '    tree = parse_ast_tree(async_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AsyncMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    sync_method,\\n', '    async_method,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(sync_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(sync_method.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sting that other methods are working fine.\"\"\"\n    tree = parse_ast_tree(mode(sync_method.format(method)))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "215": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_async_magic_methods.py",
  "lineno": "106",
  "column": "4",
  "slicing": "['sync_method = \"\"\"\\n', 'async_method = \"\"\"\\n', '    tree = parse_ast_tree(async_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [AsyncMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    sync_method,\\n', '    async_method,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(sync_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(sync_method.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e_ast_tree(mode(sync_method.format(method)))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "216": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_magic_methods.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['magic_method = \"\"\"\\n', \"regular_function = 'def {0}(): ...'\\n\", '    tree = parse_ast_tree(magic_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ng that some magic methods are restricted.\"\"\"\n    tree = parse_ast_tree(magic_method.format(method))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "217": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_magic_methods.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['magic_method = \"\"\"\\n', \"regular_function = 'def {0}(): ...'\\n\", '    tree = parse_ast_tree(magic_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(magic_method.format(method))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Bad"
 },
 "218": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_magic_methods.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['magic_method = \"\"\"\\n', \"regular_function = 'def {0}(): ...'\\n\", '    tree = parse_ast_tree(magic_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that some magic methods are working fine.\"\"\"\n    tree = parse_ast_tree(code.format(method))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "219": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_magic_methods.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['magic_method = \"\"\"\\n', \"regular_function = 'def {0}(): ...'\\n\", '    tree = parse_ast_tree(magic_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  tree = parse_ast_tree(code.format(method))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "220": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_magic_methods.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['magic_method = \"\"\"\\n', \"regular_function = 'def {0}(): ...'\\n\", '    tree = parse_ast_tree(magic_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sting that other methods are working fine.\"\"\"\n    tree = parse_ast_tree(mode(code.format(method)))\n\n    visitor = WrongMethodVisitor(default_options,"
 },
 "221": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongMethodVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_methods/test_magic_methods.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['magic_method = \"\"\"\\n', \"regular_function = 'def {0}(): ...'\\n\", '    tree = parse_ast_tree(magic_method.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicMethodViolation])\\n', '    assert_error_text(visitor, method)\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(code.format(method))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_method,\\n', '    regular_function,\\n', '    tree = parse_ast_tree(mode(code.format(method)))\\n', '    visitor = WrongMethodVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(mode(code.format(method)))\n\n    visitor = WrongMethodVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "222": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_shadow_attributes.py",
  "lineno": "128",
  "column": "4",
  "slicing": "['class_attribute = \"\"\"\\n', 'class_annotated_attribute = \"\"\"\\n', 'class_attribute_logic = \"\"\"\\n', 'class_attribute_runtime = \"\"\"\\n', 'class_attribute_annotated = \"\"\"\\n', 'class_annotation = \"\"\"\\n', 'class_attribute_usage = \"\"\"\\n', 'class_attribute_regular_assign = \"\"\"\\n', 'class_attribute_with_other = \"\"\"\\n', 'class_complex_attribute = \"\"\"\\n', 'class_complex_attribute_annotated = \"\"\"\\n', 'regular_assigns = \"\"\"\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_attribute_logic,\\n', '    tree = parse_ast_tree(code.format(field_name, field_name))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShadowedClassAttributeViolation])\\n', '    assert_error_text(visitor, field_name)\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_annotation,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    class_attribute_usage,\\n', '    class_attribute_logic,\\n', '    class_attribute_regular_assign,\\n', '    class_attribute_with_other,\\n', '    regular_assigns,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_annotation,\\n', '    class_attribute_usage,\\n', '    class_attribute_regular_assign,\\n', '    regular_assigns,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ting that incorrect fields are prohibited.\"\"\"\n    tree = parse_ast_tree(code.format(field_name, field_name))\n\n    visitor = ClassAttributeVisitor(default_optio"
 },
 "223": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.ClassAttributeVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_shadow_attributes.py",
  "lineno": "130",
  "column": "4",
  "slicing": "['class_attribute = \"\"\"\\n', 'class_annotated_attribute = \"\"\"\\n', 'class_attribute_logic = \"\"\"\\n', 'class_attribute_runtime = \"\"\"\\n', 'class_attribute_annotated = \"\"\"\\n', 'class_annotation = \"\"\"\\n', 'class_attribute_usage = \"\"\"\\n', 'class_attribute_regular_assign = \"\"\"\\n', 'class_attribute_with_other = \"\"\"\\n', 'class_complex_attribute = \"\"\"\\n', 'class_complex_attribute_annotated = \"\"\"\\n', 'regular_assigns = \"\"\"\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_attribute_logic,\\n', '    tree = parse_ast_tree(code.format(field_name, field_name))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShadowedClassAttributeViolation])\\n', '    assert_error_text(visitor, field_name)\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_annotation,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    class_attribute_usage,\\n', '    class_attribute_logic,\\n', '    class_attribute_regular_assign,\\n', '    class_attribute_with_other,\\n', '    regular_assigns,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_annotation,\\n', '    class_attribute_usage,\\n', '    class_attribute_regular_assign,\\n', '    regular_assigns,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "st_tree(code.format(field_name, field_name))\n\n    visitor = ClassAttributeVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sha"
 },
 "224": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_shadow_attributes.py",
  "lineno": "165",
  "column": "4",
  "slicing": "['class_attribute = \"\"\"\\n', 'class_annotated_attribute = \"\"\"\\n', 'class_attribute_logic = \"\"\"\\n', 'class_attribute_runtime = \"\"\"\\n', 'class_attribute_annotated = \"\"\"\\n', 'class_annotation = \"\"\"\\n', 'class_attribute_usage = \"\"\"\\n', 'class_attribute_regular_assign = \"\"\"\\n', 'class_attribute_with_other = \"\"\"\\n', 'class_complex_attribute = \"\"\"\\n', 'class_complex_attribute_annotated = \"\"\"\\n', 'regular_assigns = \"\"\"\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_attribute_logic,\\n', '    tree = parse_ast_tree(code.format(field_name, field_name))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShadowedClassAttributeViolation])\\n', '    assert_error_text(visitor, field_name)\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_annotation,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    class_attribute_usage,\\n', '    class_attribute_logic,\\n', '    class_attribute_regular_assign,\\n', '    class_attribute_with_other,\\n', '    regular_assigns,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_annotation,\\n', '    class_attribute_usage,\\n', '    class_attribute_regular_assign,\\n', '    regular_assigns,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"Testing that correct fields are allowed.\"\"\"\n    tree = parse_ast_tree(code.format(field1, field2))\n\n    visitor = ClassAttributeVisitor(default_optio"
 },
 "225": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.ClassAttributeVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_shadow_attributes.py",
  "lineno": "167",
  "column": "4",
  "slicing": "['class_attribute = \"\"\"\\n', 'class_annotated_attribute = \"\"\"\\n', 'class_attribute_logic = \"\"\"\\n', 'class_attribute_runtime = \"\"\"\\n', 'class_attribute_annotated = \"\"\"\\n', 'class_annotation = \"\"\"\\n', 'class_attribute_usage = \"\"\"\\n', 'class_attribute_regular_assign = \"\"\"\\n', 'class_attribute_with_other = \"\"\"\\n', 'class_complex_attribute = \"\"\"\\n', 'class_complex_attribute_annotated = \"\"\"\\n', 'regular_assigns = \"\"\"\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_attribute_logic,\\n', '    tree = parse_ast_tree(code.format(field_name, field_name))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShadowedClassAttributeViolation])\\n', '    assert_error_text(visitor, field_name)\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_annotation,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    class_attribute_usage,\\n', '    class_attribute_logic,\\n', '    class_attribute_regular_assign,\\n', '    class_attribute_with_other,\\n', '    regular_assigns,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_annotation,\\n', '    class_attribute_usage,\\n', '    class_attribute_regular_assign,\\n', '    regular_assigns,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(code.format(field1, field2))\n\n    visitor = ClassAttributeVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "226": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_shadow_attributes.py",
  "lineno": "195",
  "column": "4",
  "slicing": "['class_attribute = \"\"\"\\n', 'class_annotated_attribute = \"\"\"\\n', 'class_attribute_logic = \"\"\"\\n', 'class_attribute_runtime = \"\"\"\\n', 'class_attribute_annotated = \"\"\"\\n', 'class_annotation = \"\"\"\\n', 'class_attribute_usage = \"\"\"\\n', 'class_attribute_regular_assign = \"\"\"\\n', 'class_attribute_with_other = \"\"\"\\n', 'class_complex_attribute = \"\"\"\\n', 'class_complex_attribute_annotated = \"\"\"\\n', 'regular_assigns = \"\"\"\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_attribute_logic,\\n', '    tree = parse_ast_tree(code.format(field_name, field_name))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShadowedClassAttributeViolation])\\n', '    assert_error_text(visitor, field_name)\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_annotation,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    class_attribute_usage,\\n', '    class_attribute_logic,\\n', '    class_attribute_regular_assign,\\n', '    class_attribute_with_other,\\n', '    regular_assigns,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_annotation,\\n', '    class_attribute_usage,\\n', '    class_attribute_regular_assign,\\n', '    regular_assigns,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "g that safe fields can be used everywhere.\"\"\"\n    tree = parse_ast_tree(code.format(field1, field2))\n\n    visitor = ClassAttributeVisitor(default_optio"
 },
 "227": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.ClassAttributeVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_shadow_attributes.py",
  "lineno": "197",
  "column": "4",
  "slicing": "['class_attribute = \"\"\"\\n', 'class_annotated_attribute = \"\"\"\\n', 'class_attribute_logic = \"\"\"\\n', 'class_attribute_runtime = \"\"\"\\n', 'class_attribute_annotated = \"\"\"\\n', 'class_annotation = \"\"\"\\n', 'class_attribute_usage = \"\"\"\\n', 'class_attribute_regular_assign = \"\"\"\\n', 'class_attribute_with_other = \"\"\"\\n', 'class_complex_attribute = \"\"\"\\n', 'class_complex_attribute_annotated = \"\"\"\\n', 'regular_assigns = \"\"\"\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_attribute_logic,\\n', '    tree = parse_ast_tree(code.format(field_name, field_name))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShadowedClassAttributeViolation])\\n', '    assert_error_text(visitor, field_name)\\n', '    class_attribute,\\n', '    class_annotated_attribute,\\n', '    class_attribute_runtime,\\n', '    class_attribute_annotated,\\n', '    class_annotation,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    class_attribute_usage,\\n', '    class_attribute_logic,\\n', '    class_attribute_regular_assign,\\n', '    class_attribute_with_other,\\n', '    regular_assigns,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_annotation,\\n', '    class_attribute_usage,\\n', '    class_attribute_regular_assign,\\n', '    regular_assigns,\\n', '    class_complex_attribute,\\n', '    class_complex_attribute_annotated,\\n', '    tree = parse_ast_tree(code.format(field1, field2))\\n', '    visitor = ClassAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(code.format(field1, field2))\n\n    visitor = ClassAttributeVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "228": {
  "name": "wrong_slots",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_slots_syntax.py",
  "lineno": "21",
  "column": "0",
  "slicing": "['wrong_slots = (\\n', \"@pytest.mark.parametrize('code', wrong_slots)\\n\", \"@pytest.mark.parametrize('code', wrong_slots + correct_slots)\\n\"]",
  "context": "ssWithoutSlots(object):\n    some_other = {0}\n\"\"\"\n\nwrong_slots = (\n    '[]',\n    '[\"field\", \"other\"]',\n    '[x for x "
 },
 "229": {
  "name": "correct_slots",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_slots_syntax.py",
  "lineno": "52",
  "column": "0",
  "slicing": "['correct_slots = (\\n', \"@pytest.mark.parametrize('code', correct_slots)\\n\", \"@pytest.mark.parametrize('code', wrong_slots + correct_slots)\\n\"]",
  "context": "',  # invalid name\n    '(\"a\", b\"b\")',  # bytes\n)\n\ncorrect_slots = (\n    '()',\n    '(\"A\",)',\n    '(\"a\", \"b1\")',\n    '(\""
 },
 "230": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_slots_syntax.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', 'class_body_typed_template = \"\"\"\\n', 'wrong_slots = (\\n', 'correct_slots = (\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', wrong_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSlotsViolation])\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('code', wrong_slots + correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sting that incorrect slots are prohibited.\"\"\"\n    tree = parse_ast_tree(template.format(code))\n\n    visitor = WrongSlotsVisitor(default_options, "
 },
 "231": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongSlotsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_slots_syntax.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', 'class_body_typed_template = \"\"\"\\n', 'wrong_slots = (\\n', 'correct_slots = (\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', wrong_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSlotsViolation])\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('code', wrong_slots + correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(template.format(code))\n\n    visitor = WrongSlotsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "232": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_slots_syntax.py",
  "lineno": "106",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', 'class_body_typed_template = \"\"\"\\n', 'wrong_slots = (\\n', 'correct_slots = (\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', wrong_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSlotsViolation])\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('code', wrong_slots + correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing that correct slots are allowed.\"\"\"\n    tree = parse_ast_tree(template.format(code))\n\n    visitor = WrongSlotsVisitor(default_options, "
 },
 "233": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongSlotsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_slots_syntax.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', 'class_body_typed_template = \"\"\"\\n', 'wrong_slots = (\\n', 'correct_slots = (\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', wrong_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSlotsViolation])\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('code', wrong_slots + correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(template.format(code))\n\n    visitor = WrongSlotsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "234": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_slots_syntax.py",
  "lineno": "126",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', 'class_body_typed_template = \"\"\"\\n', 'wrong_slots = (\\n', 'correct_slots = (\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', wrong_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSlotsViolation])\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('code', wrong_slots + correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    \"\"\"Testing that not slots are correct.\"\"\"\n    tree = parse_ast_tree(template.format(code))\n\n    visitor = WrongSlotsVisitor(default_options, "
 },
 "235": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongSlotsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_class_attributes/test_slots_syntax.py",
  "lineno": "128",
  "column": "4",
  "slicing": "['class_body_template = \"\"\"\\n', 'class_body_typed_template = \"\"\"\\n', 'wrong_slots = (\\n', 'correct_slots = (\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', wrong_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSlotsViolation])\\n', '    class_body_template,\\n', '    class_body_typed_template,\\n', \"@pytest.mark.parametrize('code', correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('code', wrong_slots + correct_slots)\\n\", '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongSlotsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(template.format(code))\n\n    visitor = WrongSlotsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "236": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_base_builtin_classes.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', '    tree = parse_ast_tree(class_with_base.format(super_class))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BuiltinSubclassViolation])\\n', '    tree = parse_ast_tree(class_with_base.format(super_class))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t it is not possible to subclass builtins.\"\"\"\n    tree = parse_ast_tree(class_with_base.format(super_class))\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "237": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_base_builtin_classes.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', '    tree = parse_ast_tree(class_with_base.format(super_class))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BuiltinSubclassViolation])\\n', '    tree = parse_ast_tree(class_with_base.format(super_class))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "st_tree(class_with_base.format(super_class))\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Bui"
 },
 "238": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_base_builtin_classes.py",
  "lineno": "48",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', '    tree = parse_ast_tree(class_with_base.format(super_class))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BuiltinSubclassViolation])\\n', '    tree = parse_ast_tree(class_with_base.format(super_class))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that it is possible to subclass regulars.\"\"\"\n    tree = parse_ast_tree(class_with_base.format(super_class))\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "239": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_base_builtin_classes.py",
  "lineno": "50",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', '    tree = parse_ast_tree(class_with_base.format(super_class))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BuiltinSubclassViolation])\\n', '    tree = parse_ast_tree(class_with_base.format(super_class))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "st_tree(class_with_base.format(super_class))\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "240": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_object_base_class.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['class_without_base = \"\"\"\\n', 'class_with_empty_base = \"\"\"\\n', 'nested_class_without_base = \"\"\"\\n', 'nested_class_with_empty_base = \"\"\"\\n', '    class_without_base,\\n', '    class_with_empty_base,\\n', '    nested_class_without_base,\\n', '    nested_class_with_empty_base,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RequiredBaseClassViolation])\\n', \"    assert_error_text(visitor, 'Meta')\\n\", '    tree = parse_ast_tree(code.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ot using explicit base class is forbidden.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "241": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_object_base_class.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['class_without_base = \"\"\"\\n', 'class_with_empty_base = \"\"\"\\n', 'nested_class_without_base = \"\"\"\\n', 'nested_class_with_empty_base = \"\"\"\\n', '    class_without_base,\\n', '    class_with_empty_base,\\n', '    nested_class_without_base,\\n', '    nested_class_with_empty_base,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RequiredBaseClassViolation])\\n', \"    assert_error_text(visitor, 'Meta')\\n\", '    tree = parse_ast_tree(code.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "orbidden.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Req"
 },
 "242": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_object_base_class.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['class_without_base = \"\"\"\\n', 'class_with_empty_base = \"\"\"\\n', 'nested_class_without_base = \"\"\"\\n', 'nested_class_with_empty_base = \"\"\"\\n', '    class_without_base,\\n', '    class_with_empty_base,\\n', '    nested_class_without_base,\\n', '    nested_class_with_empty_base,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RequiredBaseClassViolation])\\n', \"    assert_error_text(visitor, 'Meta')\\n\", '    tree = parse_ast_tree(code.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing that regular base classes work.\"\"\"\n    tree = parse_ast_tree(code.format(base))\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "243": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_object_base_class.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['class_without_base = \"\"\"\\n', 'class_with_empty_base = \"\"\"\\n', 'nested_class_without_base = \"\"\"\\n', 'nested_class_with_empty_base = \"\"\"\\n', '    class_without_base,\\n', '    class_with_empty_base,\\n', '    nested_class_without_base,\\n', '    nested_class_with_empty_base,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RequiredBaseClassViolation])\\n', \"    assert_error_text(visitor, 'Meta')\\n\", '    tree = parse_ast_tree(code.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    tree = parse_ast_tree(code.format(base))\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "244": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_expression_base_class.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', '    tree = parse_ast_tree(class_with_base.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongBaseClassViolation])\\n', '    tree = parse_ast_tree(class_with_base.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sible to use any incorrect nodes as bases.\"\"\"\n    tree = parse_ast_tree(class_with_base.format(base))\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "245": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_expression_base_class.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', '    tree = parse_ast_tree(class_with_base.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongBaseClassViolation])\\n', '    tree = parse_ast_tree(class_with_base.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(class_with_base.format(base))\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "246": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_expression_base_class.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', '    tree = parse_ast_tree(class_with_base.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongBaseClassViolation])\\n', '    tree = parse_ast_tree(class_with_base.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "is possible to use correct nodes as bases.\"\"\"\n    tree = parse_ast_tree(class_with_base.format(base))\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "247": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_expression_base_class.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', '    tree = parse_ast_tree(class_with_base.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongBaseClassViolation])\\n', '    tree = parse_ast_tree(class_with_base.format(base))\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(class_with_base.format(base))\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "248": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_object_as_parent.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['extra_object = \"\"\"\\n', '    extra_object,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ObjectInBaseClassesListViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n):\n    \"\"\"Testing wrong class definition.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "249": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_object_as_parent.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['extra_object = \"\"\"\\n', '    extra_object,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ObjectInBaseClassesListViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "finition.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Obj"
 },
 "250": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_object_as_parent.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['extra_object = \"\"\"\\n', '    extra_object,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ObjectInBaseClassesListViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rrect class definition with single parent.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "251": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_object_as_parent.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['extra_object = \"\"\"\\n', '    extra_object,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ObjectInBaseClassesListViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e parent.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "252": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_base_exception_base_class.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', \"    tree = parse_ast_tree(class_with_base.format('BaseException'))\\n\", '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionSubclassViolation])\\n']",
  "context": " not possible to subclass `BaseException`.\"\"\"\n    tree = parse_ast_tree(class_with_base.format('BaseException'))\n\n    visitor = WrongClassVisitor(default_options, "
 },
 "253": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.classes.WrongClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_classes/test_base_classes/test_base_exception_base_class.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['class_with_base = \"\"\"\\n', \"    tree = parse_ast_tree(class_with_base.format('BaseException'))\\n\", '    visitor = WrongClassVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionSubclassViolation])\\n']",
  "context": "ree(class_with_base.format('BaseException'))\n\n    visitor = WrongClassVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Bas"
 },
 "254": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_redundant_subscripts.py",
  "lineno": "27",
  "column": "4",
  "slicing": "[\"usage_template = 'constant[{0}]'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = SubscriptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RedundantSubscriptViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = SubscriptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "g that redundant subscripts are forbidden.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = SubscriptVisitor(default_options, t"
 },
 "255": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.subscripts.SubscriptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_redundant_subscripts.py",
  "lineno": "29",
  "column": "4",
  "slicing": "[\"usage_template = 'constant[{0}]'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = SubscriptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RedundantSubscriptViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = SubscriptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = SubscriptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Red"
 },
 "256": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_redundant_subscripts.py",
  "lineno": "57",
  "column": "4",
  "slicing": "[\"usage_template = 'constant[{0}]'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = SubscriptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RedundantSubscriptViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = SubscriptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that non-redundant subscripts are allowed.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = SubscriptVisitor(default_options, t"
 },
 "257": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.subscripts.SubscriptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_redundant_subscripts.py",
  "lineno": "59",
  "column": "4",
  "slicing": "[\"usage_template = 'constant[{0}]'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = SubscriptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RedundantSubscriptViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = SubscriptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = SubscriptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "258": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_implicit_negative_index.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitNegativeIndexViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t implicit negative indexes are forbidden.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CorrectKeyVisitor(default_options, "
 },
 "259": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.subscripts.CorrectKeyVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_implicit_negative_index.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitNegativeIndexViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "orbidden.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CorrectKeyVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "260": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_implicit_negative_index.py",
  "lineno": "54",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitNegativeIndexViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing that explicit negative calls are fine.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CorrectKeyVisitor(default_options, "
 },
 "261": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.subscripts.CorrectKeyVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_implicit_negative_index.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitNegativeIndexViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "are fine.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CorrectKeyVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "262": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_implicit_get.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['if_template1 = \"\"\"\\n', 'if_template2 = \"\"\"\\n', 'if_template3 = \"\"\"\\n', 'if_template4 = \"\"\"\\n', 'if_template5 = \"\"\"\\n', '    if_template1,\\n', '    if_template2,\\n', '    if_template3,\\n', '    if_template4,\\n', '    if_template5,\\n', '    tree = parse_ast_tree(template.format(compare, expression))\\n', '    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitDictGetViolation])\\n', '    if_template1,\\n', '    if_template2,\\n', '    if_template3,\\n', '    if_template4,\\n', '    if_template5,\\n', '    tree = parse_ast_tree(template.format(compare, expression))\\n', '    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"Testing that implicit `.get` is detected.\"\"\"\n    tree = parse_ast_tree(template.format(compare, expression))\n\n    visitor = ImplicitDictGetVisitor(default_opti"
 },
 "263": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.subscripts.ImplicitDictGetVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_implicit_get.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['if_template1 = \"\"\"\\n', 'if_template2 = \"\"\"\\n', 'if_template3 = \"\"\"\\n', 'if_template4 = \"\"\"\\n', 'if_template5 = \"\"\"\\n', '    if_template1,\\n', '    if_template2,\\n', '    if_template3,\\n', '    if_template4,\\n', '    if_template5,\\n', '    tree = parse_ast_tree(template.format(compare, expression))\\n', '    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitDictGetViolation])\\n', '    if_template1,\\n', '    if_template2,\\n', '    if_template3,\\n', '    if_template4,\\n', '    if_template5,\\n', '    tree = parse_ast_tree(template.format(compare, expression))\\n', '    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t_tree(template.format(compare, expression))\n\n    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "264": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_implicit_get.py",
  "lineno": "109",
  "column": "4",
  "slicing": "['if_template1 = \"\"\"\\n', 'if_template2 = \"\"\"\\n', 'if_template3 = \"\"\"\\n', 'if_template4 = \"\"\"\\n', 'if_template5 = \"\"\"\\n', '    if_template1,\\n', '    if_template2,\\n', '    if_template3,\\n', '    if_template4,\\n', '    if_template5,\\n', '    tree = parse_ast_tree(template.format(compare, expression))\\n', '    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitDictGetViolation])\\n', '    if_template1,\\n', '    if_template2,\\n', '    if_template3,\\n', '    if_template4,\\n', '    if_template5,\\n', '    tree = parse_ast_tree(template.format(compare, expression))\\n', '    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Testing that correct `if` can be used.\"\"\"\n    tree = parse_ast_tree(template.format(compare, expression))\n\n    visitor = ImplicitDictGetVisitor(default_opti"
 },
 "265": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.subscripts.ImplicitDictGetVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_implicit_get.py",
  "lineno": "111",
  "column": "4",
  "slicing": "['if_template1 = \"\"\"\\n', 'if_template2 = \"\"\"\\n', 'if_template3 = \"\"\"\\n', 'if_template4 = \"\"\"\\n', 'if_template5 = \"\"\"\\n', '    if_template1,\\n', '    if_template2,\\n', '    if_template3,\\n', '    if_template4,\\n', '    if_template5,\\n', '    tree = parse_ast_tree(template.format(compare, expression))\\n', '    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitDictGetViolation])\\n', '    if_template1,\\n', '    if_template2,\\n', '    if_template3,\\n', '    if_template4,\\n', '    if_template5,\\n', '    tree = parse_ast_tree(template.format(compare, expression))\\n', '    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t_tree(template.format(compare, expression))\n\n    visitor = ImplicitDictGetVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "266": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_float_key_usage.py",
  "lineno": "21",
  "column": "4",
  "slicing": "[\"usage_template = 'some_dict[{0}]'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatKeyViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "g that redundant subscripts are forbidden.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = CorrectKeyVisitor(default_options, "
 },
 "267": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.subscripts.CorrectKeyVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_float_key_usage.py",
  "lineno": "23",
  "column": "4",
  "slicing": "[\"usage_template = 'some_dict[{0}]'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatKeyViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = CorrectKeyVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Flo"
 },
 "268": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_float_key_usage.py",
  "lineno": "49",
  "column": "4",
  "slicing": "[\"usage_template = 'some_dict[{0}]'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatKeyViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that non-redundant subscripts are allowed.\"\"\"\n    tree = parse_ast_tree(usage_template.format(expression))\n\n    visitor = CorrectKeyVisitor(default_options, "
 },
 "269": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.subscripts.CorrectKeyVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_subscripts/test_float_key_usage.py",
  "lineno": "51",
  "column": "4",
  "slicing": "[\"usage_template = 'some_dict[{0}]'\\n\", '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatKeyViolation])\\n', '    tree = parse_ast_tree(usage_template.format(expression))\\n', '    visitor = CorrectKeyVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(usage_template.format(expression))\n\n    visitor = CorrectKeyVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "270": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_protected_attributes.py",
  "lineno": "130",
  "column": "4",
  "slicing": "[\"protected_attribute_assigned = 'some._protected = 1'\\n\", \"protected_attribute_accessed = 'print(some._protected)'\\n\", \"protected_method_called = 'some._protected()'\\n\", \"protected_method_called_params = 'some._protected(12, 33)'\\n\", \"builtin_protected_call = 'True()._protected = 1'  # to make coverage happy\\n\", 'protected_container_attribute = \"\"\"\\n', 'protected_container_method = \"\"\"\\n', 'protected_callable_attribute = \"\"\"\\n', '    protected_attribute_assigned,\\n', '    protected_attribute_accessed,\\n', '    builtin_protected_call,\\n', '    protected_method_called,\\n', '    protected_method_called_params,\\n', '    protected_container_attribute,\\n', '    protected_container_method,\\n', '    protected_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedAttributeViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "is impossible to use protected attributes.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAttributeVisitor(default_optio"
 },
 "271": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.attributes.WrongAttributeVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_protected_attributes.py",
  "lineno": "132",
  "column": "4",
  "slicing": "[\"protected_attribute_assigned = 'some._protected = 1'\\n\", \"protected_attribute_accessed = 'print(some._protected)'\\n\", \"protected_method_called = 'some._protected()'\\n\", \"protected_method_called_params = 'some._protected(12, 33)'\\n\", \"builtin_protected_call = 'True()._protected = 1'  # to make coverage happy\\n\", 'protected_container_attribute = \"\"\"\\n', 'protected_container_method = \"\"\"\\n', 'protected_callable_attribute = \"\"\"\\n', '    protected_attribute_assigned,\\n', '    protected_attribute_accessed,\\n', '    builtin_protected_call,\\n', '    protected_method_called,\\n', '    protected_method_called_params,\\n', '    protected_container_attribute,\\n', '    protected_container_method,\\n', '    protected_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedAttributeViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "es.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAttributeVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Pro"
 },
 "272": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_protected_attributes.py",
  "lineno": "162",
  "column": "4",
  "slicing": "[\"protected_attribute_assigned = 'some._protected = 1'\\n\", \"protected_attribute_accessed = 'print(some._protected)'\\n\", \"protected_method_called = 'some._protected()'\\n\", \"protected_method_called_params = 'some._protected(12, 33)'\\n\", \"builtin_protected_call = 'True()._protected = 1'  # to make coverage happy\\n\", 'protected_container_attribute = \"\"\"\\n', 'protected_container_method = \"\"\"\\n', 'protected_callable_attribute = \"\"\"\\n', '    protected_attribute_assigned,\\n', '    protected_attribute_accessed,\\n', '    builtin_protected_call,\\n', '    protected_method_called,\\n', '    protected_method_called_params,\\n', '    protected_container_attribute,\\n', '    protected_container_method,\\n', '    protected_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedAttributeViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t is possible to use protected attributes.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAttributeVisitor(default_optio"
 },
 "273": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.attributes.WrongAttributeVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_protected_attributes.py",
  "lineno": "164",
  "column": "4",
  "slicing": "[\"protected_attribute_assigned = 'some._protected = 1'\\n\", \"protected_attribute_accessed = 'print(some._protected)'\\n\", \"protected_method_called = 'some._protected()'\\n\", \"protected_method_called_params = 'some._protected(12, 33)'\\n\", \"builtin_protected_call = 'True()._protected = 1'  # to make coverage happy\\n\", 'protected_container_attribute = \"\"\"\\n', 'protected_container_method = \"\"\"\\n', 'protected_callable_attribute = \"\"\"\\n', '    protected_attribute_assigned,\\n', '    protected_attribute_accessed,\\n', '    builtin_protected_call,\\n', '    protected_method_called,\\n', '    protected_method_called_params,\\n', '    protected_container_attribute,\\n', '    protected_container_method,\\n', '    protected_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedAttributeViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "es.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAttributeVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "274": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_magic_attributes.py",
  "lineno": "133",
  "column": "4",
  "slicing": "[\"magic_attribute_assigned = 'some.{0} = 1'\\n\", \"magic_attribute_accessed = 'print(some.{0})'\\n\", \"magic_method_called = 'some.{0}()'\\n\", \"magic_method_called_params = 'some.{0}(12, 33)'\\n\", 'magic_container_attribute = \"\"\"\\n', 'magic_container_method = \"\"\"\\n', 'magic_callable_attribute = \"\"\"\\n', \"magic_name_definition = '{0} = 1'\\n\", \"magic_name_attr_definition = '{0}.some = 1'\\n\", 'magic_self_attribute = \"\"\"\\n', 'magic_self_method = \"\"\"\\n', 'magic_cls_attribute = \"\"\"\\n', 'magic_cls_method = \"\"\"\\n', 'magic_attribute_definition = \"\"\"\\n', 'magic_method_definition = \"\"\"\\n', 'magic_classmethod_definition = \"\"\"\\n', 'magic_super_attribute = \"\"\"\\n', 'magic_super_method = \"\"\"\\n', 'magic_super_cls_attribute = \"\"\"\\n', 'magic_super_cls_method = \"\"\"\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DirectMagicAttributeAccessViolation])\\n', '    assert_error_text(visitor, attribute)\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " it is impossible to use magic attributes.\"\"\"\n    tree = parse_ast_tree(mode(code.format(attribute)))\n\n    visitor = WrongAttributeVisitor(default_optio"
 },
 "275": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.attributes.WrongAttributeVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_magic_attributes.py",
  "lineno": "135",
  "column": "4",
  "slicing": "[\"magic_attribute_assigned = 'some.{0} = 1'\\n\", \"magic_attribute_accessed = 'print(some.{0})'\\n\", \"magic_method_called = 'some.{0}()'\\n\", \"magic_method_called_params = 'some.{0}(12, 33)'\\n\", 'magic_container_attribute = \"\"\"\\n', 'magic_container_method = \"\"\"\\n', 'magic_callable_attribute = \"\"\"\\n', \"magic_name_definition = '{0} = 1'\\n\", \"magic_name_attr_definition = '{0}.some = 1'\\n\", 'magic_self_attribute = \"\"\"\\n', 'magic_self_method = \"\"\"\\n', 'magic_cls_attribute = \"\"\"\\n', 'magic_cls_method = \"\"\"\\n', 'magic_attribute_definition = \"\"\"\\n', 'magic_method_definition = \"\"\"\\n', 'magic_classmethod_definition = \"\"\"\\n', 'magic_super_attribute = \"\"\"\\n', 'magic_super_method = \"\"\"\\n', 'magic_super_cls_attribute = \"\"\"\\n', 'magic_super_cls_method = \"\"\"\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DirectMagicAttributeAccessViolation])\\n', '    assert_error_text(visitor, attribute)\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(attribute)))\n\n    visitor = WrongAttributeVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Dir"
 },
 "276": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_magic_attributes.py",
  "lineno": "169",
  "column": "4",
  "slicing": "[\"magic_attribute_assigned = 'some.{0} = 1'\\n\", \"magic_attribute_accessed = 'print(some.{0})'\\n\", \"magic_method_called = 'some.{0}()'\\n\", \"magic_method_called_params = 'some.{0}(12, 33)'\\n\", 'magic_container_attribute = \"\"\"\\n', 'magic_container_method = \"\"\"\\n', 'magic_callable_attribute = \"\"\"\\n', \"magic_name_definition = '{0} = 1'\\n\", \"magic_name_attr_definition = '{0}.some = 1'\\n\", 'magic_self_attribute = \"\"\"\\n', 'magic_self_method = \"\"\"\\n', 'magic_cls_attribute = \"\"\"\\n', 'magic_cls_method = \"\"\"\\n', 'magic_attribute_definition = \"\"\"\\n', 'magic_method_definition = \"\"\"\\n', 'magic_classmethod_definition = \"\"\"\\n', 'magic_super_attribute = \"\"\"\\n', 'magic_super_method = \"\"\"\\n', 'magic_super_cls_attribute = \"\"\"\\n', 'magic_super_cls_method = \"\"\"\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DirectMagicAttributeAccessViolation])\\n', '    assert_error_text(visitor, attribute)\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at it is possible to use magic attributes.\"\"\"\n    tree = parse_ast_tree(mode(code.format(attribute)))\n\n    visitor = WrongAttributeVisitor(default_optio"
 },
 "277": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.attributes.WrongAttributeVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_magic_attributes.py",
  "lineno": "171",
  "column": "4",
  "slicing": "[\"magic_attribute_assigned = 'some.{0} = 1'\\n\", \"magic_attribute_accessed = 'print(some.{0})'\\n\", \"magic_method_called = 'some.{0}()'\\n\", \"magic_method_called_params = 'some.{0}(12, 33)'\\n\", 'magic_container_attribute = \"\"\"\\n', 'magic_container_method = \"\"\"\\n', 'magic_callable_attribute = \"\"\"\\n', \"magic_name_definition = '{0} = 1'\\n\", \"magic_name_attr_definition = '{0}.some = 1'\\n\", 'magic_self_attribute = \"\"\"\\n', 'magic_self_method = \"\"\"\\n', 'magic_cls_attribute = \"\"\"\\n', 'magic_cls_method = \"\"\"\\n', 'magic_attribute_definition = \"\"\"\\n', 'magic_method_definition = \"\"\"\\n', 'magic_classmethod_definition = \"\"\"\\n', 'magic_super_attribute = \"\"\"\\n', 'magic_super_method = \"\"\"\\n', 'magic_super_cls_attribute = \"\"\"\\n', 'magic_super_cls_method = \"\"\"\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DirectMagicAttributeAccessViolation])\\n', '    assert_error_text(visitor, attribute)\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(attribute)))\n\n    visitor = WrongAttributeVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "278": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_magic_attributes.py",
  "lineno": "223",
  "column": "4",
  "slicing": "[\"magic_attribute_assigned = 'some.{0} = 1'\\n\", \"magic_attribute_accessed = 'print(some.{0})'\\n\", \"magic_method_called = 'some.{0}()'\\n\", \"magic_method_called_params = 'some.{0}(12, 33)'\\n\", 'magic_container_attribute = \"\"\"\\n', 'magic_container_method = \"\"\"\\n', 'magic_callable_attribute = \"\"\"\\n', \"magic_name_definition = '{0} = 1'\\n\", \"magic_name_attr_definition = '{0}.some = 1'\\n\", 'magic_self_attribute = \"\"\"\\n', 'magic_self_method = \"\"\"\\n', 'magic_cls_attribute = \"\"\"\\n', 'magic_cls_method = \"\"\"\\n', 'magic_attribute_definition = \"\"\"\\n', 'magic_method_definition = \"\"\"\\n', 'magic_classmethod_definition = \"\"\"\\n', 'magic_super_attribute = \"\"\"\\n', 'magic_super_method = \"\"\"\\n', 'magic_super_cls_attribute = \"\"\"\\n', 'magic_super_cls_method = \"\"\"\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DirectMagicAttributeAccessViolation])\\n', '    assert_error_text(visitor, attribute)\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "and\n    whitelisted magic attributes.\n    \"\"\"\n    tree = parse_ast_tree(mode(code.format(attribute)))\n\n    visitor = WrongAttributeVisitor(default_optio"
 },
 "279": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.attributes.WrongAttributeVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_attributes/test_magic_attributes.py",
  "lineno": "225",
  "column": "4",
  "slicing": "[\"magic_attribute_assigned = 'some.{0} = 1'\\n\", \"magic_attribute_accessed = 'print(some.{0})'\\n\", \"magic_method_called = 'some.{0}()'\\n\", \"magic_method_called_params = 'some.{0}(12, 33)'\\n\", 'magic_container_attribute = \"\"\"\\n', 'magic_container_method = \"\"\"\\n', 'magic_callable_attribute = \"\"\"\\n', \"magic_name_definition = '{0} = 1'\\n\", \"magic_name_attr_definition = '{0}.some = 1'\\n\", 'magic_self_attribute = \"\"\"\\n', 'magic_self_method = \"\"\"\\n', 'magic_cls_attribute = \"\"\"\\n', 'magic_cls_method = \"\"\"\\n', 'magic_attribute_definition = \"\"\"\\n', 'magic_method_definition = \"\"\"\\n', 'magic_classmethod_definition = \"\"\"\\n', 'magic_super_attribute = \"\"\"\\n', 'magic_super_method = \"\"\"\\n', 'magic_super_cls_attribute = \"\"\"\\n', 'magic_super_cls_method = \"\"\"\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DirectMagicAttributeAccessViolation])\\n', '    assert_error_text(visitor, attribute)\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    magic_attribute_assigned,\\n', '    magic_attribute_accessed,\\n', '    magic_method_called,\\n', '    magic_method_called_params,\\n', '    magic_container_attribute,\\n', '    magic_container_method,\\n', '    magic_callable_attribute,\\n', '    magic_name_definition,\\n', '    magic_name_attr_definition,\\n', '    magic_self_attribute,\\n', '    magic_self_method,\\n', '    magic_cls_attribute,\\n', '    magic_cls_method,\\n', '    magic_attribute_definition,\\n', '    magic_method_definition,\\n', '    magic_classmethod_definition,\\n', '    magic_super_attribute,\\n', '    magic_super_method,\\n', '    magic_super_cls_attribute,\\n', '    magic_super_cls_method,\\n', '    tree = parse_ast_tree(mode(code.format(attribute)))\\n', '    visitor = WrongAttributeVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(attribute)))\n\n    visitor = WrongAttributeVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "280": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_conditionals.py",
  "lineno": "52",
  "column": "4",
  "slicing": "['create_variable = \"\"\"\\n', \"if_statement = 'if {0}: ...'\\n\", \"ternary = 'ternary = 0 if {0} else 1'\\n\", 'if_statement_in_comprehension = \"\"\"\\n', '    if_statement,\\n', '    ternary,\\n', '    if_statement_in_comprehension,\\n', '    tree = parse_ast_tree(\\n', '        mode(create_variable.format(code.format(comparators))),\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_statement,\\n', '    ternary,\\n', '    tree = parse_ast_tree(create_variable.format(code.format(comparators)))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantConditionViolation])\\n']",
  "context": "   \"\"\"Testing that conditionals work well.\"\"\"\n    tree = parse_ast_tree(\n        mode(create_variable.format(code.format(co"
 },
 "281": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_conditionals.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['create_variable = \"\"\"\\n', \"if_statement = 'if {0}: ...'\\n\", \"ternary = 'ternary = 0 if {0} else 1'\\n\", 'if_statement_in_comprehension = \"\"\"\\n', '    if_statement,\\n', '    ternary,\\n', '    if_statement_in_comprehension,\\n', '    tree = parse_ast_tree(\\n', '        mode(create_variable.format(code.format(comparators))),\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_statement,\\n', '    ternary,\\n', '    tree = parse_ast_tree(create_variable.format(code.format(comparators)))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantConditionViolation])\\n']",
  "context": "ble.format(code.format(comparators))),\n    )\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "282": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_conditionals.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['create_variable = \"\"\"\\n', \"if_statement = 'if {0}: ...'\\n\", \"ternary = 'ternary = 0 if {0} else 1'\\n\", 'if_statement_in_comprehension = \"\"\"\\n', '    if_statement,\\n', '    ternary,\\n', '    if_statement_in_comprehension,\\n', '    tree = parse_ast_tree(\\n', '        mode(create_variable.format(code.format(comparators))),\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_statement,\\n', '    ternary,\\n', '    tree = parse_ast_tree(create_variable.format(code.format(comparators)))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantConditionViolation])\\n']",
  "context": "ations are when using invalid conditional.\"\"\"\n    tree = parse_ast_tree(create_variable.format(code.format(comparators)))\n\n    visitor = WrongConditionalVisitor(default_opt"
 },
 "283": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_conditionals.py",
  "lineno": "95",
  "column": "4",
  "slicing": "['create_variable = \"\"\"\\n', \"if_statement = 'if {0}: ...'\\n\", \"ternary = 'ternary = 0 if {0} else 1'\\n\", 'if_statement_in_comprehension = \"\"\"\\n', '    if_statement,\\n', '    ternary,\\n', '    if_statement_in_comprehension,\\n', '    tree = parse_ast_tree(\\n', '        mode(create_variable.format(code.format(comparators))),\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_statement,\\n', '    ternary,\\n', '    tree = parse_ast_tree(create_variable.format(code.format(comparators)))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantConditionViolation])\\n']",
  "context": "e_variable.format(code.format(comparators)))\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Con"
 },
 "284": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_multiple_in.py",
  "lineno": "42",
  "column": "4",
  "slicing": "[\"if_with_multiple_in_compares = 'if {0} in {1} in {2}: ...'\\n\", \"if_without_multiple_in_compares = 'if {0} in {1}: ...'\\n\", \"ternary = 'ternary = 0 if {0} in {1} else 1'\\n\", \"ternary_with_multiple_in = 'ternary = 0 if {0} in {1} in {2} else 1'\\n\", \"while_construct = 'while {0} in {1}: ...'\\n\", \"while_with_multiple_in = 'while {0} in {1} in {2}: ...'\\n\", '    if_without_multiple_in_compares,\\n', '    ternary,\\n', '    while_construct,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    if_with_multiple_in_compares,\\n', '    ternary_with_multiple_in,\\n', '    while_with_multiple_in,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"    tree = parse_ast_tree('x in a not in b')\\n\", '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleInCompareViolation])\\n']",
  "context": "  \"\"\"Compares work well for single ``in``.\"\"\"\n    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\n\n    visitor = InCompareSanityVisitor(default_opti"
 },
 "285": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.InCompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_multiple_in.py",
  "lineno": "44",
  "column": "4",
  "slicing": "[\"if_with_multiple_in_compares = 'if {0} in {1} in {2}: ...'\\n\", \"if_without_multiple_in_compares = 'if {0} in {1}: ...'\\n\", \"ternary = 'ternary = 0 if {0} in {1} else 1'\\n\", \"ternary_with_multiple_in = 'ternary = 0 if {0} in {1} in {2} else 1'\\n\", \"while_construct = 'while {0} in {1}: ...'\\n\", \"while_with_multiple_in = 'while {0} in {1} in {2}: ...'\\n\", '    if_without_multiple_in_compares,\\n', '    ternary,\\n', '    while_construct,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    if_with_multiple_in_compares,\\n', '    ternary_with_multiple_in,\\n', '    while_with_multiple_in,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"    tree = parse_ast_tree('x in a not in b')\\n\", '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleInCompareViolation])\\n']",
  "context": "t_tree(in_not_in(code.format(*comparators)))\n\n    visitor = InCompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "286": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_multiple_in.py",
  "lineno": "73",
  "column": "4",
  "slicing": "[\"if_with_multiple_in_compares = 'if {0} in {1} in {2}: ...'\\n\", \"if_without_multiple_in_compares = 'if {0} in {1}: ...'\\n\", \"ternary = 'ternary = 0 if {0} in {1} else 1'\\n\", \"ternary_with_multiple_in = 'ternary = 0 if {0} in {1} in {2} else 1'\\n\", \"while_construct = 'while {0} in {1}: ...'\\n\", \"while_with_multiple_in = 'while {0} in {1} in {2}: ...'\\n\", '    if_without_multiple_in_compares,\\n', '    ternary,\\n', '    while_construct,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    if_with_multiple_in_compares,\\n', '    ternary_with_multiple_in,\\n', '    while_with_multiple_in,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"    tree = parse_ast_tree('x in a not in b')\\n\", '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleInCompareViolation])\\n']",
  "context": "\"Compares raise for multiple ``in`` cases.\"\"\"\n    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\n\n    visitor = InCompareSanityVisitor(default_opti"
 },
 "287": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.InCompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_multiple_in.py",
  "lineno": "75",
  "column": "4",
  "slicing": "[\"if_with_multiple_in_compares = 'if {0} in {1} in {2}: ...'\\n\", \"if_without_multiple_in_compares = 'if {0} in {1}: ...'\\n\", \"ternary = 'ternary = 0 if {0} in {1} else 1'\\n\", \"ternary_with_multiple_in = 'ternary = 0 if {0} in {1} in {2} else 1'\\n\", \"while_construct = 'while {0} in {1}: ...'\\n\", \"while_with_multiple_in = 'while {0} in {1} in {2}: ...'\\n\", '    if_without_multiple_in_compares,\\n', '    ternary,\\n', '    while_construct,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    if_with_multiple_in_compares,\\n', '    ternary_with_multiple_in,\\n', '    while_with_multiple_in,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"    tree = parse_ast_tree('x in a not in b')\\n\", '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleInCompareViolation])\\n']",
  "context": "t_tree(in_not_in(code.format(*comparators)))\n\n    visitor = InCompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "288": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_multiple_in.py",
  "lineno": "91",
  "column": "4",
  "slicing": "[\"if_with_multiple_in_compares = 'if {0} in {1} in {2}: ...'\\n\", \"if_without_multiple_in_compares = 'if {0} in {1}: ...'\\n\", \"ternary = 'ternary = 0 if {0} in {1} else 1'\\n\", \"ternary_with_multiple_in = 'ternary = 0 if {0} in {1} in {2} else 1'\\n\", \"while_construct = 'while {0} in {1}: ...'\\n\", \"while_with_multiple_in = 'while {0} in {1} in {2}: ...'\\n\", '    if_without_multiple_in_compares,\\n', '    ternary,\\n', '    while_construct,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    if_with_multiple_in_compares,\\n', '    ternary_with_multiple_in,\\n', '    while_with_multiple_in,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"    tree = parse_ast_tree('x in a not in b')\\n\", '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleInCompareViolation])\\n']",
  "context": " for multiple ``in`` and ``not in`` cases.\"\"\"\n    tree = parse_ast_tree('x in a not in b')\n\n    visitor = InCompareSanityVisitor(default_opti"
 },
 "289": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.InCompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_multiple_in.py",
  "lineno": "93",
  "column": "4",
  "slicing": "[\"if_with_multiple_in_compares = 'if {0} in {1} in {2}: ...'\\n\", \"if_without_multiple_in_compares = 'if {0} in {1}: ...'\\n\", \"ternary = 'ternary = 0 if {0} in {1} else 1'\\n\", \"ternary_with_multiple_in = 'ternary = 0 if {0} in {1} in {2} else 1'\\n\", \"while_construct = 'while {0} in {1}: ...'\\n\", \"while_with_multiple_in = 'while {0} in {1} in {2}: ...'\\n\", '    if_without_multiple_in_compares,\\n', '    ternary,\\n', '    while_construct,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    if_with_multiple_in_compares,\\n', '    ternary_with_multiple_in,\\n', '    while_with_multiple_in,\\n', '    tree = parse_ast_tree(in_not_in(code.format(*comparators)))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"    tree = parse_ast_tree('x in a not in b')\\n\", '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleInCompareViolation])\\n']",
  "context": "    tree = parse_ast_tree('x in a not in b')\n\n    visitor = InCompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mul"
 },
 "290": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_in_with_single_item_container.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "forbid ``in`` with single item containers.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = InCompareSanityVisitor(default_opti"
 },
 "291": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.InCompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_in_with_single_item_container.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "ntainers.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = InCompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "292": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_in_with_single_item_container.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": " allow ``in`` with multi items containers.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = InCompareSanityVisitor(default_opti"
 },
 "293": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.InCompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_in_with_single_item_container.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "ntainers.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = InCompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "294": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "32",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": "):\n    \"\"\"Testing that compares work well.\"\"\"\n    tree = parse_ast_tree(simple_conditions.format(*comparators))\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "295": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "34",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": "tree(simple_conditions.format(*comparators))\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "296": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "55",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": "iolations are when using literal compares.\"\"\"\n    tree = parse_ast_tree(simple_conditions.format(*comparators))\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "297": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "57",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": "tree(simple_conditions.format(*comparators))\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Con"
 },
 "298": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "79",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": " special cases do work and raise warnings.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "299": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "81",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Con"
 },
 "300": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "111",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": " special cases do work and raise warnings.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "301": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "113",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "302": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "143",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": "l cases do work and do not raise warnings.\"\"\"\n    tree = parse_ast_tree(code.format('first_name', 'second_name'))\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "303": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_literal.py",
  "lineno": "145",
  "column": "4",
  "slicing": "[\"chained_compares1 = '0 < {0} < {1}'\\n\", \"chained_compares2 = '{0} > {1} > 0'\\n\", \"chained_compares3 = '-1 > {0} > {1} > 0'\\n\", \"walrus_compares1 = '(x := {0}) > {1} > 1'\\n\", \"walrus_compares2 = '{0} > (x := {1}) > 1'\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares1,\\n', '    chained_compares3,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConstantCompareViolation])\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    chained_compares1,\\n', '    chained_compares2,\\n', '    chained_compares3,\\n', '        walrus_compares1,\\n', '        walrus_compares2,\\n', \"    tree = parse_ast_tree(code.format('first_name', 'second_name'))\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ReversedComplexCompareViolation)\\n']",
  "context": "ee(code.format('first_name', 'second_name'))\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [], "
 },
 "304": {
  "name": "IS_COMPARES",
  "type": "frozenset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/conftest.py",
  "lineno": "34",
  "column": "0",
  "slicing": "[\"if_with_is = 'if {0} is {1}: ...'\\n\", \"if_with_is_not = 'if {0} is not {1}: ...'\\n\", 'IS_COMPARES = frozenset((\\n', '    if_with_is,\\n', '    if_with_is_not,\\n', '@pytest.fixture(params=IS_COMPARES | EQUAL_COMPARES | OTHER_COMPARES)\\n', '@pytest.fixture(params=IS_COMPARES)\\n']",
  "context": "ct = 'while {0} > {1}: ...'\n\n\n# Actual fixtures:\n\nIS_COMPARES = frozenset((\n    if_with_is,\n    if_with_is_not,\n))\n\nEQUAL_COMP"
 },
 "305": {
  "name": "EQUAL_COMPARES",
  "type": "frozenset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/conftest.py",
  "lineno": "39",
  "column": "0",
  "slicing": "[\"if_with_is = 'if {0} is {1}: ...'\\n\", \"if_with_is_not = 'if {0} is not {1}: ...'\\n\", \"if_with_eq = 'if {0} == {1}: ...'\\n\", \"if_with_not_eq = 'if {0} != {1}: ...'\\n\", \"assert_construct = 'assert {0} == {1}'\\n\", 'assert_with_message = \\'assert {0} == {1}, \"message\"\\'\\n', '    if_with_is,\\n', '    if_with_is_not,\\n', 'EQUAL_COMPARES = frozenset((\\n', '    if_with_eq,\\n', '    if_with_not_eq,\\n', '    assert_construct,\\n', '    assert_with_message,\\n', '@pytest.fixture(params=IS_COMPARES | EQUAL_COMPARES | OTHER_COMPARES)\\n', '@pytest.fixture(params=EQUAL_COMPARES)\\n']",
  "context": "ozenset((\n    if_with_is,\n    if_with_is_not,\n))\n\nEQUAL_COMPARES = frozenset((\n    if_with_eq,\n    if_with_not_eq,\n\n    assert_co"
 },
 "306": {
  "name": "OTHER_COMPARES",
  "type": "frozenset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/conftest.py",
  "lineno": "47",
  "column": "0",
  "slicing": "[\"if_with_is = 'if {0} is {1}: ...'\\n\", \"if_with_is_not = 'if {0} is not {1}: ...'\\n\", \"if_with_eq = 'if {0} == {1}: ...'\\n\", \"if_with_not_eq = 'if {0} != {1}: ...'\\n\", \"assert_construct = 'assert {0} == {1}'\\n\", 'assert_with_message = \\'assert {0} == {1}, \"message\"\\'\\n', \"if_with_gt = 'if {0} > {1}: ...'\\n\", \"if_with_lt = 'if {0} < {1}: ...'\\n\", \"if_with_gte = 'if {0} >= {1}: ...'\\n\", \"if_with_lte = 'if {0} <= {1}: ...'\\n\", \"ternary = 'ternary = 0 if {0} > {1} else 1'\\n\", \"while_construct = 'while {0} > {1}: ...'\\n\", '    if_with_is,\\n', '    if_with_is_not,\\n', '    if_with_eq,\\n', '    if_with_not_eq,\\n', '    assert_construct,\\n', '    assert_with_message,\\n', 'OTHER_COMPARES = frozenset((\\n', '    if_with_lt,\\n', '    if_with_gt,\\n', '    if_with_lte,\\n', '    if_with_gte,\\n', '    ternary,\\n', '    while_construct,\\n', '@pytest.fixture(params=IS_COMPARES | EQUAL_COMPARES | OTHER_COMPARES)\\n', '@pytest.fixture(params=OTHER_COMPARES)\\n']",
  "context": "   assert_construct,\n    assert_with_message,\n))\n\nOTHER_COMPARES = frozenset((\n    if_with_lt,\n    if_with_gt,\n    if_with_lte,\n "
 },
 "307": {
  "name": "template",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/conftest.py",
  "lineno": "94",
  "column": "16",
  "slicing": "['    def factory(template: str) -> str:\\n']",
  "context": "erators to `not in` operators.\"\"\"\n    def factory(template: str) -> str:\n        return template.replace(\n            ' in "
 },
 "308": {
  "name": "correct_comparators",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "15",
  "column": "0",
  "slicing": "['correct_comparators = [\\n', '    correct_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', correct_comparators)\\n\"]",
  "context": " = \"\"\"\nvariable = 1\nanother_variable = 2\n{0}\n\"\"\"\n\ncorrect_comparators = [\n    ('variable', '\"test\"'),\n    ('variable', 'vari"
 },
 "309": {
  "name": "wrong_comparators",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "24",
  "column": "0",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\"]",
  "context": " 'another_variable'),\n    ('variable', '222'),\n]\n\nwrong_comparators = [\n    ('variable', 'variable'),\n    ('another_variab"
 },
 "310": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "52",
  "column": "4",
  "slicing": "['create_variables = \"\"\"\\n', 'correct_comparators = [\\n', 'wrong_comparators = [\\n', '    correct_comparators.extend([\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', correct_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(in_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"    tree = parse_ast_tree('assert some == some == some')\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n']",
  "context": "):\n    \"\"\"Testing that compares work well.\"\"\"\n    tree = parse_ast_tree(\n        create_variables.format(simple_conditions."
 },
 "311": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['create_variables = \"\"\"\\n', 'correct_comparators = [\\n', 'wrong_comparators = [\\n', '    correct_comparators.extend([\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', correct_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(in_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"    tree = parse_ast_tree('assert some == some == some')\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n']",
  "context": "mple_conditions.format(*comparators)),\n    )\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "312": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['create_variables = \"\"\"\\n', 'correct_comparators = [\\n', 'wrong_comparators = [\\n', '    correct_comparators.extend([\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', correct_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(in_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"    tree = parse_ast_tree('assert some == some == some')\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n']",
  "context": "ons are when comparing identical variable.\"\"\"\n    tree = parse_ast_tree(\n        create_variables.format(simple_conditions."
 },
 "313": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['create_variables = \"\"\"\\n', 'correct_comparators = [\\n', 'wrong_comparators = [\\n', '    correct_comparators.extend([\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', correct_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(in_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"    tree = parse_ast_tree('assert some == some == some')\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n']",
  "context": "mple_conditions.format(*comparators)),\n    )\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "314": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "90",
  "column": "4",
  "slicing": "['create_variables = \"\"\"\\n', 'correct_comparators = [\\n', 'wrong_comparators = [\\n', '    correct_comparators.extend([\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', correct_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(in_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"    tree = parse_ast_tree('assert some == some == some')\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n']",
  "context": "ons are when comparing identical variable.\"\"\"\n    tree = parse_ast_tree(\n        create_variables.format(in_conditions.form"
 },
 "315": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "94",
  "column": "4",
  "slicing": "['create_variables = \"\"\"\\n', 'correct_comparators = [\\n', 'wrong_comparators = [\\n', '    correct_comparators.extend([\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', correct_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(in_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"    tree = parse_ast_tree('assert some == some == some')\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n']",
  "context": "t(in_conditions.format(*comparators)),\n    )\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "316": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "106",
  "column": "4",
  "slicing": "['create_variables = \"\"\"\\n', 'correct_comparators = [\\n', 'wrong_comparators = [\\n', '    correct_comparators.extend([\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', correct_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(in_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"    tree = parse_ast_tree('assert some == some == some')\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n']",
  "context": "seless compare returns a single violation.\"\"\"\n    tree = parse_ast_tree('assert some == some == some')\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "317": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_redundant.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['create_variables = \"\"\"\\n', 'correct_comparators = [\\n', 'wrong_comparators = [\\n', '    correct_comparators.extend([\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', correct_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(simple_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '        create_variables.format(in_conditions.format(*comparators)),\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n', \"    tree = parse_ast_tree('assert some == some == some')\\n\", '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessCompareViolation])\\n']",
  "context": "arse_ast_tree('assert some == some == some')\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "318": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_heterogenous_compare.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [HeterogeneousCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t compares with different operators raise.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "319": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_heterogenous_compare.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [HeterogeneousCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rs raise.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Het"
 },
 "320": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_heterogenous_compare.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [HeterogeneousCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "):\n    \"\"\"Testing that compares work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "321": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_heterogenous_compare.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [HeterogeneousCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "322": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_reversed_complex_compare.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReversedComplexCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that reversed compares raise a violation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "323": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_reversed_complex_compare.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReversedComplexCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "iolation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Rev"
 },
 "324": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_reversed_complex_compare.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReversedComplexCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "):\n    \"\"\"Testing that compares work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "325": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_reversed_complex_compare.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReversedComplexCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "326": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_float_complex_compare.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatComplexCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "`float`` and ``complex`` raise violations.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFloatComplexCompareVisitor(def"
 },
 "327": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongFloatComplexCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_float_complex_compare.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatComplexCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "olations.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Flo"
 },
 "328": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_float_complex_compare.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatComplexCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_options,\n):\n    \"\"\"Testing safe compares.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFloatComplexCompareVisitor(def"
 },
 "329": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongFloatComplexCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_float_complex_compare.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatComplexCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "compares.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFloatComplexCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "330": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_in_type_check.py",
  "lineno": "43",
  "column": "4",
  "slicing": "[\"in_template = 'some in {0}'\\n\", \"not_in_template = 'some not in {0}'\\n\", '    not_in_template,\\n', '    in_template,\\n', '    tree = parse_ast_tree(code.format(comparator))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    not_in_template,\\n', '    in_template,\\n', '    tree = parse_ast_tree(code.format(comparator))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e a violation for ``in`` with wrong types.\"\"\"\n    tree = parse_ast_tree(code.format(comparator))\n\n    visitor = InCompareSanityVisitor(default_opti"
 },
 "331": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.InCompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_in_type_check.py",
  "lineno": "45",
  "column": "4",
  "slicing": "[\"in_template = 'some in {0}'\\n\", \"not_in_template = 'some not in {0}'\\n\", '    not_in_template,\\n', '    in_template,\\n', '    tree = parse_ast_tree(code.format(comparator))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    not_in_template,\\n', '    in_template,\\n', '    tree = parse_ast_tree(code.format(comparator))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(code.format(comparator))\n\n    visitor = InCompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "332": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_in_type_check.py",
  "lineno": "75",
  "column": "4",
  "slicing": "[\"in_template = 'some in {0}'\\n\", \"not_in_template = 'some not in {0}'\\n\", '    not_in_template,\\n', '    in_template,\\n', '    tree = parse_ast_tree(code.format(comparator))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    not_in_template,\\n', '    in_template,\\n', '    tree = parse_ast_tree(code.format(comparator))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "k correctly for ``in`` with correct types.\"\"\"\n    tree = parse_ast_tree(code.format(comparator))\n\n    visitor = InCompareSanityVisitor(default_opti"
 },
 "333": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.InCompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_in_type_check.py",
  "lineno": "77",
  "column": "4",
  "slicing": "[\"in_template = 'some in {0}'\\n\", \"not_in_template = 'some not in {0}'\\n\", '    not_in_template,\\n', '    in_template,\\n', '    tree = parse_ast_tree(code.format(comparator))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    not_in_template,\\n', '    in_template,\\n', '    tree = parse_ast_tree(code.format(comparator))\\n', '    visitor = InCompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(code.format(comparator))\n\n    visitor = InCompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "334": {
  "name": "wrong_comparators",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "11",
  "column": "0",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\"]",
  "context": "ares import (\n    WrongComparisonOrderVisitor,\n)\n\nwrong_comparators = [\n    ('\"string constant\"', 'first_name'),\n    ([1, "
 },
 "335": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Compares work well for left variables.\"\"\"\n    tree = parse_ast_tree(simple_conditions.format(*comparators))\n\n    visitor = WrongComparisonOrderVisitor(default"
 },
 "336": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongComparisonOrderVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree(simple_conditions.format(*comparators))\n\n    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "337": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ial case for `in` and `not in` is handled.\"\"\"\n    tree = parse_ast_tree(in_conditions.format(*comparators))\n\n    visitor = WrongComparisonOrderVisitor(default"
 },
 "338": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongComparisonOrderVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ast_tree(in_conditions.format(*comparators))\n\n    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "339": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "104",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    \"\"\"Compares raise for left constants.\"\"\"\n    tree = parse_ast_tree(simple_conditions.format(*comparators))\n\n    visitor = WrongComparisonOrderVisitor(default"
 },
 "340": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongComparisonOrderVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "106",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree(simple_conditions.format(*comparators))\n\n    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Com"
 },
 "341": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "120",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " raise multiple issues for left constants.\"\"\"\n    tree = parse_ast_tree(\n        'if {0} > {1} and {0} < {1}: ...'.format(*"
 },
 "342": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongComparisonOrderVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "124",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " {0} < {1}: ...'.format(*comparators),\n    )\n\n    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "343": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "143",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s/wemake-python-styleguide/issues/577\n    \"\"\"\n    tree = parse_ast_tree(regression577)\n\n    visitor = WrongComparisonOrderVisitor(default"
 },
 "344": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongComparisonOrderVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_order.py",
  "lineno": "145",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', 'correct_walrus = pytest.param(\\n', 'regression577 = \"\"\"\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_walrus,\\n', '    tree = parse_ast_tree(in_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [CompareOrderViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(regression577)\\n', '    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"\n    tree = parse_ast_tree(regression577)\n\n    visitor = WrongComparisonOrderVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "345": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_nested_ternary.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['correct_if1 = \"\"\"\\n', 'correct_if2 = \"\"\"\\n', \"correct_unary1 = '-a if b else c'\\n\", \"correct_unary2 = 'a if -b else c'\\n\", \"correct_unary3 = 'a if b else -c'\\n\", \"correct_unary4 = 'not a if b else c'\\n\", \"correct_binop1 = 'a + x if b else c'\\n\", \"correct_binop2 = 'a if b + x else c'\\n\", \"correct_binop3 = 'a if b else c + x'\\n\", \"correct_boolop1 = 'a and x if b else c'\\n\", \"correct_boolop2 = 'a if b and x else c'\\n\", \"correct_boolop3 = 'a if b else c and x'\\n\", \"correct_compare1 = 'a > x if b else c'\\n\", \"correct_compare2 = 'a if b > x else c'\\n\", \"correct_compare3 = 'a if b else c < x'\\n\", '    correct_if1,\\n', '    correct_if2,\\n', '    correct_unary1,\\n', '    correct_unary2,\\n', '    correct_unary3,\\n', '    correct_unary4,\\n', '    correct_binop1,\\n', '    correct_binop2,\\n', '    correct_binop3,\\n', '    correct_boolop1,\\n', '    correct_boolop2,\\n', '    correct_boolop3,\\n', '    correct_compare1,\\n', '    correct_compare2,\\n', '    correct_compare3,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedTernaryViolation])\\n']",
  "context": "esting that ternary can be used work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongConditionalVisitor(default_opt"
 },
 "346": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_nested_ternary.py",
  "lineno": "112",
  "column": "4",
  "slicing": "['correct_if1 = \"\"\"\\n', 'correct_if2 = \"\"\"\\n', \"correct_unary1 = '-a if b else c'\\n\", \"correct_unary2 = 'a if -b else c'\\n\", \"correct_unary3 = 'a if b else -c'\\n\", \"correct_unary4 = 'not a if b else c'\\n\", \"correct_binop1 = 'a + x if b else c'\\n\", \"correct_binop2 = 'a if b + x else c'\\n\", \"correct_binop3 = 'a if b else c + x'\\n\", \"correct_boolop1 = 'a and x if b else c'\\n\", \"correct_boolop2 = 'a if b and x else c'\\n\", \"correct_boolop3 = 'a if b else c and x'\\n\", \"correct_compare1 = 'a > x if b else c'\\n\", \"correct_compare2 = 'a if b > x else c'\\n\", \"correct_compare3 = 'a if b else c < x'\\n\", '    correct_if1,\\n', '    correct_if2,\\n', '    correct_unary1,\\n', '    correct_unary2,\\n', '    correct_unary3,\\n', '    correct_unary4,\\n', '    correct_binop1,\\n', '    correct_binop2,\\n', '    correct_binop3,\\n', '    correct_boolop1,\\n', '    correct_boolop2,\\n', '    correct_boolop3,\\n', '    correct_compare1,\\n', '    correct_compare2,\\n', '    correct_compare3,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedTernaryViolation])\\n']",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "347": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_nested_ternary.py",
  "lineno": "168",
  "column": "4",
  "slicing": "['correct_if1 = \"\"\"\\n', 'correct_if2 = \"\"\"\\n', \"correct_unary1 = '-a if b else c'\\n\", \"correct_unary2 = 'a if -b else c'\\n\", \"correct_unary3 = 'a if b else -c'\\n\", \"correct_unary4 = 'not a if b else c'\\n\", \"correct_binop1 = 'a + x if b else c'\\n\", \"correct_binop2 = 'a if b + x else c'\\n\", \"correct_binop3 = 'a if b else c + x'\\n\", \"correct_boolop1 = 'a and x if b else c'\\n\", \"correct_boolop2 = 'a if b and x else c'\\n\", \"correct_boolop3 = 'a if b else c and x'\\n\", \"correct_compare1 = 'a > x if b else c'\\n\", \"correct_compare2 = 'a if b > x else c'\\n\", \"correct_compare3 = 'a if b else c < x'\\n\", '    correct_if1,\\n', '    correct_if2,\\n', '    correct_unary1,\\n', '    correct_unary2,\\n', '    correct_unary3,\\n', '    correct_unary4,\\n', '    correct_binop1,\\n', '    correct_binop2,\\n', '    correct_binop3,\\n', '    correct_boolop1,\\n', '    correct_boolop2,\\n', '    correct_boolop3,\\n', '    correct_compare1,\\n', '    correct_compare2,\\n', '    correct_compare3,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedTernaryViolation])\\n']",
  "context": "esting that ternary can be used work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongConditionalVisitor(default_opt"
 },
 "348": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_nested_ternary.py",
  "lineno": "170",
  "column": "4",
  "slicing": "['correct_if1 = \"\"\"\\n', 'correct_if2 = \"\"\"\\n', \"correct_unary1 = '-a if b else c'\\n\", \"correct_unary2 = 'a if -b else c'\\n\", \"correct_unary3 = 'a if b else -c'\\n\", \"correct_unary4 = 'not a if b else c'\\n\", \"correct_binop1 = 'a + x if b else c'\\n\", \"correct_binop2 = 'a if b + x else c'\\n\", \"correct_binop3 = 'a if b else c + x'\\n\", \"correct_boolop1 = 'a and x if b else c'\\n\", \"correct_boolop2 = 'a if b and x else c'\\n\", \"correct_boolop3 = 'a if b else c and x'\\n\", \"correct_compare1 = 'a > x if b else c'\\n\", \"correct_compare2 = 'a if b > x else c'\\n\", \"correct_compare3 = 'a if b else c < x'\\n\", '    correct_if1,\\n', '    correct_if2,\\n', '    correct_unary1,\\n', '    correct_unary2,\\n', '    correct_unary3,\\n', '    correct_unary4,\\n', '    correct_binop1,\\n', '    correct_binop2,\\n', '    correct_binop3,\\n', '    correct_boolop1,\\n', '    correct_boolop2,\\n', '    correct_boolop3,\\n', '    correct_compare1,\\n', '    correct_compare2,\\n', '    correct_compare3,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedTernaryViolation])\\n']",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Nes"
 },
 "349": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_unpythonic/test_useless_len.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLenCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that compares with len raise a violation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "350": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_unpythonic/test_useless_len.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLenCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "iolation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "351": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_unpythonic/test_useless_len.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLenCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "):\n    \"\"\"Testing that compares work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_option"
 },
 "352": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.CompareSanityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_unpythonic/test_useless_len.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLenCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = CompareSanityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = CompareSanityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "353": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_expr.py",
  "lineno": "28",
  "column": "4",
  "slicing": "[\"if_expression = '{0} if some() else {1}'\\n\", '    tree = parse_ast_tree(if_expression.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(if_expression.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n']",
  "context": "):\n    \"\"\"Testing that compares work well.\"\"\"\n    tree = parse_ast_tree(if_expression.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_opt"
 },
 "354": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_expr.py",
  "lineno": "30",
  "column": "4",
  "slicing": "[\"if_expression = '{0} if some() else {1}'\\n\", '    tree = parse_ast_tree(if_expression.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(if_expression.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n']",
  "context": "ast_tree(if_expression.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "355": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_expr.py",
  "lineno": "47",
  "column": "4",
  "slicing": "[\"if_expression = '{0} if some() else {1}'\\n\", '    tree = parse_ast_tree(if_expression.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(if_expression.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n']",
  "context": "\"\"Testing that compares can be simplified.\"\"\"\n    tree = parse_ast_tree(if_expression.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_opt"
 },
 "356": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_expr.py",
  "lineno": "49",
  "column": "4",
  "slicing": "[\"if_expression = '{0} if some() else {1}'\\n\", '    tree = parse_ast_tree(if_expression.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(if_expression.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n']",
  "context": "ast_tree(if_expression.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sim"
 },
 "357": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_node.py",
  "lineno": "95",
  "column": "4",
  "slicing": "['simple_if_template = \"\"\"\\n', 'simple_if_typed_template = \"\"\"\\n', 'complex_if_template = \"\"\"\\n', 'nested_if_template = \"\"\"\\n', 'near_if_template = \"\"\"\\n', 'near_elif_template = \"\"\"\\n', 'near_elif_typed_template = \"\"\"\\n', 'single_if_template = \"\"\"\\n', '    complex_if_template,\\n', '    nested_if_template,\\n', '    near_if_template,\\n', '    near_elif_template,\\n', '    near_elif_typed_template,\\n', '    single_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  \"\"\"Testing that regular nodes work well.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_opt"
 },
 "358": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_node.py",
  "lineno": "97",
  "column": "4",
  "slicing": "['simple_if_template = \"\"\"\\n', 'simple_if_typed_template = \"\"\"\\n', 'complex_if_template = \"\"\"\\n', 'nested_if_template = \"\"\"\\n', 'near_if_template = \"\"\"\\n', 'near_elif_template = \"\"\"\\n', 'near_elif_typed_template = \"\"\"\\n', 'single_if_template = \"\"\"\\n', '    complex_if_template,\\n', '    nested_if_template,\\n', '    near_if_template,\\n', '    near_elif_template,\\n', '    near_elif_typed_template,\\n', '    single_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "359": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_node.py",
  "lineno": "121",
  "column": "4",
  "slicing": "['simple_if_template = \"\"\"\\n', 'simple_if_typed_template = \"\"\"\\n', 'complex_if_template = \"\"\"\\n', 'nested_if_template = \"\"\"\\n', 'near_if_template = \"\"\"\\n', 'near_elif_template = \"\"\"\\n', 'near_elif_typed_template = \"\"\"\\n', 'single_if_template = \"\"\"\\n', '    complex_if_template,\\n', '    nested_if_template,\\n', '    near_if_template,\\n', '    near_elif_template,\\n', '    near_elif_typed_template,\\n', '    single_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "Testing that simplifiable nodes work well.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_opt"
 },
 "360": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_node.py",
  "lineno": "123",
  "column": "4",
  "slicing": "['simple_if_template = \"\"\"\\n', 'simple_if_typed_template = \"\"\"\\n', 'complex_if_template = \"\"\"\\n', 'nested_if_template = \"\"\"\\n', 'near_if_template = \"\"\"\\n', 'near_elif_template = \"\"\"\\n', 'near_elif_typed_template = \"\"\"\\n', 'single_if_template = \"\"\"\\n', '    complex_if_template,\\n', '    nested_if_template,\\n', '    near_if_template,\\n', '    near_elif_template,\\n', '    near_elif_typed_template,\\n', '    single_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sim"
 },
 "361": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_node.py",
  "lineno": "149",
  "column": "4",
  "slicing": "['simple_if_template = \"\"\"\\n', 'simple_if_typed_template = \"\"\"\\n', 'complex_if_template = \"\"\"\\n', 'nested_if_template = \"\"\"\\n', 'near_if_template = \"\"\"\\n', 'near_elif_template = \"\"\"\\n', 'near_elif_typed_template = \"\"\"\\n', 'single_if_template = \"\"\"\\n', '    complex_if_template,\\n', '    nested_if_template,\\n', '    near_if_template,\\n', '    near_elif_template,\\n', '    near_elif_typed_template,\\n', '    single_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e nodes work well with incorrect patterns.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_opt"
 },
 "362": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_node.py",
  "lineno": "151",
  "column": "4",
  "slicing": "['simple_if_template = \"\"\"\\n', 'simple_if_typed_template = \"\"\"\\n', 'complex_if_template = \"\"\"\\n', 'nested_if_template = \"\"\"\\n', 'near_if_template = \"\"\"\\n', 'near_elif_template = \"\"\"\\n', 'near_elif_typed_template = \"\"\"\\n', 'single_if_template = \"\"\"\\n', '    complex_if_template,\\n', '    nested_if_template,\\n', '    near_if_template,\\n', '    near_elif_template,\\n', '    near_elif_typed_template,\\n', '    single_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "363": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_node.py",
  "lineno": "175",
  "column": "4",
  "slicing": "['simple_if_template = \"\"\"\\n', 'simple_if_typed_template = \"\"\"\\n', 'complex_if_template = \"\"\"\\n', 'nested_if_template = \"\"\"\\n', 'near_if_template = \"\"\"\\n', 'near_elif_template = \"\"\"\\n', 'near_elif_typed_template = \"\"\"\\n', 'single_if_template = \"\"\"\\n', '    complex_if_template,\\n', '    nested_if_template,\\n', '    near_if_template,\\n', '    near_elif_template,\\n', '    near_elif_typed_template,\\n', '    single_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e nodes work well with incorrect patterns.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_opt"
 },
 "364": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConditionalVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_simplifiable_ifs/test_simplifiable_if_node.py",
  "lineno": "177",
  "column": "4",
  "slicing": "['simple_if_template = \"\"\"\\n', 'simple_if_typed_template = \"\"\"\\n', 'complex_if_template = \"\"\"\\n', 'nested_if_template = \"\"\"\\n', 'near_if_template = \"\"\"\\n', 'near_elif_template = \"\"\"\\n', 'near_elif_typed_template = \"\"\"\\n', 'single_if_template = \"\"\"\\n', '    complex_if_template,\\n', '    nested_if_template,\\n', '    near_if_template,\\n', '    near_elif_template,\\n', '    near_elif_typed_template,\\n', '    single_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableIfViolation])\\n', '    simple_if_template,\\n', '    simple_if_typed_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_if_template,\\n', '    complex_if_template,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = WrongConditionalVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = WrongConditionalVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "365": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_unary_compare/test_not_with_compare.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = UnaryCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotOperatorWithCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = UnaryCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat compares with `not` raise a violation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = UnaryCompareVisitor(default_options"
 },
 "366": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.UnaryCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_unary_compare/test_not_with_compare.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = UnaryCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotOperatorWithCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = UnaryCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "iolation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = UnaryCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Not"
 },
 "367": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_unary_compare/test_not_with_compare.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = UnaryCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotOperatorWithCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = UnaryCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "):\n    \"\"\"Testing that compares work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = UnaryCompareVisitor(default_options"
 },
 "368": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.UnaryCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_unary_compare/test_not_with_compare.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = UnaryCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NotOperatorWithCompareViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = UnaryCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = UnaryCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "369": {
  "name": "wrong_comparators",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_is_constant_compare.py",
  "lineno": "12",
  "column": "0",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\"]",
  "context": "ares import (\n    WrongConstantCompareVisitor,\n)\n\nwrong_comparators = [\n    ('some', '[1, 2]'),\n    ('some', '{}'),  # noq"
 },
 "370": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_is_constant_compare.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongIsCompareViolation], (\\n', '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ares with falsy constants are not allowed.\"\"\"\n    tree = parse_ast_tree(is_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default"
 },
 "371": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConstantCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_is_constant_compare.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongIsCompareViolation], (\\n', '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ast_tree(is_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "372": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_is_constant_compare.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongIsCompareViolation], (\\n', '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ares with falsy constants are not allowed.\"\"\"\n    tree = parse_ast_tree(is_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default"
 },
 "373": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConstantCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_is_constant_compare.py",
  "lineno": "89",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongIsCompareViolation], (\\n', '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ast_tree(is_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "374": {
  "name": "wrong_comparators",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_falsy_constant.py",
  "lineno": "12",
  "column": "0",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\"]",
  "context": "ares import (\n    WrongConstantCompareVisitor,\n)\n\nwrong_comparators = [\n    ('some', '[]'),\n    ('some', '{}'),  # noqa: P"
 },
 "375": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_falsy_constant.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(eq_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FalsyConstantCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(other_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (WrongIsCompareViolation,))\\n']",
  "context": "ares with falsy constants are not allowed.\"\"\"\n    tree = parse_ast_tree(eq_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default"
 },
 "376": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConstantCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_falsy_constant.py",
  "lineno": "46",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(eq_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FalsyConstantCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(other_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (WrongIsCompareViolation,))\\n']",
  "context": "ast_tree(eq_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Fal"
 },
 "377": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_falsy_constant.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(eq_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FalsyConstantCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(other_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (WrongIsCompareViolation,))\\n']",
  "context": "ares with falsy constants are not allowed.\"\"\"\n    tree = parse_ast_tree(is_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default"
 },
 "378": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConstantCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_falsy_constant.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(eq_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FalsyConstantCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(other_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (WrongIsCompareViolation,))\\n']",
  "context": "ast_tree(is_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "379": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_falsy_constant.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(eq_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FalsyConstantCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(other_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (WrongIsCompareViolation,))\\n']",
  "context": "ares with falsy constants are not allowed.\"\"\"\n    tree = parse_ast_tree(other_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default"
 },
 "380": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConstantCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_falsy_constant.py",
  "lineno": "84",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(eq_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FalsyConstantCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(other_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (WrongIsCompareViolation,))\\n']",
  "context": "_tree(other_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "381": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_falsy_constant.py",
  "lineno": "120",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(eq_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FalsyConstantCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(other_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (WrongIsCompareViolation,))\\n']",
  "context": "\"Testing that normal compares are allowed.\"\"\"\n    tree = parse_ast_tree(simple_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default"
 },
 "382": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.compares.WrongConstantCompareVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_compares/test_constant_compares/test_falsy_constant.py",
  "lineno": "122",
  "column": "4",
  "slicing": "['wrong_comparators = [\\n', '    wrong_comparators.extend([\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(eq_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FalsyConstantCompareViolation])\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(is_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', \"@pytest.mark.parametrize('comparators', wrong_comparators)\\n\", '    tree = parse_ast_tree(other_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_conditions.format(*comparators))\\n', '    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (WrongIsCompareViolation,))\\n']",
  "context": "tree(simple_conditions.format(*comparators))\n\n    visitor = WrongConstantCompareVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [], "
 },
 "383": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_annotations/test_multiline_annotations/test_argument_annotations.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['wrong_multiline_arguments = \"\"\"\\n', 'wrong_multiline_tuple = \"\"\"\\n', '    wrong_multiline_arguments,\\n', '    wrong_multiline_tuple,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineFunctionAnnotationViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "correct argument annotations is forbidden.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAnnotationVisitor(default_opti"
 },
 "384": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.annotations.WrongAnnotationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_annotations/test_multiline_annotations/test_argument_annotations.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['wrong_multiline_arguments = \"\"\"\\n', 'wrong_multiline_tuple = \"\"\"\\n', '    wrong_multiline_arguments,\\n', '    wrong_multiline_tuple,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineFunctionAnnotationViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "en.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAnnotationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mul"
 },
 "385": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_annotations/test_multiline_annotations/test_argument_annotations.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['wrong_multiline_arguments = \"\"\"\\n', 'wrong_multiline_tuple = \"\"\"\\n', '    wrong_multiline_arguments,\\n', '    wrong_multiline_tuple,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineFunctionAnnotationViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " possible to use correct type annotations.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAnnotationVisitor(default_opti"
 },
 "386": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.annotations.WrongAnnotationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_annotations/test_multiline_annotations/test_argument_annotations.py",
  "lineno": "90",
  "column": "4",
  "slicing": "['wrong_multiline_arguments = \"\"\"\\n', 'wrong_multiline_tuple = \"\"\"\\n', '    wrong_multiline_arguments,\\n', '    wrong_multiline_tuple,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineFunctionAnnotationViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ns.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAnnotationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "387": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_annotations/test_multiline_annotations/test_return_annotations.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['wrong_multiline_return1 = \"\"\"\\n', 'wrong_multiline_return2 = \"\"\"\\n', 'wrong_multiline_return3 = \"\"\"\\n', '    wrong_multiline_return1,\\n', '    wrong_multiline_return2,\\n', '    wrong_multiline_return3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineFunctionAnnotationViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "incorrect return annotations is forbidden.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAnnotationVisitor(default_opti"
 },
 "388": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.annotations.WrongAnnotationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_annotations/test_multiline_annotations/test_return_annotations.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['wrong_multiline_return1 = \"\"\"\\n', 'wrong_multiline_return2 = \"\"\"\\n', 'wrong_multiline_return3 = \"\"\"\\n', '    wrong_multiline_return1,\\n', '    wrong_multiline_return2,\\n', '    wrong_multiline_return3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineFunctionAnnotationViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "en.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAnnotationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mul"
 },
 "389": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_annotations/test_multiline_annotations/test_return_annotations.py",
  "lineno": "95",
  "column": "4",
  "slicing": "['wrong_multiline_return1 = \"\"\"\\n', 'wrong_multiline_return2 = \"\"\"\\n', 'wrong_multiline_return3 = \"\"\"\\n', '    wrong_multiline_return1,\\n', '    wrong_multiline_return2,\\n', '    wrong_multiline_return3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineFunctionAnnotationViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " possible to use correct type annotations.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAnnotationVisitor(default_opti"
 },
 "390": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.annotations.WrongAnnotationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_annotations/test_multiline_annotations/test_return_annotations.py",
  "lineno": "97",
  "column": "4",
  "slicing": "['wrong_multiline_return1 = \"\"\"\\n', 'wrong_multiline_return2 = \"\"\"\\n', 'wrong_multiline_return3 = \"\"\"\\n', '    wrong_multiline_return1,\\n', '    wrong_multiline_return2,\\n', '    wrong_multiline_return3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineFunctionAnnotationViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongAnnotationVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ns.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongAnnotationVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "391": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_nested_try_blocks.py",
  "lineno": "96",
  "column": "4",
  "slicing": "['wrong_try_nested_try = \"\"\"\\n', 'wrong_try_nested_except = \"\"\"\\n', 'wrong_try_nested_else = \"\"\"\\n', 'wrong_try_nested_finally = \"\"\"\\n', '    wrong_try_nested_try,\\n', '    wrong_try_nested_except,\\n', '    wrong_try_nested_else,\\n', '    wrong_try_nested_finally,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedTryViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ons are raised when try blocks are nested.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = NestedTryBlocksVisitor(default_opti"
 },
 "392": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.NestedTryBlocksVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_nested_try_blocks.py",
  "lineno": "98",
  "column": "4",
  "slicing": "['wrong_try_nested_try = \"\"\"\\n', 'wrong_try_nested_except = \"\"\"\\n', 'wrong_try_nested_else = \"\"\"\\n', 'wrong_try_nested_finally = \"\"\"\\n', '    wrong_try_nested_try,\\n', '    wrong_try_nested_except,\\n', '    wrong_try_nested_else,\\n', '    wrong_try_nested_finally,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedTryViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e nested.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Nes"
 },
 "393": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_nested_try_blocks.py",
  "lineno": "115",
  "column": "4",
  "slicing": "['wrong_try_nested_try = \"\"\"\\n', 'wrong_try_nested_except = \"\"\"\\n', 'wrong_try_nested_else = \"\"\"\\n', 'wrong_try_nested_finally = \"\"\"\\n', '    wrong_try_nested_try,\\n', '    wrong_try_nested_except,\\n', '    wrong_try_nested_else,\\n', '    wrong_try_nested_finally,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedTryViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e not raised when try block is not nested.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = NestedTryBlocksVisitor(default_opti"
 },
 "394": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.NestedTryBlocksVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_nested_try_blocks.py",
  "lineno": "117",
  "column": "4",
  "slicing": "['wrong_try_nested_try = \"\"\"\\n', 'wrong_try_nested_except = \"\"\"\\n', 'wrong_try_nested_else = \"\"\"\\n', 'wrong_try_nested_finally = \"\"\"\\n', '    wrong_try_nested_try,\\n', '    wrong_try_nested_except,\\n', '    wrong_try_nested_else,\\n', '    wrong_try_nested_finally,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedTryViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t nested.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = NestedTryBlocksVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "395": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_except_block_expression.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['use_complex_expression = \"\"\"\\n', 'use_tuple_with_forbidden_expressions = \"\"\"\\n', '    use_complex_expression,\\n', '    use_tuple_with_forbidden_expressions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonTrivialExceptViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t ValueError or TypeError:` is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_o"
 },
 "396": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongExceptHandlerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_except_block_expression.py",
  "lineno": "66",
  "column": "4",
  "slicing": "['use_complex_expression = \"\"\"\\n', 'use_tuple_with_forbidden_expressions = \"\"\"\\n', '    use_complex_expression,\\n', '    use_tuple_with_forbidden_expressions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonTrivialExceptViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Non"
 },
 "397": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_except_block_expression.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['use_complex_expression = \"\"\"\\n', 'use_tuple_with_forbidden_expressions = \"\"\"\\n', '    use_complex_expression,\\n', '    use_tuple_with_forbidden_expressions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonTrivialExceptViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing that trivial cases are allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_o"
 },
 "398": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongExceptHandlerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_except_block_expression.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['use_complex_expression = \"\"\"\\n', 'use_tuple_with_forbidden_expressions = \"\"\"\\n', '    use_complex_expression,\\n', '    use_tuple_with_forbidden_expressions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonTrivialExceptViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "399": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_try_finally.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['wrong_try_example1 = \"\"\"\\n', 'wrong_try_example2 = \"\"\"\\n', '    wrong_try_example1,\\n', '    wrong_try_example2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessFinallyViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " when finally without except in try block.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "400": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_try_finally.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['wrong_try_example1 = \"\"\"\\n', 'wrong_try_example2 = \"\"\"\\n', '    wrong_try_example1,\\n', '    wrong_try_example2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessFinallyViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ck.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "401": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_try_finally.py",
  "lineno": "98",
  "column": "4",
  "slicing": "['wrong_try_example1 = \"\"\"\\n', 'wrong_try_example2 = \"\"\"\\n', '    wrong_try_example1,\\n', '    wrong_try_example2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessFinallyViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sed when finally with except in try block.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "402": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_try_finally.py",
  "lineno": "100",
  "column": "4",
  "slicing": "['wrong_try_example1 = \"\"\"\\n', 'wrong_try_example2 = \"\"\"\\n', '    wrong_try_example1,\\n', '    wrong_try_example2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessFinallyViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ck.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "403": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_return_path.py",
  "lineno": "391",
  "column": "4",
  "slicing": "['right_outside1 = \"\"\"\\n', 'right_outside2 = \"\"\"\\n', 'right_try_except = \"\"\"\\n', 'right_try_except_multiple = \"\"\"\\n', 'right_except_else = \"\"\"\\n', 'right_multiple_except_else = \"\"\"\\n', 'right_else = \"\"\"\\n', 'right_try_except_and_else = \"\"\"\\n', 'right_finally = \"\"\"\\n', 'right_try_catch_and_finally = \"\"\"\\n', 'right_try_catch_and_else_and_finally1 = \"\"\"\\n', 'right_try_catch_and_else_and_finally2 = \"\"\"\\n', 'right_try_catch_and_else_and_finally3 = \"\"\"\\n', 'right_try_catch_and_else_and_finally4 = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_except_finally = \"\"\"\\n', 'wrong_multiple_except_finally1 = \"\"\"\\n', 'wrong_multiple_except_finally2 = \"\"\"\\n', 'wrong_multiple_except_finally3 = \"\"\"\\n', 'wrong_else_finally = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_try_else = \"\"\"\\n', 'wrong_try_except_else = \"\"\"\\n', 'wrong_all1 = \"\"\"\\n', 'wrong_all2 = \"\"\"\\n', 'wrong_all3 = \"\"\"\\n', 'wrong_all4 = \"\"\"\\n', 'all_nodes = \"\"\"\\n', '    wrong_except_finally,\\n', '    wrong_multiple_except_finally1,\\n', '    wrong_multiple_except_finally2,\\n', '    wrong_multiple_except_finally3,\\n', '    wrong_else_finally,\\n', '    wrong_try_finally,\\n', '    wrong_try_else,\\n', '    wrong_try_except_else,\\n', '    wrong_all1,\\n', '    wrong_all2,\\n', '    wrong_all3,\\n', '    wrong_all4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    right_outside1,\\n', '    right_outside2,\\n', '    right_try_except,\\n', '    right_try_except_multiple,\\n', '    right_except_else,\\n', '    right_multiple_except_else,\\n', '    right_else,\\n', '    right_try_except_and_else,\\n', '    right_finally,\\n', '    right_try_catch_and_finally,\\n', '    right_try_catch_and_else_and_finally1,\\n', '    right_try_catch_and_else_and_finally2,\\n', '    right_try_catch_and_else_and_finally3,\\n', '    right_try_catch_and_else_and_finally4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (UselessExceptCaseViolation))\\n', '    tree = parse_ast_tree(mode(all_nodes.format(*statements)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TryExceptMultipleReturnPathViolation])\\n']",
  "context": "aised when there are multiple return path.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "404": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_return_path.py",
  "lineno": "393",
  "column": "4",
  "slicing": "['right_outside1 = \"\"\"\\n', 'right_outside2 = \"\"\"\\n', 'right_try_except = \"\"\"\\n', 'right_try_except_multiple = \"\"\"\\n', 'right_except_else = \"\"\"\\n', 'right_multiple_except_else = \"\"\"\\n', 'right_else = \"\"\"\\n', 'right_try_except_and_else = \"\"\"\\n', 'right_finally = \"\"\"\\n', 'right_try_catch_and_finally = \"\"\"\\n', 'right_try_catch_and_else_and_finally1 = \"\"\"\\n', 'right_try_catch_and_else_and_finally2 = \"\"\"\\n', 'right_try_catch_and_else_and_finally3 = \"\"\"\\n', 'right_try_catch_and_else_and_finally4 = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_except_finally = \"\"\"\\n', 'wrong_multiple_except_finally1 = \"\"\"\\n', 'wrong_multiple_except_finally2 = \"\"\"\\n', 'wrong_multiple_except_finally3 = \"\"\"\\n', 'wrong_else_finally = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_try_else = \"\"\"\\n', 'wrong_try_except_else = \"\"\"\\n', 'wrong_all1 = \"\"\"\\n', 'wrong_all2 = \"\"\"\\n', 'wrong_all3 = \"\"\"\\n', 'wrong_all4 = \"\"\"\\n', 'all_nodes = \"\"\"\\n', '    wrong_except_finally,\\n', '    wrong_multiple_except_finally1,\\n', '    wrong_multiple_except_finally2,\\n', '    wrong_multiple_except_finally3,\\n', '    wrong_else_finally,\\n', '    wrong_try_finally,\\n', '    wrong_try_else,\\n', '    wrong_try_except_else,\\n', '    wrong_all1,\\n', '    wrong_all2,\\n', '    wrong_all3,\\n', '    wrong_all4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    right_outside1,\\n', '    right_outside2,\\n', '    right_try_except,\\n', '    right_try_except_multiple,\\n', '    right_except_else,\\n', '    right_multiple_except_else,\\n', '    right_else,\\n', '    right_try_except_and_else,\\n', '    right_finally,\\n', '    right_try_catch_and_finally,\\n', '    right_try_catch_and_else_and_finally1,\\n', '    right_try_catch_and_else_and_finally2,\\n', '    right_try_catch_and_else_and_finally3,\\n', '    right_try_catch_and_else_and_finally4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (UselessExceptCaseViolation))\\n', '    tree = parse_ast_tree(mode(all_nodes.format(*statements)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TryExceptMultipleReturnPathViolation])\\n']",
  "context": "parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "405": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_return_path.py",
  "lineno": "436",
  "column": "4",
  "slicing": "['right_outside1 = \"\"\"\\n', 'right_outside2 = \"\"\"\\n', 'right_try_except = \"\"\"\\n', 'right_try_except_multiple = \"\"\"\\n', 'right_except_else = \"\"\"\\n', 'right_multiple_except_else = \"\"\"\\n', 'right_else = \"\"\"\\n', 'right_try_except_and_else = \"\"\"\\n', 'right_finally = \"\"\"\\n', 'right_try_catch_and_finally = \"\"\"\\n', 'right_try_catch_and_else_and_finally1 = \"\"\"\\n', 'right_try_catch_and_else_and_finally2 = \"\"\"\\n', 'right_try_catch_and_else_and_finally3 = \"\"\"\\n', 'right_try_catch_and_else_and_finally4 = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_except_finally = \"\"\"\\n', 'wrong_multiple_except_finally1 = \"\"\"\\n', 'wrong_multiple_except_finally2 = \"\"\"\\n', 'wrong_multiple_except_finally3 = \"\"\"\\n', 'wrong_else_finally = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_try_else = \"\"\"\\n', 'wrong_try_except_else = \"\"\"\\n', 'wrong_all1 = \"\"\"\\n', 'wrong_all2 = \"\"\"\\n', 'wrong_all3 = \"\"\"\\n', 'wrong_all4 = \"\"\"\\n', 'all_nodes = \"\"\"\\n', '    wrong_except_finally,\\n', '    wrong_multiple_except_finally1,\\n', '    wrong_multiple_except_finally2,\\n', '    wrong_multiple_except_finally3,\\n', '    wrong_else_finally,\\n', '    wrong_try_finally,\\n', '    wrong_try_else,\\n', '    wrong_try_except_else,\\n', '    wrong_all1,\\n', '    wrong_all2,\\n', '    wrong_all3,\\n', '    wrong_all4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    right_outside1,\\n', '    right_outside2,\\n', '    right_try_except,\\n', '    right_try_except_multiple,\\n', '    right_except_else,\\n', '    right_multiple_except_else,\\n', '    right_else,\\n', '    right_try_except_and_else,\\n', '    right_finally,\\n', '    right_try_catch_and_finally,\\n', '    right_try_catch_and_else_and_finally1,\\n', '    right_try_catch_and_else_and_finally2,\\n', '    right_try_catch_and_else_and_finally3,\\n', '    right_try_catch_and_else_and_finally4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (UselessExceptCaseViolation))\\n', '    tree = parse_ast_tree(mode(all_nodes.format(*statements)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TryExceptMultipleReturnPathViolation])\\n']",
  "context": "re not raised when return path is correct.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "406": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_return_path.py",
  "lineno": "438",
  "column": "4",
  "slicing": "['right_outside1 = \"\"\"\\n', 'right_outside2 = \"\"\"\\n', 'right_try_except = \"\"\"\\n', 'right_try_except_multiple = \"\"\"\\n', 'right_except_else = \"\"\"\\n', 'right_multiple_except_else = \"\"\"\\n', 'right_else = \"\"\"\\n', 'right_try_except_and_else = \"\"\"\\n', 'right_finally = \"\"\"\\n', 'right_try_catch_and_finally = \"\"\"\\n', 'right_try_catch_and_else_and_finally1 = \"\"\"\\n', 'right_try_catch_and_else_and_finally2 = \"\"\"\\n', 'right_try_catch_and_else_and_finally3 = \"\"\"\\n', 'right_try_catch_and_else_and_finally4 = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_except_finally = \"\"\"\\n', 'wrong_multiple_except_finally1 = \"\"\"\\n', 'wrong_multiple_except_finally2 = \"\"\"\\n', 'wrong_multiple_except_finally3 = \"\"\"\\n', 'wrong_else_finally = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_try_else = \"\"\"\\n', 'wrong_try_except_else = \"\"\"\\n', 'wrong_all1 = \"\"\"\\n', 'wrong_all2 = \"\"\"\\n', 'wrong_all3 = \"\"\"\\n', 'wrong_all4 = \"\"\"\\n', 'all_nodes = \"\"\"\\n', '    wrong_except_finally,\\n', '    wrong_multiple_except_finally1,\\n', '    wrong_multiple_except_finally2,\\n', '    wrong_multiple_except_finally3,\\n', '    wrong_else_finally,\\n', '    wrong_try_finally,\\n', '    wrong_try_else,\\n', '    wrong_try_except_else,\\n', '    wrong_all1,\\n', '    wrong_all2,\\n', '    wrong_all3,\\n', '    wrong_all4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    right_outside1,\\n', '    right_outside2,\\n', '    right_try_except,\\n', '    right_try_except_multiple,\\n', '    right_except_else,\\n', '    right_multiple_except_else,\\n', '    right_else,\\n', '    right_try_except_and_else,\\n', '    right_finally,\\n', '    right_try_catch_and_finally,\\n', '    right_try_catch_and_else_and_finally1,\\n', '    right_try_catch_and_else_and_finally2,\\n', '    right_try_catch_and_else_and_finally3,\\n', '    right_try_catch_and_else_and_finally4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (UselessExceptCaseViolation))\\n', '    tree = parse_ast_tree(mode(all_nodes.format(*statements)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TryExceptMultipleReturnPathViolation])\\n']",
  "context": "parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [], "
 },
 "407": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_return_path.py",
  "lineno": "489",
  "column": "4",
  "slicing": "['right_outside1 = \"\"\"\\n', 'right_outside2 = \"\"\"\\n', 'right_try_except = \"\"\"\\n', 'right_try_except_multiple = \"\"\"\\n', 'right_except_else = \"\"\"\\n', 'right_multiple_except_else = \"\"\"\\n', 'right_else = \"\"\"\\n', 'right_try_except_and_else = \"\"\"\\n', 'right_finally = \"\"\"\\n', 'right_try_catch_and_finally = \"\"\"\\n', 'right_try_catch_and_else_and_finally1 = \"\"\"\\n', 'right_try_catch_and_else_and_finally2 = \"\"\"\\n', 'right_try_catch_and_else_and_finally3 = \"\"\"\\n', 'right_try_catch_and_else_and_finally4 = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_except_finally = \"\"\"\\n', 'wrong_multiple_except_finally1 = \"\"\"\\n', 'wrong_multiple_except_finally2 = \"\"\"\\n', 'wrong_multiple_except_finally3 = \"\"\"\\n', 'wrong_else_finally = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_try_else = \"\"\"\\n', 'wrong_try_except_else = \"\"\"\\n', 'wrong_all1 = \"\"\"\\n', 'wrong_all2 = \"\"\"\\n', 'wrong_all3 = \"\"\"\\n', 'wrong_all4 = \"\"\"\\n', 'all_nodes = \"\"\"\\n', '    wrong_except_finally,\\n', '    wrong_multiple_except_finally1,\\n', '    wrong_multiple_except_finally2,\\n', '    wrong_multiple_except_finally3,\\n', '    wrong_else_finally,\\n', '    wrong_try_finally,\\n', '    wrong_try_else,\\n', '    wrong_try_except_else,\\n', '    wrong_all1,\\n', '    wrong_all2,\\n', '    wrong_all3,\\n', '    wrong_all4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    right_outside1,\\n', '    right_outside2,\\n', '    right_try_except,\\n', '    right_try_except_multiple,\\n', '    right_except_else,\\n', '    right_multiple_except_else,\\n', '    right_else,\\n', '    right_try_except_and_else,\\n', '    right_finally,\\n', '    right_try_catch_and_finally,\\n', '    right_try_catch_and_else_and_finally1,\\n', '    right_try_catch_and_else_and_finally2,\\n', '    right_try_catch_and_else_and_finally3,\\n', '    right_try_catch_and_else_and_finally4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (UselessExceptCaseViolation))\\n', '    tree = parse_ast_tree(mode(all_nodes.format(*statements)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TryExceptMultipleReturnPathViolation])\\n']",
  "context": "aised when there are multiple return path.\"\"\"\n    tree = parse_ast_tree(mode(all_nodes.format(*statements)))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "408": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_return_path.py",
  "lineno": "491",
  "column": "4",
  "slicing": "['right_outside1 = \"\"\"\\n', 'right_outside2 = \"\"\"\\n', 'right_try_except = \"\"\"\\n', 'right_try_except_multiple = \"\"\"\\n', 'right_except_else = \"\"\"\\n', 'right_multiple_except_else = \"\"\"\\n', 'right_else = \"\"\"\\n', 'right_try_except_and_else = \"\"\"\\n', 'right_finally = \"\"\"\\n', 'right_try_catch_and_finally = \"\"\"\\n', 'right_try_catch_and_else_and_finally1 = \"\"\"\\n', 'right_try_catch_and_else_and_finally2 = \"\"\"\\n', 'right_try_catch_and_else_and_finally3 = \"\"\"\\n', 'right_try_catch_and_else_and_finally4 = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_except_finally = \"\"\"\\n', 'wrong_multiple_except_finally1 = \"\"\"\\n', 'wrong_multiple_except_finally2 = \"\"\"\\n', 'wrong_multiple_except_finally3 = \"\"\"\\n', 'wrong_else_finally = \"\"\"\\n', 'wrong_try_finally = \"\"\"\\n', 'wrong_try_else = \"\"\"\\n', 'wrong_try_except_else = \"\"\"\\n', 'wrong_all1 = \"\"\"\\n', 'wrong_all2 = \"\"\"\\n', 'wrong_all3 = \"\"\"\\n', 'wrong_all4 = \"\"\"\\n', 'all_nodes = \"\"\"\\n', '    wrong_except_finally,\\n', '    wrong_multiple_except_finally1,\\n', '    wrong_multiple_except_finally2,\\n', '    wrong_multiple_except_finally3,\\n', '    wrong_else_finally,\\n', '    wrong_try_finally,\\n', '    wrong_try_else,\\n', '    wrong_try_except_else,\\n', '    wrong_all1,\\n', '    wrong_all2,\\n', '    wrong_all3,\\n', '    wrong_all4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    right_outside1,\\n', '    right_outside2,\\n', '    right_try_except,\\n', '    right_try_except_multiple,\\n', '    right_except_else,\\n', '    right_multiple_except_else,\\n', '    right_else,\\n', '    right_try_except_and_else,\\n', '    right_finally,\\n', '    right_try_catch_and_finally,\\n', '    right_try_catch_and_else_and_finally1,\\n', '    right_try_catch_and_else_and_finally2,\\n', '    right_try_catch_and_else_and_finally3,\\n', '    right_try_catch_and_else_and_finally4,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (UselessExceptCaseViolation))\\n', '    tree = parse_ast_tree(mode(all_nodes.format(*statements)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TryExceptMultipleReturnPathViolation])\\n']",
  "context": "st_tree(mode(all_nodes.format(*statements)))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Try"
 },
 "409": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_base_exception.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['use_base_exception = \"\"\"\\n', '    use_base_exception,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat `except BaseException:` is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_o"
 },
 "410": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongExceptHandlerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_base_exception.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['use_base_exception = \"\"\"\\n', '    use_base_exception,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Bas"
 },
 "411": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_base_exception.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['use_base_exception = \"\"\"\\n', '    use_base_exception,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ept Exception:` and `except:` are allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_o"
 },
 "412": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongExceptHandlerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_base_exception.py",
  "lineno": "63",
  "column": "4",
  "slicing": "['use_base_exception = \"\"\"\\n', '    use_base_exception,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "413": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_duplicate_exceptions.py",
  "lineno": "119",
  "column": "4",
  "slicing": "['correct_bare_except = \"\"\"\\n', 'correct_simple_except = \"\"\"\\n', 'correct_simple_except_with_name = \"\"\"\\n', 'correct_two_exceptions = \"\"\"\\n', 'correct_two_exceptions_with_names = \"\"\"\\n', 'correct_two_excepts = \"\"\"\\n', 'correct_two_excepts_with_names = \"\"\"\\n', 'correct_two_complex_excepts = \"\"\"\\n', '    correct_bare_except,\\n', '    correct_simple_except,\\n', '    correct_simple_except_with_name,\\n', '    correct_two_exceptions,\\n', '    correct_two_exceptions_with_names,\\n', '    correct_two_excepts,\\n', '    correct_two_excepts_with_names,\\n', '    correct_two_complex_excepts,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DuplicateExceptionViolation])\\n']",
  "context": ",\n):\n    \"\"\"Violations without duplicates.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "414": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_duplicate_exceptions.py",
  "lineno": "121",
  "column": "4",
  "slicing": "['correct_bare_except = \"\"\"\\n', 'correct_simple_except = \"\"\"\\n', 'correct_simple_except_with_name = \"\"\"\\n', 'correct_two_exceptions = \"\"\"\\n', 'correct_two_exceptions_with_names = \"\"\"\\n', 'correct_two_excepts = \"\"\"\\n', 'correct_two_excepts_with_names = \"\"\"\\n', 'correct_two_complex_excepts = \"\"\"\\n', '    correct_bare_except,\\n', '    correct_simple_except,\\n', '    correct_simple_except_with_name,\\n', '    correct_two_exceptions,\\n', '    correct_two_exceptions_with_names,\\n', '    correct_two_excepts,\\n', '    correct_two_excepts_with_names,\\n', '    correct_two_complex_excepts,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DuplicateExceptionViolation])\\n']",
  "context": "plicates.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "415": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_duplicate_exceptions.py",
  "lineno": "139",
  "column": "4",
  "slicing": "['correct_bare_except = \"\"\"\\n', 'correct_simple_except = \"\"\"\\n', 'correct_simple_except_with_name = \"\"\"\\n', 'correct_two_exceptions = \"\"\"\\n', 'correct_two_exceptions_with_names = \"\"\"\\n', 'correct_two_excepts = \"\"\"\\n', 'correct_two_excepts_with_names = \"\"\"\\n', 'correct_two_complex_excepts = \"\"\"\\n', '    correct_bare_except,\\n', '    correct_simple_except,\\n', '    correct_simple_except_with_name,\\n', '    correct_two_exceptions,\\n', '    correct_two_exceptions_with_names,\\n', '    correct_two_excepts,\\n', '    correct_two_excepts_with_names,\\n', '    correct_two_complex_excepts,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DuplicateExceptionViolation])\\n']",
  "context": "xception classes should raise a violation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "416": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_duplicate_exceptions.py",
  "lineno": "141",
  "column": "4",
  "slicing": "['correct_bare_except = \"\"\"\\n', 'correct_simple_except = \"\"\"\\n', 'correct_simple_except_with_name = \"\"\"\\n', 'correct_two_exceptions = \"\"\"\\n', 'correct_two_exceptions_with_names = \"\"\"\\n', 'correct_two_excepts = \"\"\"\\n', 'correct_two_excepts_with_names = \"\"\"\\n', 'correct_two_complex_excepts = \"\"\"\\n', '    correct_bare_except,\\n', '    correct_simple_except,\\n', '    correct_simple_except_with_name,\\n', '    correct_two_exceptions,\\n', '    correct_two_exceptions_with_names,\\n', '    correct_two_excepts,\\n', '    correct_two_excepts_with_names,\\n', '    correct_two_complex_excepts,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DuplicateExceptionViolation])\\n']",
  "context": "iolation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Dup"
 },
 "417": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_useless_except_case.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['wrong_reraise_except = \"\"\"\\n', 'wrong_raise_except = \"\"\"\\n', 'wrong_bare_raise_except = \"\"\"\\n', '    wrong_reraise_except,\\n', '    wrong_raise_except,\\n', '    wrong_bare_raise_except,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessExceptCaseViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s are raised when using wrong except case.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_o"
 },
 "418": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongExceptHandlerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_useless_except_case.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['wrong_reraise_except = \"\"\"\\n', 'wrong_raise_except = \"\"\"\\n', 'wrong_bare_raise_except = \"\"\"\\n', '    wrong_reraise_except,\\n', '    wrong_raise_except,\\n', '    wrong_bare_raise_except,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessExceptCaseViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ept case.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "419": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_useless_except_case.py",
  "lineno": "105",
  "column": "4",
  "slicing": "['wrong_reraise_except = \"\"\"\\n', 'wrong_raise_except = \"\"\"\\n', 'wrong_bare_raise_except = \"\"\"\\n', '    wrong_reraise_except,\\n', '    wrong_raise_except,\\n', '    wrong_bare_raise_except,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessExceptCaseViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "not raised when using correct except case.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_o"
 },
 "420": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongExceptHandlerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_useless_except_case.py",
  "lineno": "107",
  "column": "4",
  "slicing": "['wrong_reraise_except = \"\"\"\\n', 'wrong_raise_except = \"\"\"\\n', 'wrong_bare_raise_except = \"\"\"\\n', '    wrong_reraise_except,\\n', '    wrong_raise_except,\\n', '    wrong_bare_raise_except,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessExceptCaseViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ept case.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongExceptHandlerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "421": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_exception_order.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['exception_template = \"\"\"\\n', 'custom_exception_template1 = \"\"\"\\n', 'custom_exception_template2 = \"\"\"\\n', '    exception_template,\\n', '    custom_exception_template1,\\n', '    custom_exception_template2,\\n', '    tree = parse_ast_tree(code.format(*statements))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    exception_template,\\n', '    custom_exception_template1,\\n', '    custom_exception_template2,\\n', '    tree = parse_ast_tree(code.format(*statements))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IncorrectExceptOrderViolation])\\n']",
  "context": " raised when use correct oder of `except`.\"\"\"\n    tree = parse_ast_tree(code.format(*statements))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "422": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_exception_order.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['exception_template = \"\"\"\\n', 'custom_exception_template1 = \"\"\"\\n', 'custom_exception_template2 = \"\"\"\\n', '    exception_template,\\n', '    custom_exception_template1,\\n', '    custom_exception_template2,\\n', '    tree = parse_ast_tree(code.format(*statements))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    exception_template,\\n', '    custom_exception_template1,\\n', '    custom_exception_template2,\\n', '    tree = parse_ast_tree(code.format(*statements))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IncorrectExceptOrderViolation])\\n']",
  "context": "e = parse_ast_tree(code.format(*statements))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "423": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_exception_order.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['exception_template = \"\"\"\\n', 'custom_exception_template1 = \"\"\"\\n', 'custom_exception_template2 = \"\"\"\\n', '    exception_template,\\n', '    custom_exception_template1,\\n', '    custom_exception_template2,\\n', '    tree = parse_ast_tree(code.format(*statements))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    exception_template,\\n', '    custom_exception_template1,\\n', '    custom_exception_template2,\\n', '    tree = parse_ast_tree(code.format(*statements))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IncorrectExceptOrderViolation])\\n']",
  "context": " \"\"\"Testing incorrect order of exceptions.\"\"\"\n    tree = parse_ast_tree(code.format(*statements))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "424": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_exception_order.py",
  "lineno": "89",
  "column": "4",
  "slicing": "['exception_template = \"\"\"\\n', 'custom_exception_template1 = \"\"\"\\n', 'custom_exception_template2 = \"\"\"\\n', '    exception_template,\\n', '    custom_exception_template1,\\n', '    custom_exception_template2,\\n', '    tree = parse_ast_tree(code.format(*statements))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    exception_template,\\n', '    custom_exception_template1,\\n', '    custom_exception_template2,\\n', '    tree = parse_ast_tree(code.format(*statements))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IncorrectExceptOrderViolation])\\n']",
  "context": "e = parse_ast_tree(code.format(*statements))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Inc"
 },
 "425": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_in_loops.py",
  "lineno": "91",
  "column": "4",
  "slicing": "['right_try_example_with_for = \"\"\"\\n', 'right_try_example_with_while = \"\"\"\\n', 'right_example_with_for = \"\"\"\\n', 'right_example_with_while = \"\"\"\\n', 'wrong_try_example = \"\"\"\\n', 'wrong_try_example_with_while = \"\"\"\\n', '    right_example_with_for,\\n', '    right_example_with_while,\\n', '    right_try_example_with_for,\\n', '    right_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n']",
  "context": "ar loops and loops with `try` are allowed.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "426": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_in_loops.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['right_try_example_with_for = \"\"\"\\n', 'right_try_example_with_while = \"\"\"\\n', 'right_example_with_for = \"\"\"\\n', 'right_example_with_while = \"\"\"\\n', 'wrong_try_example = \"\"\"\\n', 'wrong_try_example_with_while = \"\"\"\\n', '    right_example_with_for,\\n', '    right_example_with_while,\\n', '    right_try_example_with_for,\\n', '    right_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n']",
  "context": "parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "427": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_in_loops.py",
  "lineno": "115",
  "column": "4",
  "slicing": "['right_try_example_with_for = \"\"\"\\n', 'right_try_example_with_while = \"\"\"\\n', 'right_example_with_for = \"\"\"\\n', 'right_example_with_while = \"\"\"\\n', 'wrong_try_example = \"\"\"\\n', 'wrong_try_example_with_while = \"\"\"\\n', '    right_example_with_for,\\n', '    right_example_with_while,\\n', '    right_try_example_with_for,\\n', '    right_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n']",
  "context": "reak` keyword is not allowed in `finally`.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "428": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_in_loops.py",
  "lineno": "117",
  "column": "4",
  "slicing": "['right_try_example_with_for = \"\"\"\\n', 'right_try_example_with_while = \"\"\"\\n', 'right_example_with_for = \"\"\"\\n', 'right_example_with_while = \"\"\"\\n', 'wrong_try_example = \"\"\"\\n', 'wrong_try_example_with_while = \"\"\"\\n', '    right_example_with_for,\\n', '    right_example_with_while,\\n', '    right_try_example_with_for,\\n', '    right_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n']",
  "context": "parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Loo"
 },
 "429": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_in_loops.py",
  "lineno": "143",
  "column": "4",
  "slicing": "['right_try_example_with_for = \"\"\"\\n', 'right_try_example_with_while = \"\"\"\\n', 'right_example_with_for = \"\"\"\\n', 'right_example_with_while = \"\"\"\\n', 'wrong_try_example = \"\"\"\\n', 'wrong_try_example_with_while = \"\"\"\\n', '    right_example_with_for,\\n', '    right_example_with_while,\\n', '    right_try_example_with_for,\\n', '    right_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n']",
  "context": "inue` keyword is not allowed in `finally`.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_optio"
 },
 "430": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.exceptions.WrongTryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_exceptions/test_finally_in_loops.py",
  "lineno": "145",
  "column": "4",
  "slicing": "['right_try_example_with_for = \"\"\"\\n', 'right_try_example_with_while = \"\"\"\\n', 'right_example_with_for = \"\"\"\\n', 'right_example_with_while = \"\"\"\\n', 'wrong_try_example = \"\"\"\\n', 'wrong_try_example_with_while = \"\"\"\\n', '    right_example_with_for,\\n', '    right_example_with_while,\\n', '    right_try_example_with_for,\\n', '    right_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n', '    tree = parse_ast_tree(mode(code.format(statement)))\\n', '    visitor = WrongTryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopControlFinallyViolation])\\n', '    wrong_try_example,\\n', '    wrong_try_example_with_while,\\n']",
  "context": "parse_ast_tree(mode(code.format(statement)))\n\n    visitor = WrongTryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Loo"
 },
 "431": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_module_metadata.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['module_metadata = \"\"\"\\n', 'module_type_metadata = \"\"\"\\n', 'nested_metadata = \"\"\"\\n', 'startup_metadata = \"\"\"\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleMetadataViolation])\\n', '    assert_error_text(visitor, bad_name)\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    nested_metadata,\\n', '    tree = parse_ast_tree(code.format(correct_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(startup_metadata)\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at metadata cannot have blacklisted names.\"\"\"\n    tree = parse_ast_tree(code.format(bad_name))\n\n    visitor = WrongModuleMetadataVisitor(default_"
 },
 "432": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongModuleMetadataVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_module_metadata.py",
  "lineno": "46",
  "column": "4",
  "slicing": "['module_metadata = \"\"\"\\n', 'module_type_metadata = \"\"\"\\n', 'nested_metadata = \"\"\"\\n', 'startup_metadata = \"\"\"\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleMetadataViolation])\\n', '    assert_error_text(visitor, bad_name)\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    nested_metadata,\\n', '    tree = parse_ast_tree(code.format(correct_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(startup_metadata)\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(code.format(bad_name))\n\n    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "433": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_module_metadata.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['module_metadata = \"\"\"\\n', 'module_type_metadata = \"\"\"\\n', 'nested_metadata = \"\"\"\\n', 'startup_metadata = \"\"\"\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleMetadataViolation])\\n', '    assert_error_text(visitor, bad_name)\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    nested_metadata,\\n', '    tree = parse_ast_tree(code.format(correct_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(startup_metadata)\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sting that metadata can have normal names.\"\"\"\n    tree = parse_ast_tree(code.format(correct_name))\n\n    visitor = WrongModuleMetadataVisitor(default_"
 },
 "434": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongModuleMetadataVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_module_metadata.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['module_metadata = \"\"\"\\n', 'module_type_metadata = \"\"\"\\n', 'nested_metadata = \"\"\"\\n', 'startup_metadata = \"\"\"\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleMetadataViolation])\\n', '    assert_error_text(visitor, bad_name)\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    nested_metadata,\\n', '    tree = parse_ast_tree(code.format(correct_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(startup_metadata)\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(code.format(correct_name))\n\n    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "435": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_module_metadata.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['module_metadata = \"\"\"\\n', 'module_type_metadata = \"\"\"\\n', 'nested_metadata = \"\"\"\\n', 'startup_metadata = \"\"\"\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleMetadataViolation])\\n', '    assert_error_text(visitor, bad_name)\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    nested_metadata,\\n', '    tree = parse_ast_tree(code.format(correct_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(startup_metadata)\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  \"\"\"Testing that startup hook is allowed.\"\"\"\n    tree = parse_ast_tree(startup_metadata)\n\n    visitor = WrongModuleMetadataVisitor(default_"
 },
 "436": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongModuleMetadataVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_module_metadata.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['module_metadata = \"\"\"\\n', 'module_type_metadata = \"\"\"\\n', 'nested_metadata = \"\"\"\\n', 'startup_metadata = \"\"\"\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleMetadataViolation])\\n', '    assert_error_text(visitor, bad_name)\\n', '    module_metadata,\\n', '    module_type_metadata,\\n', '    nested_metadata,\\n', '    tree = parse_ast_tree(code.format(correct_name))\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(startup_metadata)\\n', '    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    tree = parse_ast_tree(startup_metadata)\n\n    visitor = WrongModuleMetadataVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "437": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_reserved_argument.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['wrong_method_template = \"\"\"\\n', 'wrong_classmethod_template = \"\"\"\\n', \"wrong_function_template = 'def function(different, {0}): ...'\\n\", '    wrong_method_template,\\n', '    wrong_classmethod_template,\\n', '    wrong_function_template,\\n', '    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReservedArgumentNameViolation])\\n', '    assert_error_text(visitor, argument)\\n', '    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "pecial names for arguments are restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(argument)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "438": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_reserved_argument.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['wrong_method_template = \"\"\"\\n', 'wrong_classmethod_template = \"\"\"\\n', \"wrong_function_template = 'def function(different, {0}): ...'\\n\", '    wrong_method_template,\\n', '    wrong_classmethod_template,\\n', '    wrong_function_template,\\n', '    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReservedArgumentNameViolation])\\n', '    assert_error_text(visitor, argument)\\n', '    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(mode(code.format(argument)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Res"
 },
 "439": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_reserved_argument.py",
  "lineno": "84",
  "column": "4",
  "slicing": "['wrong_method_template = \"\"\"\\n', 'wrong_classmethod_template = \"\"\"\\n', \"wrong_function_template = 'def function(different, {0}): ...'\\n\", '    wrong_method_template,\\n', '    wrong_classmethod_template,\\n', '    wrong_function_template,\\n', '    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReservedArgumentNameViolation])\\n', '    assert_error_text(visitor, argument)\\n', '    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "pecial names for arguments are restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(argument)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "440": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_reserved_argument.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['wrong_method_template = \"\"\"\\n', 'wrong_classmethod_template = \"\"\"\\n', \"wrong_function_template = 'def function(different, {0}): ...'\\n\", '    wrong_method_template,\\n', '    wrong_classmethod_template,\\n', '    wrong_function_template,\\n', '    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReservedArgumentNameViolation])\\n', '    assert_error_text(visitor, argument)\\n', '    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(mode(code.format(argument)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "441": {
  "name": "_ALL_FIXTURES",
  "type": "frozenset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/conftest.py",
  "lineno": "157",
  "column": "0",
  "slicing": "['import_alias = \"\"\"\\n', 'from_import_alias = \"\"\"\\n', \"class_name = 'class {0}: ...'\\n\", \"function_name = 'def {0}(): ...'\\n\", 'method_name = \"\"\"\\n', \"function_argument = 'def test(arg, {0}): ...'\\n\", 'method_argument = \"\"\"\\n', \"function_keyword_argument = 'def test(arg, {0}=None): ...'\\n\", 'method_keyword_argument = \"\"\"\\n', \"function_args_argument = 'def test(arg, *{0}): ...'\\n\", \"function_kwargs_argument = 'def test(arg, **{0}): ...'\\n\", 'method_args_argument = \"\"\"\\n', 'method_kwargs_argument = \"\"\"\\n', 'function_kwonly_argument = \"\"\"\\n', 'function_kwonly_default_argument = \"\"\"\\n', 'method_kwonly_argument = \"\"\"\\n', \"lambda_argument = 'lambda {0}: ...'\\n\", 'static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_annotation = \"\"\"\\n', 'instance_attribute = \"\"\"\\n', 'instance_typed_attribute = \"\"\"\\n', \"variable_def = '{0} = 1'\\n\", \"variable_typed_def = '{0}: int = 2'\\n\", \"variable_typed = '{0}: str'\\n\", 'unpacking_variables = \"\"\"\\n', 'unpacking_star_variables = \"\"\"\\n', 'for_variable = \"\"\"\\n', 'for_star_variable = \"\"\"\\n', 'with_variable = \"\"\"\\n', 'with_star_variable = \"\"\"\\n', 'exception = \"\"\"\\n', '_ALL_FIXTURES = frozenset((\\n', '    import_alias,\\n', '    from_import_alias,\\n', '    class_name,\\n', '    function_name,\\n', '    method_name,\\n', '    function_argument,\\n', '    method_argument,\\n', '    function_keyword_argument,\\n', '    method_keyword_argument,\\n', '    function_args_argument,\\n', '    function_kwargs_argument,\\n', '    method_args_argument,\\n', '    method_kwargs_argument,\\n', '    function_kwonly_argument,\\n', '    function_kwonly_default_argument,\\n', '    method_kwonly_argument,\\n', '    lambda_argument,\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '    instance_attribute,\\n', '    instance_typed_attribute,\\n', '    variable_def,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    unpacking_variables,\\n', '    unpacking_star_variables,\\n', '    for_variable,\\n', '    for_star_variable,\\n', '    with_variable,\\n', '    with_star_variable,\\n', '    exception,\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    for_variable,\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    exception,\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '    for_variable,\\n', '@pytest.fixture(params=_ALL_FIXTURES)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_PROTECTED_UNUSED)\\n']",
  "context": "pt Exception as {0}:\n    raise\n\"\"\"\n\n\n# Fixtures:\n\n_ALL_FIXTURES = frozenset((\n    # Imports:\n    import_alias,\n    from_import_a"
 },
 "442": {
  "name": "_ALL_FIXTURES",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/conftest.py",
  "lineno": "204",
  "column": "4",
  "slicing": "['    _ALL_FIXTURES |= {\\n', '@pytest.fixture(params=_ALL_FIXTURES)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_PROTECTED_UNUSED)\\n']",
  "context": "th_star_variable,\n    exception,\n))\n\nif PY38:\n    _ALL_FIXTURES |= {\n        function_posonly_argument,\n        lambda_"
 },
 "443": {
  "name": "_FORBIDDEN_UNUSED_TUPLE",
  "type": "frozenset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/conftest.py",
  "lineno": "210",
  "column": "0",
  "slicing": "['import_alias = \"\"\"\\n', 'from_import_alias = \"\"\"\\n', \"class_name = 'class {0}: ...'\\n\", \"function_name = 'def {0}(): ...'\\n\", 'method_name = \"\"\"\\n', \"function_argument = 'def test(arg, {0}): ...'\\n\", 'method_argument = \"\"\"\\n', \"function_keyword_argument = 'def test(arg, {0}=None): ...'\\n\", 'method_keyword_argument = \"\"\"\\n', \"function_args_argument = 'def test(arg, *{0}): ...'\\n\", \"function_kwargs_argument = 'def test(arg, **{0}): ...'\\n\", 'method_args_argument = \"\"\"\\n', 'method_kwargs_argument = \"\"\"\\n', 'function_posonly_argument = \"\"\"\\n', 'function_kwonly_argument = \"\"\"\\n', 'function_kwonly_default_argument = \"\"\"\\n', 'method_kwonly_argument = \"\"\"\\n', \"lambda_argument = 'lambda {0}: ...'\\n\", \"lambda_posonly_argument = 'lambda {0}, /: ...'\\n\", 'static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_annotation = \"\"\"\\n', 'instance_attribute = \"\"\"\\n', 'instance_typed_attribute = \"\"\"\\n', \"variable_def = '{0} = 1'\\n\", \"variable_typed_def = '{0}: int = 2'\\n\", \"variable_typed = '{0}: str'\\n\", \"assignment_expression = '({0} := 1)'\\n\", 'unpacking_variables = \"\"\"\\n', 'unpacking_star_variables = \"\"\"\\n', 'for_variable = \"\"\"\\n', 'for_star_variable = \"\"\"\\n', 'with_variable = \"\"\"\\n', 'with_star_variable = \"\"\"\\n', 'exception = \"\"\"\\n', '    import_alias,\\n', '    from_import_alias,\\n', '    class_name,\\n', '    function_name,\\n', '    method_name,\\n', '    function_argument,\\n', '    method_argument,\\n', '    function_keyword_argument,\\n', '    method_keyword_argument,\\n', '    function_args_argument,\\n', '    function_kwargs_argument,\\n', '    method_args_argument,\\n', '    method_kwargs_argument,\\n', '    function_kwonly_argument,\\n', '    function_kwonly_default_argument,\\n', '    method_kwonly_argument,\\n', '    lambda_argument,\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '    instance_attribute,\\n', '    instance_typed_attribute,\\n', '    variable_def,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    unpacking_variables,\\n', '    unpacking_star_variables,\\n', '    for_variable,\\n', '    for_star_variable,\\n', '    with_variable,\\n', '    with_star_variable,\\n', '    exception,\\n', '        function_posonly_argument,\\n', '        lambda_posonly_argument,\\n', '        assignment_expression,\\n', '_FORBIDDEN_UNUSED_TUPLE = frozenset((\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    for_variable,\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    exception,\\n', '        assignment_expression,\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '    for_variable,\\n', '@pytest.fixture(params=_FORBIDDEN_UNUSED_TUPLE)\\n']",
  "context": "y_argument,\n        assignment_expression,\n    }\n\n_FORBIDDEN_UNUSED_TUPLE = frozenset((\n    unpacking_variables,\n    variable_def,\n    wit"
 },
 "444": {
  "name": "_FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED",
  "type": "frozenset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/conftest.py",
  "lineno": "221",
  "column": "0",
  "slicing": "['import_alias = \"\"\"\\n', 'from_import_alias = \"\"\"\\n', \"class_name = 'class {0}: ...'\\n\", \"function_name = 'def {0}(): ...'\\n\", 'method_name = \"\"\"\\n', \"function_argument = 'def test(arg, {0}): ...'\\n\", 'method_argument = \"\"\"\\n', \"function_keyword_argument = 'def test(arg, {0}=None): ...'\\n\", 'method_keyword_argument = \"\"\"\\n', \"function_args_argument = 'def test(arg, *{0}): ...'\\n\", \"function_kwargs_argument = 'def test(arg, **{0}): ...'\\n\", 'method_args_argument = \"\"\"\\n', 'method_kwargs_argument = \"\"\"\\n', 'function_posonly_argument = \"\"\"\\n', 'function_kwonly_argument = \"\"\"\\n', 'function_kwonly_default_argument = \"\"\"\\n', 'method_kwonly_argument = \"\"\"\\n', \"lambda_argument = 'lambda {0}: ...'\\n\", \"lambda_posonly_argument = 'lambda {0}, /: ...'\\n\", 'static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_annotation = \"\"\"\\n', 'instance_attribute = \"\"\"\\n', 'instance_typed_attribute = \"\"\"\\n', \"variable_def = '{0} = 1'\\n\", \"variable_typed_def = '{0}: int = 2'\\n\", \"variable_typed = '{0}: str'\\n\", \"assignment_expression = '({0} := 1)'\\n\", 'unpacking_variables = \"\"\"\\n', 'unpacking_star_variables = \"\"\"\\n', 'for_variable = \"\"\"\\n', 'for_star_variable = \"\"\"\\n', 'with_variable = \"\"\"\\n', 'with_star_variable = \"\"\"\\n', 'exception = \"\"\"\\n', '    import_alias,\\n', '    from_import_alias,\\n', '    class_name,\\n', '    function_name,\\n', '    method_name,\\n', '    function_argument,\\n', '    method_argument,\\n', '    function_keyword_argument,\\n', '    method_keyword_argument,\\n', '    function_args_argument,\\n', '    function_kwargs_argument,\\n', '    method_args_argument,\\n', '    method_kwargs_argument,\\n', '    function_kwonly_argument,\\n', '    function_kwonly_default_argument,\\n', '    method_kwonly_argument,\\n', '    lambda_argument,\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '    instance_attribute,\\n', '    instance_typed_attribute,\\n', '    variable_def,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    unpacking_variables,\\n', '    unpacking_star_variables,\\n', '    for_variable,\\n', '    for_star_variable,\\n', '    with_variable,\\n', '    with_star_variable,\\n', '    exception,\\n', '        function_posonly_argument,\\n', '        lambda_posonly_argument,\\n', '        assignment_expression,\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    for_variable,\\n', '_FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED = frozenset((\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    exception,\\n', '    _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED |= {\\n', '        assignment_expression,\\n', '_FORBIDDEN_RAW_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '_FORBIDDEN_PROTECTED_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\\n', '    for_variable,\\n', '@pytest.fixture(params=_FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_FORBIDDEN_PROTECTED_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_PROTECTED_UNUSED)\\n']",
  "context": "ing.access.is_protected().\n# Example: _protected.\n_FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED = frozenset((\n    unpacking_variables,\n    variable_def,\n    wit"
 },
 "445": {
  "name": "_FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/conftest.py",
  "lineno": "231",
  "column": "4",
  "slicing": "['import_alias = \"\"\"\\n', 'from_import_alias = \"\"\"\\n', \"class_name = 'class {0}: ...'\\n\", \"function_name = 'def {0}(): ...'\\n\", 'method_name = \"\"\"\\n', \"function_argument = 'def test(arg, {0}): ...'\\n\", 'method_argument = \"\"\"\\n', \"function_keyword_argument = 'def test(arg, {0}=None): ...'\\n\", 'method_keyword_argument = \"\"\"\\n', \"function_args_argument = 'def test(arg, *{0}): ...'\\n\", \"function_kwargs_argument = 'def test(arg, **{0}): ...'\\n\", 'method_args_argument = \"\"\"\\n', 'method_kwargs_argument = \"\"\"\\n', 'function_posonly_argument = \"\"\"\\n', 'function_kwonly_argument = \"\"\"\\n', 'function_kwonly_default_argument = \"\"\"\\n', 'method_kwonly_argument = \"\"\"\\n', \"lambda_argument = 'lambda {0}: ...'\\n\", \"lambda_posonly_argument = 'lambda {0}, /: ...'\\n\", 'static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_annotation = \"\"\"\\n', 'instance_attribute = \"\"\"\\n', 'instance_typed_attribute = \"\"\"\\n', \"variable_def = '{0} = 1'\\n\", \"variable_typed_def = '{0}: int = 2'\\n\", \"variable_typed = '{0}: str'\\n\", \"assignment_expression = '({0} := 1)'\\n\", 'unpacking_variables = \"\"\"\\n', 'unpacking_star_variables = \"\"\"\\n', 'for_variable = \"\"\"\\n', 'for_star_variable = \"\"\"\\n', 'with_variable = \"\"\"\\n', 'with_star_variable = \"\"\"\\n', 'exception = \"\"\"\\n', '    import_alias,\\n', '    from_import_alias,\\n', '    class_name,\\n', '    function_name,\\n', '    method_name,\\n', '    function_argument,\\n', '    method_argument,\\n', '    function_keyword_argument,\\n', '    method_keyword_argument,\\n', '    function_args_argument,\\n', '    function_kwargs_argument,\\n', '    method_args_argument,\\n', '    method_kwargs_argument,\\n', '    function_kwonly_argument,\\n', '    function_kwonly_default_argument,\\n', '    method_kwonly_argument,\\n', '    lambda_argument,\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '    instance_attribute,\\n', '    instance_typed_attribute,\\n', '    variable_def,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    unpacking_variables,\\n', '    unpacking_star_variables,\\n', '    for_variable,\\n', '    for_star_variable,\\n', '    with_variable,\\n', '    with_star_variable,\\n', '    exception,\\n', '        function_posonly_argument,\\n', '        lambda_posonly_argument,\\n', '        assignment_expression,\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    for_variable,\\n', '_FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED = frozenset((\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    exception,\\n', '    _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED |= {\\n', '        assignment_expression,\\n', '_FORBIDDEN_RAW_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '_FORBIDDEN_PROTECTED_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\\n', '    for_variable,\\n', '@pytest.fixture(params=_FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_FORBIDDEN_PROTECTED_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_PROTECTED_UNUSED)\\n']",
  "context": "  variable_typed,\n    exception,\n))\n\nif PY38:\n    _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED |= {\n        assignment_expression,\n    }\n\n_FORBIDDEN_R"
 },
 "446": {
  "name": "_FORBIDDEN_RAW_UNUSED",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/conftest.py",
  "lineno": "235",
  "column": "0",
  "slicing": "['import_alias = \"\"\"\\n', 'from_import_alias = \"\"\"\\n', \"class_name = 'class {0}: ...'\\n\", \"function_name = 'def {0}(): ...'\\n\", 'method_name = \"\"\"\\n', \"function_argument = 'def test(arg, {0}): ...'\\n\", 'method_argument = \"\"\"\\n', \"function_keyword_argument = 'def test(arg, {0}=None): ...'\\n\", 'method_keyword_argument = \"\"\"\\n', \"function_args_argument = 'def test(arg, *{0}): ...'\\n\", \"function_kwargs_argument = 'def test(arg, **{0}): ...'\\n\", 'method_args_argument = \"\"\"\\n', 'method_kwargs_argument = \"\"\"\\n', 'function_posonly_argument = \"\"\"\\n', 'function_kwonly_argument = \"\"\"\\n', 'function_kwonly_default_argument = \"\"\"\\n', 'method_kwonly_argument = \"\"\"\\n', \"lambda_argument = 'lambda {0}: ...'\\n\", \"lambda_posonly_argument = 'lambda {0}, /: ...'\\n\", 'static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_annotation = \"\"\"\\n', 'instance_attribute = \"\"\"\\n', 'instance_typed_attribute = \"\"\"\\n', \"variable_def = '{0} = 1'\\n\", \"variable_typed_def = '{0}: int = 2'\\n\", \"variable_typed = '{0}: str'\\n\", \"assignment_expression = '({0} := 1)'\\n\", 'unpacking_variables = \"\"\"\\n', 'unpacking_star_variables = \"\"\"\\n', 'for_variable = \"\"\"\\n', 'for_star_variable = \"\"\"\\n', 'with_variable = \"\"\"\\n', 'with_star_variable = \"\"\"\\n', 'exception = \"\"\"\\n', '    import_alias,\\n', '    from_import_alias,\\n', '    class_name,\\n', '    function_name,\\n', '    method_name,\\n', '    function_argument,\\n', '    method_argument,\\n', '    function_keyword_argument,\\n', '    method_keyword_argument,\\n', '    function_args_argument,\\n', '    function_kwargs_argument,\\n', '    method_args_argument,\\n', '    method_kwargs_argument,\\n', '    function_kwonly_argument,\\n', '    function_kwonly_default_argument,\\n', '    method_kwonly_argument,\\n', '    lambda_argument,\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '    instance_attribute,\\n', '    instance_typed_attribute,\\n', '    variable_def,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    unpacking_variables,\\n', '    unpacking_star_variables,\\n', '    for_variable,\\n', '    for_star_variable,\\n', '    with_variable,\\n', '    with_star_variable,\\n', '    exception,\\n', '        function_posonly_argument,\\n', '        lambda_posonly_argument,\\n', '        assignment_expression,\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    for_variable,\\n', '_FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED = frozenset((\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    exception,\\n', '    _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED |= {\\n', '        assignment_expression,\\n', '_FORBIDDEN_RAW_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '_FORBIDDEN_PROTECTED_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\\n', '    for_variable,\\n', '@pytest.fixture(params=_FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_FORBIDDEN_PROTECTED_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_PROTECTED_UNUSED)\\n']",
  "context": "UNUSED |= {\n        assignment_expression,\n    }\n\n_FORBIDDEN_RAW_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\n    static_attribute,\n    static_typed_attribute,\n"
 },
 "447": {
  "name": "_FORBIDDEN_PROTECTED_UNUSED",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/conftest.py",
  "lineno": "241",
  "column": "0",
  "slicing": "['import_alias = \"\"\"\\n', 'from_import_alias = \"\"\"\\n', \"class_name = 'class {0}: ...'\\n\", \"function_name = 'def {0}(): ...'\\n\", 'method_name = \"\"\"\\n', \"function_argument = 'def test(arg, {0}): ...'\\n\", 'method_argument = \"\"\"\\n', \"function_keyword_argument = 'def test(arg, {0}=None): ...'\\n\", 'method_keyword_argument = \"\"\"\\n', \"function_args_argument = 'def test(arg, *{0}): ...'\\n\", \"function_kwargs_argument = 'def test(arg, **{0}): ...'\\n\", 'method_args_argument = \"\"\"\\n', 'method_kwargs_argument = \"\"\"\\n', 'function_posonly_argument = \"\"\"\\n', 'function_kwonly_argument = \"\"\"\\n', 'function_kwonly_default_argument = \"\"\"\\n', 'method_kwonly_argument = \"\"\"\\n', \"lambda_argument = 'lambda {0}: ...'\\n\", \"lambda_posonly_argument = 'lambda {0}, /: ...'\\n\", 'static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_annotation = \"\"\"\\n', 'instance_attribute = \"\"\"\\n', 'instance_typed_attribute = \"\"\"\\n', \"variable_def = '{0} = 1'\\n\", \"variable_typed_def = '{0}: int = 2'\\n\", \"variable_typed = '{0}: str'\\n\", \"assignment_expression = '({0} := 1)'\\n\", 'unpacking_variables = \"\"\"\\n', 'unpacking_star_variables = \"\"\"\\n', 'for_variable = \"\"\"\\n', 'for_star_variable = \"\"\"\\n', 'with_variable = \"\"\"\\n', 'with_star_variable = \"\"\"\\n', 'exception = \"\"\"\\n', '    import_alias,\\n', '    from_import_alias,\\n', '    class_name,\\n', '    function_name,\\n', '    method_name,\\n', '    function_argument,\\n', '    method_argument,\\n', '    function_keyword_argument,\\n', '    method_keyword_argument,\\n', '    function_args_argument,\\n', '    function_kwargs_argument,\\n', '    method_args_argument,\\n', '    method_kwargs_argument,\\n', '    function_kwonly_argument,\\n', '    function_kwonly_default_argument,\\n', '    method_kwonly_argument,\\n', '    lambda_argument,\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '    instance_attribute,\\n', '    instance_typed_attribute,\\n', '    variable_def,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    unpacking_variables,\\n', '    unpacking_star_variables,\\n', '    for_variable,\\n', '    for_star_variable,\\n', '    with_variable,\\n', '    with_star_variable,\\n', '    exception,\\n', '        function_posonly_argument,\\n', '        lambda_posonly_argument,\\n', '        assignment_expression,\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    for_variable,\\n', '_FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED = frozenset((\\n', '    unpacking_variables,\\n', '    variable_def,\\n', '    with_variable,\\n', '    variable_typed_def,\\n', '    variable_typed,\\n', '    exception,\\n', '    _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED |= {\\n', '        assignment_expression,\\n', '_FORBIDDEN_RAW_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_annotation,\\n', '_FORBIDDEN_PROTECTED_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\\n', '    for_variable,\\n', '@pytest.fixture(params=_FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_RAW_UNUSED)\\n', '@pytest.fixture(params=_FORBIDDEN_PROTECTED_UNUSED)\\n', '@pytest.fixture(params=_ALL_FIXTURES - _FORBIDDEN_PROTECTED_UNUSED)\\n']",
  "context": "_typed_attribute,\n    static_typed_annotation,\n}\n\n_FORBIDDEN_PROTECTED_UNUSED = _FORBIDDEN_BOTH_RAW_AND_PROTECTED_UNUSED | {\n    for_variable,\n}\n\n\n@pytest.fixture(params=_ALL_"
 },
 "448": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_class_attributes.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_condition_attribute = \"\"\"\\n', 'regression423 = \"\"\"\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(non_snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UpperCaseAttributeViolation])\\n', '    assert_error_text(visitor, non_snake_case_name)\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(regression423)\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat attribute cannot have too short names.\"\"\"\n    tree = parse_ast_tree(code.format(non_snake_case_name))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "449": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_class_attributes.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_condition_attribute = \"\"\"\\n', 'regression423 = \"\"\"\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(non_snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UpperCaseAttributeViolation])\\n', '    assert_error_text(visitor, non_snake_case_name)\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(regression423)\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e_ast_tree(code.format(non_snake_case_name))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Upp"
 },
 "450": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_class_attributes.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_condition_attribute = \"\"\"\\n', 'regression423 = \"\"\"\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(non_snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UpperCaseAttributeViolation])\\n', '    assert_error_text(visitor, non_snake_case_name)\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(regression423)\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat attribute cannot have too short names.\"\"\"\n    tree = parse_ast_tree(code.format(snake_case_name))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "451": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_class_attributes.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_condition_attribute = \"\"\"\\n', 'regression423 = \"\"\"\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(non_snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UpperCaseAttributeViolation])\\n', '    assert_error_text(visitor, non_snake_case_name)\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(regression423)\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(code.format(snake_case_name))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "452": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_class_attributes.py",
  "lineno": "104",
  "column": "4",
  "slicing": "['static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_condition_attribute = \"\"\"\\n', 'regression423 = \"\"\"\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(non_snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UpperCaseAttributeViolation])\\n', '    assert_error_text(visitor, non_snake_case_name)\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(regression423)\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s/wemake-python-styleguide/issues/423\n    \"\"\"\n    tree = parse_ast_tree(regression423)\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "453": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_class_attributes.py",
  "lineno": "106",
  "column": "4",
  "slicing": "['static_attribute = \"\"\"\\n', 'static_typed_attribute = \"\"\"\\n', 'static_typed_condition_attribute = \"\"\"\\n', 'regression423 = \"\"\"\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(non_snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UpperCaseAttributeViolation])\\n', '    assert_error_text(visitor, non_snake_case_name)\\n', '    static_attribute,\\n', '    static_typed_attribute,\\n', '    static_typed_condition_attribute,\\n', '    tree = parse_ast_tree(code.format(snake_case_name))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(regression423)\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"\n    tree = parse_ast_tree(regression423)\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "454": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_variable_self_reassignment.py",
  "lineno": "157",
  "column": "4",
  "slicing": "['wrong_fragment = \"\"\"\\n', 'wrong_typed_fragment = \"\"\"\\n', 'wrong_partial_typed_fragment1 = \"\"\"\\n', 'wrong_partial_typed_fragment2 = \"\"\"\\n', 'wrong_fragment_double_assignment = \"\"\"\\n', 'wrong_fragment_double_typed_assignment = \"\"\"\\n', 'wrong_fragment_other_assignment = \"\"\"\\n', 'wrong_fragment_typed_other_assignment = \"\"\"\\n', 'wrong_fragment_mixed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_multiple_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_multiple_assignment = \"\"\"\\n', '    wrong_fragment,\\n', '    wrong_typed_fragment,\\n', '    wrong_partial_typed_fragment1,\\n', '    wrong_partial_typed_fragment2,\\n', '    wrong_fragment_double_assignment,\\n', '    wrong_fragment_double_typed_assignment,\\n', '    wrong_fragment_other_assignment,\\n', '    wrong_fragment_typed_other_assignment,\\n', '    wrong_fragment_mixed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReassigningVariableToItselfViolation])\\n', '    wrong_fragment_tuple_assignment,\\n', '    wrong_fragment_typed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    wrong_fragment_multiple_tuple_assignment,\\n', '    wrong_fragment_typed_multiple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " self variable reassignment is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongVariableAssignmentVisitor(defa"
 },
 "455": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongVariableAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_variable_self_reassignment.py",
  "lineno": "159",
  "column": "4",
  "slicing": "['wrong_fragment = \"\"\"\\n', 'wrong_typed_fragment = \"\"\"\\n', 'wrong_partial_typed_fragment1 = \"\"\"\\n', 'wrong_partial_typed_fragment2 = \"\"\"\\n', 'wrong_fragment_double_assignment = \"\"\"\\n', 'wrong_fragment_double_typed_assignment = \"\"\"\\n', 'wrong_fragment_other_assignment = \"\"\"\\n', 'wrong_fragment_typed_other_assignment = \"\"\"\\n', 'wrong_fragment_mixed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_multiple_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_multiple_assignment = \"\"\"\\n', '    wrong_fragment,\\n', '    wrong_typed_fragment,\\n', '    wrong_partial_typed_fragment1,\\n', '    wrong_partial_typed_fragment2,\\n', '    wrong_fragment_double_assignment,\\n', '    wrong_fragment_double_typed_assignment,\\n', '    wrong_fragment_other_assignment,\\n', '    wrong_fragment_typed_other_assignment,\\n', '    wrong_fragment_mixed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReassigningVariableToItselfViolation])\\n', '    wrong_fragment_tuple_assignment,\\n', '    wrong_fragment_typed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    wrong_fragment_multiple_tuple_assignment,\\n', '    wrong_fragment_typed_multiple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Rea"
 },
 "456": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_variable_self_reassignment.py",
  "lineno": "176",
  "column": "4",
  "slicing": "['wrong_fragment = \"\"\"\\n', 'wrong_typed_fragment = \"\"\"\\n', 'wrong_partial_typed_fragment1 = \"\"\"\\n', 'wrong_partial_typed_fragment2 = \"\"\"\\n', 'wrong_fragment_double_assignment = \"\"\"\\n', 'wrong_fragment_double_typed_assignment = \"\"\"\\n', 'wrong_fragment_other_assignment = \"\"\"\\n', 'wrong_fragment_typed_other_assignment = \"\"\"\\n', 'wrong_fragment_mixed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_multiple_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_multiple_assignment = \"\"\"\\n', '    wrong_fragment,\\n', '    wrong_typed_fragment,\\n', '    wrong_partial_typed_fragment1,\\n', '    wrong_partial_typed_fragment2,\\n', '    wrong_fragment_double_assignment,\\n', '    wrong_fragment_double_typed_assignment,\\n', '    wrong_fragment_other_assignment,\\n', '    wrong_fragment_typed_other_assignment,\\n', '    wrong_fragment_mixed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReassigningVariableToItselfViolation])\\n', '    wrong_fragment_tuple_assignment,\\n', '    wrong_fragment_typed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    wrong_fragment_multiple_tuple_assignment,\\n', '    wrong_fragment_typed_multiple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " self variable reassignment is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongVariableAssignmentVisitor(defa"
 },
 "457": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongVariableAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_variable_self_reassignment.py",
  "lineno": "178",
  "column": "4",
  "slicing": "['wrong_fragment = \"\"\"\\n', 'wrong_typed_fragment = \"\"\"\\n', 'wrong_partial_typed_fragment1 = \"\"\"\\n', 'wrong_partial_typed_fragment2 = \"\"\"\\n', 'wrong_fragment_double_assignment = \"\"\"\\n', 'wrong_fragment_double_typed_assignment = \"\"\"\\n', 'wrong_fragment_other_assignment = \"\"\"\\n', 'wrong_fragment_typed_other_assignment = \"\"\"\\n', 'wrong_fragment_mixed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_multiple_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_multiple_assignment = \"\"\"\\n', '    wrong_fragment,\\n', '    wrong_typed_fragment,\\n', '    wrong_partial_typed_fragment1,\\n', '    wrong_partial_typed_fragment2,\\n', '    wrong_fragment_double_assignment,\\n', '    wrong_fragment_double_typed_assignment,\\n', '    wrong_fragment_other_assignment,\\n', '    wrong_fragment_typed_other_assignment,\\n', '    wrong_fragment_mixed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReassigningVariableToItselfViolation])\\n', '    wrong_fragment_tuple_assignment,\\n', '    wrong_fragment_typed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    wrong_fragment_multiple_tuple_assignment,\\n', '    wrong_fragment_typed_multiple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "458": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_variable_self_reassignment.py",
  "lineno": "198",
  "column": "4",
  "slicing": "['wrong_fragment = \"\"\"\\n', 'wrong_typed_fragment = \"\"\"\\n', 'wrong_partial_typed_fragment1 = \"\"\"\\n', 'wrong_partial_typed_fragment2 = \"\"\"\\n', 'wrong_fragment_double_assignment = \"\"\"\\n', 'wrong_fragment_double_typed_assignment = \"\"\"\\n', 'wrong_fragment_other_assignment = \"\"\"\\n', 'wrong_fragment_typed_other_assignment = \"\"\"\\n', 'wrong_fragment_mixed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_multiple_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_multiple_assignment = \"\"\"\\n', '    wrong_fragment,\\n', '    wrong_typed_fragment,\\n', '    wrong_partial_typed_fragment1,\\n', '    wrong_partial_typed_fragment2,\\n', '    wrong_fragment_double_assignment,\\n', '    wrong_fragment_double_typed_assignment,\\n', '    wrong_fragment_other_assignment,\\n', '    wrong_fragment_typed_other_assignment,\\n', '    wrong_fragment_mixed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReassigningVariableToItselfViolation])\\n', '    wrong_fragment_tuple_assignment,\\n', '    wrong_fragment_typed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    wrong_fragment_multiple_tuple_assignment,\\n', '    wrong_fragment_typed_multiple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " self variable reassignment is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongVariableAssignmentVisitor(defa"
 },
 "459": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongVariableAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_variable_self_reassignment.py",
  "lineno": "200",
  "column": "4",
  "slicing": "['wrong_fragment = \"\"\"\\n', 'wrong_typed_fragment = \"\"\"\\n', 'wrong_partial_typed_fragment1 = \"\"\"\\n', 'wrong_partial_typed_fragment2 = \"\"\"\\n', 'wrong_fragment_double_assignment = \"\"\"\\n', 'wrong_fragment_double_typed_assignment = \"\"\"\\n', 'wrong_fragment_other_assignment = \"\"\"\\n', 'wrong_fragment_typed_other_assignment = \"\"\"\\n', 'wrong_fragment_mixed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_multiple_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_multiple_assignment = \"\"\"\\n', '    wrong_fragment,\\n', '    wrong_typed_fragment,\\n', '    wrong_partial_typed_fragment1,\\n', '    wrong_partial_typed_fragment2,\\n', '    wrong_fragment_double_assignment,\\n', '    wrong_fragment_double_typed_assignment,\\n', '    wrong_fragment_other_assignment,\\n', '    wrong_fragment_typed_other_assignment,\\n', '    wrong_fragment_mixed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReassigningVariableToItselfViolation])\\n', '    wrong_fragment_tuple_assignment,\\n', '    wrong_fragment_typed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    wrong_fragment_multiple_tuple_assignment,\\n', '    wrong_fragment_typed_multiple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "460": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_variable_self_reassignment.py",
  "lineno": "227",
  "column": "4",
  "slicing": "['wrong_fragment = \"\"\"\\n', 'wrong_typed_fragment = \"\"\"\\n', 'wrong_partial_typed_fragment1 = \"\"\"\\n', 'wrong_partial_typed_fragment2 = \"\"\"\\n', 'wrong_fragment_double_assignment = \"\"\"\\n', 'wrong_fragment_double_typed_assignment = \"\"\"\\n', 'wrong_fragment_other_assignment = \"\"\"\\n', 'wrong_fragment_typed_other_assignment = \"\"\"\\n', 'wrong_fragment_mixed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_multiple_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_multiple_assignment = \"\"\"\\n', '    wrong_fragment,\\n', '    wrong_typed_fragment,\\n', '    wrong_partial_typed_fragment1,\\n', '    wrong_partial_typed_fragment2,\\n', '    wrong_fragment_double_assignment,\\n', '    wrong_fragment_double_typed_assignment,\\n', '    wrong_fragment_other_assignment,\\n', '    wrong_fragment_typed_other_assignment,\\n', '    wrong_fragment_mixed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReassigningVariableToItselfViolation])\\n', '    wrong_fragment_tuple_assignment,\\n', '    wrong_fragment_typed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    wrong_fragment_multiple_tuple_assignment,\\n', '    wrong_fragment_typed_multiple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing that we can do normal variable.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongVariableAssignmentVisitor(defa"
 },
 "461": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongVariableAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_variable_self_reassignment.py",
  "lineno": "229",
  "column": "4",
  "slicing": "['wrong_fragment = \"\"\"\\n', 'wrong_typed_fragment = \"\"\"\\n', 'wrong_partial_typed_fragment1 = \"\"\"\\n', 'wrong_partial_typed_fragment2 = \"\"\"\\n', 'wrong_fragment_double_assignment = \"\"\"\\n', 'wrong_fragment_double_typed_assignment = \"\"\"\\n', 'wrong_fragment_other_assignment = \"\"\"\\n', 'wrong_fragment_typed_other_assignment = \"\"\"\\n', 'wrong_fragment_mixed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_tuple_assignment = \"\"\"\\n', 'wrong_fragment_multiple_tuple_assignment = \"\"\"\\n', 'wrong_fragment_typed_multiple_assignment = \"\"\"\\n', '    wrong_fragment,\\n', '    wrong_typed_fragment,\\n', '    wrong_partial_typed_fragment1,\\n', '    wrong_partial_typed_fragment2,\\n', '    wrong_fragment_double_assignment,\\n', '    wrong_fragment_double_typed_assignment,\\n', '    wrong_fragment_other_assignment,\\n', '    wrong_fragment_typed_other_assignment,\\n', '    wrong_fragment_mixed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ReassigningVariableToItselfViolation])\\n', '    wrong_fragment_tuple_assignment,\\n', '    wrong_fragment_typed_tuple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    wrong_fragment_multiple_tuple_assignment,\\n', '    wrong_fragment_typed_multiple_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "variable.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongVariableAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "462": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_first_arguments.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"Testing that first arguments are allowed.\"\"\"\n    tree = parse_ast_tree(mode(code.format(argument)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "463": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_first_arguments.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code.format(argument)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(mode(code.format(argument)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "464": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_names.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, wrong_name, multiple=True)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, forbidden_name)\\n']",
  "context": "g names are not allowed, case insensitive.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "465": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_names.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, wrong_name, multiple=True)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, forbidden_name)\\n']",
  "context": "ee(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "466": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_names.py",
  "lineno": "54",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, wrong_name, multiple=True)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, forbidden_name)\\n']",
  "context": "\"Ensures that wrong names are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "467": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_names.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, wrong_name, multiple=True)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, forbidden_name)\\n']",
  "context": "ee(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "468": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_names.py",
  "lineno": "77",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, wrong_name, multiple=True)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(forbidden_name)))\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, forbidden_name)\\n']",
  "context": "in `forbidden-domain-names` are forbidden.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(forbidden_name)))\n\n    visitor = WrongNameVisitor(\n        options(f"
 },
 "469": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_names.py",
  "lineno": "79",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, wrong_name, multiple=True)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(forbidden_name)))\\n', '    visitor = WrongNameVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongVariableNameViolation])\\n', '    assert_error_text(visitor, forbidden_name)\\n']",
  "context": "ode(naming_template.format(forbidden_name)))\n\n    visitor = WrongNameVisitor(\n        options(forbidden_domain_names=(forbidden_"
 },
 "470": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_redability.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreadableNameViolation])\\n', '    assert_error_text(visitor, unreadable)\\n']",
  "context": "res that unreadable names are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(code.format(expression, expression)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "471": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_redability.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreadableNameViolation])\\n', '    assert_error_text(visitor, unreadable)\\n']",
  "context": "e(mode(code.format(expression, expression)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    unreadable = get_unreadable"
 },
 "472": {
  "name": "unreadable",
  "type": "wemake_python_styleguide.logic.naming.alphabet.get_unreadable_characters",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_redability.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    unreadable = get_unreadable_characters(\\n', '    assert_errors(visitor, [UnreadableNameViolation])\\n', '    assert_error_text(visitor, unreadable)\\n']",
  "context": "efault_options, tree=tree)\n    visitor.run()\n\n    unreadable = get_unreadable_characters(\n        expression, constants.UNREADABLE_CHARACTER"
 },
 "473": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_unused_name.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnusedVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"Ensures that wrong names are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "474": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_unused_name.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnusedVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "475": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_unused_name.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnusedVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"Ensures that wrong names are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "476": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_wrong_unused_name.py",
  "lineno": "46",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnusedVariableNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "477": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_underscored_number.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(number_suffix)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnderscoredNumberNameViolation])\\n', '    assert_error_text(visitor, number_suffix)\\n']",
  "context": " that number suffix names are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(number_suffix)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "478": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_underscored_number.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(number_suffix)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnderscoredNumberNameViolation])\\n', '    assert_error_text(visitor, number_suffix)\\n']",
  "context": "mode(naming_template.format(number_suffix)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Und"
 },
 "479": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_short.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, default_options.min_name_length)\\n', '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation], (\\n', \"    short_name = 'xy'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    option_values = options(min_name_length=3)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, option_values.min_name_length)\\n']",
  "context": "\"Ensures that short names are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(short_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "480": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_short.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, default_options.min_name_length)\\n', '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation], (\\n', \"    short_name = 'xy'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    option_values = options(min_name_length=3)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, option_values.min_name_length)\\n']",
  "context": "ee(mode(naming_template.format(short_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "481": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_short.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, default_options.min_name_length)\\n', '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation], (\\n', \"    short_name = 'xy'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    option_values = options(min_name_length=3)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, option_values.min_name_length)\\n']",
  "context": "\"Ensures that short names are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(short_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "482": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_short.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, default_options.min_name_length)\\n', '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation], (\\n', \"    short_name = 'xy'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    option_values = options(min_name_length=3)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, option_values.min_name_length)\\n']",
  "context": "ee(mode(naming_template.format(short_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "483": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_short.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, default_options.min_name_length)\\n', '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation], (\\n', \"    short_name = 'xy'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    option_values = options(min_name_length=3)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, option_values.min_name_length)\\n']",
  "context": "t names are allowed.\"\"\"\n    short_name = 'xy'\n    tree = parse_ast_tree(mode(naming_template.format(short_name)))\n\n    option_values = options(min_name_length=3)\n  "
 },
 "484": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_short.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, default_options.min_name_length)\\n', '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation], (\\n', \"    short_name = 'xy'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    option_values = options(min_name_length=3)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, option_values.min_name_length)\\n']",
  "context": "ee(mode(naming_template.format(short_name)))\n\n    option_values = options(min_name_length=3)\n    visitor = WrongNameVisitor(option_values, tree"
 },
 "485": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_short.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, default_options.min_name_length)\\n', '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation], (\\n', \"    short_name = 'xy'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(short_name)))\\n', '    option_values = options(min_name_length=3)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    assert_error_text(visitor, short_name, option_values.min_name_length)\\n']",
  "context": "   option_values = options(min_name_length=3)\n    visitor = WrongNameVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "486": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_unicode.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n']",
  "context": "g_name,\n):\n    \"\"\"Test names with unicode.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "487": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_unicode.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeNameViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n']",
  "context": "ee(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Uni"
 },
 "488": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_builtin_shadowing.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BuiltinShadowingViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n']",
  "context": "):\n    \"\"\"Test names that shadow builtins.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "489": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_builtin_shadowing.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BuiltinShadowingViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n']",
  "context": "ee(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Bui"
 },
 "490": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_trailing_underscore.py",
  "lineno": "19",
  "column": "4",
  "slicing": "[\"    wrong_name = 'my_variable_'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TrailingUnderscoreViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "derscores.\"\"\"\n    wrong_name = 'my_variable_'\n    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "491": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_trailing_underscore.py",
  "lineno": "21",
  "column": "4",
  "slicing": "[\"    wrong_name = 'my_variable_'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TrailingUnderscoreViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee(mode(naming_template.format(wrong_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Tra"
 },
 "492": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_trailing_underscore.py",
  "lineno": "43",
  "column": "4",
  "slicing": "[\"    wrong_name = 'my_variable_'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TrailingUnderscoreViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t names with correct trailing underscores.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "493": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_trailing_underscore.py",
  "lineno": "45",
  "column": "4",
  "slicing": "[\"    wrong_name = 'my_variable_'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(wrong_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TrailingUnderscoreViolation])\\n', '    assert_error_text(visitor, wrong_name)\\n', '    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "(mode(naming_template.format(correct_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "494": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_consecutive_underscore.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(underscored_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveUnderscoresInNameViolation])\\n', '    assert_error_text(visitor, underscored_name)\\n']",
  "context": "es that underscored names are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(underscored_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "495": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_consecutive_underscore.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(underscored_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveUnderscoresInNameViolation])\\n', '    assert_error_text(visitor, underscored_name)\\n']",
  "context": "e(naming_template.format(underscored_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Con"
 },
 "496": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_correct.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Ensures that correct names are allowed.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "497": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_correct.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "(mode(naming_template.format(correct_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "498": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_correct.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(naming_template.format(allowed_name)))\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ted in `allowed-domain-names` are allowed.\"\"\"\n    tree = parse_ast_tree(mode(naming_template.format(allowed_name)))\n\n    visitor = WrongNameVisitor(\n        options(a"
 },
 "499": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_correct.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(naming_template.format(correct_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(naming_template.format(allowed_name)))\\n', '    visitor = WrongNameVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "(mode(naming_template.format(allowed_name)))\n\n    visitor = WrongNameVisitor(\n        options(allowed_domain_names=(allowed_name"
 },
 "500": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_private.py",
  "lineno": "15",
  "column": "4",
  "slicing": "[\"    private_name = '__private'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(private_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PrivateNameViolation])\\n', '    assert_error_text(visitor, private_name)\\n']",
  "context": "ot allowed.\"\"\"\n    private_name = '__private'\n    tree = parse_ast_tree(mode(naming_template.format(private_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "501": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_private.py",
  "lineno": "17",
  "column": "4",
  "slicing": "[\"    private_name = '__private'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(private_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PrivateNameViolation])\\n', '    assert_error_text(visitor, private_name)\\n']",
  "context": "(mode(naming_template.format(private_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Pri"
 },
 "502": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_long.py",
  "lineno": "15",
  "column": "4",
  "slicing": "[\"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    assert_error_text(visitor, long_name, default_options.max_name_length)\\n', \"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    option_values = options(max_name_length=len(long_name) + 1)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "name_that_should_not_pass_the_long_name_test'\n    tree = parse_ast_tree(mode(naming_template.format(long_name)))\n\n    visitor = WrongNameVisitor(default_options, t"
 },
 "503": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_long.py",
  "lineno": "17",
  "column": "4",
  "slicing": "[\"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    assert_error_text(visitor, long_name, default_options.max_name_length)\\n', \"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    option_values = options(max_name_length=len(long_name) + 1)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree(mode(naming_template.format(long_name)))\n\n    visitor = WrongNameVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "504": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_long.py",
  "lineno": "33",
  "column": "4",
  "slicing": "[\"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    assert_error_text(visitor, long_name, default_options.max_name_length)\\n', \"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    option_values = options(max_name_length=len(long_name) + 1)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "name_that_should_not_pass_the_long_name_test'\n    tree = parse_ast_tree(mode(naming_template.format(long_name)))\n\n    option_values = options(max_name_length=len(l"
 },
 "505": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_long.py",
  "lineno": "35",
  "column": "4",
  "slicing": "[\"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    assert_error_text(visitor, long_name, default_options.max_name_length)\\n', \"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    option_values = options(max_name_length=len(long_name) + 1)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree(mode(naming_template.format(long_name)))\n\n    option_values = options(max_name_length=len(long_name) + 1)\n    visitor = WrongNameVisitor(option_values, tree"
 },
 "506": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.WrongNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_naming_rules/test_long.py",
  "lineno": "36",
  "column": "4",
  "slicing": "[\"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    visitor = WrongNameVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    assert_error_text(visitor, long_name, default_options.max_name_length)\\n', \"    long_name = 'incredibly_long_name_that_should_not_pass_the_long_name_test'\\n\", '    tree = parse_ast_tree(mode(naming_template.format(long_name)))\\n', '    option_values = options(max_name_length=len(long_name) + 1)\\n', '    visitor = WrongNameVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "= options(max_name_length=len(long_name) + 1)\n    visitor = WrongNameVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "507": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_variable_usages.py",
  "lineno": "103",
  "column": "4",
  "slicing": "[\"annotation = 'some_var: {0}'\\n\", \"annotation_value = 'some_var: {0} = None'\\n\", \"assigned = 'some_var = {0}'\\n\", \"assigned_attribute = '{0}.attribute = 1'\\n\", \"import_name = 'import {0}'\\n\", \"from_import_module = 'from {0} import some'\\n\", \"from_import_name = 'from some import {0}'\\n\", \"calling_function = 'print({0})'\\n\", \"calling_star_function = 'print(*{0})'\\n\", \"called_function = '{0}()'\\n\", \"calling_method = 'instance.call({0})'\\n\", \"called_method = 'instance.{0}()'\\n\", \"accessing_attribute = 'instance.{0}'\\n\", \"accessed_attribute = '{0}.attribute'\\n\", \"key_access = 'instance[{0}]'\\n\", \"list_definition = 'instance = [{0}, 1]'\\n\", \"raising_variable = 'raise {0}'\\n\", 'returning_variable = \"\"\"\\n', 'awaiting_variable = \"\"\"\\n', 'yielding_variable = \"\"\"\\n', \"inheriting_variables = 'class ValidName({0}): ...'\\n\", '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    import_name,\\n', '    from_import_module,\\n', '    from_import_name,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    called_method,\\n', '    accessing_attribute,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = visitor_class(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "iable can used without raising violations.\"\"\"\n    tree = parse_ast_tree(code.format(bad_name))\n\n    visitor = visitor_class(default_options, tree"
 },
 "508": {
  "name": "visitor",
  "type": "visitor_class",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_variable_usages.py",
  "lineno": "105",
  "column": "4",
  "slicing": "[\"annotation = 'some_var: {0}'\\n\", \"annotation_value = 'some_var: {0} = None'\\n\", \"assigned = 'some_var = {0}'\\n\", \"assigned_attribute = '{0}.attribute = 1'\\n\", \"import_name = 'import {0}'\\n\", \"from_import_module = 'from {0} import some'\\n\", \"from_import_name = 'from some import {0}'\\n\", \"calling_function = 'print({0})'\\n\", \"calling_star_function = 'print(*{0})'\\n\", \"called_function = '{0}()'\\n\", \"calling_method = 'instance.call({0})'\\n\", \"called_method = 'instance.{0}()'\\n\", \"accessing_attribute = 'instance.{0}'\\n\", \"accessed_attribute = '{0}.attribute'\\n\", \"key_access = 'instance[{0}]'\\n\", \"list_definition = 'instance = [{0}, 1]'\\n\", \"raising_variable = 'raise {0}'\\n\", 'returning_variable = \"\"\"\\n', 'awaiting_variable = \"\"\"\\n', 'yielding_variable = \"\"\"\\n', \"inheriting_variables = 'class ValidName({0}): ...'\\n\", '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    import_name,\\n', '    from_import_module,\\n', '    from_import_name,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    called_method,\\n', '    accessing_attribute,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = visitor_class(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(code.format(bad_name))\n\n    visitor = visitor_class(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "509": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_variable_usages.py",
  "lineno": "141",
  "column": "4",
  "slicing": "[\"annotation = 'some_var: {0}'\\n\", \"annotation_value = 'some_var: {0} = None'\\n\", \"assigned = 'some_var = {0}'\\n\", \"assigned_attribute = '{0}.attribute = 1'\\n\", \"import_name = 'import {0}'\\n\", \"from_import_module = 'from {0} import some'\\n\", \"from_import_name = 'from some import {0}'\\n\", \"calling_function = 'print({0})'\\n\", \"calling_star_function = 'print(*{0})'\\n\", \"called_function = '{0}()'\\n\", \"calling_method = 'instance.call({0})'\\n\", \"called_method = 'instance.{0}()'\\n\", \"accessing_attribute = 'instance.{0}'\\n\", \"accessed_attribute = '{0}.attribute'\\n\", \"key_access = 'instance[{0}]'\\n\", \"list_definition = 'instance = [{0}, 1]'\\n\", \"raising_variable = 'raise {0}'\\n\", 'returning_variable = \"\"\"\\n', 'awaiting_variable = \"\"\"\\n', 'yielding_variable = \"\"\"\\n', \"inheriting_variables = 'class ValidName({0}): ...'\\n\", '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    import_name,\\n', '    from_import_module,\\n', '    from_import_name,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    called_method,\\n', '    accessing_attribute,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = visitor_class(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " cannot be used if it is marked as unused.\"\"\"\n    tree = parse_ast_tree(code.format(bad_name))\n\n    visitor = UnusedVariableUsageVisitor(default_"
 },
 "510": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.UnusedVariableUsageVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_variable_usages.py",
  "lineno": "143",
  "column": "4",
  "slicing": "[\"annotation = 'some_var: {0}'\\n\", \"annotation_value = 'some_var: {0} = None'\\n\", \"assigned = 'some_var = {0}'\\n\", \"assigned_attribute = '{0}.attribute = 1'\\n\", \"import_name = 'import {0}'\\n\", \"from_import_module = 'from {0} import some'\\n\", \"from_import_name = 'from some import {0}'\\n\", \"calling_function = 'print({0})'\\n\", \"calling_star_function = 'print(*{0})'\\n\", \"called_function = '{0}()'\\n\", \"calling_method = 'instance.call({0})'\\n\", \"called_method = 'instance.{0}()'\\n\", \"accessing_attribute = 'instance.{0}'\\n\", \"accessed_attribute = '{0}.attribute'\\n\", \"key_access = 'instance[{0}]'\\n\", \"list_definition = 'instance = [{0}, 1]'\\n\", \"raising_variable = 'raise {0}'\\n\", 'returning_variable = \"\"\"\\n', 'awaiting_variable = \"\"\"\\n', 'yielding_variable = \"\"\"\\n', \"inheriting_variables = 'class ValidName({0}): ...'\\n\", '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    import_name,\\n', '    from_import_module,\\n', '    from_import_name,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    called_method,\\n', '    accessing_attribute,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = visitor_class(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(code.format(bad_name))\n\n    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unu"
 },
 "511": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_variable_usages.py",
  "lineno": "178",
  "column": "4",
  "slicing": "[\"annotation = 'some_var: {0}'\\n\", \"annotation_value = 'some_var: {0} = None'\\n\", \"assigned = 'some_var = {0}'\\n\", \"assigned_attribute = '{0}.attribute = 1'\\n\", \"import_name = 'import {0}'\\n\", \"from_import_module = 'from {0} import some'\\n\", \"from_import_name = 'from some import {0}'\\n\", \"calling_function = 'print({0})'\\n\", \"calling_star_function = 'print(*{0})'\\n\", \"called_function = '{0}()'\\n\", \"calling_method = 'instance.call({0})'\\n\", \"called_method = 'instance.{0}()'\\n\", \"accessing_attribute = 'instance.{0}'\\n\", \"accessed_attribute = '{0}.attribute'\\n\", \"key_access = 'instance[{0}]'\\n\", \"list_definition = 'instance = [{0}, 1]'\\n\", \"raising_variable = 'raise {0}'\\n\", 'returning_variable = \"\"\"\\n', 'awaiting_variable = \"\"\"\\n', 'yielding_variable = \"\"\"\\n', \"inheriting_variables = 'class ValidName({0}): ...'\\n\", '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    import_name,\\n', '    from_import_module,\\n', '    from_import_name,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    called_method,\\n', '    accessing_attribute,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = visitor_class(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " cannot be used if it is marked as unused.\"\"\"\n    tree = parse_ast_tree(code.format(bad_name))\n\n    visitor = UnusedVariableUsageVisitor(default_"
 },
 "512": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.UnusedVariableUsageVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_variable_usages.py",
  "lineno": "180",
  "column": "4",
  "slicing": "[\"annotation = 'some_var: {0}'\\n\", \"annotation_value = 'some_var: {0} = None'\\n\", \"assigned = 'some_var = {0}'\\n\", \"assigned_attribute = '{0}.attribute = 1'\\n\", \"import_name = 'import {0}'\\n\", \"from_import_module = 'from {0} import some'\\n\", \"from_import_name = 'from some import {0}'\\n\", \"calling_function = 'print({0})'\\n\", \"calling_star_function = 'print(*{0})'\\n\", \"called_function = '{0}()'\\n\", \"calling_method = 'instance.call({0})'\\n\", \"called_method = 'instance.{0}()'\\n\", \"accessing_attribute = 'instance.{0}'\\n\", \"accessed_attribute = '{0}.attribute'\\n\", \"key_access = 'instance[{0}]'\\n\", \"list_definition = 'instance = [{0}, 1]'\\n\", \"raising_variable = 'raise {0}'\\n\", 'returning_variable = \"\"\"\\n', 'awaiting_variable = \"\"\"\\n', 'yielding_variable = \"\"\"\\n', \"inheriting_variables = 'class ValidName({0}): ...'\\n\", '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    import_name,\\n', '    from_import_module,\\n', '    from_import_name,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    called_method,\\n', '    accessing_attribute,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = visitor_class(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    annotation,\\n', '    annotation_value,\\n', '    assigned,\\n', '    assigned_attribute,\\n', '    calling_function,\\n', '    calling_star_function,\\n', '    called_function,\\n', '    calling_method,\\n', '    accessed_attribute,\\n', '    key_access,\\n', '    list_definition,\\n', '    raising_variable,\\n', '    returning_variable,\\n', '    awaiting_variable,\\n', '    yielding_variable,\\n', '    inheriting_variables,\\n', '    tree = parse_ast_tree(code.format(bad_name))\\n', '    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(code.format(bad_name))\n\n    visitor = UnusedVariableUsageVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "513": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "44",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "th all unused variables cannot be defined.\"\"\"\n    tree = parse_ast_tree(\n        mode(context.format(\n            indent(\n "
 },
 "514": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.UnusedVariableDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "53",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ndentation,\n            ),\n        )),\n    )\n\n    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unu"
 },
 "515": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "80",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at least one used variable can be defined.\"\"\"\n    tree = parse_ast_tree(\n        mode(context.format(\n            indent(\n "
 },
 "516": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.UnusedVariableDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "89",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ndentation,\n            ),\n        )),\n    )\n\n    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "517": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "115",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ble definition is forbidden in some cases.\"\"\"\n    tree = parse_ast_tree(\n        mode(context.format(\n            indent(\n "
 },
 "518": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.UnusedVariableDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "124",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ndentation,\n            ),\n        )),\n    )\n\n    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unu"
 },
 "519": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "150",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "iable definition is allowed in some cases.\"\"\"\n    tree = parse_ast_tree(\n        mode(context.format(\n            indent(\n "
 },
 "520": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.UnusedVariableDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "159",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ndentation,\n            ),\n        )),\n    )\n\n    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "521": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "183",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " definition is forbidden in certain cases.\"\"\"\n    tree = parse_ast_tree(\n        mode(context.format(\n            indent(\n "
 },
 "522": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.UnusedVariableDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "192",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ndentation,\n            ),\n        )),\n    )\n\n    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unu"
 },
 "523": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "217",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "le definition is allowed in certain cases.\"\"\"\n    tree = parse_ast_tree(\n        mode(context.format(\n            indent(\n "
 },
 "524": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.UnusedVariableDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "226",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ndentation,\n            ),\n        )),\n    )\n\n    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "525": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "252",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "iable can be used if it is marked as used.\"\"\"\n    tree = parse_ast_tree(\n        mode(context.format(\n            indent(\n "
 },
 "526": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.naming.UnusedVariableDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_naming/test_unused/test_unused_definition.py",
  "lineno": "260",
  "column": "4",
  "slicing": "[\"module_context = '{0}'\\n\", 'function_context = \"\"\"\\n', 'method_context = \"\"\"\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsDefinedViolation])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_context, 0),\\n', '    (function_context, 4),\\n', '    (method_context, 8),\\n', '    tree = parse_ast_tree(\\n', '    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ndentation,\n            ),\n        )),\n    )\n\n    visitor = UnusedVariableDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "527": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_for_count.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['regular_loop_comprehension = \"\"\"\\n', 'complex_loop_comprehension = \"\"\"\\n', 'regular_dict_comprehension = \"\"\"\\n', 'complex_dict_comprehension = \"\"\"\\n', 'regular_gen_expression = \"\"\"\\n', 'complex_gen_expression = \"\"\"\\n', 'complex_nested_list_comprehension = \"\"\"\\n', '    complex_loop_comprehension,\\n', '    complex_dict_comprehension,\\n', '    complex_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    complex_nested_list_comprehension,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    regular_loop_comprehension,\\n', '    regular_dict_comprehension,\\n', '    regular_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing multiple `for` keywords is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n    visitor = WrongComprehensionVisitor(default_op"
 },
 "528": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongComprehensionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_for_count.py",
  "lineno": "94",
  "column": "4",
  "slicing": "['regular_loop_comprehension = \"\"\"\\n', 'complex_loop_comprehension = \"\"\"\\n', 'regular_dict_comprehension = \"\"\"\\n', 'complex_dict_comprehension = \"\"\"\\n', 'regular_gen_expression = \"\"\"\\n', 'complex_gen_expression = \"\"\"\\n', 'complex_nested_list_comprehension = \"\"\"\\n', '    complex_loop_comprehension,\\n', '    complex_dict_comprehension,\\n', '    complex_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    complex_nested_list_comprehension,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    regular_loop_comprehension,\\n', '    regular_dict_comprehension,\\n', '    regular_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "estricted.\"\"\"\n    tree = parse_ast_tree(code)\n    visitor = WrongComprehensionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "529": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_for_count.py",
  "lineno": "111",
  "column": "4",
  "slicing": "['regular_loop_comprehension = \"\"\"\\n', 'complex_loop_comprehension = \"\"\"\\n', 'regular_dict_comprehension = \"\"\"\\n', 'complex_dict_comprehension = \"\"\"\\n', 'regular_gen_expression = \"\"\"\\n', 'complex_gen_expression = \"\"\"\\n', 'complex_nested_list_comprehension = \"\"\"\\n', '    complex_loop_comprehension,\\n', '    complex_dict_comprehension,\\n', '    complex_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    complex_nested_list_comprehension,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    regular_loop_comprehension,\\n', '    regular_dict_comprehension,\\n', '    regular_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing multiple `for` keywords is restricted.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = WrongComprehensionVisitor(default_op"
 },
 "530": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongComprehensionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_for_count.py",
  "lineno": "112",
  "column": "4",
  "slicing": "['regular_loop_comprehension = \"\"\"\\n', 'complex_loop_comprehension = \"\"\"\\n', 'regular_dict_comprehension = \"\"\"\\n', 'complex_dict_comprehension = \"\"\"\\n', 'regular_gen_expression = \"\"\"\\n', 'complex_gen_expression = \"\"\"\\n', 'complex_nested_list_comprehension = \"\"\"\\n', '    complex_loop_comprehension,\\n', '    complex_dict_comprehension,\\n', '    complex_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    complex_nested_list_comprehension,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    regular_loop_comprehension,\\n', '    regular_dict_comprehension,\\n', '    regular_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ted.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = WrongComprehensionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "531": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_for_count.py",
  "lineno": "130",
  "column": "4",
  "slicing": "['regular_loop_comprehension = \"\"\"\\n', 'complex_loop_comprehension = \"\"\"\\n', 'regular_dict_comprehension = \"\"\"\\n', 'complex_dict_comprehension = \"\"\"\\n', 'regular_gen_expression = \"\"\"\\n', 'complex_gen_expression = \"\"\"\\n', 'complex_nested_list_comprehension = \"\"\"\\n', '    complex_loop_comprehension,\\n', '    complex_dict_comprehension,\\n', '    complex_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    complex_nested_list_comprehension,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    regular_loop_comprehension,\\n', '    regular_dict_comprehension,\\n', '    regular_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that using two `for` keywords is allowed.\"\"\"\n    tree = parse_ast_tree(code)\n    visitor = WrongComprehensionVisitor(default_op"
 },
 "532": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongComprehensionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_for_count.py",
  "lineno": "131",
  "column": "4",
  "slicing": "['regular_loop_comprehension = \"\"\"\\n', 'complex_loop_comprehension = \"\"\"\\n', 'regular_dict_comprehension = \"\"\"\\n', 'complex_dict_comprehension = \"\"\"\\n', 'regular_gen_expression = \"\"\"\\n', 'complex_gen_expression = \"\"\"\\n', 'complex_nested_list_comprehension = \"\"\"\\n', '    complex_loop_comprehension,\\n', '    complex_dict_comprehension,\\n', '    complex_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    complex_nested_list_comprehension,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    regular_loop_comprehension,\\n', '    regular_dict_comprehension,\\n', '    regular_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s allowed.\"\"\"\n    tree = parse_ast_tree(code)\n    visitor = WrongComprehensionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "533": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_for_count.py",
  "lineno": "148",
  "column": "4",
  "slicing": "['regular_loop_comprehension = \"\"\"\\n', 'complex_loop_comprehension = \"\"\"\\n', 'regular_dict_comprehension = \"\"\"\\n', 'complex_dict_comprehension = \"\"\"\\n', 'regular_gen_expression = \"\"\"\\n', 'complex_gen_expression = \"\"\"\\n', 'complex_nested_list_comprehension = \"\"\"\\n', '    complex_loop_comprehension,\\n', '    complex_dict_comprehension,\\n', '    complex_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    complex_nested_list_comprehension,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    regular_loop_comprehension,\\n', '    regular_dict_comprehension,\\n', '    regular_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that using two `for` keywords is allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = WrongComprehensionVisitor(default_op"
 },
 "534": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongComprehensionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_for_count.py",
  "lineno": "149",
  "column": "4",
  "slicing": "['regular_loop_comprehension = \"\"\"\\n', 'complex_loop_comprehension = \"\"\"\\n', 'regular_dict_comprehension = \"\"\"\\n', 'complex_dict_comprehension = \"\"\"\\n', 'regular_gen_expression = \"\"\"\\n', 'complex_gen_expression = \"\"\"\\n', 'complex_nested_list_comprehension = \"\"\"\\n', '    complex_loop_comprehension,\\n', '    complex_dict_comprehension,\\n', '    complex_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    complex_nested_list_comprehension,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyForsInComprehensionViolation])\\n', '    regular_loop_comprehension,\\n', '    regular_dict_comprehension,\\n', '    regular_gen_expression,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "wed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = WrongComprehensionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "535": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_ifs_count.py",
  "lineno": "117",
  "column": "4",
  "slicing": "['list_ifs_single = \"\"\"\\n', 'list_without_ifs = \"\"\"\\n', 'dict_ifs_single = \"\"\"\\n', 'dict_without_ifs = \"\"\"\\n', 'gen_ifs_single = \"\"\"\\n', 'gen_without_ifs = \"\"\"\\n', 'set_ifs_single = \"\"\"\\n', 'set_without_ifs = \"\"\"\\n', '    list_ifs_single,\\n', '    list_without_ifs,\\n', '    dict_ifs_single,\\n', '    dict_without_ifs,\\n', '    gen_ifs_single,\\n', '    gen_without_ifs,\\n', '    set_ifs_single,\\n', '    set_without_ifs,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleIfsInComprehensionViolation])\\n']",
  "context": "esting that using `if` keyword is allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongComprehensionVisitor(default_o"
 },
 "536": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongComprehensionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_ifs_count.py",
  "lineno": "119",
  "column": "4",
  "slicing": "['list_ifs_single = \"\"\"\\n', 'list_without_ifs = \"\"\"\\n', 'dict_ifs_single = \"\"\"\\n', 'dict_without_ifs = \"\"\"\\n', 'gen_ifs_single = \"\"\"\\n', 'gen_without_ifs = \"\"\"\\n', 'set_ifs_single = \"\"\"\\n', 'set_without_ifs = \"\"\"\\n', '    list_ifs_single,\\n', '    list_without_ifs,\\n', '    dict_ifs_single,\\n', '    dict_without_ifs,\\n', '    gen_ifs_single,\\n', '    gen_without_ifs,\\n', '    set_ifs_single,\\n', '    set_without_ifs,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleIfsInComprehensionViolation])\\n']",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongComprehensionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "537": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_ifs_count.py",
  "lineno": "143",
  "column": "4",
  "slicing": "['list_ifs_single = \"\"\"\\n', 'list_without_ifs = \"\"\"\\n', 'dict_ifs_single = \"\"\"\\n', 'dict_without_ifs = \"\"\"\\n', 'gen_ifs_single = \"\"\"\\n', 'gen_without_ifs = \"\"\"\\n', 'set_ifs_single = \"\"\"\\n', 'set_without_ifs = \"\"\"\\n', '    list_ifs_single,\\n', '    list_without_ifs,\\n', '    dict_ifs_single,\\n', '    dict_without_ifs,\\n', '    gen_ifs_single,\\n', '    gen_without_ifs,\\n', '    set_ifs_single,\\n', '    set_without_ifs,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleIfsInComprehensionViolation])\\n']",
  "context": "sing multiple `if` keywords is restricted.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = WrongComprehensionVisitor(default_op"
 },
 "538": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongComprehensionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_ifs_count.py",
  "lineno": "144",
  "column": "4",
  "slicing": "['list_ifs_single = \"\"\"\\n', 'list_without_ifs = \"\"\"\\n', 'dict_ifs_single = \"\"\"\\n', 'dict_without_ifs = \"\"\"\\n', 'gen_ifs_single = \"\"\"\\n', 'gen_without_ifs = \"\"\"\\n', 'set_ifs_single = \"\"\"\\n', 'set_without_ifs = \"\"\"\\n', '    list_ifs_single,\\n', '    list_without_ifs,\\n', '    dict_ifs_single,\\n', '    dict_without_ifs,\\n', '    gen_ifs_single,\\n', '    gen_without_ifs,\\n', '    set_ifs_single,\\n', '    set_without_ifs,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleIfsInComprehensionViolation])\\n']",
  "context": "ted.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = WrongComprehensionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mul"
 },
 "539": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_yield_inside_comprehension.py",
  "lineno": "48",
  "column": "4",
  "slicing": "['list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', \"    tree = parse_ast_tree(mode(code.format('(yield xy)')))\\n\", '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldInComprehensionViolation])\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', \"    tree = parse_ast_tree(mode(code.format('xy')))\\n\", '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that using `yield` keyword is not allowed.\"\"\"\n    tree = parse_ast_tree(mode(code.format('(yield xy)')))\n\n    visitor = WrongComprehensionVisitor(default_o"
 },
 "540": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongComprehensionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_yield_inside_comprehension.py",
  "lineno": "50",
  "column": "4",
  "slicing": "['list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', \"    tree = parse_ast_tree(mode(code.format('(yield xy)')))\\n\", '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldInComprehensionViolation])\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', \"    tree = parse_ast_tree(mode(code.format('xy')))\\n\", '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "se_ast_tree(mode(code.format('(yield xy)')))\n\n    visitor = WrongComprehensionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Yie"
 },
 "541": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_yield_inside_comprehension.py",
  "lineno": "90",
  "column": "4",
  "slicing": "['list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', \"    tree = parse_ast_tree(mode(code.format('(yield xy)')))\\n\", '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldInComprehensionViolation])\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', \"    tree = parse_ast_tree(mode(code.format('xy')))\\n\", '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "g that regular comprehensions are allowed.\"\"\"\n    tree = parse_ast_tree(mode(code.format('xy')))\n    visitor = WrongComprehensionVisitor(default_op"
 },
 "542": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongComprehensionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_yield_inside_comprehension.py",
  "lineno": "91",
  "column": "4",
  "slicing": "['list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', \"    tree = parse_ast_tree(mode(code.format('(yield xy)')))\\n\", '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [YieldInComprehensionViolation])\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', \"    tree = parse_ast_tree(mode(code.format('xy')))\\n\", '    visitor = WrongComprehensionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(mode(code.format('xy')))\n    visitor = WrongComprehensionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "543": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_variable_definition_comprehensions.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    tree = parse_ast_tree(mode(code.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopVariableDefinitionViolation])\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    tree = parse_ast_tree(mode(code.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that using wrong variables is not allowed.\"\"\"\n    tree = parse_ast_tree(mode(code.format(definition)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "544": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_variable_definition_comprehensions.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    tree = parse_ast_tree(mode(code.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopVariableDefinitionViolation])\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    tree = parse_ast_tree(mode(code.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "arse_ast_tree(mode(code.format(definition)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Loo"
 },
 "545": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_variable_definition_comprehensions.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    tree = parse_ast_tree(mode(code.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopVariableDefinitionViolation])\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    tree = parse_ast_tree(mode(code.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "g that regular comprehensions are allowed.\"\"\"\n    tree = parse_ast_tree(mode(code.format(definition)))\n    visitor = WrongLoopDefinitionVisitor(default_o"
 },
 "546": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_comprehensions/test_variable_definition_comprehensions.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    tree = parse_ast_tree(mode(code.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopVariableDefinitionViolation])\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    tree = parse_ast_tree(mode(code.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(definition)))\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "547": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_sync_loops/test_implicit_items.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['for_loop_template1 = \"\"\"\\n', 'for_loop_template2 = \"\"\"\\n', 'for_loop_template3 = \"\"\"\\n', '    for_loop_template1,\\n', '    for_loop_template2,\\n', '    for_loop_template3,\\n', '    tree = parse_ast_tree(\\n', '    visitor = SyncForLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitItemsIteratorViolation])\\n', '    for_loop_template1,\\n', '    for_loop_template2,\\n', '    for_loop_template3,\\n', '    tree = parse_ast_tree(\\n', '    visitor = SyncForLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  \"\"\"Ensures that `.items()` are required.\"\"\"\n    tree = parse_ast_tree(\n        template.format(target, iterable, expressi"
 },
 "548": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.SyncForLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_sync_loops/test_implicit_items.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['for_loop_template1 = \"\"\"\\n', 'for_loop_template2 = \"\"\"\\n', 'for_loop_template3 = \"\"\"\\n', '    for_loop_template1,\\n', '    for_loop_template2,\\n', '    for_loop_template3,\\n', '    tree = parse_ast_tree(\\n', '    visitor = SyncForLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitItemsIteratorViolation])\\n', '    for_loop_template1,\\n', '    for_loop_template2,\\n', '    for_loop_template3,\\n', '    tree = parse_ast_tree(\\n', '    visitor = SyncForLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": ".format(target, iterable, expression),\n    )\n\n    visitor = SyncForLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "549": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_sync_loops/test_implicit_items.py",
  "lineno": "100",
  "column": "4",
  "slicing": "['for_loop_template1 = \"\"\"\\n', 'for_loop_template2 = \"\"\"\\n', 'for_loop_template3 = \"\"\"\\n', '    for_loop_template1,\\n', '    for_loop_template2,\\n', '    for_loop_template3,\\n', '    tree = parse_ast_tree(\\n', '    visitor = SyncForLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitItemsIteratorViolation])\\n', '    for_loop_template1,\\n', '    for_loop_template2,\\n', '    for_loop_template3,\\n', '    tree = parse_ast_tree(\\n', '    visitor = SyncForLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ong types cannot be used as a loop's iter.\"\"\"\n    tree = parse_ast_tree(\n        template.format(target, iterable, expressi"
 },
 "550": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.SyncForLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_sync_loops/test_implicit_items.py",
  "lineno": "104",
  "column": "4",
  "slicing": "['for_loop_template1 = \"\"\"\\n', 'for_loop_template2 = \"\"\"\\n', 'for_loop_template3 = \"\"\"\\n', '    for_loop_template1,\\n', '    for_loop_template2,\\n', '    for_loop_template3,\\n', '    tree = parse_ast_tree(\\n', '    visitor = SyncForLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitItemsIteratorViolation])\\n', '    for_loop_template1,\\n', '    for_loop_template2,\\n', '    for_loop_template3,\\n', '    tree = parse_ast_tree(\\n', '    visitor = SyncForLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": ".format(target, iterable, expression),\n    )\n\n    visitor = SyncForLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "551": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_useless_conitue.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['wrong_for_loop = \"\"\"\\n', 'wrong_nested_for_loop = \"\"\"\\n', '    wrong_for_loop,\\n', '    wrong_nested_for_loop,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessContinueViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sed when `continue` is the last statement.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "552": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_useless_conitue.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['wrong_for_loop = \"\"\"\\n', 'wrong_nested_for_loop = \"\"\"\\n', '    wrong_for_loop,\\n', '    wrong_nested_for_loop,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessContinueViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nt.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "553": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_useless_conitue.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['wrong_for_loop = \"\"\"\\n', 'wrong_nested_for_loop = \"\"\"\\n', '    wrong_for_loop,\\n', '    wrong_nested_for_loop,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessContinueViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "when `continue` is not the last statement.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "554": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_useless_conitue.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['wrong_for_loop = \"\"\"\\n', 'wrong_nested_for_loop = \"\"\"\\n', '    wrong_for_loop,\\n', '    wrong_nested_for_loop,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessContinueViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nt.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "555": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_iter_type.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', 'list_comprehension_template = \"\"\"\\n', 'dict_comprehension_template = \"\"\"\\n', 'set_comprehension_template = \"\"\"\\n', 'generator_expression_template = \"\"\"\\n', '    for_loop_template,\\n', '    list_comprehension_template,\\n', '    dict_comprehension_template,\\n', '    set_comprehension_template,\\n', '    generator_expression_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongLoopIterTypeViolation])\\n', '    for_loop_template,\\n', '    list_comprehension_template,\\n', '    dict_comprehension_template,\\n', '    set_comprehension_template,\\n', '    generator_expression_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ong types cannot be used as a loop's iter.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "556": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_iter_type.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', 'list_comprehension_template = \"\"\"\\n', 'dict_comprehension_template = \"\"\"\\n', 'set_comprehension_template = \"\"\"\\n', 'generator_expression_template = \"\"\"\\n', '    for_loop_template,\\n', '    list_comprehension_template,\\n', '    dict_comprehension_template,\\n', '    set_comprehension_template,\\n', '    generator_expression_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongLoopIterTypeViolation])\\n', '    for_loop_template,\\n', '    list_comprehension_template,\\n', '    dict_comprehension_template,\\n', '    set_comprehension_template,\\n', '    generator_expression_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "557": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_iter_type.py",
  "lineno": "115",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', 'list_comprehension_template = \"\"\"\\n', 'dict_comprehension_template = \"\"\"\\n', 'set_comprehension_template = \"\"\"\\n', 'generator_expression_template = \"\"\"\\n', '    for_loop_template,\\n', '    list_comprehension_template,\\n', '    dict_comprehension_template,\\n', '    set_comprehension_template,\\n', '    generator_expression_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongLoopIterTypeViolation])\\n', '    for_loop_template,\\n', '    list_comprehension_template,\\n', '    dict_comprehension_template,\\n', '    set_comprehension_template,\\n', '    generator_expression_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "orrect types can be used as a loop's iter.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "558": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_iter_type.py",
  "lineno": "117",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', 'list_comprehension_template = \"\"\"\\n', 'dict_comprehension_template = \"\"\"\\n', 'set_comprehension_template = \"\"\"\\n', 'generator_expression_template = \"\"\"\\n', '    for_loop_template,\\n', '    list_comprehension_template,\\n', '    dict_comprehension_template,\\n', '    set_comprehension_template,\\n', '    generator_expression_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongLoopIterTypeViolation])\\n', '    for_loop_template,\\n', '    list_comprehension_template,\\n', '    dict_comprehension_template,\\n', '    set_comprehension_template,\\n', '    generator_expression_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "559": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_multiline_loops.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['incorrect_loop1 = \"\"\"\\n', 'incorrect_loop2 = \"\"\"\\n', 'incorrect_loop3 = \"\"\"\\n', '    incorrect_loop1,\\n', '    incorrect_loop2,\\n', '    incorrect_loop3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineLoopViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  mode,\n):\n    \"\"\"Testing multiline loops.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "560": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_multiline_loops.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['incorrect_loop1 = \"\"\"\\n', 'incorrect_loop2 = \"\"\"\\n', 'incorrect_loop3 = \"\"\"\\n', '    incorrect_loop1,\\n', '    incorrect_loop2,\\n', '    incorrect_loop3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineLoopViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ps.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mul"
 },
 "561": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_multiline_loops.py",
  "lineno": "81",
  "column": "4",
  "slicing": "['incorrect_loop1 = \"\"\"\\n', 'incorrect_loop2 = \"\"\"\\n', 'incorrect_loop3 = \"\"\"\\n', '    incorrect_loop1,\\n', '    incorrect_loop2,\\n', '    incorrect_loop3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineLoopViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  mode,\n):\n    \"\"\"Testing multiline loops.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "562": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_multiline_loops.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['incorrect_loop1 = \"\"\"\\n', 'incorrect_loop2 = \"\"\"\\n', 'incorrect_loop3 = \"\"\"\\n', '    incorrect_loop1,\\n', '    incorrect_loop2,\\n', '    incorrect_loop3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineLoopViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ps.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "563": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_lambda_in_loop.py",
  "lineno": "112",
  "column": "4",
  "slicing": "['lambda_inside_for_loop = \"\"\"\\n', 'nested_lambda_inside_for_loop = \"\"\"\\n', 'lambda_inside_while_loop = \"\"\"\\n', 'nested_lambda_inside_while_loop = \"\"\"\\n', 'lambda_inside_set = \"\"\"\\n', 'lambda_inside_list = \"\"\"\\n', 'lambda_inside_gen = \"\"\"\\n', 'lambda_inside_dict_key = \"\"\"\\n', 'lambda_inside_dict_value = \"\"\"\\n', '    lambda_inside_for_loop,\\n', '    nested_lambda_inside_for_loop,\\n', '    lambda_inside_while_loop,\\n', '    nested_lambda_inside_while_loop,\\n', '    lambda_inside_list,\\n', '    lambda_inside_set,\\n', '    lambda_inside_gen,\\n', '    lambda_inside_dict_key,\\n', '    lambda_inside_dict_value,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LambdaInsideLoopViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat lambda cannot be inside a loop's body.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "564": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_lambda_in_loop.py",
  "lineno": "114",
  "column": "4",
  "slicing": "['lambda_inside_for_loop = \"\"\"\\n', 'nested_lambda_inside_for_loop = \"\"\"\\n', 'lambda_inside_while_loop = \"\"\"\\n', 'nested_lambda_inside_while_loop = \"\"\"\\n', 'lambda_inside_set = \"\"\"\\n', 'lambda_inside_list = \"\"\"\\n', 'lambda_inside_gen = \"\"\"\\n', 'lambda_inside_dict_key = \"\"\"\\n', 'lambda_inside_dict_value = \"\"\"\\n', '    lambda_inside_for_loop,\\n', '    nested_lambda_inside_for_loop,\\n', '    lambda_inside_while_loop,\\n', '    nested_lambda_inside_while_loop,\\n', '    lambda_inside_list,\\n', '    lambda_inside_set,\\n', '    lambda_inside_gen,\\n', '    lambda_inside_dict_key,\\n', '    lambda_inside_dict_value,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LambdaInsideLoopViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "dy.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Lam"
 },
 "565": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_lambda_in_loop.py",
  "lineno": "135",
  "column": "4",
  "slicing": "['lambda_inside_for_loop = \"\"\"\\n', 'nested_lambda_inside_for_loop = \"\"\"\\n', 'lambda_inside_while_loop = \"\"\"\\n', 'nested_lambda_inside_while_loop = \"\"\"\\n', 'lambda_inside_set = \"\"\"\\n', 'lambda_inside_list = \"\"\"\\n', 'lambda_inside_gen = \"\"\"\\n', 'lambda_inside_dict_key = \"\"\"\\n', 'lambda_inside_dict_value = \"\"\"\\n', '    lambda_inside_for_loop,\\n', '    nested_lambda_inside_for_loop,\\n', '    lambda_inside_while_loop,\\n', '    nested_lambda_inside_while_loop,\\n', '    lambda_inside_list,\\n', '    lambda_inside_set,\\n', '    lambda_inside_gen,\\n', '    lambda_inside_dict_key,\\n', '    lambda_inside_dict_value,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LambdaInsideLoopViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Ensures that lambda can be near loops.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "566": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_lambda_in_loop.py",
  "lineno": "137",
  "column": "4",
  "slicing": "['lambda_inside_for_loop = \"\"\"\\n', 'nested_lambda_inside_for_loop = \"\"\"\\n', 'lambda_inside_while_loop = \"\"\"\\n', 'nested_lambda_inside_while_loop = \"\"\"\\n', 'lambda_inside_set = \"\"\"\\n', 'lambda_inside_list = \"\"\"\\n', 'lambda_inside_gen = \"\"\"\\n', 'lambda_inside_dict_key = \"\"\"\\n', 'lambda_inside_dict_value = \"\"\"\\n', '    lambda_inside_for_loop,\\n', '    nested_lambda_inside_for_loop,\\n', '    lambda_inside_while_loop,\\n', '    nested_lambda_inside_while_loop,\\n', '    lambda_inside_list,\\n', '    lambda_inside_set,\\n', '    lambda_inside_gen,\\n', '    lambda_inside_dict_key,\\n', '    lambda_inside_dict_value,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LambdaInsideLoopViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ps.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "567": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_loop_sum.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitSumViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " implicit ``sum()`` calls are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "568": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_loop_sum.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitSumViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "569": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_loop_sum.py",
  "lineno": "66",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitSumViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that correct ``sum()`` calls are allowed.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "570": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_loop_sum.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitSumViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "571": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": " \"\"\"Testing while loops with correct code.\"\"\"\n    tree = parse_ast_tree(template.format(keyword))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "572": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "e = parse_ast_tree(template.format(keyword))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "573": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "100",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "ng while loops with ``return`` statements.\"\"\"\n    tree = parse_ast_tree(mode(template.format(keyword)))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "574": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "102",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "rse_ast_tree(mode(template.format(keyword)))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "575": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "124",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "sting other while loops with regular code.\"\"\"\n    tree = parse_ast_tree(template.format(keyword))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "576": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "126",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "e = parse_ast_tree(template.format(keyword))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "577": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "152",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "   \"\"\"Testing while loops with wrong code.\"\"\"\n    tree = parse_ast_tree(template.format(keyword))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "578": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "154",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "e = parse_ast_tree(template.format(keyword))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Inf"
 },
 "579": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "175",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "   \"\"\"Testing while loops with wrong code.\"\"\"\n    tree = parse_ast_tree(template.format(keyword, keyword))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "580": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "177",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "_ast_tree(template.format(keyword, keyword))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "581": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "199",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "   \"\"\"Testing while loops with wrong code.\"\"\"\n    tree = parse_ast_tree(template.format(keyword1, keyword2))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "582": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_infinite_while_loops.py",
  "lineno": "201",
  "column": "4",
  "slicing": "['template_simple = \"\"\"\\n', 'template_nested_while1 = \"\"\"\\n', 'template_nested_while2 = \"\"\"\\n', 'template_nested_if = \"\"\"\\n', 'template_function = \"\"\"\\n', 'template_other = \"\"\"\\n', 'template_double_while = \"\"\"\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_function,\\n', '    tree = parse_ast_tree(mode(template.format(keyword)))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_other,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_simple,\\n', '    template_nested_while1,\\n', '    template_nested_while2,\\n', '    template_nested_if,\\n', '    template_function,\\n', '    tree = parse_ast_tree(template.format(keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword, keyword))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_double_while,\\n', '    tree = parse_ast_tree(template.format(keyword1, keyword2))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InfiniteWhileLoopViolation])\\n']",
  "context": "st_tree(template.format(keyword1, keyword2))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Inf"
 },
 "583": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_variable_definitions_loops.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['for_loop_def = \"\"\"\\n', '    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopVariableDefinitionViolation])\\n', '    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "es that wrong definitions are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "584": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_variable_definitions_loops.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['for_loop_def = \"\"\"\\n', '    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopVariableDefinitionViolation])\\n', '    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_tree(mode(for_loop_def.format(definition)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Loo"
 },
 "585": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_variable_definitions_loops.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['for_loop_def = \"\"\"\\n', '    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopVariableDefinitionViolation])\\n', '    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ures that correct definitions are allowed.\"\"\"\n    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "586": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_variable_definitions_loops.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['for_loop_def = \"\"\"\\n', '    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LoopVariableDefinitionViolation])\\n', '    tree = parse_ast_tree(mode(for_loop_def.format(definition)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_tree(mode(for_loop_def.format(definition)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "587": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_loop_with_else.py",
  "lineno": "145",
  "column": "4",
  "slicing": "['wrong_else_in_for_loop = \"\"\"\\n', 'wrong_nested_else_in_for_loop = \"\"\"\\n', 'wrong_nested_for_with_break = \"\"\"\\n', 'wrong_nested_while_with_break = \"\"\"\\n', 'wrong_multiple_breaks = \"\"\"\\n', 'wrong_while_without_break = \"\"\"\\n', '    wrong_else_in_for_loop,\\n', '    wrong_nested_else_in_for_loop,\\n', '    wrong_nested_for_with_break,\\n', '    wrong_nested_while_with_break,\\n', '    wrong_multiple_breaks,\\n', '    wrong_while_without_break,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLoopElseViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "are raised when else with break statement.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "588": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_loop_with_else.py",
  "lineno": "147",
  "column": "4",
  "slicing": "['wrong_else_in_for_loop = \"\"\"\\n', 'wrong_nested_else_in_for_loop = \"\"\"\\n', 'wrong_nested_for_with_break = \"\"\"\\n', 'wrong_nested_while_with_break = \"\"\"\\n', 'wrong_multiple_breaks = \"\"\"\\n', 'wrong_while_without_break = \"\"\"\\n', '    wrong_else_in_for_loop,\\n', '    wrong_nested_else_in_for_loop,\\n', '    wrong_nested_for_with_break,\\n', '    wrong_nested_while_with_break,\\n', '    wrong_multiple_breaks,\\n', '    wrong_while_without_break,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLoopElseViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nt.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "589": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_loop_with_else.py",
  "lineno": "170",
  "column": "4",
  "slicing": "['wrong_else_in_for_loop = \"\"\"\\n', 'wrong_nested_else_in_for_loop = \"\"\"\\n', 'wrong_nested_for_with_break = \"\"\"\\n', 'wrong_nested_while_with_break = \"\"\"\\n', 'wrong_multiple_breaks = \"\"\"\\n', 'wrong_while_without_break = \"\"\"\\n', '    wrong_else_in_for_loop,\\n', '    wrong_nested_else_in_for_loop,\\n', '    wrong_nested_for_with_break,\\n', '    wrong_nested_while_with_break,\\n', '    wrong_multiple_breaks,\\n', '    wrong_while_without_break,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLoopElseViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " raised when else without break statement.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, t"
 },
 "590": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_loop_with_else.py",
  "lineno": "172",
  "column": "4",
  "slicing": "['wrong_else_in_for_loop = \"\"\"\\n', 'wrong_nested_else_in_for_loop = \"\"\"\\n', 'wrong_nested_for_with_break = \"\"\"\\n', 'wrong_nested_while_with_break = \"\"\"\\n', 'wrong_multiple_breaks = \"\"\"\\n', 'wrong_while_without_break = \"\"\"\\n', '    wrong_else_in_for_loop,\\n', '    wrong_nested_else_in_for_loop,\\n', '    wrong_nested_for_with_break,\\n', '    wrong_nested_while_with_break,\\n', '    wrong_multiple_breaks,\\n', '    wrong_while_without_break,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLoopElseViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongLoopVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nt.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongLoopVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "591": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_implicit_yield_from.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(regular_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitYieldFromViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(async_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t implicit ``yield from`` are not allowed.\"\"\"\n    tree = parse_ast_tree(regular_wrapper(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "592": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_implicit_yield_from.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(regular_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitYieldFromViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(async_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree(regular_wrapper(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "593": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_implicit_yield_from.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(regular_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitYieldFromViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(async_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "eld from`` in async functions are allowed.\"\"\"\n    tree = parse_ast_tree(async_wrapper(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "594": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_implicit_yield_from.py",
  "lineno": "63",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(regular_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitYieldFromViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(async_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t_tree(async_wrapper(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "595": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_implicit_yield_from.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(regular_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitYieldFromViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(async_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "es that correct ``for`` loops are allowed.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "596": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_implicit_yield_from.py",
  "lineno": "89",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(regular_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitYieldFromViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(async_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "597": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_implicit_yield_from.py",
  "lineno": "109",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(regular_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitYieldFromViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(async_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "es that correct ``for`` loops are allowed.\"\"\"\n    tree = parse_ast_tree(template.format(code))\n\n    visitor = WrongLoopDefinitionVisitor(default_"
 },
 "598": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.loops.WrongLoopDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_loops/test_loops/test_implicit_yield_from.py",
  "lineno": "111",
  "column": "4",
  "slicing": "['for_loop_template = \"\"\"\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(regular_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitYieldFromViolation])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(async_wrapper(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop_template,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(template.format(code))\n\n    visitor = WrongLoopDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "599": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_approximate_constants.py",
  "lineno": "26",
  "column": "4",
  "slicing": "[\"    tree = parse_ast_tree('my_const = {0}'.format(variable_value))\\n\", '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ApproximateConstantViolation])\\n', '    assert_error_text(visitor, str(variable_value))\\n', \"    tree = parse_ast_tree('a = {0}'.format(variable_value))\\n\", '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sage of approximate constants not allowed.\"\"\"\n    tree = parse_ast_tree('my_const = {0}'.format(variable_value))\n    visitor = WrongNumberVisitor(default_options, "
 },
 "600": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongNumberVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_approximate_constants.py",
  "lineno": "27",
  "column": "4",
  "slicing": "[\"    tree = parse_ast_tree('my_const = {0}'.format(variable_value))\\n\", '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ApproximateConstantViolation])\\n', '    assert_error_text(visitor, str(variable_value))\\n', \"    tree = parse_ast_tree('a = {0}'.format(variable_value))\\n\", '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree('my_const = {0}'.format(variable_value))\n    visitor = WrongNumberVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [App"
 },
 "601": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_approximate_constants.py",
  "lineno": "67",
  "column": "4",
  "slicing": "[\"    tree = parse_ast_tree('my_const = {0}'.format(variable_value))\\n\", '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ApproximateConstantViolation])\\n', '    assert_error_text(visitor, str(variable_value))\\n', \"    tree = parse_ast_tree('a = {0}'.format(variable_value))\\n\", '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ures that usage of simple numbers allowed.\"\"\"\n    tree = parse_ast_tree('a = {0}'.format(variable_value))\n    visitor = WrongNumberVisitor(default_options, "
 },
 "602": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongNumberVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_approximate_constants.py",
  "lineno": "68",
  "column": "4",
  "slicing": "[\"    tree = parse_ast_tree('my_const = {0}'.format(variable_value))\\n\", '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ApproximateConstantViolation])\\n', '    assert_error_text(visitor, str(variable_value))\\n', \"    tree = parse_ast_tree('a = {0}'.format(variable_value))\\n\", '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "se_ast_tree('a = {0}'.format(variable_value))\n    visitor = WrongNumberVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "603": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_magic_numbers.py",
  "lineno": "115",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_typed = 'constant: int = {0}'\\n\", \"assignment_unary = 'constant = -{0}'\\n\", \"walrus = '(constant := {0})'\\n\", 'function_definition = \"\"\"\\n', 'function_definition_typed = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", \"assignment_binop = 'final = {0} + 1'\\n\", \"assignment_binop_typed = 'final: int = {0} + 1'\\n\", \"function_call = 'print({0})'\\n\", \"function_call_named = 'print(end={0})'\\n\", \"expression = '{0}'\\n\", 'inside_function = \"\"\"\\n', 'inside_class = \"\"\"\\n', 'inside_class_typed = \"\"\"\\n', 'inside_method = \"\"\"\\n', 'list_index = \"\"\"\\n', 'dict_key = \"\"\"\\n', '    assignment,\\n', '    assignment_typed,\\n', '    assignment_unary,\\n', '        walrus,\\n', '    function_definition,\\n', '    function_definition_typed,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n', \"    assert_error_text(visitor, number.replace('-', ''))\\n\", '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n']",
  "context": "t there are no magic numbers in this code.\"\"\"\n    tree = parse_ast_tree(mode(code.format(number)))\n\n    visitor = WrongNumberVisitor(default_options,"
 },
 "604": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongNumberVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_magic_numbers.py",
  "lineno": "117",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_typed = 'constant: int = {0}'\\n\", \"assignment_unary = 'constant = -{0}'\\n\", \"walrus = '(constant := {0})'\\n\", 'function_definition = \"\"\"\\n', 'function_definition_typed = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", \"assignment_binop = 'final = {0} + 1'\\n\", \"assignment_binop_typed = 'final: int = {0} + 1'\\n\", \"function_call = 'print({0})'\\n\", \"function_call_named = 'print(end={0})'\\n\", \"expression = '{0}'\\n\", 'inside_function = \"\"\"\\n', 'inside_class = \"\"\"\\n', 'inside_class_typed = \"\"\"\\n', 'inside_method = \"\"\"\\n', 'list_index = \"\"\"\\n', 'dict_key = \"\"\"\\n', '    assignment,\\n', '    assignment_typed,\\n', '    assignment_unary,\\n', '        walrus,\\n', '    function_definition,\\n', '    function_definition_typed,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n', \"    assert_error_text(visitor, number.replace('-', ''))\\n\", '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n']",
  "context": " = parse_ast_tree(mode(code.format(number)))\n\n    visitor = WrongNumberVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "605": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_magic_numbers.py",
  "lineno": "153",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_typed = 'constant: int = {0}'\\n\", \"assignment_unary = 'constant = -{0}'\\n\", \"walrus = '(constant := {0})'\\n\", 'function_definition = \"\"\"\\n', 'function_definition_typed = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", \"assignment_binop = 'final = {0} + 1'\\n\", \"assignment_binop_typed = 'final: int = {0} + 1'\\n\", \"function_call = 'print({0})'\\n\", \"function_call_named = 'print(end={0})'\\n\", \"expression = '{0}'\\n\", 'inside_function = \"\"\"\\n', 'inside_class = \"\"\"\\n', 'inside_class_typed = \"\"\"\\n', 'inside_method = \"\"\"\\n', 'list_index = \"\"\"\\n', 'dict_key = \"\"\"\\n', '    assignment,\\n', '    assignment_typed,\\n', '    assignment_unary,\\n', '        walrus,\\n', '    function_definition,\\n', '    function_definition_typed,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n', \"    assert_error_text(visitor, number.replace('-', ''))\\n\", '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n']",
  "context": "agic numbers in this code are whitelisted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(number)))\n\n    visitor = WrongNumberVisitor(default_options,"
 },
 "606": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongNumberVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_magic_numbers.py",
  "lineno": "155",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_typed = 'constant: int = {0}'\\n\", \"assignment_unary = 'constant = -{0}'\\n\", \"walrus = '(constant := {0})'\\n\", 'function_definition = \"\"\"\\n', 'function_definition_typed = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", \"assignment_binop = 'final = {0} + 1'\\n\", \"assignment_binop_typed = 'final: int = {0} + 1'\\n\", \"function_call = 'print({0})'\\n\", \"function_call_named = 'print(end={0})'\\n\", \"expression = '{0}'\\n\", 'inside_function = \"\"\"\\n', 'inside_class = \"\"\"\\n', 'inside_class_typed = \"\"\"\\n', 'inside_method = \"\"\"\\n', 'list_index = \"\"\"\\n', 'dict_key = \"\"\"\\n', '    assignment,\\n', '    assignment_typed,\\n', '    assignment_unary,\\n', '        walrus,\\n', '    function_definition,\\n', '    function_definition_typed,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n', \"    assert_error_text(visitor, number.replace('-', ''))\\n\", '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n']",
  "context": " = parse_ast_tree(mode(code.format(number)))\n\n    visitor = WrongNumberVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "607": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_magic_numbers.py",
  "lineno": "191",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_typed = 'constant: int = {0}'\\n\", \"assignment_unary = 'constant = -{0}'\\n\", \"walrus = '(constant := {0})'\\n\", 'function_definition = \"\"\"\\n', 'function_definition_typed = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", \"assignment_binop = 'final = {0} + 1'\\n\", \"assignment_binop_typed = 'final: int = {0} + 1'\\n\", \"function_call = 'print({0})'\\n\", \"function_call_named = 'print(end={0})'\\n\", \"expression = '{0}'\\n\", 'inside_function = \"\"\"\\n', 'inside_class = \"\"\"\\n', 'inside_class_typed = \"\"\"\\n', 'inside_method = \"\"\"\\n', 'list_index = \"\"\"\\n', 'dict_key = \"\"\"\\n', '    assignment,\\n', '    assignment_typed,\\n', '    assignment_unary,\\n', '        walrus,\\n', '    function_definition,\\n', '    function_definition_typed,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n', \"    assert_error_text(visitor, number.replace('-', ''))\\n\", '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n']",
  "context": "t magic numbers in this code are warnings.\"\"\"\n    tree = parse_ast_tree(mode(code.format(number)))\n\n    visitor = WrongNumberVisitor(default_options,"
 },
 "608": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongNumberVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_magic_numbers.py",
  "lineno": "193",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_typed = 'constant: int = {0}'\\n\", \"assignment_unary = 'constant = -{0}'\\n\", \"walrus = '(constant := {0})'\\n\", 'function_definition = \"\"\"\\n', 'function_definition_typed = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", \"assignment_binop = 'final = {0} + 1'\\n\", \"assignment_binop_typed = 'final: int = {0} + 1'\\n\", \"function_call = 'print({0})'\\n\", \"function_call_named = 'print(end={0})'\\n\", \"expression = '{0}'\\n\", 'inside_function = \"\"\"\\n', 'inside_class = \"\"\"\\n', 'inside_class_typed = \"\"\"\\n', 'inside_method = \"\"\"\\n', 'list_index = \"\"\"\\n', 'dict_key = \"\"\"\\n', '    assignment,\\n', '    assignment_typed,\\n', '    assignment_unary,\\n', '        walrus,\\n', '    function_definition,\\n', '    function_definition_typed,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n', \"    assert_error_text(visitor, number.replace('-', ''))\\n\", '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n']",
  "context": " = parse_ast_tree(mode(code.format(number)))\n\n    visitor = WrongNumberVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mag"
 },
 "609": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_magic_numbers.py",
  "lineno": "227",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_typed = 'constant: int = {0}'\\n\", \"assignment_unary = 'constant = -{0}'\\n\", \"walrus = '(constant := {0})'\\n\", 'function_definition = \"\"\"\\n', 'function_definition_typed = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", \"assignment_binop = 'final = {0} + 1'\\n\", \"assignment_binop_typed = 'final: int = {0} + 1'\\n\", \"function_call = 'print({0})'\\n\", \"function_call_named = 'print(end={0})'\\n\", \"expression = '{0}'\\n\", 'inside_function = \"\"\"\\n', 'inside_class = \"\"\"\\n', 'inside_class_typed = \"\"\"\\n', 'inside_method = \"\"\"\\n', 'list_index = \"\"\"\\n', 'dict_key = \"\"\"\\n', '    assignment,\\n', '    assignment_typed,\\n', '    assignment_unary,\\n', '        walrus,\\n', '    function_definition,\\n', '    function_definition_typed,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n', \"    assert_error_text(visitor, number.replace('-', ''))\\n\", '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n']",
  "context": "t magic numbers in this code are warnings.\"\"\"\n    tree = parse_ast_tree(mode(code.format(number)))\n\n    visitor = WrongNumberVisitor(default_options,"
 },
 "610": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongNumberVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_numbers/test_magic_numbers.py",
  "lineno": "229",
  "column": "4",
  "slicing": "[\"assignment = 'constant = {0}'\\n\", \"assignment_typed = 'constant: int = {0}'\\n\", \"assignment_unary = 'constant = -{0}'\\n\", \"walrus = '(constant := {0})'\\n\", 'function_definition = \"\"\"\\n', 'function_definition_typed = \"\"\"\\n', \"list_definition = '[{0}]'\\n\", 'dict_definition_key = \\'{{{0}: \"value\"}}\\'\\n', 'dict_definition_value = \\'{{\"first\": {0}}}\\'\\n', 'set_definition = \\'{{\"first\", {0}, \"other\"}}\\'\\n', \"tuple_definition = '({0}, )'\\n\", \"assignment_binop = 'final = {0} + 1'\\n\", \"assignment_binop_typed = 'final: int = {0} + 1'\\n\", \"function_call = 'print({0})'\\n\", \"function_call_named = 'print(end={0})'\\n\", \"expression = '{0}'\\n\", 'inside_function = \"\"\"\\n', 'inside_class = \"\"\"\\n', 'inside_class_typed = \"\"\"\\n', 'inside_method = \"\"\"\\n', 'list_index = \"\"\"\\n', 'dict_key = \"\"\"\\n', '    assignment,\\n', '    assignment_typed,\\n', '    assignment_unary,\\n', '        walrus,\\n', '    function_definition,\\n', '    function_definition_typed,\\n', '    list_definition,\\n', '    dict_definition_key,\\n', '    dict_definition_value,\\n', '    set_definition,\\n', '    tuple_definition,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n', \"    assert_error_text(visitor, number.replace('-', ''))\\n\", '    assignment_binop,\\n', '    assignment_binop_typed,\\n', '    function_call,\\n', '    function_call_named,\\n', '    expression,\\n', '    inside_function,\\n', '    inside_class,\\n', '    inside_class_typed,\\n', '    inside_method,\\n', '    list_index,\\n', '    dict_key,\\n', '    tree = parse_ast_tree(mode(code.format(number)))\\n', '    visitor = WrongNumberVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MagicNumberViolation])\\n']",
  "context": " = parse_ast_tree(mode(code.format(number)))\n\n    visitor = WrongNumberVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mag"
 },
 "611": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_multiple_assign.py",
  "lineno": "34",
  "column": "4",
  "slicing": "[\"single_assignment = 'constant = 1'\\n\", \"tuple_assignment = 'first, second = (1, 2)'\\n\", \"spread_assignment = 'first, *_, second = [1, 2, 4, 3]'\\n\", '    single_assignment,\\n', '    tuple_assignment,\\n', '    spread_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleAssignmentsViolation])\\n']",
  "context": " \"\"\"Testing that correct assignments work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "612": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_multiple_assign.py",
  "lineno": "36",
  "column": "4",
  "slicing": "[\"single_assignment = 'constant = 1'\\n\", \"tuple_assignment = 'first, second = (1, 2)'\\n\", \"spread_assignment = 'first, *_, second = [1, 2, 4, 3]'\\n\", '    single_assignment,\\n', '    tuple_assignment,\\n', '    spread_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleAssignmentsViolation])\\n']",
  "context": "nts work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "613": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_multiple_assign.py",
  "lineno": "53",
  "column": "4",
  "slicing": "[\"single_assignment = 'constant = 1'\\n\", \"tuple_assignment = 'first, second = (1, 2)'\\n\", \"spread_assignment = 'first, *_, second = [1, 2, 4, 3]'\\n\", '    single_assignment,\\n', '    tuple_assignment,\\n', '    spread_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleAssignmentsViolation])\\n']",
  "context": " that multiple assignments are restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "614": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_multiple_assign.py",
  "lineno": "55",
  "column": "4",
  "slicing": "[\"single_assignment = 'constant = 1'\\n\", \"tuple_assignment = 'first, second = (1, 2)'\\n\", \"spread_assignment = 'first, *_, second = [1, 2, 4, 3]'\\n\", '    single_assignment,\\n', '    tuple_assignment,\\n', '    spread_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleAssignmentsViolation])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mul"
 },
 "615": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_to_list.py",
  "lineno": "91",
  "column": "4",
  "slicing": "[\"list_target = '[first, second]'\\n\", \"nested_list_target0 = '([first, second], third)'\\n\", \"nested_list_target1 = '(first, [second, third])'\\n\", \"nested_list_target2 = '(first, (second, [third, fourth]))'\\n\", \"multiple_level_nested_list_target = '(first, (second, [third, fourth]))'\\n\", \"spread_assignment_in_list_target = '[first, *rest]'\\n\", \"nested_spread_assignment_in_list = '(first, [second, *rest])'\\n\", 'multiple_level_nested_spread_assign_in_list = (\\n', \"regular_assignment = '{0} = some()'\\n\", 'for_assignment = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_multiple_assignments = \"\"\"\\n', '    list_target,\\n', '    spread_assignment_in_list_target,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnpackingIterableToListViolation])\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    list_target,\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    spread_assignment_in_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": " unpacking iterable to list is restricted.\"\"\"\n    tree = parse_ast_tree(code.format(assignment))\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "616": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_to_list.py",
  "lineno": "93",
  "column": "4",
  "slicing": "[\"list_target = '[first, second]'\\n\", \"nested_list_target0 = '([first, second], third)'\\n\", \"nested_list_target1 = '(first, [second, third])'\\n\", \"nested_list_target2 = '(first, (second, [third, fourth]))'\\n\", \"multiple_level_nested_list_target = '(first, (second, [third, fourth]))'\\n\", \"spread_assignment_in_list_target = '[first, *rest]'\\n\", \"nested_spread_assignment_in_list = '(first, [second, *rest])'\\n\", 'multiple_level_nested_spread_assign_in_list = (\\n', \"regular_assignment = '{0} = some()'\\n\", 'for_assignment = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_multiple_assignments = \"\"\"\\n', '    list_target,\\n', '    spread_assignment_in_list_target,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnpackingIterableToListViolation])\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    list_target,\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    spread_assignment_in_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "ee = parse_ast_tree(code.format(assignment))\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unp"
 },
 "617": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_to_list.py",
  "lineno": "125",
  "column": "4",
  "slicing": "[\"list_target = '[first, second]'\\n\", \"nested_list_target0 = '([first, second], third)'\\n\", \"nested_list_target1 = '(first, [second, third])'\\n\", \"nested_list_target2 = '(first, (second, [third, fourth]))'\\n\", \"multiple_level_nested_list_target = '(first, (second, [third, fourth]))'\\n\", \"spread_assignment_in_list_target = '[first, *rest]'\\n\", \"nested_spread_assignment_in_list = '(first, [second, *rest])'\\n\", 'multiple_level_nested_spread_assign_in_list = (\\n', \"regular_assignment = '{0} = some()'\\n\", 'for_assignment = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_multiple_assignments = \"\"\"\\n', '    list_target,\\n', '    spread_assignment_in_list_target,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnpackingIterableToListViolation])\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    list_target,\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    spread_assignment_in_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "ing iterable to nested list is restricted.\"\"\"\n    tree = parse_ast_tree(code.format(assignment))\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "618": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_to_list.py",
  "lineno": "127",
  "column": "4",
  "slicing": "[\"list_target = '[first, second]'\\n\", \"nested_list_target0 = '([first, second], third)'\\n\", \"nested_list_target1 = '(first, [second, third])'\\n\", \"nested_list_target2 = '(first, (second, [third, fourth]))'\\n\", \"multiple_level_nested_list_target = '(first, (second, [third, fourth]))'\\n\", \"spread_assignment_in_list_target = '[first, *rest]'\\n\", \"nested_spread_assignment_in_list = '(first, [second, *rest])'\\n\", 'multiple_level_nested_spread_assign_in_list = (\\n', \"regular_assignment = '{0} = some()'\\n\", 'for_assignment = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_multiple_assignments = \"\"\"\\n', '    list_target,\\n', '    spread_assignment_in_list_target,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnpackingIterableToListViolation])\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    list_target,\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    spread_assignment_in_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "ee = parse_ast_tree(code.format(assignment))\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "619": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_to_list.py",
  "lineno": "155",
  "column": "4",
  "slicing": "[\"list_target = '[first, second]'\\n\", \"nested_list_target0 = '([first, second], third)'\\n\", \"nested_list_target1 = '(first, [second, third])'\\n\", \"nested_list_target2 = '(first, (second, [third, fourth]))'\\n\", \"multiple_level_nested_list_target = '(first, (second, [third, fourth]))'\\n\", \"spread_assignment_in_list_target = '[first, *rest]'\\n\", \"nested_spread_assignment_in_list = '(first, [second, *rest])'\\n\", 'multiple_level_nested_spread_assign_in_list = (\\n', \"regular_assignment = '{0} = some()'\\n\", 'for_assignment = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_multiple_assignments = \"\"\"\\n', '    list_target,\\n', '    spread_assignment_in_list_target,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnpackingIterableToListViolation])\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    list_target,\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    spread_assignment_in_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "le to list in middle target is restricted.\"\"\"\n    tree = parse_ast_tree(code.format(assignment))\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "620": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_to_list.py",
  "lineno": "157",
  "column": "4",
  "slicing": "[\"list_target = '[first, second]'\\n\", \"nested_list_target0 = '([first, second], third)'\\n\", \"nested_list_target1 = '(first, [second, third])'\\n\", \"nested_list_target2 = '(first, (second, [third, fourth]))'\\n\", \"multiple_level_nested_list_target = '(first, (second, [third, fourth]))'\\n\", \"spread_assignment_in_list_target = '[first, *rest]'\\n\", \"nested_spread_assignment_in_list = '(first, [second, *rest])'\\n\", 'multiple_level_nested_spread_assign_in_list = (\\n', \"regular_assignment = '{0} = some()'\\n\", 'for_assignment = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_multiple_assignments = \"\"\"\\n', '    list_target,\\n', '    spread_assignment_in_list_target,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnpackingIterableToListViolation])\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    regular_assignment,\\n', '    for_assignment,\\n', '    list_comprehension,\\n', '    generator_expression,\\n', '    set_comprehension,\\n', '    dict_comprehension,\\n', '    with_assignment,\\n', '    with_multiple_assignments,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    list_target,\\n', '    nested_list_target0,\\n', '    nested_list_target1,\\n', '    nested_list_target2,\\n', '    multiple_level_nested_list_target,\\n', '    spread_assignment_in_list_target,\\n', '    nested_spread_assignment_in_list,\\n', '    multiple_level_nested_spread_assign_in_list,\\n', '    tree = parse_ast_tree(code.format(assignment))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "ee = parse_ast_tree(code.format(assignment))\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "621": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "117",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": " \"\"\"Testing that correct assignments work.\"\"\"\n    tree = parse_ast_tree(mode(code.format('some_name', target)))\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "622": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "119",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "tree(mode(code.format('some_name', target)))\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "623": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "138",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": " \"\"\"Testing that correct assignments work.\"\"\"\n    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "624": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "140",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "(mode(single_assignment.format(assignment)))\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "625": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "184",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": " that multiple assignments are restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(assignment, target)))\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "626": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "186",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "_tree(mode(code.format(assignment, target)))\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "627": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "204",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": " that correct elements destructuring work.\"\"\"\n    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "628": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "206",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "orrect_single_destructuring.format(target)))\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "629": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "232",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "ingle element destructuring is restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(assignment)))\n\n    visitor = WrongAssignmentVisitor(default_opti"
 },
 "630": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongAssignmentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_assign/test_unpacking_rules.py",
  "lineno": "234",
  "column": "4",
  "slicing": "[\"single_assignment = '{0} = 1'\\n\", \"sequence_assignment1 = 'first, {0} = {1}'\\n\", \"sequence_assignment2 = '{0}, second = {1}'\\n\", \"tuple_assignment1 = 'first, {0} = (1, 2)'\\n\", \"tuple_assignment2 = '{0}, second = (1, 2)'\\n\", \"spread_assignment1 = '{0}, *second = [1, 2, 3]'\\n\", \"spread_assignment2 = 'first, *{0} = [1, 2, 3]'\\n\", 'for_assignment = \"\"\"\\n', 'for_unpacking1 = \"\"\"\\n', 'for_unpacking2 = \"\"\"\\n', 'list_comprehension = \"\"\"\\n', 'dict_comprehension = \"\"\"\\n', 'set_comprehension = \"\"\"\\n', 'generator_expression = \"\"\"\\n', 'with_assignment = \"\"\"\\n', 'with_unpacking1 = \"\"\"\\n', 'with_unpacking2 = \"\"\"\\n', \"correct_single_destructuring = 'first = {0}'\\n\", '    single_assignment,\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_assignment,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_assignment,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', \"    tree = parse_ast_tree(mode(code.format('some_name', target)))\\n\", '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_assignment.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    sequence_assignment1,\\n', '    sequence_assignment2,\\n', '    tuple_assignment1,\\n', '    tuple_assignment2,\\n', '    spread_assignment1,\\n', '    spread_assignment2,\\n', '    for_unpacking1,\\n', '    for_unpacking2,\\n', '    list_comprehension,\\n', '    dict_comprehension,\\n', '    set_comprehension,\\n', '    generator_expression,\\n', '    with_unpacking1,\\n', '    with_unpacking2,\\n', '    tree = parse_ast_tree(mode(code.format(assignment, target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnpackingViolation])\\n', '    tree = parse_ast_tree(mode(correct_single_destructuring.format(target)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code.format(assignment)))\\n', '    visitor = WrongAssignmentVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "arse_ast_tree(mode(code.format(assignment)))\n\n    visitor = WrongAssignmentVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "631": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_alphabet_string.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(\\'{0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation])\\n', '    assert_error_text(visitor, code)\\n', '    tree = parse_ast_tree(\\'f\"{0}\"\\'.format(string.ascii_letters))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation], (\\n', '    tree = parse_ast_tree(\\'\"{0}\"\\'.format(code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "esting that the strings violate the rules.\"\"\"\n    tree = parse_ast_tree('{0}\"{1}\"'.format(prefix, code))\n\n    visitor = WrongStringVisitor(default_options,"
 },
 "632": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_alphabet_string.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(\\'{0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation])\\n', '    assert_error_text(visitor, code)\\n', '    tree = parse_ast_tree(\\'f\"{0}\"\\'.format(string.ascii_letters))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation], (\\n', '    tree = parse_ast_tree(\\'\"{0}\"\\'.format(code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "se_ast_tree('{0}\"{1}\"'.format(prefix, code))\n\n    visitor = WrongStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Str"
 },
 "633": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_alphabet_string.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(\\'{0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation])\\n', '    assert_error_text(visitor, code)\\n', '    tree = parse_ast_tree(\\'f\"{0}\"\\'.format(string.ascii_letters))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation], (\\n', '    tree = parse_ast_tree(\\'\"{0}\"\\'.format(code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "sting that the fstrings violate the rules.\"\"\"\n    tree = parse_ast_tree('f\"{0}\"'.format(string.ascii_letters))\n\n    visitor = WrongStringVisitor(default_options,"
 },
 "634": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_alphabet_string.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(\\'{0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation])\\n', '    assert_error_text(visitor, code)\\n', '    tree = parse_ast_tree(\\'f\"{0}\"\\'.format(string.ascii_letters))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation], (\\n', '    tree = parse_ast_tree(\\'\"{0}\"\\'.format(code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_tree('f\"{0}\"'.format(string.ascii_letters))\n\n    visitor = WrongStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Str"
 },
 "635": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_alphabet_string.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(\\'{0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation])\\n', '    assert_error_text(visitor, code)\\n', '    tree = parse_ast_tree(\\'f\"{0}\"\\'.format(string.ascii_letters))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation], (\\n', '    tree = parse_ast_tree(\\'\"{0}\"\\'.format(code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing that regular strings work well.\"\"\"\n    tree = parse_ast_tree('\"{0}\"'.format(code))\n\n    visitor = WrongStringVisitor(default_options,"
 },
 "636": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_alphabet_string.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(\\'{0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation])\\n', '    assert_error_text(visitor, code)\\n', '    tree = parse_ast_tree(\\'f\"{0}\"\\'.format(string.ascii_letters))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StringConstantRedefinedViolation], (\\n', '    tree = parse_ast_tree(\\'\"{0}\"\\'.format(code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " tree = parse_ast_tree('\"{0}\"'.format(code))\n\n    visitor = WrongStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "637": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_formatted_string.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['regular_string = \"\\'some value\\'\"\\n', 'binary_string = \"b\\'binary\\'\"\\n', 'unicode_string = \"u\\'unicode\\'\"\\n', 'string_variable = \"some = \\'123\\'\"\\n', 'formatted_string = \"\\'x + y = {0}\\'.format(2)\"\\n', 'key_formatted_string = \"\\'x + y = {res}\\'.format(res=2)\"\\n', 'variable_format = \"\"\"\\n', 'f_string = \"f\\'x + y = {2 + 2}\\'\"\\n', 'f_double_indexing = \"f\\'{list[0][1]}\\'\"\\n', 'f_calling_returned_function = \"f\\'{calling_returned_function()()}\\'\"\\n', 'f_empty_string = \"f\\'\\'\"\\n', 'f_complex_f_string = \"\"\"\\n', 'f_function_with_args = \"f\\'smth {func(arg)}\\'\"\\n', 'f_dict_lookup_function_empty_args = \"f\\'smth {dict_value[func()]}\\'\"\\n', 'f_list_slice_lookup = \"f\\'smth {list[:]}\\'\"\\n', 'f_attr_on_returned_value = \"f\\'{some.call().attr}\\'\"\\n', 'f_function_on_attr = \"f\\'{some.attr.call()}\\'\"\\n', 'f_array_object = \"f\\'{some.first[0].attr.other}\\'\"\\n', 'f_double_chained_attr = \"f\\'{attr1.attr2.attr3}\\'\"\\n', 'f_triple_call = \"f\\'{foo()()()}\\'\"\\n', 'f_triple_lookup = \"f\\'{arr[0][1][2]}\\'\"\\n', 'f_double_call_arg = \"f\\'{foo()(arg)}\\'\"\\n', 'f_single_chained_functions = \"f\\'{f1().f2()}\\'\"\\n', '    regular_string,\\n', '    binary_string,\\n', '    unicode_string,\\n', '    string_variable,\\n', '    formatted_string,\\n', '    key_formatted_string,\\n', '    variable_format,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    f_empty_string,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    f_complex_f_string,\\n', '    f_function_with_args,\\n', '    f_dict_lookup_function_empty_args,\\n', '    f_string,\\n', '    f_list_slice_lookup,\\n', '    f_attr_on_returned_value,\\n', '    f_function_on_attr,\\n', '    f_array_object,\\n', '    f_double_chained_attr,\\n', '    f_triple_call,\\n', '    f_triple_lookup,\\n', '    f_double_call_arg,\\n', '    f_double_indexing,\\n', '    f_calling_returned_function,\\n', '    f_single_chained_functions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FormattedStringViolation])\\n']",
  "context": "\"\"\"Testing that regular strings work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongStringVisitor(default_options,"
 },
 "638": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_formatted_string.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['regular_string = \"\\'some value\\'\"\\n', 'binary_string = \"b\\'binary\\'\"\\n', 'unicode_string = \"u\\'unicode\\'\"\\n', 'string_variable = \"some = \\'123\\'\"\\n', 'formatted_string = \"\\'x + y = {0}\\'.format(2)\"\\n', 'key_formatted_string = \"\\'x + y = {res}\\'.format(res=2)\"\\n', 'variable_format = \"\"\"\\n', 'f_string = \"f\\'x + y = {2 + 2}\\'\"\\n', 'f_double_indexing = \"f\\'{list[0][1]}\\'\"\\n', 'f_calling_returned_function = \"f\\'{calling_returned_function()()}\\'\"\\n', 'f_empty_string = \"f\\'\\'\"\\n', 'f_complex_f_string = \"\"\"\\n', 'f_function_with_args = \"f\\'smth {func(arg)}\\'\"\\n', 'f_dict_lookup_function_empty_args = \"f\\'smth {dict_value[func()]}\\'\"\\n', 'f_list_slice_lookup = \"f\\'smth {list[:]}\\'\"\\n', 'f_attr_on_returned_value = \"f\\'{some.call().attr}\\'\"\\n', 'f_function_on_attr = \"f\\'{some.attr.call()}\\'\"\\n', 'f_array_object = \"f\\'{some.first[0].attr.other}\\'\"\\n', 'f_double_chained_attr = \"f\\'{attr1.attr2.attr3}\\'\"\\n', 'f_triple_call = \"f\\'{foo()()()}\\'\"\\n', 'f_triple_lookup = \"f\\'{arr[0][1][2]}\\'\"\\n', 'f_double_call_arg = \"f\\'{foo()(arg)}\\'\"\\n', 'f_single_chained_functions = \"f\\'{f1().f2()}\\'\"\\n', '    regular_string,\\n', '    binary_string,\\n', '    unicode_string,\\n', '    string_variable,\\n', '    formatted_string,\\n', '    key_formatted_string,\\n', '    variable_format,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    f_empty_string,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    f_complex_f_string,\\n', '    f_function_with_args,\\n', '    f_dict_lookup_function_empty_args,\\n', '    f_string,\\n', '    f_list_slice_lookup,\\n', '    f_attr_on_returned_value,\\n', '    f_function_on_attr,\\n', '    f_array_object,\\n', '    f_double_chained_attr,\\n', '    f_triple_call,\\n', '    f_triple_lookup,\\n', '    f_double_call_arg,\\n', '    f_double_indexing,\\n', '    f_calling_returned_function,\\n', '    f_single_chained_functions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FormattedStringViolation])\\n']",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "639": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_formatted_string.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['regular_string = \"\\'some value\\'\"\\n', 'binary_string = \"b\\'binary\\'\"\\n', 'unicode_string = \"u\\'unicode\\'\"\\n', 'string_variable = \"some = \\'123\\'\"\\n', 'formatted_string = \"\\'x + y = {0}\\'.format(2)\"\\n', 'key_formatted_string = \"\\'x + y = {res}\\'.format(res=2)\"\\n', 'variable_format = \"\"\"\\n', 'f_string = \"f\\'x + y = {2 + 2}\\'\"\\n', 'f_double_indexing = \"f\\'{list[0][1]}\\'\"\\n', 'f_calling_returned_function = \"f\\'{calling_returned_function()()}\\'\"\\n', 'f_empty_string = \"f\\'\\'\"\\n', 'f_complex_f_string = \"\"\"\\n', 'f_function_with_args = \"f\\'smth {func(arg)}\\'\"\\n', 'f_dict_lookup_function_empty_args = \"f\\'smth {dict_value[func()]}\\'\"\\n', 'f_list_slice_lookup = \"f\\'smth {list[:]}\\'\"\\n', 'f_attr_on_returned_value = \"f\\'{some.call().attr}\\'\"\\n', 'f_function_on_attr = \"f\\'{some.attr.call()}\\'\"\\n', 'f_array_object = \"f\\'{some.first[0].attr.other}\\'\"\\n', 'f_double_chained_attr = \"f\\'{attr1.attr2.attr3}\\'\"\\n', 'f_triple_call = \"f\\'{foo()()()}\\'\"\\n', 'f_triple_lookup = \"f\\'{arr[0][1][2]}\\'\"\\n', 'f_double_call_arg = \"f\\'{foo()(arg)}\\'\"\\n', 'f_single_chained_functions = \"f\\'{f1().f2()}\\'\"\\n', '    regular_string,\\n', '    binary_string,\\n', '    unicode_string,\\n', '    string_variable,\\n', '    formatted_string,\\n', '    key_formatted_string,\\n', '    variable_format,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    f_empty_string,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    f_complex_f_string,\\n', '    f_function_with_args,\\n', '    f_dict_lookup_function_empty_args,\\n', '    f_string,\\n', '    f_list_slice_lookup,\\n', '    f_attr_on_returned_value,\\n', '    f_function_on_attr,\\n', '    f_array_object,\\n', '    f_double_chained_attr,\\n', '    f_triple_call,\\n', '    f_triple_lookup,\\n', '    f_double_call_arg,\\n', '    f_double_indexing,\\n', '    f_calling_returned_function,\\n', '    f_single_chained_functions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FormattedStringViolation])\\n']",
  "context": "ations are raised when reaching max value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFormatStringVisitor(default_op"
 },
 "640": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongFormatStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_formatted_string.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['regular_string = \"\\'some value\\'\"\\n', 'binary_string = \"b\\'binary\\'\"\\n', 'unicode_string = \"u\\'unicode\\'\"\\n', 'string_variable = \"some = \\'123\\'\"\\n', 'formatted_string = \"\\'x + y = {0}\\'.format(2)\"\\n', 'key_formatted_string = \"\\'x + y = {res}\\'.format(res=2)\"\\n', 'variable_format = \"\"\"\\n', 'f_string = \"f\\'x + y = {2 + 2}\\'\"\\n', 'f_double_indexing = \"f\\'{list[0][1]}\\'\"\\n', 'f_calling_returned_function = \"f\\'{calling_returned_function()()}\\'\"\\n', 'f_empty_string = \"f\\'\\'\"\\n', 'f_complex_f_string = \"\"\"\\n', 'f_function_with_args = \"f\\'smth {func(arg)}\\'\"\\n', 'f_dict_lookup_function_empty_args = \"f\\'smth {dict_value[func()]}\\'\"\\n', 'f_list_slice_lookup = \"f\\'smth {list[:]}\\'\"\\n', 'f_attr_on_returned_value = \"f\\'{some.call().attr}\\'\"\\n', 'f_function_on_attr = \"f\\'{some.attr.call()}\\'\"\\n', 'f_array_object = \"f\\'{some.first[0].attr.other}\\'\"\\n', 'f_double_chained_attr = \"f\\'{attr1.attr2.attr3}\\'\"\\n', 'f_triple_call = \"f\\'{foo()()()}\\'\"\\n', 'f_triple_lookup = \"f\\'{arr[0][1][2]}\\'\"\\n', 'f_double_call_arg = \"f\\'{foo()(arg)}\\'\"\\n', 'f_single_chained_functions = \"f\\'{f1().f2()}\\'\"\\n', '    regular_string,\\n', '    binary_string,\\n', '    unicode_string,\\n', '    string_variable,\\n', '    formatted_string,\\n', '    key_formatted_string,\\n', '    variable_format,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    f_empty_string,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    f_complex_f_string,\\n', '    f_function_with_args,\\n', '    f_dict_lookup_function_empty_args,\\n', '    f_string,\\n', '    f_list_slice_lookup,\\n', '    f_attr_on_returned_value,\\n', '    f_function_on_attr,\\n', '    f_array_object,\\n', '    f_double_chained_attr,\\n', '    f_triple_call,\\n', '    f_triple_lookup,\\n', '    f_double_call_arg,\\n', '    f_double_indexing,\\n', '    f_calling_returned_function,\\n', '    f_single_chained_functions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FormattedStringViolation])\\n']",
  "context": "ax value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFormatStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "641": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_formatted_string.py",
  "lineno": "113",
  "column": "4",
  "slicing": "['regular_string = \"\\'some value\\'\"\\n', 'binary_string = \"b\\'binary\\'\"\\n', 'unicode_string = \"u\\'unicode\\'\"\\n', 'string_variable = \"some = \\'123\\'\"\\n', 'formatted_string = \"\\'x + y = {0}\\'.format(2)\"\\n', 'key_formatted_string = \"\\'x + y = {res}\\'.format(res=2)\"\\n', 'variable_format = \"\"\"\\n', 'f_string = \"f\\'x + y = {2 + 2}\\'\"\\n', 'f_double_indexing = \"f\\'{list[0][1]}\\'\"\\n', 'f_calling_returned_function = \"f\\'{calling_returned_function()()}\\'\"\\n', 'f_empty_string = \"f\\'\\'\"\\n', 'f_complex_f_string = \"\"\"\\n', 'f_function_with_args = \"f\\'smth {func(arg)}\\'\"\\n', 'f_dict_lookup_function_empty_args = \"f\\'smth {dict_value[func()]}\\'\"\\n', 'f_list_slice_lookup = \"f\\'smth {list[:]}\\'\"\\n', 'f_attr_on_returned_value = \"f\\'{some.call().attr}\\'\"\\n', 'f_function_on_attr = \"f\\'{some.attr.call()}\\'\"\\n', 'f_array_object = \"f\\'{some.first[0].attr.other}\\'\"\\n', 'f_double_chained_attr = \"f\\'{attr1.attr2.attr3}\\'\"\\n', 'f_triple_call = \"f\\'{foo()()()}\\'\"\\n', 'f_triple_lookup = \"f\\'{arr[0][1][2]}\\'\"\\n', 'f_double_call_arg = \"f\\'{foo()(arg)}\\'\"\\n', 'f_single_chained_functions = \"f\\'{f1().f2()}\\'\"\\n', '    regular_string,\\n', '    binary_string,\\n', '    unicode_string,\\n', '    string_variable,\\n', '    formatted_string,\\n', '    key_formatted_string,\\n', '    variable_format,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    f_empty_string,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    f_complex_f_string,\\n', '    f_function_with_args,\\n', '    f_dict_lookup_function_empty_args,\\n', '    f_string,\\n', '    f_list_slice_lookup,\\n', '    f_attr_on_returned_value,\\n', '    f_function_on_attr,\\n', '    f_array_object,\\n', '    f_double_chained_attr,\\n', '    f_triple_call,\\n', '    f_triple_lookup,\\n', '    f_double_call_arg,\\n', '    f_double_indexing,\\n', '    f_calling_returned_function,\\n', '    f_single_chained_functions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FormattedStringViolation])\\n']",
  "context": "hat complex ``f`` strings are not allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFormatStringVisitor(default_op"
 },
 "642": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongFormatStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_formatted_string.py",
  "lineno": "115",
  "column": "4",
  "slicing": "['regular_string = \"\\'some value\\'\"\\n', 'binary_string = \"b\\'binary\\'\"\\n', 'unicode_string = \"u\\'unicode\\'\"\\n', 'string_variable = \"some = \\'123\\'\"\\n', 'formatted_string = \"\\'x + y = {0}\\'.format(2)\"\\n', 'key_formatted_string = \"\\'x + y = {res}\\'.format(res=2)\"\\n', 'variable_format = \"\"\"\\n', 'f_string = \"f\\'x + y = {2 + 2}\\'\"\\n', 'f_double_indexing = \"f\\'{list[0][1]}\\'\"\\n', 'f_calling_returned_function = \"f\\'{calling_returned_function()()}\\'\"\\n', 'f_empty_string = \"f\\'\\'\"\\n', 'f_complex_f_string = \"\"\"\\n', 'f_function_with_args = \"f\\'smth {func(arg)}\\'\"\\n', 'f_dict_lookup_function_empty_args = \"f\\'smth {dict_value[func()]}\\'\"\\n', 'f_list_slice_lookup = \"f\\'smth {list[:]}\\'\"\\n', 'f_attr_on_returned_value = \"f\\'{some.call().attr}\\'\"\\n', 'f_function_on_attr = \"f\\'{some.attr.call()}\\'\"\\n', 'f_array_object = \"f\\'{some.first[0].attr.other}\\'\"\\n', 'f_double_chained_attr = \"f\\'{attr1.attr2.attr3}\\'\"\\n', 'f_triple_call = \"f\\'{foo()()()}\\'\"\\n', 'f_triple_lookup = \"f\\'{arr[0][1][2]}\\'\"\\n', 'f_double_call_arg = \"f\\'{foo()(arg)}\\'\"\\n', 'f_single_chained_functions = \"f\\'{f1().f2()}\\'\"\\n', '    regular_string,\\n', '    binary_string,\\n', '    unicode_string,\\n', '    string_variable,\\n', '    formatted_string,\\n', '    key_formatted_string,\\n', '    variable_format,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    f_empty_string,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    f_complex_f_string,\\n', '    f_function_with_args,\\n', '    f_dict_lookup_function_empty_args,\\n', '    f_string,\\n', '    f_list_slice_lookup,\\n', '    f_attr_on_returned_value,\\n', '    f_function_on_attr,\\n', '    f_array_object,\\n', '    f_double_chained_attr,\\n', '    f_triple_call,\\n', '    f_triple_lookup,\\n', '    f_double_call_arg,\\n', '    f_double_indexing,\\n', '    f_calling_returned_function,\\n', '    f_single_chained_functions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FormattedStringViolation])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFormatStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "643": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_formatted_string.py",
  "lineno": "138",
  "column": "4",
  "slicing": "['regular_string = \"\\'some value\\'\"\\n', 'binary_string = \"b\\'binary\\'\"\\n', 'unicode_string = \"u\\'unicode\\'\"\\n', 'string_variable = \"some = \\'123\\'\"\\n', 'formatted_string = \"\\'x + y = {0}\\'.format(2)\"\\n', 'key_formatted_string = \"\\'x + y = {res}\\'.format(res=2)\"\\n', 'variable_format = \"\"\"\\n', 'f_string = \"f\\'x + y = {2 + 2}\\'\"\\n', 'f_double_indexing = \"f\\'{list[0][1]}\\'\"\\n', 'f_calling_returned_function = \"f\\'{calling_returned_function()()}\\'\"\\n', 'f_empty_string = \"f\\'\\'\"\\n', 'f_complex_f_string = \"\"\"\\n', 'f_function_with_args = \"f\\'smth {func(arg)}\\'\"\\n', 'f_dict_lookup_function_empty_args = \"f\\'smth {dict_value[func()]}\\'\"\\n', 'f_list_slice_lookup = \"f\\'smth {list[:]}\\'\"\\n', 'f_attr_on_returned_value = \"f\\'{some.call().attr}\\'\"\\n', 'f_function_on_attr = \"f\\'{some.attr.call()}\\'\"\\n', 'f_array_object = \"f\\'{some.first[0].attr.other}\\'\"\\n', 'f_double_chained_attr = \"f\\'{attr1.attr2.attr3}\\'\"\\n', 'f_triple_call = \"f\\'{foo()()()}\\'\"\\n', 'f_triple_lookup = \"f\\'{arr[0][1][2]}\\'\"\\n', 'f_double_call_arg = \"f\\'{foo()(arg)}\\'\"\\n', 'f_single_chained_functions = \"f\\'{f1().f2()}\\'\"\\n', '    regular_string,\\n', '    binary_string,\\n', '    unicode_string,\\n', '    string_variable,\\n', '    formatted_string,\\n', '    key_formatted_string,\\n', '    variable_format,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    f_empty_string,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    f_complex_f_string,\\n', '    f_function_with_args,\\n', '    f_dict_lookup_function_empty_args,\\n', '    f_string,\\n', '    f_list_slice_lookup,\\n', '    f_attr_on_returned_value,\\n', '    f_function_on_attr,\\n', '    f_array_object,\\n', '    f_double_chained_attr,\\n', '    f_triple_call,\\n', '    f_triple_lookup,\\n', '    f_double_call_arg,\\n', '    f_double_indexing,\\n', '    f_calling_returned_function,\\n', '    f_single_chained_functions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FormattedStringViolation])\\n']",
  "context": "hat non complex ``f`` strings are allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFormatStringVisitor(default_op"
 },
 "644": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongFormatStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_formatted_string.py",
  "lineno": "140",
  "column": "4",
  "slicing": "['regular_string = \"\\'some value\\'\"\\n', 'binary_string = \"b\\'binary\\'\"\\n', 'unicode_string = \"u\\'unicode\\'\"\\n', 'string_variable = \"some = \\'123\\'\"\\n', 'formatted_string = \"\\'x + y = {0}\\'.format(2)\"\\n', 'key_formatted_string = \"\\'x + y = {res}\\'.format(res=2)\"\\n', 'variable_format = \"\"\"\\n', 'f_string = \"f\\'x + y = {2 + 2}\\'\"\\n', 'f_double_indexing = \"f\\'{list[0][1]}\\'\"\\n', 'f_calling_returned_function = \"f\\'{calling_returned_function()()}\\'\"\\n', 'f_empty_string = \"f\\'\\'\"\\n', 'f_complex_f_string = \"\"\"\\n', 'f_function_with_args = \"f\\'smth {func(arg)}\\'\"\\n', 'f_dict_lookup_function_empty_args = \"f\\'smth {dict_value[func()]}\\'\"\\n', 'f_list_slice_lookup = \"f\\'smth {list[:]}\\'\"\\n', 'f_attr_on_returned_value = \"f\\'{some.call().attr}\\'\"\\n', 'f_function_on_attr = \"f\\'{some.attr.call()}\\'\"\\n', 'f_array_object = \"f\\'{some.first[0].attr.other}\\'\"\\n', 'f_double_chained_attr = \"f\\'{attr1.attr2.attr3}\\'\"\\n', 'f_triple_call = \"f\\'{foo()()()}\\'\"\\n', 'f_triple_lookup = \"f\\'{arr[0][1][2]}\\'\"\\n', 'f_double_call_arg = \"f\\'{foo()(arg)}\\'\"\\n', 'f_single_chained_functions = \"f\\'{f1().f2()}\\'\"\\n', '    regular_string,\\n', '    binary_string,\\n', '    unicode_string,\\n', '    string_variable,\\n', '    formatted_string,\\n', '    key_formatted_string,\\n', '    variable_format,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    f_empty_string,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    f_complex_f_string,\\n', '    f_function_with_args,\\n', '    f_dict_lookup_function_empty_args,\\n', '    f_string,\\n', '    f_list_slice_lookup,\\n', '    f_attr_on_returned_value,\\n', '    f_function_on_attr,\\n', '    f_array_object,\\n', '    f_double_chained_attr,\\n', '    f_triple_call,\\n', '    f_triple_lookup,\\n', '    f_double_call_arg,\\n', '    f_double_indexing,\\n', '    f_calling_returned_function,\\n', '    f_single_chained_functions,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFormatStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FormattedStringViolation])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFormatStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [For"
 },
 "645": {
  "name": "_PREFIXES",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "12",
  "column": "0",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\"]",
  "context": ".visitors.ast.builtins import WrongStringVisitor\n\n_PREFIXES = (\n    '',\n    'b',\n    'u',\n    'r',\n    'rb',\n    '"
 },
 "646": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "94",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "esting that the strings violate the rules.\"\"\"\n    tree = parse_ast_tree('x = {0}\"{1}\"'.format(prefix, code))\n\n    visitor = WrongStringVisitor(default_options,"
 },
 "647": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "96",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "st_tree('x = {0}\"{1}\"'.format(prefix, code))\n\n    visitor = WrongStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mod"
 },
 "648": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "142",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "esting that the strings violate the rules.\"\"\"\n    tree = parse_ast_tree('x = {0}\"{1}\"'.format(prefix, code))\n\n    visitor = WrongStringVisitor(default_options,"
 },
 "649": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "144",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "st_tree('x = {0}\"{1}\"'.format(prefix, code))\n\n    visitor = WrongStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [], "
 },
 "650": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "172",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "esting that the strings violate the rules.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongStringVisitor(default_options,"
 },
 "651": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "174",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "he rules.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [], "
 },
 "652": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "194",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at the modulo operations are not affected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongStringVisitor(default_options,"
 },
 "653": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "196",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "affected.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "654": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "215",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"Testing that the docstrings are allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongStringVisitor(default_options,"
 },
 "655": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_strings/test_modulo_formatting.py",
  "lineno": "217",
  "column": "4",
  "slicing": "['_PREFIXES = (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ModuloStringFormatViolation], (\\n', \"@pytest.mark.parametrize('prefix', _PREFIXES)\\n\", '    tree = parse_ast_tree(\\'x = {0}\"{1}\"\\'.format(prefix, code))\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], (FormattedStringViolation,))\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongStringVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongStringVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "656": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "48",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": "ts can be contained in set multiple times.\"\"\"\n    tree = parse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_opti"
 },
 "657": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongCollectionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "50",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": "arse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "658": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "82",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": "\"Testing that unique elements are allowed.\"\"\"\n    tree = parse_ast_tree(code.format(element, 'other'))\n\n    visitor = WrongCollectionVisitor(default_opti"
 },
 "659": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongCollectionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "84",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": "arse_ast_tree(code.format(element, 'other'))\n\n    visitor = WrongCollectionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "660": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "115",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": "ements cannot be contained multiple times.\"\"\"\n    tree = parse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_opti"
 },
 "661": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongCollectionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "117",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": "arse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Non"
 },
 "662": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "140",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": "ements cannot be contained multiple times.\"\"\"\n    tree = parse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_opti"
 },
 "663": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongCollectionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "142",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": "arse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Non"
 },
 "664": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "169",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": " \"\"\"Testing that same values are reported.\"\"\"\n    tree = parse_ast_tree(code.format(first, second))\n\n    visitor = WrongCollectionVisitor(default_opti"
 },
 "665": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongCollectionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_elements.py",
  "lineno": "171",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", \"regression769 = '{{ **{0}, **{1} }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    regression769,\\n', \"    tree = parse_ast_tree(code.format(element, 'other'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NonUniqueItemsInHashViolation])\\n']",
  "context": "= parse_ast_tree(code.format(first, second))\n\n    visitor = WrongCollectionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Non"
 },
 "666": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_hashable.py",
  "lineno": "50",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', \"    tree = parse_ast_tree(code.format(element, 'correct'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnhashableTypeInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": " impure elements can be contained in hash.\"\"\"\n    tree = parse_ast_tree(code.format(element, 'correct'))\n\n    visitor = WrongCollectionVisitor(default_opti"
 },
 "667": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongCollectionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_hashable.py",
  "lineno": "52",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', \"    tree = parse_ast_tree(code.format(element, 'correct'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnhashableTypeInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "se_ast_tree(code.format(element, 'correct'))\n\n    visitor = WrongCollectionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unh"
 },
 "668": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_hashable.py",
  "lineno": "80",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', \"    tree = parse_ast_tree(code.format(element, 'correct'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnhashableTypeInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": " impure elements can be contained in hash.\"\"\"\n    tree = parse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_opti"
 },
 "669": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongCollectionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_hash_hashable.py",
  "lineno": "82",
  "column": "4",
  "slicing": "[\"set_literal_template = '{{{0}, {1}}}'\\n\", 'nested_set_template = \"\"\"\\n', \"dict_literal_template = '{{ {0}: 1, {1}: 2 }}'\\n\", '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', \"    tree = parse_ast_tree(code.format(element, 'correct'))\\n\", '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnhashableTypeInHashViolation])\\n', '    set_literal_template,\\n', '    nested_set_template,\\n', '    dict_literal_template,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "arse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "670": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_float_keys.py",
  "lineno": "33",
  "column": "4",
  "slicing": "[\"dict_template1 = '{{ {0}: 1 }}'\\n\", \"dict_template2 = '{{ {0}: {0} }}'\\n\", \"dict_template3 = '{{ {0}: 1, **kwargs }}'\\n\", \"dict_template4 = '{{ {0}: 1, other: value }}'\\n\", '    dict_template1,\\n', '    dict_template2,\\n', '    dict_template3,\\n', '    dict_template4,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatKeyViolation])\\n', '    dict_template1,\\n', '    dict_template2,\\n', '    dict_template3,\\n', '    dict_template4,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"Testing that float keys are not allowed.\"\"\"\n    tree = parse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_opti"
 },
 "671": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongCollectionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_float_keys.py",
  "lineno": "35",
  "column": "4",
  "slicing": "[\"dict_template1 = '{{ {0}: 1 }}'\\n\", \"dict_template2 = '{{ {0}: {0} }}'\\n\", \"dict_template3 = '{{ {0}: 1, **kwargs }}'\\n\", \"dict_template4 = '{{ {0}: 1, other: value }}'\\n\", '    dict_template1,\\n', '    dict_template2,\\n', '    dict_template3,\\n', '    dict_template4,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatKeyViolation])\\n', '    dict_template1,\\n', '    dict_template2,\\n', '    dict_template3,\\n', '    dict_template4,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "arse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Flo"
 },
 "672": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_float_keys.py",
  "lineno": "67",
  "column": "4",
  "slicing": "[\"dict_template1 = '{{ {0}: 1 }}'\\n\", \"dict_template2 = '{{ {0}: {0} }}'\\n\", \"dict_template3 = '{{ {0}: 1, **kwargs }}'\\n\", \"dict_template4 = '{{ {0}: 1, other: value }}'\\n\", '    dict_template1,\\n', '    dict_template2,\\n', '    dict_template3,\\n', '    dict_template4,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatKeyViolation])\\n', '    dict_template1,\\n', '    dict_template2,\\n', '    dict_template3,\\n', '    dict_template4,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Testing that regular keys are allowed.\"\"\"\n    tree = parse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_opti"
 },
 "673": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.builtins.WrongCollectionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_builtins/test_collection_hashes/test_float_keys.py",
  "lineno": "69",
  "column": "4",
  "slicing": "[\"dict_template1 = '{{ {0}: 1 }}'\\n\", \"dict_template2 = '{{ {0}: {0} }}'\\n\", \"dict_template3 = '{{ {0}: 1, **kwargs }}'\\n\", \"dict_template4 = '{{ {0}: 1, other: value }}'\\n\", '    dict_template1,\\n', '    dict_template2,\\n', '    dict_template3,\\n', '    dict_template4,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatKeyViolation])\\n', '    dict_template1,\\n', '    dict_template2,\\n', '    dict_template3,\\n', '    dict_template4,\\n', '    tree = parse_ast_tree(code.format(element, element))\\n', '    visitor = WrongCollectionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "arse_ast_tree(code.format(element, element))\n\n    visitor = WrongCollectionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "674": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_mutable_constants.py",
  "lineno": "37",
  "column": "4",
  "slicing": "[\"module_constant = 'CONST = {0}'\\n\", \"module_typed_constant = 'CONST: int = {0}'\\n\", \"module_variable = 'some_variable = {0}'\\n\", \"module_attribute = 'some.attr = {0}'\\n\", \"module_slice = 'some[0] = {0}'\\n\", '    module_constant,\\n', '    module_typed_constant,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MutableModuleConstantViolation])\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_constant,\\n', '    module_typed_constant,\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "esting that some constants are restricted.\"\"\"\n    tree = parse_ast_tree(assignment.format(code))\n\n    visitor = ModuleConstantsVisitor(default_opti"
 },
 "675": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.modules.ModuleConstantsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_mutable_constants.py",
  "lineno": "39",
  "column": "4",
  "slicing": "[\"module_constant = 'CONST = {0}'\\n\", \"module_typed_constant = 'CONST: int = {0}'\\n\", \"module_variable = 'some_variable = {0}'\\n\", \"module_attribute = 'some.attr = {0}'\\n\", \"module_slice = 'some[0] = {0}'\\n\", '    module_constant,\\n', '    module_typed_constant,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MutableModuleConstantViolation])\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_constant,\\n', '    module_typed_constant,\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(assignment.format(code))\n\n    visitor = ModuleConstantsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mut"
 },
 "676": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_mutable_constants.py",
  "lineno": "66",
  "column": "4",
  "slicing": "[\"module_constant = 'CONST = {0}'\\n\", \"module_typed_constant = 'CONST: int = {0}'\\n\", \"module_variable = 'some_variable = {0}'\\n\", \"module_attribute = 'some.attr = {0}'\\n\", \"module_slice = 'some[0] = {0}'\\n\", '    module_constant,\\n', '    module_typed_constant,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MutableModuleConstantViolation])\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_constant,\\n', '    module_typed_constant,\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "esting that some constants are restricted.\"\"\"\n    tree = parse_ast_tree(assignment.format(code))\n\n    visitor = ModuleConstantsVisitor(default_opti"
 },
 "677": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.modules.ModuleConstantsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_mutable_constants.py",
  "lineno": "68",
  "column": "4",
  "slicing": "[\"module_constant = 'CONST = {0}'\\n\", \"module_typed_constant = 'CONST: int = {0}'\\n\", \"module_variable = 'some_variable = {0}'\\n\", \"module_attribute = 'some.attr = {0}'\\n\", \"module_slice = 'some[0] = {0}'\\n\", '    module_constant,\\n', '    module_typed_constant,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MutableModuleConstantViolation])\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_constant,\\n', '    module_typed_constant,\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(assignment.format(code))\n\n    visitor = ModuleConstantsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "678": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_mutable_constants.py",
  "lineno": "99",
  "column": "4",
  "slicing": "[\"module_constant = 'CONST = {0}'\\n\", \"module_typed_constant = 'CONST: int = {0}'\\n\", \"module_variable = 'some_variable = {0}'\\n\", \"module_attribute = 'some.attr = {0}'\\n\", \"module_slice = 'some[0] = {0}'\\n\", '    module_constant,\\n', '    module_typed_constant,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MutableModuleConstantViolation])\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_constant,\\n', '    module_typed_constant,\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    \"\"\"Testing that some constants are ok.\"\"\"\n    tree = parse_ast_tree(assignment.format(code))\n\n    visitor = ModuleConstantsVisitor(default_opti"
 },
 "679": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.modules.ModuleConstantsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_mutable_constants.py",
  "lineno": "101",
  "column": "4",
  "slicing": "[\"module_constant = 'CONST = {0}'\\n\", \"module_typed_constant = 'CONST: int = {0}'\\n\", \"module_variable = 'some_variable = {0}'\\n\", \"module_attribute = 'some.attr = {0}'\\n\", \"module_slice = 'some[0] = {0}'\\n\", '    module_constant,\\n', '    module_typed_constant,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MutableModuleConstantViolation])\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_constant,\\n', '    module_typed_constant,\\n', '    module_variable,\\n', '    module_attribute,\\n', '    module_slice,\\n', '    tree = parse_ast_tree(assignment.format(code))\\n', '    visitor = ModuleConstantsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(assignment.format(code))\n\n    visitor = ModuleConstantsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "680": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_magic_module_functions.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['module_level_method = \"\"\"\\n', 'class_level_method = \"\"\"\\n', '    module_level_method,\\n', '    class_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    option_values = options(i_control_code=False)\\n', '    visitor = MagicModuleFunctionsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    visitor = MagicModuleFunctionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicModuleFunctionViolation])\\n']",
  "context": "ng magic methods with logic is restricted.\"\"\"\n    tree = parse_ast_tree(code.format(function_names))\n    option_values = options(i_control_code=False)\n"
 },
 "681": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_magic_module_functions.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['module_level_method = \"\"\"\\n', 'class_level_method = \"\"\"\\n', '    module_level_method,\\n', '    class_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    option_values = options(i_control_code=False)\\n', '    visitor = MagicModuleFunctionsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    visitor = MagicModuleFunctionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicModuleFunctionViolation])\\n']",
  "context": "= parse_ast_tree(code.format(function_names))\n    option_values = options(i_control_code=False)\n\n    visitor = MagicModuleFunctionsVisitor(option_"
 },
 "682": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.modules.MagicModuleFunctionsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_magic_module_functions.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['module_level_method = \"\"\"\\n', 'class_level_method = \"\"\"\\n', '    module_level_method,\\n', '    class_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    option_values = options(i_control_code=False)\\n', '    visitor = MagicModuleFunctionsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    visitor = MagicModuleFunctionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicModuleFunctionViolation])\\n']",
  "context": "ption_values = options(i_control_code=False)\n\n    visitor = MagicModuleFunctionsVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "683": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_magic_module_functions.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['module_level_method = \"\"\"\\n', 'class_level_method = \"\"\"\\n', '    module_level_method,\\n', '    class_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    option_values = options(i_control_code=False)\\n', '    visitor = MagicModuleFunctionsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    visitor = MagicModuleFunctionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicModuleFunctionViolation])\\n']",
  "context": "ng that some magic methods are restricted.\"\"\"\n    tree = parse_ast_tree(code.format(function_names))\n\n    visitor = MagicModuleFunctionsVisitor(default"
 },
 "684": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.modules.MagicModuleFunctionsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_magic_module_functions.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['module_level_method = \"\"\"\\n', 'class_level_method = \"\"\"\\n', '    module_level_method,\\n', '    class_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    option_values = options(i_control_code=False)\\n', '    visitor = MagicModuleFunctionsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_level_method,\\n', '    tree = parse_ast_tree(code.format(function_names))\\n', '    visitor = MagicModuleFunctionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadMagicModuleFunctionViolation])\\n']",
  "context": " parse_ast_tree(code.format(function_names))\n\n    visitor = MagicModuleFunctionsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Bad"
 },
 "685": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_empty_init.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", \"        default_options, tree=tree, filename='__init__.py',\\n\", '        tree=tree,\\n']",
  "context": " that `__init__` without logic is allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = EmptyModuleContentsVisitor(\n       "
 },
 "686": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.modules.EmptyModuleContentsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_empty_init.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [InitModuleHasLogicViolation])\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = EmptyModuleContentsVisitor(\n        default_options, tree=tree, filename='__in"
 },
 "687": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_empty_init.py",
  "lineno": "71",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", 'module_with_docstring = \"\"\"\\n', 'module_with_comments = \"\"\"\\n', '    empty_module,\\n', '    module_with_docstring,\\n', '    module_with_comments,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [InitModuleHasLogicViolation])\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that `__init__` with logic is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = EmptyModuleContentsVisitor(\n       "
 },
 "688": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.modules.EmptyModuleContentsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_empty_init.py",
  "lineno": "73",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", 'module_with_docstring = \"\"\"\\n', 'module_with_comments = \"\"\"\\n', '    empty_module,\\n', '    module_with_docstring,\\n', '    module_with_comments,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [InitModuleHasLogicViolation])\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = EmptyModuleContentsVisitor(\n        default_options, tree=tree, filename='__in"
 },
 "689": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_empty_init.py",
  "lineno": "93",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", 'module_with_docstring = \"\"\"\\n', 'module_with_comments = \"\"\"\\n', \"module_with_one_import = 'from some_module import other'\\n\", 'module_with_imports = \"\"\"\\n', 'module_with_logic = \"\"\"\\n', '    empty_module,\\n', '    module_with_docstring,\\n', '    module_with_comments,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_imports,\\n', '    module_with_one_import,\\n', '    module_with_logic,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [InitModuleHasLogicViolation])\\n', '    module_with_imports,\\n', '    module_with_one_import,\\n', '    module_with_logic,\\n', '    tree = parse_ast_tree(code)\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that `__init__` with logic is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(i_control_code=False)"
 },
 "690": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_empty_init.py",
  "lineno": "95",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", 'module_with_docstring = \"\"\"\\n', 'module_with_comments = \"\"\"\\n', \"module_with_one_import = 'from some_module import other'\\n\", 'module_with_imports = \"\"\"\\n', 'module_with_logic = \"\"\"\\n', '    empty_module,\\n', '    module_with_docstring,\\n', '    module_with_comments,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_imports,\\n', '    module_with_one_import,\\n', '    module_with_logic,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [InitModuleHasLogicViolation])\\n', '    module_with_imports,\\n', '    module_with_one_import,\\n', '    module_with_logic,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(i_control_code=False)\\n', '        option_values,\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(i_control_code=False)\n    visitor = EmptyModuleContentsVisitor(\n        "
 },
 "691": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.modules.EmptyModuleContentsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_empty_init.py",
  "lineno": "96",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", 'module_with_docstring = \"\"\"\\n', 'module_with_comments = \"\"\"\\n', \"module_with_one_import = 'from some_module import other'\\n\", 'module_with_imports = \"\"\"\\n', 'module_with_logic = \"\"\"\\n', '    empty_module,\\n', '    module_with_docstring,\\n', '    module_with_comments,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_imports,\\n', '    module_with_one_import,\\n', '    module_with_logic,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', \"        default_options, tree=tree, filename='__init__.py',\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [InitModuleHasLogicViolation])\\n', '    module_with_imports,\\n', '    module_with_one_import,\\n', '    module_with_logic,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(i_control_code=False)\\n', '    visitor = EmptyModuleContentsVisitor(\\n', '        option_values,\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "option_values = options(i_control_code=False)\n    visitor = EmptyModuleContentsVisitor(\n        option_values,\n        tree=tree,\n        "
 },
 "692": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_empty_modules.py",
  "lineno": "24",
  "column": "4",
  "slicing": "[\"    tree = parse_ast_tree('')\\n\", '        default_options, tree=tree, filename=filename,\\n']",
  "context": "hat simple file names should not be empty.\"\"\"\n    tree = parse_ast_tree('')\n\n    visitor = EmptyModuleContentsVisitor(\n       "
 },
 "693": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.modules.EmptyModuleContentsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_modules/test_empty_modules.py",
  "lineno": "26",
  "column": "4",
  "slicing": "[\"    tree = parse_ast_tree('')\\n\", '    visitor = EmptyModuleContentsVisitor(\\n', '        default_options, tree=tree, filename=filename,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyModuleViolation])\\n']",
  "context": "t be empty.\"\"\"\n    tree = parse_ast_tree('')\n\n    visitor = EmptyModuleContentsVisitor(\n        default_options, tree=tree, filename=filen"
 },
 "694": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "90",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "xpression with default options works well.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = OffsetVisitor(default_options, tree"
 },
 "695": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.offset.OffsetVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "92",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ll.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = OffsetVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "696": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s/wemake-python-styleguide/issues/320\n    \"\"\"\n    tree = parse_ast_tree(real_await_nested_values)\n\n    visitor = OffsetVisitor(default_options, tree"
 },
 "697": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.offset.OffsetVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e = parse_ast_tree(real_await_nested_values)\n\n    visitor = OffsetVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "698": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "135",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ng that nested expressions are restricted.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    monkeypatch.setattr(OffsetVisitor, '_max_offs"
 },
 "699": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.offset.OffsetVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "138",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tattr(OffsetVisitor, '_max_offset_blocks', 1)\n    visitor = OffsetVisitor(default_options, tree=tree)\n    visitor.run()\n\n    errors = [TooDeepNestingVio"
 },
 "700": {
  "name": "errors",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "141",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "efault_options, tree=tree)\n    visitor.run()\n\n    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\n    assert_errors(visitor, errors)\n\n\n@pytest.mark."
 },
 "701": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "162",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ng that nested expressions are restricted.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    monkeypatch.setattr(OffsetVisitor, '_max_offs"
 },
 "702": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.offset.OffsetVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "165",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tattr(OffsetVisitor, '_max_offset_blocks', 1)\n    visitor = OffsetVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "703": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "180",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Ensures that real configuration works.\"\"\"\n    tree = parse_ast_tree(mode(real_nested_values))\n\n    visitor = OffsetVisitor(default_options, tree"
 },
 "704": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.offset.OffsetVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "182",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e = parse_ast_tree(mode(real_nested_values))\n\n    visitor = OffsetVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "705": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "204",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "   async def no_offset():\n        ...\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    monkeypatch.setattr(OffsetVisitor, '_max_offs"
 },
 "706": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.offset.OffsetVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_offset_visitor.py",
  "lineno": "207",
  "column": "4",
  "slicing": "['nested_if = \"\"\"\\n', 'nested_if2 = \"\"\"\\n', 'nested_for = \"\"\"\\n', 'nested_try = \"\"\"\\n', 'nested_try2 = \"\"\"\\n', 'nested_with = \"\"\"\\n', 'nested_while = \"\"\"\\n', 'real_nested_values = \"\"\"\\n', 'real_await_nested_values = \"\"\"\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_try,\\n', '    nested_try2,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(real_await_nested_values)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (nested_if, 1),\\n', '    (nested_if2, 1),\\n', '    (nested_for, 1),\\n', '    (nested_try, 2),\\n', '    (nested_try2, 4),\\n', '    (nested_with, 1),\\n', '    (nested_while, 1),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    errors = [TooDeepNestingViolation for _ in range(number_of_errors)]\\n', '    assert_errors(visitor, errors)\\n', '    nested_if,\\n', '    nested_if2,\\n', '    nested_for,\\n', '    nested_with,\\n', '    nested_while,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '8', 4)\\n\", '    tree = parse_ast_tree(mode(real_nested_values))\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepNestingViolation])\\n', \"    assert_error_text(visitor, '24', 10 * 2)\\n\", '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = OffsetVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tattr(OffsetVisitor, '_max_offset_blocks', 1)\n    visitor = OffsetVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "707": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "123",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "es that settings for string over-use work.\"\"\"\n    tree = parse_ast_tree(mode(strings.format(string_value)))\n\n    option_values = options(max_string_usages=5)\n"
 },
 "708": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "125",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ast_tree(mode(strings.format(string_value)))\n\n    option_values = options(max_string_usages=5)\n    visitor = StringOveruseVisitor(option_values, "
 },
 "709": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.overuses.StringOveruseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "126",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " option_values = options(max_string_usages=5)\n    visitor = StringOveruseVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "710": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "154",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s that over-used strings raise violations.\"\"\"\n    tree = parse_ast_tree(strings.format(prefix + string_value))\n\n    visitor = StringOveruseVisitor(default_option"
 },
 "711": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.overuses.StringOveruseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "156",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_tree(strings.format(prefix + string_value))\n\n    visitor = StringOveruseVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Ove"
 },
 "712": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "190",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " type annotations do not raise violations.\"\"\"\n    tree = parse_ast_tree(mode(strings.format(string_value)))\n\n    option_values = options(max_string_usages=0)\n"
 },
 "713": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "192",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ast_tree(mode(strings.format(string_value)))\n\n    option_values = options(max_string_usages=0)\n    visitor = StringOveruseVisitor(option_values, "
 },
 "714": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.overuses.StringOveruseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "193",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " option_values = options(max_string_usages=0)\n    visitor = StringOveruseVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "715": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "218",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " string_actions.format(prefix + string_value)\n    tree = parse_ast_tree(snippet)\n\n    visitor = StringOveruseVisitor(default_option"
 },
 "716": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.overuses.StringOveruseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_string.py",
  "lineno": "220",
  "column": "4",
  "slicing": "['string_actions = \"\"\"\\n', 'string_function_type_annotations1 = \"\"\"\\n', 'string_function_type_annotations2 = \"\"\"\\n', 'string_class_type_annotations = \"\"\"\\n', 'string_method_type_annotations1 = \"\"\"\\n', 'string_method_type_annotations2 = \"\"\"\\n', 'string_variable_type_annotations = \"\"\"\\n', 'regression1127 = \"\"\"\\n', '    string_actions,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=5)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    string_actions,\\n', '    tree = parse_ast_tree(strings.format(prefix + string_value))\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedStringViolation])\\n', '        visitor,\\n', '    string_function_type_annotations1,\\n', '    string_function_type_annotations2,\\n', '    string_class_type_annotations,\\n', '    string_method_type_annotations1,\\n', '    string_method_type_annotations2,\\n', '    string_variable_type_annotations,\\n', '    regression1127,\\n', '    tree = parse_ast_tree(mode(strings.format(string_value)))\\n', '    option_values = options(max_string_usages=0)\\n', '    visitor = StringOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    snippet = string_actions.format(prefix + string_value)\\n', '    tree = parse_ast_tree(snippet)\\n', '    visitor = StringOveruseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ng_value)\n    tree = parse_ast_tree(snippet)\n\n    visitor = StringOveruseVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "717": {
  "name": "violating_expressions",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "119",
  "column": "0",
  "slicing": "['violating_expressions = (\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", \"@pytest.mark.parametrize('expression', violating_expressions)\\n\"]",
  "context": "ny':\n        {0}\n        {0}\n\"\"\"\n\n# Expressions:\n\nviolating_expressions = (\n    # Nodes:\n    'assert 1',\n    'a and b',\n    'b"
 },
 "718": {
  "name": "ignored_expressions",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "145",
  "column": "0",
  "slicing": "['ignored_expressions = (\\n', \"@pytest.mark.parametrize('expression', ignored_expressions)\\n\"]",
  "context": "Set[int]] = call(1, 2, 3)',  # call is raising\n)\n\nignored_expressions = (\n    # super\n    'super()',\n    # special attrs\n   "
 },
 "719": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "191",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at settings for expressions over-use work.\"\"\"\n    tree = parse_ast_tree(mode(code.format(expression, expression)))\n\n    option_values = options(max_function_expressi"
 },
 "720": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "193",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e(mode(code.format(expression, expression)))\n\n    option_values = options(max_function_expressions=1)\n    visitor = ExpressionOveruseVisitor(option_valu"
 },
 "721": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.overuses.ExpressionOveruseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "194",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_values = options(max_function_expressions=1)\n    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Ove"
 },
 "722": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "212",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at settings for expressions over-use work.\"\"\"\n    tree = parse_ast_tree(code.format(expression, expression))\n\n    option_values = options(max_module_expression"
 },
 "723": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "214",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "st_tree(code.format(expression, expression))\n\n    option_values = options(max_module_expressions=1)\n    visitor = ExpressionOveruseVisitor(option_valu"
 },
 "724": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.overuses.ExpressionOveruseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "215",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "on_values = options(max_module_expressions=1)\n    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Ove"
 },
 "725": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "235",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at settings for expressions over-use work.\"\"\"\n    tree = parse_ast_tree(code.format(expression, expression))\n\n    option_values = options(\n        max_module_e"
 },
 "726": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "237",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "st_tree(code.format(expression, expression))\n\n    option_values = options(\n        max_module_expressions=1,\n        max_func"
 },
 "727": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.overuses.ExpressionOveruseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "241",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "=1,\n        max_function_expressions=1,\n    )\n    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "728": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "272",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "red expressions does not raise violations.\"\"\"\n    tree = parse_ast_tree(mode(code.format(expression, expression)))\n\n    option_values = options(max_function_expressi"
 },
 "729": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "274",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e(mode(code.format(expression, expression)))\n\n    option_values = options(max_function_expressions=1)\n    visitor = ExpressionOveruseVisitor(option_valu"
 },
 "730": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.overuses.ExpressionOveruseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_overuses/test_overused_expressions.py",
  "lineno": "275",
  "column": "4",
  "slicing": "['module_context = \"\"\"\\n', 'function_context1 = \"\"\"\\n', 'function_context2 = \"\"\"\\n', 'function_context3 = \"\"\"\\n', 'function_context4 = \"\"\"\\n', 'class_context1 = \"\"\"\\n', 'class_context2 = \"\"\"\\n', 'class_context3 = \"\"\"\\n', 'method_context1 = \"\"\"\\n', 'method_context2 = \"\"\"\\n', 'method_context3 = \"\"\"\\n', 'method_context4 = \"\"\"\\n', 'method_context5 = \"\"\"\\n', 'violating_expressions = (\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    module_context,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(max_module_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OverusedExpressionViolation])\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', \"@pytest.mark.parametrize('expression', violating_expressions)\\n\", '    tree = parse_ast_tree(code.format(expression, expression))\\n', '    option_values = options(\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_context1,\\n', '    function_context2,\\n', '    function_context3,\\n', '    function_context4,\\n', '    class_context1,\\n', '    class_context2,\\n', '    class_context3,\\n', '    method_context1,\\n', '    method_context2,\\n', '    method_context3,\\n', '    method_context4,\\n', '    method_context5,\\n', '    module_context,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_function_expressions=1)\\n', '    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_values = options(max_function_expressions=1)\n    visitor = ExpressionOveruseVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "731": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "38",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "esting that imports in a module work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ImportMembersVisitor(default_option"
 },
 "732": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.imports.ImportMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "40",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ImportMembersVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "733": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "58",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "ations are raised when reaching max value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_imports=1)\n    vi"
 },
 "734": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "60",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "ax value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_imports=1)\n    visitor = ImportMembersVisitor(option_values, "
 },
 "735": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.imports.ImportMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "61",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": ")\n\n    option_values = options(max_imports=1)\n    visitor = ImportMembersVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "736": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "80",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "ations are raised when reaching max value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_imported_names=1)"
 },
 "737": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "82",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "ax value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_imported_names=1)\n    visitor = ImportMembersVisitor(option_values, "
 },
 "738": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.imports.ImportMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "83",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "option_values = options(max_imported_names=1)\n    visitor = ImportMembersVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "739": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "102",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "ion not raised when max value not reached.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_import_from_membe"
 },
 "740": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "104",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": " reached.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_import_from_members=3)\n    visitor = ImportMembersVisitor(option_values, "
 },
 "741": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.imports.ImportMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "105",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "n_values = options(max_import_from_members=3)\n    visitor = ImportMembersVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "742": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "122",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "ations are raised when reaching max value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_import_from_membe"
 },
 "743": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "124",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "ax value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_import_from_members=2)\n    visitor = ImportMembersVisitor(option_values, "
 },
 "744": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.imports.ImportMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_imports_counts.py",
  "lineno": "125",
  "column": "4",
  "slicing": "[\"module_import = ''\\n\", 'module_with_regular_imports = \"\"\"\\n', 'module_with_from_imports = \"\"\"\\n', \"import_from_multiple_names = 'from module import name0, name1, name2'\\n\", '    module_import,\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImportMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imports=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imports)\\n\", '    module_with_regular_imports,\\n', '    module_with_from_imports,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_imported_names=1)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedNamesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_imported_names)\\n\", '    module_with_from_imports,\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=3)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_from_multiple_names,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_import_from_members=2)\\n', '    visitor = ImportMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyImportedModuleMembersViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_import_from_members)\\n\"]",
  "context": "n_values = options(max_import_from_members=2)\n    visitor = ImportMembersVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "745": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "90",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing that default settings raise a warning.\"\"\"\n    tree = parse_ast_tree(code.format(statements))\n\n    visitor = TryExceptVisitor(default_options, t"
 },
 "746": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.TryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "92",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(code.format(statements))\n\n    visitor = TryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "747": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "118",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing that default settings raise a warning.\"\"\"\n    tree = parse_ast_tree(code.format(statements))\n\n    option_values = options(max_try_body_length=1"
 },
 "748": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "120",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(code.format(statements))\n\n    option_values = options(max_try_body_length=1)\n    visitor = TryExceptVisitor(option_values, tree"
 },
 "749": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.TryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "121",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ption_values = options(max_try_body_length=1)\n    visitor = TryExceptVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "750": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "149",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing that default settings raise a warning.\"\"\"\n    tree = parse_ast_tree(code.format(statements))\n\n    option_values = options(max_try_body_length=2"
 },
 "751": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "151",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(code.format(statements))\n\n    option_values = options(max_try_body_length=2)\n    visitor = TryExceptVisitor(option_values, tree"
 },
 "752": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.TryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "152",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ption_values = options(max_try_body_length=2)\n    visitor = TryExceptVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "753": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "177",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing that default settings raise a warning.\"\"\"\n    tree = parse_ast_tree(code.format(statements))\n\n    visitor = TryExceptVisitor(default_options, t"
 },
 "754": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.TryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "179",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(code.format(statements))\n\n    visitor = TryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "755": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "203",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing that default settings raise a warning.\"\"\"\n    tree = parse_ast_tree(code.format(statements))\n\n    visitor = TryExceptVisitor(default_options, t"
 },
 "756": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.TryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_body_length.py",
  "lineno": "205",
  "column": "4",
  "slicing": "['try_without_except = \"\"\"\\n', 'simple_try_except = \"\"\"\\n', 'try_except_with_else = \"\"\"\\n', 'full_except_with_else = \"\"\"\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=1)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTryBodyViolation])\\n', \"        visitor, '2', baseline=option_values.max_try_body_length,\\n\", '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    option_values = options(max_try_body_length=2)\\n', '    visitor = TryExceptVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    try_without_except,\\n', '    simple_try_except,\\n', '    try_except_with_else,\\n', '    full_except_with_else,\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(statements))\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(code.format(statements))\n\n    visitor = TryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "757": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_yield_length.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['generator = \"\"\"\\n', \"single = 'i + 1'\\n\", \"tuple_empty = '()'\\n\", \"tuple_fixed_short = '(1, 2, 3)'\\n\", \"tuple_short = 'i, i + 1, i + 2'\\n\", '    tuple_short,\\n', '    single,\\n', '    tuple_empty,\\n', '    tuple_fixed_short,\\n', '    tree = parse_ast_tree(mode(generator.format(tuple_param)))\\n', '    visitor = YieldTupleVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(generator.format(tuple_param)))\\n', '    visitor = YieldTupleVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongYieldTupleViolation])\\n', '    assert_error_text(visitor, 6, MAX_LEN_YIELD_TUPLE)\\n']",
  "context": "asses and functions in a module work well.\"\"\"\n    tree = parse_ast_tree(mode(generator.format(tuple_param)))\n\n    visitor = YieldTupleVisitor(default_options, "
 },
 "758": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.YieldTupleVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_yield_length.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['generator = \"\"\"\\n', \"single = 'i + 1'\\n\", \"tuple_empty = '()'\\n\", \"tuple_fixed_short = '(1, 2, 3)'\\n\", \"tuple_short = 'i, i + 1, i + 2'\\n\", '    tuple_short,\\n', '    single,\\n', '    tuple_empty,\\n', '    tuple_fixed_short,\\n', '    tree = parse_ast_tree(mode(generator.format(tuple_param)))\\n', '    visitor = YieldTupleVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(generator.format(tuple_param)))\\n', '    visitor = YieldTupleVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongYieldTupleViolation])\\n', '    assert_error_text(visitor, 6, MAX_LEN_YIELD_TUPLE)\\n']",
  "context": "st_tree(mode(generator.format(tuple_param)))\n\n    visitor = YieldTupleVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "759": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_yield_length.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['generator = \"\"\"\\n', \"single = 'i + 1'\\n\", \"tuple_empty = '()'\\n\", \"tuple_fixed_short = '(1, 2, 3)'\\n\", \"tuple_short = 'i, i + 1, i + 2'\\n\", '    tuple_short,\\n', '    single,\\n', '    tuple_empty,\\n', '    tuple_fixed_short,\\n', '    tree = parse_ast_tree(mode(generator.format(tuple_param)))\\n', '    visitor = YieldTupleVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(generator.format(tuple_param)))\\n', '    visitor = YieldTupleVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongYieldTupleViolation])\\n', '    assert_error_text(visitor, 6, MAX_LEN_YIELD_TUPLE)\\n']",
  "context": "asses and functions in a module work well.\"\"\"\n    tree = parse_ast_tree(mode(generator.format(tuple_param)))\n\n    visitor = YieldTupleVisitor(default_options, "
 },
 "760": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.YieldTupleVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_yield_length.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['generator = \"\"\"\\n', \"single = 'i + 1'\\n\", \"tuple_empty = '()'\\n\", \"tuple_fixed_short = '(1, 2, 3)'\\n\", \"tuple_short = 'i, i + 1, i + 2'\\n\", '    tuple_short,\\n', '    single,\\n', '    tuple_empty,\\n', '    tuple_fixed_short,\\n', '    tree = parse_ast_tree(mode(generator.format(tuple_param)))\\n', '    visitor = YieldTupleVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(generator.format(tuple_param)))\\n', '    visitor = YieldTupleVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongYieldTupleViolation])\\n', '    assert_error_text(visitor, 6, MAX_LEN_YIELD_TUPLE)\\n']",
  "context": "st_tree(mode(generator.format(tuple_param)))\n\n    visitor = YieldTupleVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "761": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_module_counts.py",
  "lineno": "127",
  "column": "4",
  "slicing": "['module_with_function_and_class = \"\"\"\\n', 'module_with_function_and_class_and_method = \"\"\"\\n', 'module_with_function_and_async_method = \"\"\"\\n', 'module_with_function_and_classmethod = \"\"\"\\n', 'module_with_async_function_and_class = \"\"\"\\n', 'module_with_methods = \"\"\"\\n', 'module_with_async_methods = \"\"\"\\n', 'module_with_classmethods = \"\"\"\\n', 'module_with_staticmethods = \"\"\"\\n', 'module_with_single_class = \"\"\"\\n', \"empty_module = ''\\n\", '    empty_module,\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_staticmethods,\\n', '    module_with_classmethods,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_classmethods,\\n', '    module_with_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyModuleMembersViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_module_members)\\n\", '    empty_module,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "asses and functions in a module work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ModuleMembersVisitor(default_option"
 },
 "762": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ModuleMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_module_counts.py",
  "lineno": "129",
  "column": "4",
  "slicing": "['module_with_function_and_class = \"\"\"\\n', 'module_with_function_and_class_and_method = \"\"\"\\n', 'module_with_function_and_async_method = \"\"\"\\n', 'module_with_function_and_classmethod = \"\"\"\\n', 'module_with_async_function_and_class = \"\"\"\\n', 'module_with_methods = \"\"\"\\n', 'module_with_async_methods = \"\"\"\\n', 'module_with_classmethods = \"\"\"\\n', 'module_with_staticmethods = \"\"\"\\n', 'module_with_single_class = \"\"\"\\n', \"empty_module = ''\\n\", '    empty_module,\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_staticmethods,\\n', '    module_with_classmethods,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_classmethods,\\n', '    module_with_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyModuleMembersViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_module_members)\\n\", '    empty_module,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ModuleMembersVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "763": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_module_counts.py",
  "lineno": "154",
  "column": "4",
  "slicing": "['module_with_function_and_class = \"\"\"\\n', 'module_with_function_and_class_and_method = \"\"\"\\n', 'module_with_function_and_async_method = \"\"\"\\n', 'module_with_function_and_classmethod = \"\"\"\\n', 'module_with_async_function_and_class = \"\"\"\\n', 'module_with_methods = \"\"\"\\n', 'module_with_async_methods = \"\"\"\\n', 'module_with_classmethods = \"\"\"\\n', 'module_with_staticmethods = \"\"\"\\n', 'module_with_single_class = \"\"\"\\n', \"empty_module = ''\\n\", '    empty_module,\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_staticmethods,\\n', '    module_with_classmethods,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_classmethods,\\n', '    module_with_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyModuleMembersViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_module_members)\\n\", '    empty_module,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ations are raised when reaching max value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_module_members=1)"
 },
 "764": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_module_counts.py",
  "lineno": "156",
  "column": "4",
  "slicing": "['module_with_function_and_class = \"\"\"\\n', 'module_with_function_and_class_and_method = \"\"\"\\n', 'module_with_function_and_async_method = \"\"\"\\n', 'module_with_function_and_classmethod = \"\"\"\\n', 'module_with_async_function_and_class = \"\"\"\\n', 'module_with_methods = \"\"\"\\n', 'module_with_async_methods = \"\"\"\\n', 'module_with_classmethods = \"\"\"\\n', 'module_with_staticmethods = \"\"\"\\n', 'module_with_single_class = \"\"\"\\n', \"empty_module = ''\\n\", '    empty_module,\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_staticmethods,\\n', '    module_with_classmethods,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_classmethods,\\n', '    module_with_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyModuleMembersViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_module_members)\\n\", '    empty_module,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ax value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_module_members=1)\n    visitor = ModuleMembersVisitor(option_values, "
 },
 "765": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ModuleMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_module_counts.py",
  "lineno": "157",
  "column": "4",
  "slicing": "['module_with_function_and_class = \"\"\"\\n', 'module_with_function_and_class_and_method = \"\"\"\\n', 'module_with_function_and_async_method = \"\"\"\\n', 'module_with_function_and_classmethod = \"\"\"\\n', 'module_with_async_function_and_class = \"\"\"\\n', 'module_with_methods = \"\"\"\\n', 'module_with_async_methods = \"\"\"\\n', 'module_with_classmethods = \"\"\"\\n', 'module_with_staticmethods = \"\"\"\\n', 'module_with_single_class = \"\"\"\\n', \"empty_module = ''\\n\", '    empty_module,\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_staticmethods,\\n', '    module_with_classmethods,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_classmethods,\\n', '    module_with_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyModuleMembersViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_module_members)\\n\", '    empty_module,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "option_values = options(max_module_members=1)\n    visitor = ModuleMembersVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "766": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_module_counts.py",
  "lineno": "177",
  "column": "4",
  "slicing": "['module_with_function_and_class = \"\"\"\\n', 'module_with_function_and_class_and_method = \"\"\"\\n', 'module_with_function_and_async_method = \"\"\"\\n', 'module_with_function_and_classmethod = \"\"\"\\n', 'module_with_async_function_and_class = \"\"\"\\n', 'module_with_methods = \"\"\"\\n', 'module_with_async_methods = \"\"\"\\n', 'module_with_classmethods = \"\"\"\\n', 'module_with_staticmethods = \"\"\"\\n', 'module_with_single_class = \"\"\"\\n', \"empty_module = ''\\n\", '    empty_module,\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_staticmethods,\\n', '    module_with_classmethods,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_classmethods,\\n', '    module_with_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyModuleMembersViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_module_members)\\n\", '    empty_module,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ations are not raised for a single member.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_module_members=1)"
 },
 "767": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_module_counts.py",
  "lineno": "179",
  "column": "4",
  "slicing": "['module_with_function_and_class = \"\"\"\\n', 'module_with_function_and_class_and_method = \"\"\"\\n', 'module_with_function_and_async_method = \"\"\"\\n', 'module_with_function_and_classmethod = \"\"\"\\n', 'module_with_async_function_and_class = \"\"\"\\n', 'module_with_methods = \"\"\"\\n', 'module_with_async_methods = \"\"\"\\n', 'module_with_classmethods = \"\"\"\\n', 'module_with_staticmethods = \"\"\"\\n', 'module_with_single_class = \"\"\"\\n', \"empty_module = ''\\n\", '    empty_module,\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_staticmethods,\\n', '    module_with_classmethods,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_classmethods,\\n', '    module_with_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyModuleMembersViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_module_members)\\n\", '    empty_module,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e member.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_module_members=1)\n    visitor = ModuleMembersVisitor(option_values, "
 },
 "768": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ModuleMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_module_counts.py",
  "lineno": "180",
  "column": "4",
  "slicing": "['module_with_function_and_class = \"\"\"\\n', 'module_with_function_and_class_and_method = \"\"\"\\n', 'module_with_function_and_async_method = \"\"\"\\n', 'module_with_function_and_classmethod = \"\"\"\\n', 'module_with_async_function_and_class = \"\"\"\\n', 'module_with_methods = \"\"\"\\n', 'module_with_async_methods = \"\"\"\\n', 'module_with_classmethods = \"\"\"\\n', 'module_with_staticmethods = \"\"\"\\n', 'module_with_single_class = \"\"\"\\n', \"empty_module = ''\\n\", '    empty_module,\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_staticmethods,\\n', '    module_with_classmethods,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    module_with_function_and_class,\\n', '    module_with_function_and_class_and_method,\\n', '    module_with_function_and_async_method,\\n', '    module_with_function_and_classmethod,\\n', '    module_with_async_function_and_class,\\n', '    module_with_methods,\\n', '    module_with_async_methods,\\n', '    module_with_classmethods,\\n', '    module_with_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyModuleMembersViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_module_members)\\n\", '    empty_module,\\n', '    module_with_single_class,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_module_members=1)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "option_values = options(max_module_members=1)\n    visitor = ModuleMembersVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "769": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_elifs.py",
  "lineno": "183",
  "column": "4",
  "slicing": "['module_with_one_elif = \"\"\"\\n', 'module_with_two_elifs = \"\"\"\\n', 'module_with_three_elifs = \"\"\"\\n', 'function_with_one_elif = \"\"\"\\n', 'function_with_two_elifs = \"\"\"\\n', 'function_with_three_elifs = \"\"\"\\n', 'function_with_ifs = \"\"\"\\n', 'function_with_raw_if = \"\"\"\\n', 'function_with_if_else = \"\"\"\\n', 'function_with_ternary = \"\"\"\\n', '    module_with_one_elif,\\n', '    module_with_two_elifs,\\n', '    module_with_three_elifs,\\n', '    function_with_one_elif,\\n', '    function_with_two_elifs,\\n', '    function_with_three_elifs,\\n', '    function_with_ifs,\\n', '    function_with_raw_if,\\n', '    function_with_if_else,\\n', '    function_with_ternary,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ElifVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ElifVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyElifsViolation])\\n', \"    assert_error_text(visitor, '4', baseline=3)\\n\"]",
  "context": "ng that all `if`/`elif`/`else` is allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ElifVisitor(default_options, tree=t"
 },
 "770": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ElifVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_elifs.py",
  "lineno": "185",
  "column": "4",
  "slicing": "['module_with_one_elif = \"\"\"\\n', 'module_with_two_elifs = \"\"\"\\n', 'module_with_three_elifs = \"\"\"\\n', 'function_with_one_elif = \"\"\"\\n', 'function_with_two_elifs = \"\"\"\\n', 'function_with_three_elifs = \"\"\"\\n', 'function_with_ifs = \"\"\"\\n', 'function_with_raw_if = \"\"\"\\n', 'function_with_if_else = \"\"\"\\n', 'function_with_ternary = \"\"\"\\n', '    module_with_one_elif,\\n', '    module_with_two_elifs,\\n', '    module_with_three_elifs,\\n', '    function_with_one_elif,\\n', '    function_with_two_elifs,\\n', '    function_with_three_elifs,\\n', '    function_with_ifs,\\n', '    function_with_raw_if,\\n', '    function_with_if_else,\\n', '    function_with_ternary,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ElifVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ElifVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyElifsViolation])\\n', \"    assert_error_text(visitor, '4', baseline=3)\\n\"]",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ElifVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "771": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_elifs.py",
  "lineno": "205",
  "column": "4",
  "slicing": "['module_with_one_elif = \"\"\"\\n', 'module_with_two_elifs = \"\"\"\\n', 'module_with_three_elifs = \"\"\"\\n', 'function_with_one_elif = \"\"\"\\n', 'function_with_two_elifs = \"\"\"\\n', 'function_with_three_elifs = \"\"\"\\n', 'function_with_ifs = \"\"\"\\n', 'function_with_raw_if = \"\"\"\\n', 'function_with_if_else = \"\"\"\\n', 'function_with_ternary = \"\"\"\\n', '    module_with_one_elif,\\n', '    module_with_two_elifs,\\n', '    module_with_three_elifs,\\n', '    function_with_one_elif,\\n', '    function_with_two_elifs,\\n', '    function_with_three_elifs,\\n', '    function_with_ifs,\\n', '    function_with_raw_if,\\n', '    function_with_if_else,\\n', '    function_with_ternary,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ElifVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ElifVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyElifsViolation])\\n', \"    assert_error_text(visitor, '4', baseline=3)\\n\"]",
  "context": " incorrect number of `elif` is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ElifVisitor(default_options, tree=t"
 },
 "772": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ElifVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_elifs.py",
  "lineno": "207",
  "column": "4",
  "slicing": "['module_with_one_elif = \"\"\"\\n', 'module_with_two_elifs = \"\"\"\\n', 'module_with_three_elifs = \"\"\"\\n', 'function_with_one_elif = \"\"\"\\n', 'function_with_two_elifs = \"\"\"\\n', 'function_with_three_elifs = \"\"\"\\n', 'function_with_ifs = \"\"\"\\n', 'function_with_raw_if = \"\"\"\\n', 'function_with_if_else = \"\"\"\\n', 'function_with_ternary = \"\"\"\\n', '    module_with_one_elif,\\n', '    module_with_two_elifs,\\n', '    module_with_three_elifs,\\n', '    function_with_one_elif,\\n', '    function_with_two_elifs,\\n', '    function_with_three_elifs,\\n', '    function_with_ifs,\\n', '    function_with_raw_if,\\n', '    function_with_if_else,\\n', '    function_with_ternary,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ElifVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ElifVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyElifsViolation])\\n', \"    assert_error_text(visitor, '4', baseline=3)\\n\"]",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ElifVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "773": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_decorators_count.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['function_with_decorators = \"\"\"\\n', 'class_with_decorators = \"\"\"\\n', 'method_with_decorators = \"\"\"\\n', 'classmethod_with_decorators = \"\"\"\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_decorators=2)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyDecoratorsViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_decorators)\\n\"]",
  "context": "g that correct amount of decorators works.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ModuleMembersVisitor(default_option"
 },
 "774": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ModuleMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_decorators_count.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['function_with_decorators = \"\"\"\\n', 'class_with_decorators = \"\"\"\\n', 'method_with_decorators = \"\"\"\\n', 'classmethod_with_decorators = \"\"\"\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_decorators=2)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyDecoratorsViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_decorators)\\n\"]",
  "context": "ks.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ModuleMembersVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "775": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_decorators_count.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['function_with_decorators = \"\"\"\\n', 'class_with_decorators = \"\"\"\\n', 'method_with_decorators = \"\"\"\\n', 'classmethod_with_decorators = \"\"\"\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_decorators=2)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyDecoratorsViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_decorators)\\n\"]",
  "context": "that too large amount of decorators works.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_decorators=2)\n   "
 },
 "776": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_decorators_count.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['function_with_decorators = \"\"\"\\n', 'class_with_decorators = \"\"\"\\n', 'method_with_decorators = \"\"\"\\n', 'classmethod_with_decorators = \"\"\"\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_decorators=2)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyDecoratorsViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_decorators)\\n\"]",
  "context": "ks.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_decorators=2)\n    visitor = ModuleMembersVisitor(option_values, "
 },
 "777": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ModuleMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_decorators_count.py",
  "lineno": "81",
  "column": "4",
  "slicing": "['function_with_decorators = \"\"\"\\n', 'class_with_decorators = \"\"\"\\n', 'method_with_decorators = \"\"\"\\n', 'classmethod_with_decorators = \"\"\"\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ModuleMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_decorators,\\n', '    class_with_decorators,\\n', '    method_with_decorators,\\n', '    classmethod_with_decorators,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_decorators=2)\\n', '    visitor = ModuleMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyDecoratorsViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_decorators)\\n\"]",
  "context": "    option_values = options(max_decorators=2)\n    visitor = ModuleMembersVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "778": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_condition_counts.py",
  "lineno": "84",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", \"assignment = 'some = x > y or None'\\n\", 'condition_with_single_if = \"\"\"\\n', 'condition_with_single_if_multiline = \"\"\"\\n', 'condition_with_several_ifs = \"\"\"\\n', 'condition_with_several_elifs = \"\"\"\\n', \"condition_inline = 'some_value = 12 if True and 4 > 3 else 0'\\n\", \"condition_with_inline_for = 'nodes = [node for node in html if 1 and 2 > 1]'\\n\", \"condition_with_simple_inline_for = 'nodes = [node for node in html]'\\n\", 'while_with_condition = \"\"\"\\n', '    empty_module,\\n', '    assignment,\\n', '    condition_with_single_if,\\n', '    condition_with_single_if_multiline,\\n', '    condition_with_several_ifs,\\n', '    condition_with_several_elifs,\\n', '    condition_inline,\\n', '    condition_with_inline_for,\\n', '    condition_with_simple_inline_for,\\n', '    while_with_condition,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyConditionsViolation])\\n', \"    assert_error_text(visitor, '5', baseline=4)\\n\"]",
  "context": "ing that conditions in a module work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ConditionsVisitor(default_options, "
 },
 "779": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ConditionsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_condition_counts.py",
  "lineno": "86",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", \"assignment = 'some = x > y or None'\\n\", 'condition_with_single_if = \"\"\"\\n', 'condition_with_single_if_multiline = \"\"\"\\n', 'condition_with_several_ifs = \"\"\"\\n', 'condition_with_several_elifs = \"\"\"\\n', \"condition_inline = 'some_value = 12 if True and 4 > 3 else 0'\\n\", \"condition_with_inline_for = 'nodes = [node for node in html if 1 and 2 > 1]'\\n\", \"condition_with_simple_inline_for = 'nodes = [node for node in html]'\\n\", 'while_with_condition = \"\"\"\\n', '    empty_module,\\n', '    assignment,\\n', '    condition_with_single_if,\\n', '    condition_with_single_if_multiline,\\n', '    condition_with_several_ifs,\\n', '    condition_with_several_elifs,\\n', '    condition_inline,\\n', '    condition_with_inline_for,\\n', '    condition_with_simple_inline_for,\\n', '    while_with_condition,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyConditionsViolation])\\n', \"    assert_error_text(visitor, '5', baseline=4)\\n\"]",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ConditionsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "780": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_condition_counts.py",
  "lineno": "105",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", \"assignment = 'some = x > y or None'\\n\", 'condition_with_single_if = \"\"\"\\n', 'condition_with_single_if_multiline = \"\"\"\\n', 'condition_with_several_ifs = \"\"\"\\n', 'condition_with_several_elifs = \"\"\"\\n', \"condition_inline = 'some_value = 12 if True and 4 > 3 else 0'\\n\", \"condition_with_inline_for = 'nodes = [node for node in html if 1 and 2 > 1]'\\n\", \"condition_with_simple_inline_for = 'nodes = [node for node in html]'\\n\", 'while_with_condition = \"\"\"\\n', '    empty_module,\\n', '    assignment,\\n', '    condition_with_single_if,\\n', '    condition_with_single_if_multiline,\\n', '    condition_with_several_ifs,\\n', '    condition_with_several_elifs,\\n', '    condition_inline,\\n', '    condition_with_inline_for,\\n', '    condition_with_simple_inline_for,\\n', '    while_with_condition,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyConditionsViolation])\\n', \"    assert_error_text(visitor, '5', baseline=4)\\n\"]",
  "context": "ations are raised when reaching max value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ConditionsVisitor(default_options, "
 },
 "781": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ConditionsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_condition_counts.py",
  "lineno": "107",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", \"assignment = 'some = x > y or None'\\n\", 'condition_with_single_if = \"\"\"\\n', 'condition_with_single_if_multiline = \"\"\"\\n', 'condition_with_several_ifs = \"\"\"\\n', 'condition_with_several_elifs = \"\"\"\\n', \"condition_inline = 'some_value = 12 if True and 4 > 3 else 0'\\n\", \"condition_with_inline_for = 'nodes = [node for node in html if 1 and 2 > 1]'\\n\", \"condition_with_simple_inline_for = 'nodes = [node for node in html]'\\n\", 'while_with_condition = \"\"\"\\n', '    empty_module,\\n', '    assignment,\\n', '    condition_with_single_if,\\n', '    condition_with_single_if_multiline,\\n', '    condition_with_several_ifs,\\n', '    condition_with_several_elifs,\\n', '    condition_inline,\\n', '    condition_with_inline_for,\\n', '    condition_with_simple_inline_for,\\n', '    while_with_condition,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyConditionsViolation])\\n', \"    assert_error_text(visitor, '5', baseline=4)\\n\"]",
  "context": "ax value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ConditionsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "782": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_tuple_unpack_length.py",
  "lineno": "42",
  "column": "4",
  "slicing": "[\"short_unpack = 'a, b = (1, 2)'\\n\", \"short_starred_unpack = 'a, b, *rest = (1, 2, 3, 4, 5)'\\n\", \"single_unpack = 'result = (1, 2, 3, 4, 5)'\\n\", \"function_unpack = 'result = some()'\\n\", 'class_attr_unpack = \"\"\"\\n', '    short_unpack,\\n', '    short_starred_unpack,\\n', '    single_unpack,\\n', '    function_unpack,\\n', '    class_attr_unpack,\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTupleUnpackViolation])\\n', '    assert_error_text(visitor, 5, option_values.max_tuple_unpack_length)\\n']",
  "context": "f unpack expression don't raise excptions.\"\"\"\n    tree = parse_ast_tree(unpack_expression)\n\n    option_values = options(max_tuple_unpack_leng"
 },
 "783": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_tuple_unpack_length.py",
  "lineno": "44",
  "column": "4",
  "slicing": "[\"short_unpack = 'a, b = (1, 2)'\\n\", \"short_starred_unpack = 'a, b, *rest = (1, 2, 3, 4, 5)'\\n\", \"single_unpack = 'result = (1, 2, 3, 4, 5)'\\n\", \"function_unpack = 'result = some()'\\n\", 'class_attr_unpack = \"\"\"\\n', '    short_unpack,\\n', '    short_starred_unpack,\\n', '    single_unpack,\\n', '    function_unpack,\\n', '    class_attr_unpack,\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTupleUnpackViolation])\\n', '    assert_error_text(visitor, 5, option_values.max_tuple_unpack_length)\\n']",
  "context": "    tree = parse_ast_tree(unpack_expression)\n\n    option_values = options(max_tuple_unpack_length=4)\n    visitor = TupleUnpackVisitor(option_values, tr"
 },
 "784": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.TupleUnpackVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_tuple_unpack_length.py",
  "lineno": "45",
  "column": "4",
  "slicing": "[\"short_unpack = 'a, b = (1, 2)'\\n\", \"short_starred_unpack = 'a, b, *rest = (1, 2, 3, 4, 5)'\\n\", \"single_unpack = 'result = (1, 2, 3, 4, 5)'\\n\", \"function_unpack = 'result = some()'\\n\", 'class_attr_unpack = \"\"\"\\n', '    short_unpack,\\n', '    short_starred_unpack,\\n', '    single_unpack,\\n', '    function_unpack,\\n', '    class_attr_unpack,\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTupleUnpackViolation])\\n', '    assert_error_text(visitor, 5, option_values.max_tuple_unpack_length)\\n']",
  "context": "n_values = options(max_tuple_unpack_length=4)\n    visitor = TupleUnpackVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "785": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_tuple_unpack_length.py",
  "lineno": "65",
  "column": "4",
  "slicing": "[\"short_unpack = 'a, b = (1, 2)'\\n\", \"short_starred_unpack = 'a, b, *rest = (1, 2, 3, 4, 5)'\\n\", \"single_unpack = 'result = (1, 2, 3, 4, 5)'\\n\", \"function_unpack = 'result = some()'\\n\", 'class_attr_unpack = \"\"\"\\n', '    short_unpack,\\n', '    short_starred_unpack,\\n', '    single_unpack,\\n', '    function_unpack,\\n', '    class_attr_unpack,\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTupleUnpackViolation])\\n', '    assert_error_text(visitor, 5, option_values.max_tuple_unpack_length)\\n']",
  "context": "t that violations raise proper exceptions.\"\"\"\n    tree = parse_ast_tree(unpack_expression)\n\n    option_values = options(max_tuple_unpack_leng"
 },
 "786": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_tuple_unpack_length.py",
  "lineno": "67",
  "column": "4",
  "slicing": "[\"short_unpack = 'a, b = (1, 2)'\\n\", \"short_starred_unpack = 'a, b, *rest = (1, 2, 3, 4, 5)'\\n\", \"single_unpack = 'result = (1, 2, 3, 4, 5)'\\n\", \"function_unpack = 'result = some()'\\n\", 'class_attr_unpack = \"\"\"\\n', '    short_unpack,\\n', '    short_starred_unpack,\\n', '    single_unpack,\\n', '    function_unpack,\\n', '    class_attr_unpack,\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTupleUnpackViolation])\\n', '    assert_error_text(visitor, 5, option_values.max_tuple_unpack_length)\\n']",
  "context": "    tree = parse_ast_tree(unpack_expression)\n\n    option_values = options(max_tuple_unpack_length=4)\n    visitor = TupleUnpackVisitor(option_values, tr"
 },
 "787": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.TupleUnpackVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_tuple_unpack_length.py",
  "lineno": "68",
  "column": "4",
  "slicing": "[\"short_unpack = 'a, b = (1, 2)'\\n\", \"short_starred_unpack = 'a, b, *rest = (1, 2, 3, 4, 5)'\\n\", \"single_unpack = 'result = (1, 2, 3, 4, 5)'\\n\", \"function_unpack = 'result = some()'\\n\", 'class_attr_unpack = \"\"\"\\n', '    short_unpack,\\n', '    short_starred_unpack,\\n', '    single_unpack,\\n', '    function_unpack,\\n', '    class_attr_unpack,\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(unpack_expression)\\n', '    option_values = options(max_tuple_unpack_length=4)\\n', '    visitor = TupleUnpackVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongTupleUnpackViolation])\\n', '    assert_error_text(visitor, 5, option_values.max_tuple_unpack_length)\\n']",
  "context": "n_values = options(max_tuple_unpack_length=4)\n    visitor = TupleUnpackVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "788": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_compare_complexity.py",
  "lineno": "55",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", \"one_compare = 'x > 1'\\n\", \"two_compare = 'x < y() >= 2'\\n\", \"one_equals = 'x == 1'\\n\", \"two_equals = 'x == call() == prop.attr'\\n\", \"only_equals = 'x == y == z == c'\\n\", \"one_non_equals = 'x != 1'\\n\", \"two_non_equals = 'x != call() != prop.attr'\\n\", \"only_non_equals = 'x != y != z != c'\\n\", \"mixed_short_equals = 'x != y == z'\\n\", '    empty_module,\\n', '    one_compare,\\n', '    two_compare,\\n', '    one_equals,\\n', '    two_equals,\\n', '    only_equals,\\n', '    one_non_equals,\\n', '    two_non_equals,\\n', '    only_non_equals,\\n', '    mixed_short_equals,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCompareViolation])\\n']",
  "context": "esting that compare in a module work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ConditionsVisitor(default_options, "
 },
 "789": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ConditionsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_compare_complexity.py",
  "lineno": "57",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", \"one_compare = 'x > 1'\\n\", \"two_compare = 'x < y() >= 2'\\n\", \"one_equals = 'x == 1'\\n\", \"two_equals = 'x == call() == prop.attr'\\n\", \"only_equals = 'x == y == z == c'\\n\", \"one_non_equals = 'x != 1'\\n\", \"two_non_equals = 'x != call() != prop.attr'\\n\", \"only_non_equals = 'x != y != z != c'\\n\", \"mixed_short_equals = 'x != y == z'\\n\", '    empty_module,\\n', '    one_compare,\\n', '    two_compare,\\n', '    one_equals,\\n', '    two_equals,\\n', '    only_equals,\\n', '    one_non_equals,\\n', '    two_non_equals,\\n', '    only_non_equals,\\n', '    mixed_short_equals,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCompareViolation])\\n']",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ConditionsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "790": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_compare_complexity.py",
  "lineno": "78",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", \"one_compare = 'x > 1'\\n\", \"two_compare = 'x < y() >= 2'\\n\", \"one_equals = 'x == 1'\\n\", \"two_equals = 'x == call() == prop.attr'\\n\", \"only_equals = 'x == y == z == c'\\n\", \"one_non_equals = 'x != 1'\\n\", \"two_non_equals = 'x != call() != prop.attr'\\n\", \"only_non_equals = 'x != y != z != c'\\n\", \"mixed_short_equals = 'x != y == z'\\n\", '    empty_module,\\n', '    one_compare,\\n', '    two_compare,\\n', '    one_equals,\\n', '    two_equals,\\n', '    only_equals,\\n', '    one_non_equals,\\n', '    two_non_equals,\\n', '    only_non_equals,\\n', '    mixed_short_equals,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCompareViolation])\\n']",
  "context": "ations are raised when reaching max value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ConditionsVisitor(default_options, "
 },
 "791": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.ConditionsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_compare_complexity.py",
  "lineno": "80",
  "column": "4",
  "slicing": "[\"empty_module = ''\\n\", \"one_compare = 'x > 1'\\n\", \"two_compare = 'x < y() >= 2'\\n\", \"one_equals = 'x == 1'\\n\", \"two_equals = 'x == call() == prop.attr'\\n\", \"only_equals = 'x == y == z == c'\\n\", \"one_non_equals = 'x != 1'\\n\", \"two_non_equals = 'x != call() != prop.attr'\\n\", \"only_non_equals = 'x != y != z != c'\\n\", \"mixed_short_equals = 'x != y == z'\\n\", '    empty_module,\\n', '    one_compare,\\n', '    two_compare,\\n', '    one_equals,\\n', '    two_equals,\\n', '    only_equals,\\n', '    one_non_equals,\\n', '    two_non_equals,\\n', '    only_non_equals,\\n', '    mixed_short_equals,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ConditionsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCompareViolation])\\n']",
  "context": "ax value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ConditionsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "792": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_except.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['complex_try_except = \"\"\"\\n', '    tree = parse_ast_tree(complex_try_except)\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyExceptCasesViolation])\\n', \"    assert_error_text(visitor, '4', baseline=3)\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing that default settings raise a warning.\"\"\"\n    tree = parse_ast_tree(complex_try_except)\n\n    visitor = TryExceptVisitor(default_options, t"
 },
 "793": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.TryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_except.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['complex_try_except = \"\"\"\\n', '    tree = parse_ast_tree(complex_try_except)\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyExceptCasesViolation])\\n', \"    assert_error_text(visitor, '4', baseline=3)\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "   tree = parse_ast_tree(complex_try_except)\n\n    visitor = TryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "794": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_except.py",
  "lineno": "89",
  "column": "4",
  "slicing": "['complex_try_except = \"\"\"\\n', '    tree = parse_ast_tree(complex_try_except)\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyExceptCasesViolation])\\n', \"    assert_error_text(visitor, '4', baseline=3)\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    \"\"\"Testing that correct patterns work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = TryExceptVisitor(default_options, t"
 },
 "795": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.counts.TryExceptVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_counts/test_try_except.py",
  "lineno": "91",
  "column": "4",
  "slicing": "['complex_try_except = \"\"\"\\n', '    tree = parse_ast_tree(complex_try_except)\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyExceptCasesViolation])\\n', \"    assert_error_text(visitor, '4', baseline=3)\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = TryExceptVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rns work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = TryExceptVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "796": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_method_counts.py",
  "lineno": "113",
  "column": "4",
  "slicing": "['module_without_methods = \"\"\"\\n', 'module_with_async_functions = \"\"\"\\n', 'module_async_and_usual_functions = \"\"\"\\n', 'class_with_methods = \"\"\"\\n', 'class_with_async_methods = \"\"\"\\n', 'class_with_async_and_usual_methods = \"\"\"\\n', 'class_with_class_methods = \"\"\"\\n', 'class_with_async_class_methods = \"\"\"\\n', 'class_with_async_and_usual_class_methods = \"\"\"\\n', 'class_with_staticmethods = \"\"\"\\n', 'class_with_async_staticmethods = \"\"\"\\n', '    module_without_methods,\\n', '    module_with_async_functions,\\n', '    module_async_and_usual_functions,\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = MethodMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_methods=1)\\n', '    visitor = MethodMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyMethodsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_methods)\\n\"]",
  "context": "t regular classes and functions work well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = MethodMembersVisitor(default_option"
 },
 "797": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.classes.MethodMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_method_counts.py",
  "lineno": "115",
  "column": "4",
  "slicing": "['module_without_methods = \"\"\"\\n', 'module_with_async_functions = \"\"\"\\n', 'module_async_and_usual_functions = \"\"\"\\n', 'class_with_methods = \"\"\"\\n', 'class_with_async_methods = \"\"\"\\n', 'class_with_async_and_usual_methods = \"\"\"\\n', 'class_with_class_methods = \"\"\"\\n', 'class_with_async_class_methods = \"\"\"\\n', 'class_with_async_and_usual_class_methods = \"\"\"\\n', 'class_with_staticmethods = \"\"\"\\n', 'class_with_async_staticmethods = \"\"\"\\n', '    module_without_methods,\\n', '    module_with_async_functions,\\n', '    module_async_and_usual_functions,\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = MethodMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_methods=1)\\n', '    visitor = MethodMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyMethodsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_methods)\\n\"]",
  "context": "ork well.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = MethodMembersVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "798": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_method_counts.py",
  "lineno": "139",
  "column": "4",
  "slicing": "['module_without_methods = \"\"\"\\n', 'module_with_async_functions = \"\"\"\\n', 'module_async_and_usual_functions = \"\"\"\\n', 'class_with_methods = \"\"\"\\n', 'class_with_async_methods = \"\"\"\\n', 'class_with_async_and_usual_methods = \"\"\"\\n', 'class_with_class_methods = \"\"\"\\n', 'class_with_async_class_methods = \"\"\"\\n', 'class_with_async_and_usual_class_methods = \"\"\"\\n', 'class_with_staticmethods = \"\"\"\\n', 'class_with_async_staticmethods = \"\"\"\\n', '    module_without_methods,\\n', '    module_with_async_functions,\\n', '    module_async_and_usual_functions,\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = MethodMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_methods=1)\\n', '    visitor = MethodMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyMethodsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_methods)\\n\"]",
  "context": "ations are raised when reaching max value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_methods=1)\n    vi"
 },
 "799": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_method_counts.py",
  "lineno": "141",
  "column": "4",
  "slicing": "['module_without_methods = \"\"\"\\n', 'module_with_async_functions = \"\"\"\\n', 'module_async_and_usual_functions = \"\"\"\\n', 'class_with_methods = \"\"\"\\n', 'class_with_async_methods = \"\"\"\\n', 'class_with_async_and_usual_methods = \"\"\"\\n', 'class_with_class_methods = \"\"\"\\n', 'class_with_async_class_methods = \"\"\"\\n', 'class_with_async_and_usual_class_methods = \"\"\"\\n', 'class_with_staticmethods = \"\"\"\\n', 'class_with_async_staticmethods = \"\"\"\\n', '    module_without_methods,\\n', '    module_with_async_functions,\\n', '    module_async_and_usual_functions,\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = MethodMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_methods=1)\\n', '    visitor = MethodMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyMethodsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_methods)\\n\"]",
  "context": "ax value.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_methods=1)\n    visitor = MethodMembersVisitor(option_values, "
 },
 "800": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.classes.MethodMembersVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_method_counts.py",
  "lineno": "142",
  "column": "4",
  "slicing": "['module_without_methods = \"\"\"\\n', 'module_with_async_functions = \"\"\"\\n', 'module_async_and_usual_functions = \"\"\"\\n', 'class_with_methods = \"\"\"\\n', 'class_with_async_methods = \"\"\"\\n', 'class_with_async_and_usual_methods = \"\"\"\\n', 'class_with_class_methods = \"\"\"\\n', 'class_with_async_class_methods = \"\"\"\\n', 'class_with_async_and_usual_class_methods = \"\"\"\\n', 'class_with_staticmethods = \"\"\"\\n', 'class_with_async_staticmethods = \"\"\"\\n', '    module_without_methods,\\n', '    module_with_async_functions,\\n', '    module_async_and_usual_functions,\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = MethodMembersVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_with_methods,\\n', '    class_with_async_methods,\\n', '    class_with_async_and_usual_methods,\\n', '    class_with_class_methods,\\n', '    class_with_async_class_methods,\\n', '    class_with_async_and_usual_class_methods,\\n', '    class_with_staticmethods,\\n', '    class_with_async_staticmethods,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_methods=1)\\n', '    visitor = MethodMembersVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyMethodsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_methods)\\n\"]",
  "context": ")\n\n    option_values = options(max_methods=1)\n    visitor = MethodMembersVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "801": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_bases_classes_counts.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['correct_count = \"\"\"\\n', 'correct_count_with_keywords = \"\"\"\\n', 'too_many_count = \"\"\"\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    too_many_count,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyBaseClassesViolation])\\n', \"    assert_error_text(visitor, '5', default_options.max_base_classes)\\n\", '    too_many_count,\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    options = options(max_base_classes=5)\\n', '    visitor = ClassComplexityVisitor(options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing of correct base classes number.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ClassComplexityVisitor(default_opti"
 },
 "802": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.classes.ClassComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_bases_classes_counts.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['correct_count = \"\"\"\\n', 'correct_count_with_keywords = \"\"\"\\n', 'too_many_count = \"\"\"\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    too_many_count,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyBaseClassesViolation])\\n', \"    assert_error_text(visitor, '5', default_options.max_base_classes)\\n\", '    too_many_count,\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    options = options(max_base_classes=5)\\n', '    visitor = ClassComplexityVisitor(options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s number.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ClassComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "803": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_bases_classes_counts.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['correct_count = \"\"\"\\n', 'correct_count_with_keywords = \"\"\"\\n', 'too_many_count = \"\"\"\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    too_many_count,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyBaseClassesViolation])\\n', \"    assert_error_text(visitor, '5', default_options.max_base_classes)\\n\", '    too_many_count,\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    options = options(max_base_classes=5)\\n', '    visitor = ClassComplexityVisitor(options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " base classes number with default options.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ClassComplexityVisitor(default_opti"
 },
 "804": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.classes.ClassComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_bases_classes_counts.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['correct_count = \"\"\"\\n', 'correct_count_with_keywords = \"\"\"\\n', 'too_many_count = \"\"\"\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    too_many_count,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyBaseClassesViolation])\\n', \"    assert_error_text(visitor, '5', default_options.max_base_classes)\\n\", '    too_many_count,\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    options = options(max_base_classes=5)\\n', '    visitor = ClassComplexityVisitor(options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " options.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ClassComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "805": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_bases_classes_counts.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['correct_count = \"\"\"\\n', 'correct_count_with_keywords = \"\"\"\\n', 'too_many_count = \"\"\"\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    too_many_count,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyBaseClassesViolation])\\n', \"    assert_error_text(visitor, '5', default_options.max_base_classes)\\n\", '    too_many_count,\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    options = options(max_base_classes=5)\\n', '    visitor = ClassComplexityVisitor(options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "f base classes number with custom options.\"\"\"\n    tree = parse_ast_tree(code)\n\n    options = options(max_base_classes=5)\n    vis"
 },
 "806": {
  "name": "options",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_bases_classes_counts.py",
  "lineno": "95",
  "column": "4",
  "slicing": "['correct_count = \"\"\"\\n', 'correct_count_with_keywords = \"\"\"\\n', 'too_many_count = \"\"\"\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    too_many_count,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyBaseClassesViolation])\\n', \"    assert_error_text(visitor, '5', default_options.max_base_classes)\\n\", '    too_many_count,\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    options = options(max_base_classes=5)\\n', '    visitor = ClassComplexityVisitor(options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " options.\"\"\"\n    tree = parse_ast_tree(code)\n\n    options = options(max_base_classes=5)\n    visitor = ClassComplexityVisitor(options, tree"
 },
 "807": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.classes.ClassComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_bases_classes_counts.py",
  "lineno": "96",
  "column": "4",
  "slicing": "['correct_count = \"\"\"\\n', 'correct_count_with_keywords = \"\"\"\\n', 'too_many_count = \"\"\"\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    too_many_count,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ClassComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyBaseClassesViolation])\\n', \"    assert_error_text(visitor, '5', default_options.max_base_classes)\\n\", '    too_many_count,\\n', '    correct_count,\\n', '    correct_count_with_keywords,\\n', '    tree = parse_ast_tree(code)\\n', '    options = options(max_base_classes=5)\\n', '    visitor = ClassComplexityVisitor(options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e)\n\n    options = options(max_base_classes=5)\n    visitor = ClassComplexityVisitor(options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "808": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_public_attrs_count.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['class_template = \"\"\"\\n', 'module_template = \"\"\"\\n', 'function_template = \"\"\"\\n', '    class_template,\\n', '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyPublicAttributesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_attributes)\\n\", '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing of correct base classes number.\"\"\"\n    tree = parse_ast_tree(mode(code.format(expression, expression)))\n\n    option_values = options(max_attributes=1)\n   "
 },
 "809": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_public_attrs_count.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['class_template = \"\"\"\\n', 'module_template = \"\"\"\\n', 'function_template = \"\"\"\\n', '    class_template,\\n', '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyPublicAttributesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_attributes)\\n\", '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e(mode(code.format(expression, expression)))\n\n    option_values = options(max_attributes=1)\n    visitor = ClassComplexityVisitor(option_values"
 },
 "810": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.classes.ClassComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_public_attrs_count.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['class_template = \"\"\"\\n', 'module_template = \"\"\"\\n', 'function_template = \"\"\"\\n', '    class_template,\\n', '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyPublicAttributesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_attributes)\\n\", '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    option_values = options(max_attributes=1)\n    visitor = ClassComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "811": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_public_attrs_count.py",
  "lineno": "90",
  "column": "4",
  "slicing": "['class_template = \"\"\"\\n', 'module_template = \"\"\"\\n', 'function_template = \"\"\"\\n', '    class_template,\\n', '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyPublicAttributesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_attributes)\\n\", '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing of correct base classes number.\"\"\"\n    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\n\n    option_values = options(max_attributes=1)\n   "
 },
 "812": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_public_attrs_count.py",
  "lineno": "92",
  "column": "4",
  "slicing": "['class_template = \"\"\"\\n', 'module_template = \"\"\"\\n', 'function_template = \"\"\"\\n', '    class_template,\\n', '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyPublicAttributesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_attributes)\\n\", '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "mode(code.format(expression1, expression2)))\n\n    option_values = options(max_attributes=1)\n    visitor = ClassComplexityVisitor(option_values"
 },
 "813": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.classes.ClassComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_public_attrs_count.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['class_template = \"\"\"\\n', 'module_template = \"\"\"\\n', 'function_template = \"\"\"\\n', '    class_template,\\n', '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyPublicAttributesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_attributes)\\n\", '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    option_values = options(max_attributes=1)\n    visitor = ClassComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "814": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_public_attrs_count.py",
  "lineno": "118",
  "column": "4",
  "slicing": "['class_template = \"\"\"\\n', 'module_template = \"\"\"\\n', 'function_template = \"\"\"\\n', '    class_template,\\n', '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyPublicAttributesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_attributes)\\n\", '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"\"\"Testing of correct base classes number.\"\"\"\n    tree = parse_ast_tree(mode(code.format(expression, expression)))\n\n    option_values = options(max_attributes=1)\n   "
 },
 "815": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_public_attrs_count.py",
  "lineno": "120",
  "column": "4",
  "slicing": "['class_template = \"\"\"\\n', 'module_template = \"\"\"\\n', 'function_template = \"\"\"\\n', '    class_template,\\n', '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyPublicAttributesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_attributes)\\n\", '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e(mode(code.format(expression, expression)))\n\n    option_values = options(max_attributes=1)\n    visitor = ClassComplexityVisitor(option_values"
 },
 "816": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.classes.ClassComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_classes/test_public_attrs_count.py",
  "lineno": "121",
  "column": "4",
  "slicing": "['class_template = \"\"\"\\n', 'module_template = \"\"\"\\n', 'function_template = \"\"\"\\n', '    class_template,\\n', '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression1, expression2)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyPublicAttributesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_attributes)\\n\", '    module_template,\\n', '    function_template,\\n', '    tree = parse_ast_tree(mode(code.format(expression, expression)))\\n', '    option_values = options(max_attributes=1)\\n', '    visitor = ClassComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    option_values = options(max_attributes=1)\n    visitor = ClassComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "817": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "118",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "estricted.\"\"\"\n    nested_name = 'NestedClass'\n    tree = parse_ast_tree(mode(code.format(nested_name)))\n\n    visitor = NestedComplexityVisitor(default_opt"
 },
 "818": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "120",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rse_ast_tree(mode(code.format(nested_name)))\n\n    visitor = NestedComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Nes"
 },
 "819": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "140",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t is possible to nest whitelisted classes.\"\"\"\n    tree = parse_ast_tree(mode(code.format(whitelist_name)))\n\n    visitor = NestedComplexityVisitor(default_opt"
 },
 "820": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "142",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(mode(code.format(whitelist_name)))\n\n    visitor = NestedComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "821": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "164",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ssible to nest custom whitelisted classes.\"\"\"\n    tree = parse_ast_tree(mode(code.format(whitelist_name)))\n\n    option_values = options(\n        nested_class"
 },
 "822": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "166",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(mode(code.format(whitelist_name)))\n\n    option_values = options(\n        nested_classes_whitelist=[*NESTED_CLASSES_"
 },
 "823": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "170",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "TED_CLASSES_WHITELIST, 'NestedClass'],\n    )\n\n    visitor = NestedComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "824": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "203",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted to nest any classes in functions.\"\"\"\n    tree = parse_ast_tree(mode(code.format(whitelist_name)))\n\n    visitor = NestedComplexityVisitor(default_opt"
 },
 "825": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "205",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(mode(code.format(whitelist_name)))\n\n    visitor = NestedComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Nes"
 },
 "826": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "226",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "inary):\n        def method(self): ...\n    \"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = NestedComplexityVisitor(default_opt"
 },
 "827": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_classes.py",
  "lineno": "228",
  "column": "4",
  "slicing": "['nested_class_in_class = \"\"\"\\n', 'nested_class_in_method = \"\"\"\\n', 'nested_class_in_function = \"\"\"\\n', 'nested_class_in_if = \"\"\"\\n', 'nested_class_in_if_else = \"\"\"\\n', 'nested_class_in_context_manager = \"\"\"\\n', 'nested_class_in_for_loop = \"\"\"\\n', 'nested_class_in_while_loop = \"\"\"\\n', 'nested_class_in_try = \"\"\"\\n', 'nested_class_in_except = \"\"\"\\n', 'nested_class_in_try_else = \"\"\"\\n', 'nested_class_in_try_finally = \"\"\"\\n', '    nested_class_in_class,\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', \"    nested_name = 'NestedClass'\\n\", '    tree = parse_ast_tree(mode(code.format(nested_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_class,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    option_values = options(\\n', '    visitor = NestedComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_class_in_method,\\n', '    nested_class_in_function,\\n', '    nested_class_in_if,\\n', '    nested_class_in_if_else,\\n', '    nested_class_in_context_manager,\\n', '    nested_class_in_for_loop,\\n', '    nested_class_in_while_loop,\\n', '    nested_class_in_try,\\n', '    nested_class_in_except,\\n', '    nested_class_in_try_else,\\n', '    nested_class_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedClassViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "   \"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = NestedComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "828": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "187",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": "ting that nested functions are restricted.\"\"\"\n    tree = parse_ast_tree(code.format(nested_name))\n\n    visitor = NestedComplexityVisitor(default_opt"
 },
 "829": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "189",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": "e = parse_ast_tree(code.format(nested_name))\n\n    visitor = NestedComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Nes"
 },
 "830": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "215",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": "is possible to nest whitelisted functions.\"\"\"\n    tree = parse_ast_tree(code.format(whitelist_name))\n\n    visitor = NestedComplexityVisitor(default_opt"
 },
 "831": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "217",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": " parse_ast_tree(code.format(whitelist_name))\n\n    visitor = NestedComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "832": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "244",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": "is possible to nest whitelisted functions.\"\"\"\n    tree = parse_ast_tree(mode(code.format(whitelist_name)))\n\n    visitor = NestedComplexityVisitor(default_opt"
 },
 "833": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "246",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": "_ast_tree(mode(code.format(whitelist_name)))\n\n    visitor = NestedComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Nes"
 },
 "834": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "265",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": " possible to nest lambda inside functions.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = NestedComplexityVisitor(default_opt"
 },
 "835": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "267",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": "ns.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = NestedComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "836": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "292",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": "es/wemake-python-styleguide/issues/94\n    \"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = NestedComplexityVisitor(default_opt"
 },
 "837": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.nested.NestedComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_nested/test_nested_functions.py",
  "lineno": "294",
  "column": "4",
  "slicing": "['nested_function_in_function = \"\"\"\\n', 'nested_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_async_function = \"\"\"\\n', 'nested_async_function_in_function = \"\"\"\\n', 'nested_function_in_if = \"\"\"\\n', 'nested_function_in_if_else = \"\"\"\\n', 'nested_function_while_loop = \"\"\"\\n', 'nested_function_in_for_loop = \"\"\"\\n', 'nested_function_in_try = \"\"\"\\n', 'nested_function_in_try_except = \"\"\"\\n', 'nested_function_in_try_else = \"\"\"\\n', 'nested_function_in_try_finally = \"\"\"\\n', 'nested_function_in_method = \"\"\"\\n', 'nested_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_async_method = \"\"\"\\n', 'nested_async_function_in_method = \"\"\"\\n', 'lambda_in_function = \"\"\"\\n', 'lambda_in_method = \"\"\"\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(code.format(nested_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, nested_name)\\n', '    nested_function_in_function,\\n', '    nested_async_function_in_function,\\n', '    nested_function_in_async_function,\\n', '    nested_async_function_in_async_function,\\n', '    nested_function_in_method,\\n', '    nested_async_function_in_method,\\n', '    nested_function_in_async_method,\\n', '    nested_async_function_in_async_method,\\n', '    tree = parse_ast_tree(code.format(whitelist_name))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nested_function_in_if,\\n', '    nested_function_in_if_else,\\n', '    nested_function_while_loop,\\n', '    nested_function_in_for_loop,\\n', '    nested_function_in_try,\\n', '    nested_function_in_try_except,\\n', '    nested_function_in_try_else,\\n', '    nested_function_in_try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(whitelist_name)))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', '    assert_error_text(visitor, whitelist_name)\\n', '    lambda_in_function,\\n', '    lambda_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = NestedComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedFunctionViolation])\\n', \"    assert_error_text(visitor, 'lambda')\\n\"]",
  "context": "   \"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = NestedComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Nes"
 },
 "838": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_annotation_complexity/test_annotation_complexity_nesting.py",
  "lineno": "85",
  "column": "4",
  "slicing": "[\"annassign_template = 'some: {0}'\\n\", 'function_arg_template = \"\"\"\\n', 'function_posonly_arg_template = \"\"\"\\n', 'function_args_template = \"\"\"\\n', 'function_kwargs_template = \"\"\"\\n', 'function_kwarg_template = \"\"\"\\n', 'function_return_template = \"\"\"\\n', 'class_field_template = \"\"\"\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    option_values = options(max_annotation_complexity=2)\\n', '    visitor = AnnotationComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_annotation_complexity)\\n\"]",
  "context": " with correct call chain length work well.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    visitor = AnnotationComplexityVisitor(default"
 },
 "839": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.annotations.AnnotationComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_annotation_complexity/test_annotation_complexity_nesting.py",
  "lineno": "87",
  "column": "4",
  "slicing": "[\"annassign_template = 'some: {0}'\\n\", 'function_arg_template = \"\"\"\\n', 'function_posonly_arg_template = \"\"\"\\n', 'function_args_template = \"\"\"\\n', 'function_kwargs_template = \"\"\"\\n', 'function_kwarg_template = \"\"\"\\n', 'function_return_template = \"\"\"\\n', 'class_field_template = \"\"\"\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    option_values = options(max_annotation_complexity=2)\\n', '    visitor = AnnotationComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_annotation_complexity)\\n\"]",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "840": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_annotation_complexity/test_annotation_complexity_nesting.py",
  "lineno": "132",
  "column": "4",
  "slicing": "[\"annassign_template = 'some: {0}'\\n\", 'function_arg_template = \"\"\"\\n', 'function_posonly_arg_template = \"\"\"\\n', 'function_args_template = \"\"\"\\n', 'function_kwargs_template = \"\"\"\\n', 'function_kwarg_template = \"\"\"\\n', 'function_return_template = \"\"\"\\n', 'class_field_template = \"\"\"\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    option_values = options(max_annotation_complexity=2)\\n', '    visitor = AnnotationComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_annotation_complexity)\\n\"]",
  "context": " with correct call chain length work well.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    visitor = AnnotationComplexityVisitor(default"
 },
 "841": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.annotations.AnnotationComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_annotation_complexity/test_annotation_complexity_nesting.py",
  "lineno": "134",
  "column": "4",
  "slicing": "[\"annassign_template = 'some: {0}'\\n\", 'function_arg_template = \"\"\"\\n', 'function_posonly_arg_template = \"\"\"\\n', 'function_args_template = \"\"\"\\n', 'function_kwargs_template = \"\"\"\\n', 'function_kwarg_template = \"\"\"\\n', 'function_return_template = \"\"\"\\n', 'class_field_template = \"\"\"\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    option_values = options(max_annotation_complexity=2)\\n', '    visitor = AnnotationComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_annotation_complexity)\\n\"]",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "842": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_annotation_complexity/test_annotation_complexity_nesting.py",
  "lineno": "168",
  "column": "4",
  "slicing": "[\"annassign_template = 'some: {0}'\\n\", 'function_arg_template = \"\"\"\\n', 'function_posonly_arg_template = \"\"\"\\n', 'function_args_template = \"\"\"\\n', 'function_kwargs_template = \"\"\"\\n', 'function_kwarg_template = \"\"\"\\n', 'function_return_template = \"\"\"\\n', 'class_field_template = \"\"\"\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    option_values = options(max_annotation_complexity=2)\\n', '    visitor = AnnotationComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_annotation_complexity)\\n\"]",
  "context": " with correct call chain length work well.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    option_values = options(max_annotation_comple"
 },
 "843": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_annotation_complexity/test_annotation_complexity_nesting.py",
  "lineno": "170",
  "column": "4",
  "slicing": "[\"annassign_template = 'some: {0}'\\n\", 'function_arg_template = \"\"\"\\n', 'function_posonly_arg_template = \"\"\"\\n', 'function_args_template = \"\"\"\\n', 'function_kwargs_template = \"\"\"\\n', 'function_kwarg_template = \"\"\"\\n', 'function_return_template = \"\"\"\\n', 'class_field_template = \"\"\"\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    option_values = options(max_annotation_complexity=2)\\n', '    visitor = AnnotationComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_annotation_complexity)\\n\"]",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    option_values = options(max_annotation_complexity=2)\n    visitor = AnnotationComplexityVisitor(option_v"
 },
 "844": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.annotations.AnnotationComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_annotation_complexity/test_annotation_complexity_nesting.py",
  "lineno": "171",
  "column": "4",
  "slicing": "[\"annassign_template = 'some: {0}'\\n\", 'function_arg_template = \"\"\"\\n', 'function_posonly_arg_template = \"\"\"\\n', 'function_args_template = \"\"\"\\n', 'function_kwargs_template = \"\"\"\\n', 'function_kwarg_template = \"\"\"\\n', 'function_return_template = \"\"\"\\n', 'class_field_template = \"\"\"\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = AnnotationComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', '    annassign_template,\\n', '    function_arg_template,\\n', '    function_args_template,\\n', '    function_kwargs_template,\\n', '    function_kwarg_template,\\n', '        function_posonly_arg_template,\\n', '    function_return_template,\\n', '    class_field_template,\\n', '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    option_values = options(max_annotation_complexity=2)\\n', '    visitor = AnnotationComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooComplexAnnotationViolation])\\n', \"    assert_error_text(visitor, '3', option_values.max_annotation_complexity)\\n\"]",
  "context": "values = options(max_annotation_complexity=2)\n    visitor = AnnotationComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "845": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_access/test_access.py",
  "lineno": "38",
  "column": "4",
  "slicing": "[\"subscript_access = 'my_matrix[0][0][0][0]'\\n\", \"attribute_access = 'self.attr.inner.wrapper.value'\\n\", \"mixed_access = 'self.attr[0].wrapper[0]'\\n\", \"mixed_with_calls_access = 'self.attr[0]().wrapper[0][0].bar().foo[0]()'\\n\", \"call_chain = 'manager.filter().exclude().annotate().values().first()'\\n\", '    subscript_access,\\n', '    attribute_access,\\n', '    mixed_access,\\n', '    mixed_with_calls_access,\\n', '    call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=4)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (subscript_access, 4),\\n', '    (attribute_access, 4),\\n', '    (mixed_access, 4),\\n', '    (mixed_with_calls_access, 4),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=3)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepAccessViolation])\\n', '        visitor,\\n', '        option_values.max_access_level,\\n']",
  "context": "sions with correct access level work well.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_access_level=4)\n "
 },
 "846": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_access/test_access.py",
  "lineno": "40",
  "column": "4",
  "slicing": "[\"subscript_access = 'my_matrix[0][0][0][0]'\\n\", \"attribute_access = 'self.attr.inner.wrapper.value'\\n\", \"mixed_access = 'self.attr[0].wrapper[0]'\\n\", \"mixed_with_calls_access = 'self.attr[0]().wrapper[0][0].bar().foo[0]()'\\n\", \"call_chain = 'manager.filter().exclude().annotate().values().first()'\\n\", '    subscript_access,\\n', '    attribute_access,\\n', '    mixed_access,\\n', '    mixed_with_calls_access,\\n', '    call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=4)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (subscript_access, 4),\\n', '    (attribute_access, 4),\\n', '    (mixed_access, 4),\\n', '    (mixed_with_calls_access, 4),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=3)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepAccessViolation])\\n', '        visitor,\\n', '        option_values.max_access_level,\\n']",
  "context": "ll.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_access_level=4)\n    visitor = AccessVisitor(option_values, tree=tr"
 },
 "847": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.access.AccessVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_access/test_access.py",
  "lineno": "41",
  "column": "4",
  "slicing": "[\"subscript_access = 'my_matrix[0][0][0][0]'\\n\", \"attribute_access = 'self.attr.inner.wrapper.value'\\n\", \"mixed_access = 'self.attr[0].wrapper[0]'\\n\", \"mixed_with_calls_access = 'self.attr[0]().wrapper[0][0].bar().foo[0]()'\\n\", \"call_chain = 'manager.filter().exclude().annotate().values().first()'\\n\", '    subscript_access,\\n', '    attribute_access,\\n', '    mixed_access,\\n', '    mixed_with_calls_access,\\n', '    call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=4)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (subscript_access, 4),\\n', '    (attribute_access, 4),\\n', '    (mixed_access, 4),\\n', '    (mixed_with_calls_access, 4),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=3)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepAccessViolation])\\n', '        visitor,\\n', '        option_values.max_access_level,\\n']",
  "context": "  option_values = options(max_access_level=4)\n    visitor = AccessVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "848": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_access/test_access.py",
  "lineno": "64",
  "column": "4",
  "slicing": "[\"subscript_access = 'my_matrix[0][0][0][0]'\\n\", \"attribute_access = 'self.attr.inner.wrapper.value'\\n\", \"mixed_access = 'self.attr[0].wrapper[0]'\\n\", \"mixed_with_calls_access = 'self.attr[0]().wrapper[0][0].bar().foo[0]()'\\n\", \"call_chain = 'manager.filter().exclude().annotate().values().first()'\\n\", '    subscript_access,\\n', '    attribute_access,\\n', '    mixed_access,\\n', '    mixed_with_calls_access,\\n', '    call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=4)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (subscript_access, 4),\\n', '    (attribute_access, 4),\\n', '    (mixed_access, 4),\\n', '    (mixed_with_calls_access, 4),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=3)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepAccessViolation])\\n', '        visitor,\\n', '        option_values.max_access_level,\\n']",
  "context": " are raised when reaching too deep access.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_access_level=3)\n "
 },
 "849": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_access/test_access.py",
  "lineno": "66",
  "column": "4",
  "slicing": "[\"subscript_access = 'my_matrix[0][0][0][0]'\\n\", \"attribute_access = 'self.attr.inner.wrapper.value'\\n\", \"mixed_access = 'self.attr[0].wrapper[0]'\\n\", \"mixed_with_calls_access = 'self.attr[0]().wrapper[0][0].bar().foo[0]()'\\n\", \"call_chain = 'manager.filter().exclude().annotate().values().first()'\\n\", '    subscript_access,\\n', '    attribute_access,\\n', '    mixed_access,\\n', '    mixed_with_calls_access,\\n', '    call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=4)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (subscript_access, 4),\\n', '    (attribute_access, 4),\\n', '    (mixed_access, 4),\\n', '    (mixed_with_calls_access, 4),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=3)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepAccessViolation])\\n', '        visitor,\\n', '        option_values.max_access_level,\\n']",
  "context": "ss.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_access_level=3)\n    visitor = AccessVisitor(option_values, tree=tr"
 },
 "850": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.access.AccessVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_access/test_access.py",
  "lineno": "67",
  "column": "4",
  "slicing": "[\"subscript_access = 'my_matrix[0][0][0][0]'\\n\", \"attribute_access = 'self.attr.inner.wrapper.value'\\n\", \"mixed_access = 'self.attr[0].wrapper[0]'\\n\", \"mixed_with_calls_access = 'self.attr[0]().wrapper[0][0].bar().foo[0]()'\\n\", \"call_chain = 'manager.filter().exclude().annotate().values().first()'\\n\", '    subscript_access,\\n', '    attribute_access,\\n', '    mixed_access,\\n', '    mixed_with_calls_access,\\n', '    call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=4)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (subscript_access, 4),\\n', '    (attribute_access, 4),\\n', '    (mixed_access, 4),\\n', '    (mixed_with_calls_access, 4),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_access_level=3)\\n', '    visitor = AccessVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooDeepAccessViolation])\\n', '        visitor,\\n', '        option_values.max_access_level,\\n']",
  "context": "  option_values = options(max_access_level=3)\n    visitor = AccessVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "851": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_call_chains/test_call_chains.py",
  "lineno": "33",
  "column": "4",
  "slicing": "[\"deep_call_chain = 'foo(a)(b)(c)(d)'\\n\", \"call_chain = 'bar(a)(b)'\\n\", \"long_call_chain = 'baz(a)(b)(c)'\\n\", '    deep_call_chain,\\n', '    call_chain,\\n', '    long_call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=4)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (call_chain, 2),\\n', '    (deep_call_chain, 4),\\n', '    (long_call_chain, 3),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=1)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCallChainViolation])\\n', '    assert_error_text(visitor, str(call_level), option_values.max_call_level)\\n']",
  "context": " with correct call chain length work well.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_call_level=4)\n   "
 },
 "852": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_call_chains/test_call_chains.py",
  "lineno": "35",
  "column": "4",
  "slicing": "[\"deep_call_chain = 'foo(a)(b)(c)(d)'\\n\", \"call_chain = 'bar(a)(b)'\\n\", \"long_call_chain = 'baz(a)(b)(c)'\\n\", '    deep_call_chain,\\n', '    call_chain,\\n', '    long_call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=4)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (call_chain, 2),\\n', '    (deep_call_chain, 4),\\n', '    (long_call_chain, 3),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=1)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCallChainViolation])\\n', '    assert_error_text(visitor, str(call_level), option_values.max_call_level)\\n']",
  "context": "ll.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_call_level=4)\n    visitor = CallChainsVisitor(option_values, tre"
 },
 "853": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.calls.CallChainsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_call_chains/test_call_chains.py",
  "lineno": "36",
  "column": "4",
  "slicing": "[\"deep_call_chain = 'foo(a)(b)(c)(d)'\\n\", \"call_chain = 'bar(a)(b)'\\n\", \"long_call_chain = 'baz(a)(b)(c)'\\n\", '    deep_call_chain,\\n', '    call_chain,\\n', '    long_call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=4)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (call_chain, 2),\\n', '    (deep_call_chain, 4),\\n', '    (long_call_chain, 3),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=1)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCallChainViolation])\\n', '    assert_error_text(visitor, str(call_level), option_values.max_call_level)\\n']",
  "context": "    option_values = options(max_call_level=4)\n    visitor = CallChainsVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "854": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_call_chains/test_call_chains.py",
  "lineno": "57",
  "column": "4",
  "slicing": "[\"deep_call_chain = 'foo(a)(b)(c)(d)'\\n\", \"call_chain = 'bar(a)(b)'\\n\", \"long_call_chain = 'baz(a)(b)(c)'\\n\", '    deep_call_chain,\\n', '    call_chain,\\n', '    long_call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=4)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (call_chain, 2),\\n', '    (deep_call_chain, 4),\\n', '    (long_call_chain, 3),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=1)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCallChainViolation])\\n', '    assert_error_text(visitor, str(call_level), option_values.max_call_level)\\n']",
  "context": "e raised when using a too long call chain.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_call_level=1)\n   "
 },
 "855": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_call_chains/test_call_chains.py",
  "lineno": "59",
  "column": "4",
  "slicing": "[\"deep_call_chain = 'foo(a)(b)(c)(d)'\\n\", \"call_chain = 'bar(a)(b)'\\n\", \"long_call_chain = 'baz(a)(b)(c)'\\n\", '    deep_call_chain,\\n', '    call_chain,\\n', '    long_call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=4)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (call_chain, 2),\\n', '    (deep_call_chain, 4),\\n', '    (long_call_chain, 3),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=1)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCallChainViolation])\\n', '    assert_error_text(visitor, str(call_level), option_values.max_call_level)\\n']",
  "context": "in.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_call_level=1)\n    visitor = CallChainsVisitor(option_values, tre"
 },
 "856": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.calls.CallChainsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_call_chains/test_call_chains.py",
  "lineno": "60",
  "column": "4",
  "slicing": "[\"deep_call_chain = 'foo(a)(b)(c)(d)'\\n\", \"call_chain = 'bar(a)(b)'\\n\", \"long_call_chain = 'baz(a)(b)(c)'\\n\", '    deep_call_chain,\\n', '    call_chain,\\n', '    long_call_chain,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=4)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (call_chain, 2),\\n', '    (deep_call_chain, 4),\\n', '    (long_call_chain, 3),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_call_level=1)\\n', '    visitor = CallChainsVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongCallChainViolation])\\n', '    assert_error_text(visitor, str(call_level), option_values.max_call_level)\\n']",
  "context": "    option_values = options(max_call_level=1)\n    visitor = CallChainsVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "857": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_awaits_count.py",
  "lineno": "41",
  "column": "4",
  "slicing": "[\"function_without_awaits = 'def function(): ...'\\n\", \"function_async_without_awaits = 'async def function(): ...'\\n\", 'function_with_awaits = \"\"\"\\n', 'function_with_nested_function_and_awaits = \"\"\"\\n', '    function_without_awaits,\\n', '    function_async_without_awaits,\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_awaits=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAwaitsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_awaits)\\n\"]",
  "context": " \"\"\"Testing that awaits counted correctly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = FunctionComplexityVisitor(default_o"
 },
 "858": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_awaits_count.py",
  "lineno": "43",
  "column": "4",
  "slicing": "[\"function_without_awaits = 'def function(): ...'\\n\", \"function_async_without_awaits = 'async def function(): ...'\\n\", 'function_with_awaits = \"\"\"\\n', 'function_with_nested_function_and_awaits = \"\"\"\\n', '    function_without_awaits,\\n', '    function_async_without_awaits,\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_awaits=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAwaitsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_awaits)\\n\"]",
  "context": "orrectly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = FunctionComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "859": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_awaits_count.py",
  "lineno": "61",
  "column": "4",
  "slicing": "[\"function_without_awaits = 'def function(): ...'\\n\", \"function_async_without_awaits = 'async def function(): ...'\\n\", 'function_with_awaits = \"\"\"\\n', 'function_with_nested_function_and_awaits = \"\"\"\\n', '    function_without_awaits,\\n', '    function_async_without_awaits,\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_awaits=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAwaitsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_awaits)\\n\"]",
  "context": "Testing that many awaits raises a warning.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_awaits=1)\n    vis"
 },
 "860": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_awaits_count.py",
  "lineno": "63",
  "column": "4",
  "slicing": "[\"function_without_awaits = 'def function(): ...'\\n\", \"function_async_without_awaits = 'async def function(): ...'\\n\", 'function_with_awaits = \"\"\"\\n', 'function_with_nested_function_and_awaits = \"\"\"\\n', '    function_without_awaits,\\n', '    function_async_without_awaits,\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_awaits=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAwaitsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_awaits)\\n\"]",
  "context": " warning.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_awaits=1)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "861": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_awaits_count.py",
  "lineno": "64",
  "column": "4",
  "slicing": "[\"function_without_awaits = 'def function(): ...'\\n\", \"function_async_without_awaits = 'async def function(): ...'\\n\", 'function_with_awaits = \"\"\"\\n', 'function_with_nested_function_and_awaits = \"\"\"\\n', '    function_without_awaits,\\n', '    function_async_without_awaits,\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_awaits,\\n', '    function_with_nested_function_and_awaits,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_awaits=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAwaitsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_awaits)\\n\"]",
  "context": "e)\n\n    option_values = options(max_awaits=1)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "862": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "39",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nctions with correct argument count works.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = FunctionComplexityVisitor(default_o"
 },
 "863": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "41",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nt works.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = FunctionComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "864": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "66",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nctions with correct argument count works.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_arguments=1)\n    "
 },
 "865": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "68",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nt works.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_arguments=1)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "866": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "69",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    option_values = options(max_arguments=1)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "867": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "94",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ns with multiple arguments raise an error.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_arguments=0)\n    "
 },
 "868": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "96",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "an error.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_arguments=0)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "869": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "97",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    option_values = options(max_arguments=0)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "870": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "114",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t lambda functions with no arguments work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_arguments=0)\n    "
 },
 "871": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "116",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nts work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_arguments=0)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "872": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments_lambda.py",
  "lineno": "117",
  "column": "4",
  "slicing": "[\"lambda_without_arguments = 'lambda: ...'\\n\", \"lambda_with_single_argument = 'lambda arg1: ...'\\n\", \"lambda_with_default_argument = 'lambda arg1=None: ...'\\n\", \"lambda_with_single_args = 'lambda *args: ...'\\n\", \"lambda_with_posonly_args = 'lambda arg, /: ...'\\n\", \"lambda_with_single_kwargs = 'lambda **kwargs: ...'\\n\", \"lambda_with_single_kwonly = 'lambda *, kwonly=True: ...'\\n\", '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_without_arguments,\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    lambda_with_single_argument,\\n', '    lambda_with_default_argument,\\n', '    lambda_with_single_args,\\n', '        lambda_with_posonly_args,\\n', '    lambda_with_single_kwargs,\\n', '    lambda_with_single_kwonly,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    lambda_without_arguments,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    option_values = options(max_arguments=0)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "873": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_asserts_count.py",
  "lineno": "39",
  "column": "4",
  "slicing": "[\"function_without_asserts = 'def function(): ...'\\n\", 'function_with_asserts = \"\"\"\\n', 'function_with_nested_function_and_asserts = \"\"\"\\n', '    function_without_asserts,\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_asserts=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAssertsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_asserts)\\n\"]",
  "context": "\"\"\"Testing that asserts counted correctly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = FunctionComplexityVisitor(default_o"
 },
 "874": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_asserts_count.py",
  "lineno": "41",
  "column": "4",
  "slicing": "[\"function_without_asserts = 'def function(): ...'\\n\", 'function_with_asserts = \"\"\"\\n', 'function_with_nested_function_and_asserts = \"\"\"\\n', '    function_without_asserts,\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_asserts=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAssertsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_asserts)\\n\"]",
  "context": "orrectly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = FunctionComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "875": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_asserts_count.py",
  "lineno": "59",
  "column": "4",
  "slicing": "[\"function_without_asserts = 'def function(): ...'\\n\", 'function_with_asserts = \"\"\"\\n', 'function_with_nested_function_and_asserts = \"\"\"\\n', '    function_without_asserts,\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_asserts=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAssertsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_asserts)\\n\"]",
  "context": "esting that many asserts raises a warning.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_asserts=1)\n    vi"
 },
 "876": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_asserts_count.py",
  "lineno": "61",
  "column": "4",
  "slicing": "[\"function_without_asserts = 'def function(): ...'\\n\", 'function_with_asserts = \"\"\"\\n', 'function_with_nested_function_and_asserts = \"\"\"\\n', '    function_without_asserts,\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_asserts=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAssertsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_asserts)\\n\"]",
  "context": " warning.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_asserts=1)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "877": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_asserts_count.py",
  "lineno": "62",
  "column": "4",
  "slicing": "[\"function_without_asserts = 'def function(): ...'\\n\", 'function_with_asserts = \"\"\"\\n', 'function_with_nested_function_and_asserts = \"\"\"\\n', '    function_without_asserts,\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_asserts,\\n', '    function_with_nested_function_and_asserts,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_asserts=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyAssertsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_asserts)\\n\"]",
  "context": ")\n\n    option_values = options(max_asserts=1)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "878": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_local_variables.py",
  "lineno": "100",
  "column": "4",
  "slicing": "['function_with_locals = \"\"\"\\n', 'function_with_walrus = \"\"\"\\n', 'function_with_locals_redefinition = \"\"\"\\n', 'function_with_locals_and_params = \"\"\"\\n', 'function_with_comprehension = \"\"\"\\n', 'function_with_nested = \"\"\"\\n', 'function_with_nested_and_params = \"\"\"\\n', 'method_with_locals = \"\"\"\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=2)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=1)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyLocalsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_local_variables)\\n\"]",
  "context": "s/wemake-python-styleguide/issues/247\n    \"\"\"\n    option_values = options(max_local_variables=2)\n    tree = parse_ast_tree(mode(code))\n\n    visitor"
 },
 "879": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_local_variables.py",
  "lineno": "101",
  "column": "4",
  "slicing": "['function_with_locals = \"\"\"\\n', 'function_with_walrus = \"\"\"\\n', 'function_with_locals_redefinition = \"\"\"\\n', 'function_with_locals_and_params = \"\"\"\\n', 'function_with_comprehension = \"\"\"\\n', 'function_with_nested = \"\"\"\\n', 'function_with_nested_and_params = \"\"\"\\n', 'method_with_locals = \"\"\"\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=2)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=1)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyLocalsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_local_variables)\\n\"]",
  "context": "ption_values = options(max_local_variables=2)\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionComplexityVisitor(option_va"
 },
 "880": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_local_variables.py",
  "lineno": "103",
  "column": "4",
  "slicing": "['function_with_locals = \"\"\"\\n', 'function_with_walrus = \"\"\"\\n', 'function_with_locals_redefinition = \"\"\"\\n', 'function_with_locals_and_params = \"\"\"\\n', 'function_with_comprehension = \"\"\"\\n', 'function_with_nested = \"\"\"\\n', 'function_with_nested_and_params = \"\"\"\\n', 'method_with_locals = \"\"\"\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=2)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=1)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyLocalsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_local_variables)\\n\"]",
  "context": "les=2)\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "881": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_local_variables.py",
  "lineno": "139",
  "column": "4",
  "slicing": "['function_with_locals = \"\"\"\\n', 'function_with_walrus = \"\"\"\\n', 'function_with_locals_redefinition = \"\"\"\\n', 'function_with_locals_and_params = \"\"\"\\n', 'function_with_comprehension = \"\"\"\\n', 'function_with_nested = \"\"\"\\n', 'function_with_nested_and_params = \"\"\"\\n', 'method_with_locals = \"\"\"\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=2)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=1)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyLocalsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_local_variables)\\n\"]",
  "context": "s/wemake-python-styleguide/issues/247\n    \"\"\"\n    option_values = options(max_local_variables=1)\n    tree = parse_ast_tree(mode(code))\n\n    visitor"
 },
 "882": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_local_variables.py",
  "lineno": "140",
  "column": "4",
  "slicing": "['function_with_locals = \"\"\"\\n', 'function_with_walrus = \"\"\"\\n', 'function_with_locals_redefinition = \"\"\"\\n', 'function_with_locals_and_params = \"\"\"\\n', 'function_with_comprehension = \"\"\"\\n', 'function_with_nested = \"\"\"\\n', 'function_with_nested_and_params = \"\"\"\\n', 'method_with_locals = \"\"\"\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=2)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=1)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyLocalsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_local_variables)\\n\"]",
  "context": "ption_values = options(max_local_variables=1)\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionComplexityVisitor(option_va"
 },
 "883": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_local_variables.py",
  "lineno": "142",
  "column": "4",
  "slicing": "['function_with_locals = \"\"\"\\n', 'function_with_walrus = \"\"\"\\n', 'function_with_locals_redefinition = \"\"\"\\n', 'function_with_locals_and_params = \"\"\"\\n', 'function_with_comprehension = \"\"\"\\n', 'function_with_nested = \"\"\"\\n', 'function_with_nested_and_params = \"\"\"\\n', 'method_with_locals = \"\"\"\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=2)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_locals,\\n', '        function_with_walrus,\\n', '    function_with_locals_redefinition,\\n', '    function_with_locals_and_params,\\n', '    function_with_comprehension,\\n', '    function_with_nested,\\n', '    function_with_nested_and_params,\\n', '    method_with_locals,\\n', '    option_values = options(max_local_variables=1)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyLocalsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_local_variables)\\n\"]",
  "context": "les=1)\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "884": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_raises.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['module_many_raises = \"\"\"\\n', 'lambda_many_raises = \"\"\"\\n', 'function_template = \"\"\"\\n', 'instance_method_template = \"\"\"\\n', 'class_method_template = \"\"\"\\n', 'static_method_template = \"\"\"\\n', '    module_many_raises,\\n', '    lambda_many_raises,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = context.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = function_template.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyRaisesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_raises)\\n\"]",
  "context": " \"\"\"Testing that raises counted correctly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_raises=1)\n    vis"
 },
 "885": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_raises.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['module_many_raises = \"\"\"\\n', 'lambda_many_raises = \"\"\"\\n', 'function_template = \"\"\"\\n', 'instance_method_template = \"\"\"\\n', 'class_method_template = \"\"\"\\n', 'static_method_template = \"\"\"\\n', '    module_many_raises,\\n', '    lambda_many_raises,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = context.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = function_template.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyRaisesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_raises)\\n\"]",
  "context": "orrectly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_raises=1)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "886": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_raises.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['module_many_raises = \"\"\"\\n', 'lambda_many_raises = \"\"\"\\n', 'function_template = \"\"\"\\n', 'instance_method_template = \"\"\"\\n', 'class_method_template = \"\"\"\\n', 'static_method_template = \"\"\"\\n', '    module_many_raises,\\n', '    lambda_many_raises,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = context.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = function_template.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyRaisesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_raises)\\n\"]",
  "context": "e)\n\n    option_values = options(max_raises=1)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "887": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_raises.py",
  "lineno": "99",
  "column": "4",
  "slicing": "['module_many_raises = \"\"\"\\n', 'lambda_many_raises = \"\"\"\\n', 'function_template = \"\"\"\\n', 'instance_method_template = \"\"\"\\n', 'class_method_template = \"\"\"\\n', 'static_method_template = \"\"\"\\n', '    module_many_raises,\\n', '    lambda_many_raises,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = context.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = function_template.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyRaisesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_raises)\\n\"]",
  "context": "stance = context.format(first, second, third)\n    tree = parse_ast_tree(mode(test_instance))\n\n    visitor = FunctionComplexityVisitor(default_o"
 },
 "888": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_raises.py",
  "lineno": "101",
  "column": "4",
  "slicing": "['module_many_raises = \"\"\"\\n', 'lambda_many_raises = \"\"\"\\n', 'function_template = \"\"\"\\n', 'instance_method_template = \"\"\"\\n', 'class_method_template = \"\"\"\\n', 'static_method_template = \"\"\"\\n', '    module_many_raises,\\n', '    lambda_many_raises,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = context.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = function_template.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyRaisesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_raises)\\n\"]",
  "context": "  tree = parse_ast_tree(mode(test_instance))\n\n    visitor = FunctionComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "889": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_raises.py",
  "lineno": "130",
  "column": "4",
  "slicing": "['module_many_raises = \"\"\"\\n', 'lambda_many_raises = \"\"\"\\n', 'function_template = \"\"\"\\n', 'instance_method_template = \"\"\"\\n', 'class_method_template = \"\"\"\\n', 'static_method_template = \"\"\"\\n', '    module_many_raises,\\n', '    lambda_many_raises,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = context.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = function_template.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyRaisesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_raises)\\n\"]",
  "context": "unction_template.format(first, second, third)\n    tree = parse_ast_tree(mode(test_instance))\n\n    option_values = options(max_raises=1)\n    vis"
 },
 "890": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_raises.py",
  "lineno": "132",
  "column": "4",
  "slicing": "['module_many_raises = \"\"\"\\n', 'lambda_many_raises = \"\"\"\\n', 'function_template = \"\"\"\\n', 'instance_method_template = \"\"\"\\n', 'class_method_template = \"\"\"\\n', 'static_method_template = \"\"\"\\n', '    module_many_raises,\\n', '    lambda_many_raises,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = context.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = function_template.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyRaisesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_raises)\\n\"]",
  "context": "  tree = parse_ast_tree(mode(test_instance))\n\n    option_values = options(max_raises=1)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "891": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_raises.py",
  "lineno": "133",
  "column": "4",
  "slicing": "['module_many_raises = \"\"\"\\n', 'lambda_many_raises = \"\"\"\\n', 'function_template = \"\"\"\\n', 'instance_method_template = \"\"\"\\n', 'class_method_template = \"\"\"\\n', 'static_method_template = \"\"\"\\n', '    module_many_raises,\\n', '    lambda_many_raises,\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = context.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_template,\\n', '    instance_method_template,\\n', '    class_method_template,\\n', '    static_method_template,\\n', '    test_instance = function_template.format(first, second, third)\\n', '    tree = parse_ast_tree(mode(test_instance))\\n', '    option_values = options(max_raises=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyRaisesViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_raises)\\n\"]",
  "context": "))\n\n    option_values = options(max_raises=1)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "892": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_expressions.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['function_without_expressions = \"\"\"\\n', 'function_with_expressions = \"\"\"\\n', 'function_with_nested_function_and_expressions = \"\"\"\\n', '    function_without_expressions,\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_expressions=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyExpressionsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_expressions)\\n\"]",
  "context": "esting that expressions counted correctly.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionComplexityVisitor(default_o"
 },
 "893": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_expressions.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['function_without_expressions = \"\"\"\\n', 'function_with_expressions = \"\"\"\\n', 'function_with_nested_function_and_expressions = \"\"\"\\n', '    function_without_expressions,\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_expressions=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyExpressionsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_expressions)\\n\"]",
  "context": "ly.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "894": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_expressions.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['function_without_expressions = \"\"\"\\n', 'function_with_expressions = \"\"\"\\n', 'function_with_nested_function_and_expressions = \"\"\"\\n', '    function_without_expressions,\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_expressions=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyExpressionsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_expressions)\\n\"]",
  "context": "ng that many expressions raises a warning.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_expressions=1)\n  "
 },
 "895": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_expressions.py",
  "lineno": "66",
  "column": "4",
  "slicing": "['function_without_expressions = \"\"\"\\n', 'function_with_expressions = \"\"\"\\n', 'function_with_nested_function_and_expressions = \"\"\"\\n', '    function_without_expressions,\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_expressions=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyExpressionsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_expressions)\\n\"]",
  "context": "ng.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_expressions=1)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "896": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_expressions.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['function_without_expressions = \"\"\"\\n', 'function_with_expressions = \"\"\"\\n', 'function_with_nested_function_and_expressions = \"\"\"\\n', '    function_without_expressions,\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_expressions,\\n', '    function_with_nested_function_and_expressions,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_expressions=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyExpressionsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_expressions)\\n\"]",
  "context": "   option_values = options(max_expressions=1)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "897": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_returns.py",
  "lineno": "40",
  "column": "4",
  "slicing": "[\"function_without_returns = 'def function(): ...'\\n\", 'function_with_returns = \"\"\"\\n', 'function_with_nested_function_and_returns = \"\"\"\\n', '    function_without_returns,\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_returns=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyReturnsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_returns)\\n\"]",
  "context": "\"\"\"Testing that returns counted correctly.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionComplexityVisitor(default_o"
 },
 "898": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_returns.py",
  "lineno": "42",
  "column": "4",
  "slicing": "[\"function_without_returns = 'def function(): ...'\\n\", 'function_with_returns = \"\"\"\\n', 'function_with_nested_function_and_returns = \"\"\"\\n', '    function_without_returns,\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_returns=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyReturnsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_returns)\\n\"]",
  "context": "ly.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "899": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_returns.py",
  "lineno": "61",
  "column": "4",
  "slicing": "[\"function_without_returns = 'def function(): ...'\\n\", 'function_with_returns = \"\"\"\\n', 'function_with_nested_function_and_returns = \"\"\"\\n', '    function_without_returns,\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_returns=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyReturnsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_returns)\\n\"]",
  "context": "esting that many returns raises a warning.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_returns=1)\n    vi"
 },
 "900": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_returns.py",
  "lineno": "63",
  "column": "4",
  "slicing": "[\"function_without_returns = 'def function(): ...'\\n\", 'function_with_returns = \"\"\"\\n', 'function_with_nested_function_and_returns = \"\"\"\\n', '    function_without_returns,\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_returns=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyReturnsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_returns)\\n\"]",
  "context": "ng.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_returns=1)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "901": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_returns.py",
  "lineno": "64",
  "column": "4",
  "slicing": "[\"function_without_returns = 'def function(): ...'\\n\", 'function_with_returns = \"\"\"\\n', 'function_with_nested_function_and_returns = \"\"\"\\n', '    function_without_returns,\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_with_returns,\\n', '    function_with_nested_function_and_returns,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_returns=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyReturnsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_returns)\\n\"]",
  "context": ")\n\n    option_values = options(max_returns=1)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "902": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "nctions with correct argument count works.\"\"\"\n    tree = parse_ast_tree(mode(single_argument))\n\n    visitor = FunctionComplexityVisitor(default_o"
 },
 "903": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "tree = parse_ast_tree(mode(single_argument))\n\n    visitor = FunctionComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "904": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "nctions with correct argument count works.\"\"\"\n    tree = parse_ast_tree(mode(single_argument))\n\n    option_values = options(max_arguments=1)\n    "
 },
 "905": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "tree = parse_ast_tree(mode(single_argument))\n\n    option_values = options(max_arguments=1)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "906": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "\n    option_values = options(max_arguments=1)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "907": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "res that functions with no arguments work.\"\"\"\n    tree = parse_ast_tree(mode('def function(): ...'))\n\n    option_values = options(max_arguments=0)\n    "
 },
 "908": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": " parse_ast_tree(mode('def function(): ...'))\n\n    option_values = options(max_arguments=0)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "909": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "52",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "\n    option_values = options(max_arguments=0)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "910": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "se violation when there are multiple args.\"\"\"\n    tree = parse_ast_tree(mode(single_argument))\n\n    option_values = options(max_arguments=0)\n    "
 },
 "911": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "tree = parse_ast_tree(mode(single_argument))\n\n    option_values = options(max_arguments=0)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "912": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "\n    option_values = options(max_arguments=0)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "913": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "se violation when there are multiple args.\"\"\"\n    tree = parse_ast_tree(mode(two_arguments))\n\n    option_values = options(max_arguments=1)\n    "
 },
 "914": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "  tree = parse_ast_tree(mode(two_arguments))\n\n    option_values = options(max_arguments=1)\n    visitor = FunctionComplexityVisitor(option_val"
 },
 "915": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.FunctionComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_arguments.py",
  "lineno": "89",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(single_argument))\\n', '    visitor = FunctionComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    tree = parse_ast_tree(mode('def function(): ...'))\\n\", '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(single_argument))\\n', '    option_values = options(max_arguments=0)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '1', option_values.max_arguments)\\n\", '    tree = parse_ast_tree(mode(two_arguments))\\n', '    option_values = options(max_arguments=1)\\n', '    visitor = FunctionComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooManyArgumentsViolation])\\n', \"    assert_error_text(visitor, '2', option_values.max_arguments)\\n\"]",
  "context": "\n    option_values = options(max_arguments=1)\n    visitor = FunctionComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "916": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_score.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '22', default_options.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_score=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1', option_values.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that complex cognitive code does not work.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = CognitiveComplexityVisitor(default_"
 },
 "917": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.CognitiveComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_score.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '22', default_options.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_score=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1', option_values.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rk.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "918": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_score.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '22', default_options.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_score=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1', option_values.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that complex can be modified via settings.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_cognitive_score=0"
 },
 "919": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_score.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '22', default_options.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_score=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1', option_values.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "gs.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_cognitive_score=0)\n    visitor = CognitiveComplexityVisitor(option_va"
 },
 "920": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.CognitiveComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_score.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '22', default_options.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_score=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1', option_values.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ption_values = options(max_cognitive_score=0)\n    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "921": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_score.py",
  "lineno": "114",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '22', default_options.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_score=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1', option_values.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ures that simple cognitive code does work.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = CognitiveComplexityVisitor(default_"
 },
 "922": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.CognitiveComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_score.py",
  "lineno": "116",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '22', default_options.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_score=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1', option_values.max_cognitive_score, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rk.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "923": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_average.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_average=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1.0', option_values.max_cognitive_average, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that complex cognitive code does not work.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = CognitiveComplexityVisitor(default_"
 },
 "924": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.CognitiveComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_average.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_average=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1.0', option_values.max_cognitive_average, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rk.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "925": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_average.py",
  "lineno": "81",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_average=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1.0', option_values.max_cognitive_average, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that complex can be modified via settings.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_cognitive_average"
 },
 "926": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_average.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_average=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1.0', option_values.max_cognitive_average, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "gs.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_cognitive_average=0)\n    visitor = CognitiveComplexityVisitor(option_va"
 },
 "927": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.CognitiveComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_average.py",
  "lineno": "84",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_average=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1.0', option_values.max_cognitive_average, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ion_values = options(max_cognitive_average=0)\n    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "928": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_average.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_average=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1.0', option_values.max_cognitive_average, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ures that simple cognitive code does work.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = CognitiveComplexityVisitor(default_"
 },
 "929": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.function.CognitiveComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_function/test_cognitive/test_cognitive_average.py",
  "lineno": "112",
  "column": "4",
  "slicing": "['complex_function = \"\"\"\\n', 'function_example = \"\"\"\\n', 'method_example = \"\"\"\\n', '    complex_function,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_cognitive_average=0)\\n', '    visitor = CognitiveComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"        visitor, '1.0', option_values.max_cognitive_average, multiple=True,\\n\", '    function_example,\\n', '    method_example,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rk.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = CognitiveComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "930": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_module_complexity.py",
  "lineno": "45",
  "column": "4",
  "slicing": "[\"module_without_nodes = ''\\n\", 'module_with_nodes = \"\"\"\\n', 'module_with_function = \"\"\"\\n', 'module_with_class = \"\"\"\\n', '    module_without_nodes,\\n', '    module_with_nodes,\\n', '    module_with_function,\\n', '    module_with_class,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_without_nodes, 0),\\n', '    (module_with_nodes, 8.5),\\n', '    (module_with_function, 6),\\n', '    (module_with_class, 2),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_jones_score=-1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [JonesScoreViolation])\\n', '    assert_error_text(visitor, str(score), option_values.max_jones_score)\\n']",
  "context": "hat regular nodes do not raise violations.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = JonesComplexityVisitor(default_opti"
 },
 "931": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.jones.JonesComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_module_complexity.py",
  "lineno": "47",
  "column": "4",
  "slicing": "[\"module_without_nodes = ''\\n\", 'module_with_nodes = \"\"\"\\n', 'module_with_function = \"\"\"\\n', 'module_with_class = \"\"\"\\n', '    module_without_nodes,\\n', '    module_with_nodes,\\n', '    module_with_function,\\n', '    module_with_class,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_without_nodes, 0),\\n', '    (module_with_nodes, 8.5),\\n', '    (module_with_function, 6),\\n', '    (module_with_class, 2),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_jones_score=-1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [JonesScoreViolation])\\n', '    assert_error_text(visitor, str(score), option_values.max_jones_score)\\n']",
  "context": "ns.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = JonesComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "932": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_module_complexity.py",
  "lineno": "69",
  "column": "4",
  "slicing": "[\"module_without_nodes = ''\\n\", 'module_with_nodes = \"\"\"\\n', 'module_with_function = \"\"\"\\n', 'module_with_class = \"\"\"\\n', '    module_without_nodes,\\n', '    module_with_nodes,\\n', '    module_with_function,\\n', '    module_with_class,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_without_nodes, 0),\\n', '    (module_with_nodes, 8.5),\\n', '    (module_with_function, 6),\\n', '    (module_with_class, 2),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_jones_score=-1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [JonesScoreViolation])\\n', '    assert_error_text(visitor, str(score), option_values.max_jones_score)\\n']",
  "context": "ng that regular nodes do raise violations.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_jones_score=-1)\n "
 },
 "933": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_module_complexity.py",
  "lineno": "71",
  "column": "4",
  "slicing": "[\"module_without_nodes = ''\\n\", 'module_with_nodes = \"\"\"\\n', 'module_with_function = \"\"\"\\n', 'module_with_class = \"\"\"\\n', '    module_without_nodes,\\n', '    module_with_nodes,\\n', '    module_with_function,\\n', '    module_with_class,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_without_nodes, 0),\\n', '    (module_with_nodes, 8.5),\\n', '    (module_with_function, 6),\\n', '    (module_with_class, 2),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_jones_score=-1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [JonesScoreViolation])\\n', '    assert_error_text(visitor, str(score), option_values.max_jones_score)\\n']",
  "context": "ns.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    option_values = options(max_jones_score=-1)\n    visitor = JonesComplexityVisitor(option_values"
 },
 "934": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.jones.JonesComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_module_complexity.py",
  "lineno": "72",
  "column": "4",
  "slicing": "[\"module_without_nodes = ''\\n\", 'module_with_nodes = \"\"\"\\n', 'module_with_function = \"\"\"\\n', 'module_with_class = \"\"\"\\n', '    module_without_nodes,\\n', '    module_with_nodes,\\n', '    module_with_function,\\n', '    module_with_class,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (module_without_nodes, 0),\\n', '    (module_with_nodes, 8.5),\\n', '    (module_with_function, 6),\\n', '    (module_with_class, 2),\\n', '    tree = parse_ast_tree(mode(code))\\n', '    option_values = options(max_jones_score=-1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [JonesScoreViolation])\\n', '    assert_error_text(visitor, str(score), option_values.max_jones_score)\\n']",
  "context": "  option_values = options(max_jones_score=-1)\n    visitor = JonesComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Jon"
 },
 "935": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "80",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "hat regular nodes do not raise violations.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = JonesComplexityVisitor(default_opti"
 },
 "936": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.jones.JonesComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "82",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "olations.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = JonesComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "937": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "109",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "ng that complex lines do raise violations.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_line_complexity=1"
 },
 "938": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "111",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "olations.\"\"\"\n    tree = parse_ast_tree(code)\n\n    option_values = options(max_line_complexity=1)\n    visitor = JonesComplexityVisitor(option_values"
 },
 "939": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.jones.JonesComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "112",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "ption_values = options(max_line_complexity=1)\n    visitor = JonesComplexityVisitor(option_values, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Lin"
 },
 "940": {
  "name": "tree_without_types",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "123",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "ures that complexity is counted correctly.\"\"\"\n    tree_without_types = parse_ast_tree(line_simple)\n    tree_with_types = parse_ast_tree(line_with_typ"
 },
 "941": {
  "name": "tree_with_types",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "124",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "e_without_types = parse_ast_tree(line_simple)\n    tree_with_types = parse_ast_tree(line_with_types)\n\n    simple_visitor = JonesComplexityVisitor(\n    "
 },
 "942": {
  "name": "simple_visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.jones.JonesComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "126",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "with_types = parse_ast_tree(line_with_types)\n\n    simple_visitor = JonesComplexityVisitor(\n        default_options, tree=tree_without_types,\n"
 },
 "943": {
  "name": "typed_visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.jones.JonesComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "129",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "fault_options, tree=tree_without_types,\n    )\n    typed_visitor = JonesComplexityVisitor(\n        default_options, tree=tree_with_types,\n   "
 },
 "944": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "148",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "ures that complexity is counted correctly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = JonesComplexityVisitor(default_opti"
 },
 "945": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.jones.JonesComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "150",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "orrectly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = JonesComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert len(visitor._lines) "
 },
 "946": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "172",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "ures that complexity is counted correctly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = JonesComplexityVisitor(default_opti"
 },
 "947": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.complexity.jones.JonesComplexityVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_complexity/test_jones/test_line_complexity.py",
  "lineno": "174",
  "column": "4",
  "slicing": "[\"line_simple = 'x = 2'\\n\", \"line_with_types = 'x: int = 2'\\n\", \"line_with_complex_types = 'x: Dict[Tuple[str, str, int], Set[List[attr.Val]]]'\\n\", 'line_with_comprehension = \\'x = [f for f in \"abc\"]\\'\\n', \"line_with_math = 'x = y * 2 + 19 / 9.3'\\n\", 'line_inside_function = \"\"\"\\n', 'line_inside_async_function = \"\"\"\\n', 'line_inside_class = \"\"\"\\n', 'class_with_function = \"\"\"\\n', 'class_with_async_function = \"\"\"\\n', 'class_with_usual_and_async_function = \"\"\"\\n', \"function_declaration = 'def some_function(): ...'\\n\", \"async_function_declaration = 'async def some_function(): ...'\\n\", \"class_declaration = 'class SomeClass(object): ...'\\n\", \"empty_module = ''\\n\", \"regression1216 = 'call.endswith(post) and len(node.args) == self._post[post]'\\n\", '    line_simple,\\n', '    line_with_types,\\n', '    line_with_complex_types,\\n', '    line_with_comprehension,\\n', '    line_with_math,\\n', '    line_inside_function,\\n', '    line_inside_async_function,\\n', '    line_inside_class,\\n', '    function_declaration,\\n', '    async_function_declaration,\\n', '    class_declaration,\\n', '    empty_module,\\n', '    class_with_function,\\n', '    class_with_async_function,\\n', '    class_with_usual_and_async_function,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    (line_simple, 3),\\n', '    (line_with_types, 3),\\n', '    (line_with_complex_types, 2),\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (line_inside_function, 4),\\n', '    (line_inside_async_function, 4),\\n', '    (line_inside_class, 5),\\n', '    (class_with_function, 4),\\n', '    (class_with_async_function, 4),\\n', '    tree = parse_ast_tree(code)\\n', '    option_values = options(max_line_complexity=1)\\n', '    visitor = JonesComplexityVisitor(option_values, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineComplexityViolation])\\n', '        visitor, str(complexity), option_values.max_line_complexity,\\n', '    tree_without_types = parse_ast_tree(line_simple)\\n', '    tree_with_types = parse_ast_tree(line_with_types)\\n', '    simple_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_without_types,\\n', '    typed_visitor = JonesComplexityVisitor(\\n', '        default_options, tree=tree_with_types,\\n', '    simple_visitor.run()\\n', '    typed_visitor.run()\\n', '    assert len(simple_visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(simple_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    assert len(typed_visitor._lines[1]) == 3  # noqa: WPS437\\n', '    (line_with_comprehension, 6),\\n', '    (line_with_math, 9),\\n', '    (regression1216, 15),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == 1  # noqa: WPS437\\n', '    assert len(visitor._lines[1]) == complexity  # noqa: WPS437\\n', '    (line_inside_function, 1),\\n', '    (line_inside_async_function, 1),\\n', '    (class_with_async_function, 2),\\n', '    (class_with_function, 2),\\n', '    (class_with_usual_and_async_function, 3),\\n', '    (regression1216, 1),\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = JonesComplexityVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert len(visitor._lines) == number_of_lines  # noqa: WPS437\\n']",
  "context": "orrectly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = JonesComplexityVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert len(visitor._lines) "
 },
 "948": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_outer_scope_shadow.py",
  "lineno": "285",
  "column": "4",
  "slicing": "['correct_for_loop1 = \"\"\"\\n', 'correct_for_loop2 = \"\"\"\\n', 'correct_for_loop3 = \"\"\"\\n', 'correct_for_comprehension = \"\"\"\\n', 'correct_except = \"\"\"\\n', 'correct_with1 = \"\"\"\\n', 'correct_with2 = \"\"\"\\n', 'correct_with3 = \"\"\"\\n', 'correct_class1 = \"\"\"\\n', 'correct_class2 = \"\"\"\\n', 'correct_class3 = \"\"\"\\n', 'correct_class4 = \"\"\"\\n', 'correct_walrus = \"\"\"\\n', 'import_overlap1 = \"\"\"\\n', 'import_overlap2 = \"\"\"\\n', 'import_overlap3 = \"\"\"\\n', 'import_overlap4 = \"\"\"\\n', 'function_overlap1 = \"\"\"\\n', 'function_overlap2 = \"\"\"\\n', 'constant_overlap1 = \"\"\"\\n', 'constant_overlap2 = \"\"\"\\n', 'constant_overlap3 = \"\"\"\\n', 'constant_overlap4 = \"\"\"\\n', 'constant_overlap5 = \"\"\"\\n', 'constant_overlap6 = \"\"\"\\n', 'walrus_overlap = \"\"\"\\n', '    correct_for_loop1,\\n', '    correct_for_loop2,\\n', '    correct_for_loop3,\\n', '    correct_for_comprehension,\\n', '    correct_except,\\n', '    correct_with1,\\n', '    correct_with2,\\n', '    correct_with3,\\n', '    correct_class1,\\n', '    correct_class2,\\n', '    correct_class3,\\n', '    correct_class4,\\n', '        correct_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_overlap1,\\n', '    import_overlap2,\\n', '    import_overlap3,\\n', '    import_overlap4,\\n', '    function_overlap1,\\n', '    function_overlap2,\\n', '    constant_overlap1,\\n', '    constant_overlap2,\\n', '    constant_overlap3,\\n', '    constant_overlap4,\\n', '    constant_overlap5,\\n', '    constant_overlap6,\\n', '        walrus_overlap,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OuterScopeShadowingViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "using variables inside a block is correct.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "949": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_outer_scope_shadow.py",
  "lineno": "287",
  "column": "4",
  "slicing": "['correct_for_loop1 = \"\"\"\\n', 'correct_for_loop2 = \"\"\"\\n', 'correct_for_loop3 = \"\"\"\\n', 'correct_for_comprehension = \"\"\"\\n', 'correct_except = \"\"\"\\n', 'correct_with1 = \"\"\"\\n', 'correct_with2 = \"\"\"\\n', 'correct_with3 = \"\"\"\\n', 'correct_class1 = \"\"\"\\n', 'correct_class2 = \"\"\"\\n', 'correct_class3 = \"\"\"\\n', 'correct_class4 = \"\"\"\\n', 'correct_walrus = \"\"\"\\n', 'import_overlap1 = \"\"\"\\n', 'import_overlap2 = \"\"\"\\n', 'import_overlap3 = \"\"\"\\n', 'import_overlap4 = \"\"\"\\n', 'function_overlap1 = \"\"\"\\n', 'function_overlap2 = \"\"\"\\n', 'constant_overlap1 = \"\"\"\\n', 'constant_overlap2 = \"\"\"\\n', 'constant_overlap3 = \"\"\"\\n', 'constant_overlap4 = \"\"\"\\n', 'constant_overlap5 = \"\"\"\\n', 'constant_overlap6 = \"\"\"\\n', 'walrus_overlap = \"\"\"\\n', '    correct_for_loop1,\\n', '    correct_for_loop2,\\n', '    correct_for_loop3,\\n', '    correct_for_comprehension,\\n', '    correct_except,\\n', '    correct_with1,\\n', '    correct_with2,\\n', '    correct_with3,\\n', '    correct_class1,\\n', '    correct_class2,\\n', '    correct_class3,\\n', '    correct_class4,\\n', '        correct_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_overlap1,\\n', '    import_overlap2,\\n', '    import_overlap3,\\n', '    import_overlap4,\\n', '    function_overlap1,\\n', '    function_overlap2,\\n', '    constant_overlap1,\\n', '    constant_overlap2,\\n', '    constant_overlap3,\\n', '    constant_overlap4,\\n', '    constant_overlap5,\\n', '    constant_overlap6,\\n', '        walrus_overlap,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OuterScopeShadowingViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ct.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "950": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_outer_scope_shadow.py",
  "lineno": "319",
  "column": "4",
  "slicing": "['correct_for_loop1 = \"\"\"\\n', 'correct_for_loop2 = \"\"\"\\n', 'correct_for_loop3 = \"\"\"\\n', 'correct_for_comprehension = \"\"\"\\n', 'correct_except = \"\"\"\\n', 'correct_with1 = \"\"\"\\n', 'correct_with2 = \"\"\"\\n', 'correct_with3 = \"\"\"\\n', 'correct_class1 = \"\"\"\\n', 'correct_class2 = \"\"\"\\n', 'correct_class3 = \"\"\"\\n', 'correct_class4 = \"\"\"\\n', 'correct_walrus = \"\"\"\\n', 'import_overlap1 = \"\"\"\\n', 'import_overlap2 = \"\"\"\\n', 'import_overlap3 = \"\"\"\\n', 'import_overlap4 = \"\"\"\\n', 'function_overlap1 = \"\"\"\\n', 'function_overlap2 = \"\"\"\\n', 'constant_overlap1 = \"\"\"\\n', 'constant_overlap2 = \"\"\"\\n', 'constant_overlap3 = \"\"\"\\n', 'constant_overlap4 = \"\"\"\\n', 'constant_overlap5 = \"\"\"\\n', 'constant_overlap6 = \"\"\"\\n', 'walrus_overlap = \"\"\"\\n', '    correct_for_loop1,\\n', '    correct_for_loop2,\\n', '    correct_for_loop3,\\n', '    correct_for_comprehension,\\n', '    correct_except,\\n', '    correct_with1,\\n', '    correct_with2,\\n', '    correct_with3,\\n', '    correct_class1,\\n', '    correct_class2,\\n', '    correct_class3,\\n', '    correct_class4,\\n', '        correct_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_overlap1,\\n', '    import_overlap2,\\n', '    import_overlap3,\\n', '    import_overlap4,\\n', '    function_overlap1,\\n', '    function_overlap2,\\n', '    constant_overlap1,\\n', '    constant_overlap2,\\n', '    constant_overlap3,\\n', '    constant_overlap4,\\n', '    constant_overlap5,\\n', '    constant_overlap6,\\n', '        walrus_overlap,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OuterScopeShadowingViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "sting that shadowing vars are not allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "951": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_outer_scope_shadow.py",
  "lineno": "321",
  "column": "4",
  "slicing": "['correct_for_loop1 = \"\"\"\\n', 'correct_for_loop2 = \"\"\"\\n', 'correct_for_loop3 = \"\"\"\\n', 'correct_for_comprehension = \"\"\"\\n', 'correct_except = \"\"\"\\n', 'correct_with1 = \"\"\"\\n', 'correct_with2 = \"\"\"\\n', 'correct_with3 = \"\"\"\\n', 'correct_class1 = \"\"\"\\n', 'correct_class2 = \"\"\"\\n', 'correct_class3 = \"\"\"\\n', 'correct_class4 = \"\"\"\\n', 'correct_walrus = \"\"\"\\n', 'import_overlap1 = \"\"\"\\n', 'import_overlap2 = \"\"\"\\n', 'import_overlap3 = \"\"\"\\n', 'import_overlap4 = \"\"\"\\n', 'function_overlap1 = \"\"\"\\n', 'function_overlap2 = \"\"\"\\n', 'constant_overlap1 = \"\"\"\\n', 'constant_overlap2 = \"\"\"\\n', 'constant_overlap3 = \"\"\"\\n', 'constant_overlap4 = \"\"\"\\n', 'constant_overlap5 = \"\"\"\\n', 'constant_overlap6 = \"\"\"\\n', 'walrus_overlap = \"\"\"\\n', '    correct_for_loop1,\\n', '    correct_for_loop2,\\n', '    correct_for_loop3,\\n', '    correct_for_comprehension,\\n', '    correct_except,\\n', '    correct_with1,\\n', '    correct_with2,\\n', '    correct_with3,\\n', '    correct_class1,\\n', '    correct_class2,\\n', '    correct_class3,\\n', '    correct_class4,\\n', '        correct_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_overlap1,\\n', '    import_overlap2,\\n', '    import_overlap3,\\n', '    import_overlap4,\\n', '    function_overlap1,\\n', '    function_overlap2,\\n', '    constant_overlap1,\\n', '    constant_overlap2,\\n', '    constant_overlap3,\\n', '    constant_overlap4,\\n', '    constant_overlap5,\\n', '    constant_overlap6,\\n', '        walrus_overlap,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OuterScopeShadowingViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Out"
 },
 "952": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_outer_scope_shadow.py",
  "lineno": "343",
  "column": "4",
  "slicing": "['correct_for_loop1 = \"\"\"\\n', 'correct_for_loop2 = \"\"\"\\n', 'correct_for_loop3 = \"\"\"\\n', 'correct_for_comprehension = \"\"\"\\n', 'correct_except = \"\"\"\\n', 'correct_with1 = \"\"\"\\n', 'correct_with2 = \"\"\"\\n', 'correct_with3 = \"\"\"\\n', 'correct_class1 = \"\"\"\\n', 'correct_class2 = \"\"\"\\n', 'correct_class3 = \"\"\"\\n', 'correct_class4 = \"\"\"\\n', 'correct_walrus = \"\"\"\\n', 'import_overlap1 = \"\"\"\\n', 'import_overlap2 = \"\"\"\\n', 'import_overlap3 = \"\"\"\\n', 'import_overlap4 = \"\"\"\\n', 'function_overlap1 = \"\"\"\\n', 'function_overlap2 = \"\"\"\\n', 'constant_overlap1 = \"\"\"\\n', 'constant_overlap2 = \"\"\"\\n', 'constant_overlap3 = \"\"\"\\n', 'constant_overlap4 = \"\"\"\\n', 'constant_overlap5 = \"\"\"\\n', 'constant_overlap6 = \"\"\"\\n', 'walrus_overlap = \"\"\"\\n', '    correct_for_loop1,\\n', '    correct_for_loop2,\\n', '    correct_for_loop3,\\n', '    correct_for_comprehension,\\n', '    correct_except,\\n', '    correct_with1,\\n', '    correct_with2,\\n', '    correct_with3,\\n', '    correct_class1,\\n', '    correct_class2,\\n', '    correct_class3,\\n', '    correct_class4,\\n', '        correct_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_overlap1,\\n', '    import_overlap2,\\n', '    import_overlap3,\\n', '    import_overlap4,\\n', '    function_overlap1,\\n', '    function_overlap2,\\n', '    constant_overlap1,\\n', '    constant_overlap2,\\n', '    constant_overlap3,\\n', '    constant_overlap4,\\n', '    constant_overlap5,\\n', '    constant_overlap6,\\n', '        walrus_overlap,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OuterScopeShadowingViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": " a = 2\n\n    def test2(a):\n        ...\n    \"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "953": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_outer_scope_shadow.py",
  "lineno": "345",
  "column": "4",
  "slicing": "['correct_for_loop1 = \"\"\"\\n', 'correct_for_loop2 = \"\"\"\\n', 'correct_for_loop3 = \"\"\"\\n', 'correct_for_comprehension = \"\"\"\\n', 'correct_except = \"\"\"\\n', 'correct_with1 = \"\"\"\\n', 'correct_with2 = \"\"\"\\n', 'correct_with3 = \"\"\"\\n', 'correct_class1 = \"\"\"\\n', 'correct_class2 = \"\"\"\\n', 'correct_class3 = \"\"\"\\n', 'correct_class4 = \"\"\"\\n', 'correct_walrus = \"\"\"\\n', 'import_overlap1 = \"\"\"\\n', 'import_overlap2 = \"\"\"\\n', 'import_overlap3 = \"\"\"\\n', 'import_overlap4 = \"\"\"\\n', 'function_overlap1 = \"\"\"\\n', 'function_overlap2 = \"\"\"\\n', 'constant_overlap1 = \"\"\"\\n', 'constant_overlap2 = \"\"\"\\n', 'constant_overlap3 = \"\"\"\\n', 'constant_overlap4 = \"\"\"\\n', 'constant_overlap5 = \"\"\"\\n', 'constant_overlap6 = \"\"\"\\n', 'walrus_overlap = \"\"\"\\n', '    correct_for_loop1,\\n', '    correct_for_loop2,\\n', '    correct_for_loop3,\\n', '    correct_for_comprehension,\\n', '    correct_except,\\n', '    correct_with1,\\n', '    correct_with2,\\n', '    correct_with3,\\n', '    correct_class1,\\n', '    correct_class2,\\n', '    correct_class3,\\n', '    correct_class4,\\n', '        correct_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_overlap1,\\n', '    import_overlap2,\\n', '    import_overlap3,\\n', '    import_overlap4,\\n', '    function_overlap1,\\n', '    function_overlap2,\\n', '    constant_overlap1,\\n', '    constant_overlap2,\\n', '    constant_overlap3,\\n', '    constant_overlap4,\\n', '    constant_overlap5,\\n', '    constant_overlap6,\\n', '        walrus_overlap,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OuterScopeShadowingViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "   \"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "954": {
  "name": "_assigned_statements",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/conftest.py",
  "lineno": "12",
  "column": "0",
  "slicing": "[\"simple_assign = '{0} = 1'\\n\", \"multiple_assign = '{0} = unmatched_assign = 1'\\n\", \"annotated_assign1 = '{0}: type = 1'\\n\", \"simple_annotation = '{0}: type'\\n\", \"unpacking_assign1 = '{0}, unmatched_assign = (1, 2)'\\n\", \"unpacking_assign2 = 'unmatched_assign, *{0} = (1, 2)'\\n\", '_assigned_statements = [\\n', '    simple_assign,\\n', '    multiple_assign,\\n', '    annotated_assign1,\\n', '    unpacking_assign1,\\n', '    unpacking_assign2,\\n', '_assigned_and_annotation_statements = _assigned_statements + [simple_annotation]\\n', '@pytest.fixture(params=_assigned_statements)\\n', '@pytest.fixture(params=_assigned_and_annotation_statements)\\n']",
  "context": "king_assign2 = 'unmatched_assign, *{0} = (1, 2)'\n\n_assigned_statements = [\n    simple_assign,\n    multiple_assign,\n    annota"
 },
 "955": {
  "name": "_assigned_and_annotation_statements",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/conftest.py",
  "lineno": "20",
  "column": "0",
  "slicing": "[\"simple_assign = '{0} = 1'\\n\", \"multiple_assign = '{0} = unmatched_assign = 1'\\n\", \"annotated_assign1 = '{0}: type = 1'\\n\", \"simple_annotation = '{0}: type'\\n\", \"unpacking_assign1 = '{0}, unmatched_assign = (1, 2)'\\n\", \"unpacking_assign2 = 'unmatched_assign, *{0} = (1, 2)'\\n\", '_assigned_statements = [\\n', '    simple_assign,\\n', '    multiple_assign,\\n', '    annotated_assign1,\\n', '    unpacking_assign1,\\n', '    unpacking_assign2,\\n', '_assigned_and_annotation_statements = _assigned_statements + [simple_annotation]\\n', '@pytest.fixture(params=_assigned_statements)\\n', '@pytest.fixture(params=_assigned_and_annotation_statements)\\n']",
  "context": "\n    unpacking_assign1,\n    unpacking_assign2,\n]\n\n_assigned_and_annotation_statements = _assigned_statements + [simple_annotation]\n\n\n@pytest.fixture(params=_assigned_statements)\ndef"
 },
 "956": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_control_variables.py",
  "lineno": "213",
  "column": "4",
  "slicing": "['wrong_for_loop1 = \"\"\"\\n', 'wrong_for_loop2 = \"\"\"\\n', 'wrong_for_loop3 = \"\"\"\\n', 'wrong_with1 = \"\"\"\\n', 'wrong_with2 = \"\"\"\\n', 'wrong_with3 = \"\"\"\\n', '    wrong_for_loop1,\\n', '    wrong_for_loop2,\\n', '    wrong_for_loop3,\\n', '    wrong_with1,\\n', '    wrong_with2,\\n', '    wrong_with3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ControlVarUsedAfterBlockViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "g variable after the block is not allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = AfterBlockVariablesVisitor(default_"
 },
 "957": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.AfterBlockVariablesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_control_variables.py",
  "lineno": "215",
  "column": "4",
  "slicing": "['wrong_for_loop1 = \"\"\"\\n', 'wrong_for_loop2 = \"\"\"\\n', 'wrong_for_loop3 = \"\"\"\\n', 'wrong_with1 = \"\"\"\\n', 'wrong_with2 = \"\"\"\\n', 'wrong_with3 = \"\"\"\\n', '    wrong_for_loop1,\\n', '    wrong_for_loop2,\\n', '    wrong_for_loop3,\\n', '    wrong_with1,\\n', '    wrong_with2,\\n', '    wrong_with3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ControlVarUsedAfterBlockViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Con"
 },
 "958": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_control_variables.py",
  "lineno": "248",
  "column": "4",
  "slicing": "['wrong_for_loop1 = \"\"\"\\n', 'wrong_for_loop2 = \"\"\"\\n', 'wrong_for_loop3 = \"\"\"\\n', 'wrong_with1 = \"\"\"\\n', 'wrong_with2 = \"\"\"\\n', 'wrong_with3 = \"\"\"\\n', '    wrong_for_loop1,\\n', '    wrong_for_loop2,\\n', '    wrong_for_loop3,\\n', '    wrong_with1,\\n', '    wrong_with2,\\n', '    wrong_with3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ControlVarUsedAfterBlockViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "using variables inside a block is correct.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = AfterBlockVariablesVisitor(default_"
 },
 "959": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.AfterBlockVariablesVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_control_variables.py",
  "lineno": "250",
  "column": "4",
  "slicing": "['wrong_for_loop1 = \"\"\"\\n', 'wrong_for_loop2 = \"\"\"\\n', 'wrong_for_loop3 = \"\"\"\\n', 'wrong_with1 = \"\"\"\\n', 'wrong_with2 = \"\"\"\\n', 'wrong_with3 = \"\"\"\\n', '    wrong_for_loop1,\\n', '    wrong_for_loop2,\\n', '    wrong_for_loop3,\\n', '    wrong_with1,\\n', '    wrong_with2,\\n', '    wrong_with3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ControlVarUsedAfterBlockViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ct.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = AfterBlockVariablesVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "960": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "73",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "assign_statement.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "961": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "75",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "962": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "107",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tation_statement.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "963": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "109",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "964": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "141",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    'print({0})'.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "965": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "143",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "966": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "178",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "notation_statement.format(second_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "967": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "180",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "968": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "212",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ad_template.format(import_overload, pipeline)\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "969": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "214",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "eline)\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "970": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "235",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "template.format(decorator_template, pipeline)\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "971": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "237",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "eline)\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "972": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "262",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " code = method_setter_template.format('func')\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "973": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_function_block.py",
  "lineno": "264",
  "column": "4",
  "slicing": "[\"function_def1 = 'def {0}():'\\n\", 'function_template1 = \"\"\"\\n', 'function_template2 = \"\"\"\\n', 'method_template1 = \"\"\"\\n', 'method_template2 = \"\"\"\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    function_def1,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    function_def1,\\n', '    function_template1,\\n', '    function_template2,\\n', '    method_template1,\\n', '    method_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', 'pipeline = \"\"\"\\n', 'overload_template = \"\"\"\\n', '    code = overload_template.format(import_overload, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = overload_template.format(decorator_template, pipeline)\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', 'method_setter_template = \"\"\"\\n', \"    code = method_setter_template.format('func')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "func')\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "974": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_import_block.py",
  "lineno": "64",
  "column": "4",
  "slicing": "[\"import_block = 'import {0}'\\n\", \"import_block_as = 'import some as {0}'\\n\", \"from_import_block = 'from some import {0}'\\n\", \"from_import_block_as = 'from some import some as {0}'\\n\", 'import_template1 = \"\"\"\\n', 'import_template2 = \"\"\"\\n', 'import_template3 = \"\"\"\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tation_statement.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "975": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_import_block.py",
  "lineno": "66",
  "column": "4",
  "slicing": "[\"import_block = 'import {0}'\\n\", \"import_block_as = 'import some as {0}'\\n\", \"from_import_block = 'from some import {0}'\\n\", \"from_import_block_as = 'from some import some as {0}'\\n\", 'import_template1 = \"\"\"\\n', 'import_template2 = \"\"\"\\n', 'import_template3 = \"\"\"\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "976": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_import_block.py",
  "lineno": "101",
  "column": "4",
  "slicing": "[\"import_block = 'import {0}'\\n\", \"import_block_as = 'import some as {0}'\\n\", \"from_import_block = 'from some import {0}'\\n\", \"from_import_block_as = 'from some import some as {0}'\\n\", 'import_template1 = \"\"\"\\n', 'import_template2 = \"\"\"\\n', 'import_template3 = \"\"\"\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    'print({0})'.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "977": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_import_block.py",
  "lineno": "103",
  "column": "4",
  "slicing": "[\"import_block = 'import {0}'\\n\", \"import_block_as = 'import some as {0}'\\n\", \"from_import_block = 'from some import {0}'\\n\", \"from_import_block_as = 'from some import some as {0}'\\n\", 'import_template1 = \"\"\"\\n', 'import_template2 = \"\"\"\\n', 'import_template3 = \"\"\"\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "978": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_import_block.py",
  "lineno": "140",
  "column": "4",
  "slicing": "[\"import_block = 'import {0}'\\n\", \"import_block_as = 'import some as {0}'\\n\", \"from_import_block = 'from some import {0}'\\n\", \"from_import_block_as = 'from some import some as {0}'\\n\", 'import_template1 = \"\"\"\\n', 'import_template2 = \"\"\"\\n', 'import_template3 = \"\"\"\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "notation_statement.format(second_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "979": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_import_block.py",
  "lineno": "142",
  "column": "4",
  "slicing": "[\"import_block = 'import {0}'\\n\", \"import_block_as = 'import some as {0}'\\n\", \"from_import_block = 'from some import {0}'\\n\", \"from_import_block_as = 'from some import some as {0}'\\n\", 'import_template1 = \"\"\"\\n', 'import_template2 = \"\"\"\\n', 'import_template3 = \"\"\"\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_block,\\n', '    import_block_as,\\n', '    from_import_block,\\n', '    from_import_block_as,\\n', '    import_template1,\\n', '    import_template2,\\n', '    import_template3,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "980": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_same_name.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['context = \"\"\"\\n', \"block_statement1 = 'from some import {0}, {1}'\\n\", '    block_statement1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    block_statement1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n']",
  "context": "tement.format(first_name, second_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "981": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_same_name.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['context = \"\"\"\\n', \"block_statement1 = 'from some import {0}, {1}'\\n\", '    block_statement1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    block_statement1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "982": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_same_name.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['context = \"\"\"\\n', \"block_statement1 = 'from some import {0}, {1}'\\n\", '    block_statement1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    block_statement1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n']",
  "context": "tement.format(first_name, second_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "983": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_same_name.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['context = \"\"\"\\n', \"block_statement1 = 'from some import {0}, {1}'\\n\", '    block_statement1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    block_statement1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "984": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_try_block.py",
  "lineno": "150",
  "column": "4",
  "slicing": "[\"except_block1 = 'except Exception as {0}:'\\n\", \"except_block2 = 'except (TypeError, ValueError) as {0}:'\\n\", 'try_template1 = \"\"\"\\n', 'try_template2 = \"\"\"\\n', 'try_template3 = \"\"\"\\n', 'try_template4 = \"\"\"\\n', 'try_template5 = \"\"\"\\n', 'try_template6 = \"\"\"\\n', 'try_template7 = \"\"\"\\n', 'try_template8 = \"\"\"\\n', 'try_template9 = \"\"\"\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, violations)\\n']",
  "context": "assign_statement.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "985": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_try_block.py",
  "lineno": "152",
  "column": "4",
  "slicing": "[\"except_block1 = 'except Exception as {0}:'\\n\", \"except_block2 = 'except (TypeError, ValueError) as {0}:'\\n\", 'try_template1 = \"\"\"\\n', 'try_template2 = \"\"\"\\n', 'try_template3 = \"\"\"\\n', 'try_template4 = \"\"\"\\n', 'try_template5 = \"\"\"\\n', 'try_template6 = \"\"\"\\n', 'try_template7 = \"\"\"\\n', 'try_template8 = \"\"\"\\n', 'try_template9 = \"\"\"\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, violations)\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "986": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_try_block.py",
  "lineno": "191",
  "column": "4",
  "slicing": "[\"except_block1 = 'except Exception as {0}:'\\n\", \"except_block2 = 'except (TypeError, ValueError) as {0}:'\\n\", 'try_template1 = \"\"\"\\n', 'try_template2 = \"\"\"\\n', 'try_template3 = \"\"\"\\n', 'try_template4 = \"\"\"\\n', 'try_template5 = \"\"\"\\n', 'try_template6 = \"\"\"\\n', 'try_template7 = \"\"\"\\n', 'try_template8 = \"\"\"\\n', 'try_template9 = \"\"\"\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, violations)\\n']",
  "context": "    'print({0})'.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "987": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_try_block.py",
  "lineno": "193",
  "column": "4",
  "slicing": "[\"except_block1 = 'except Exception as {0}:'\\n\", \"except_block2 = 'except (TypeError, ValueError) as {0}:'\\n\", 'try_template1 = \"\"\"\\n', 'try_template2 = \"\"\"\\n', 'try_template3 = \"\"\"\\n', 'try_template4 = \"\"\"\\n', 'try_template5 = \"\"\"\\n', 'try_template6 = \"\"\"\\n', 'try_template7 = \"\"\"\\n', 'try_template8 = \"\"\"\\n', 'try_template9 = \"\"\"\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, violations)\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "988": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_try_block.py",
  "lineno": "234",
  "column": "4",
  "slicing": "[\"except_block1 = 'except Exception as {0}:'\\n\", \"except_block2 = 'except (TypeError, ValueError) as {0}:'\\n\", 'try_template1 = \"\"\"\\n', 'try_template2 = \"\"\"\\n', 'try_template3 = \"\"\"\\n', 'try_template4 = \"\"\"\\n', 'try_template5 = \"\"\"\\n', 'try_template6 = \"\"\"\\n', 'try_template7 = \"\"\"\\n', 'try_template8 = \"\"\"\\n', 'try_template9 = \"\"\"\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, violations)\\n']",
  "context": "notation_statement.format(second_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "989": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_try_block.py",
  "lineno": "236",
  "column": "4",
  "slicing": "[\"except_block1 = 'except Exception as {0}:'\\n\", \"except_block2 = 'except (TypeError, ValueError) as {0}:'\\n\", 'try_template1 = \"\"\"\\n', 'try_template2 = \"\"\"\\n', 'try_template3 = \"\"\"\\n', 'try_template4 = \"\"\"\\n', 'try_template5 = \"\"\"\\n', 'try_template6 = \"\"\"\\n', 'try_template7 = \"\"\"\\n', 'try_template8 = \"\"\"\\n', 'try_template9 = \"\"\"\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, violations)\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "990": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_try_block.py",
  "lineno": "259",
  "column": "4",
  "slicing": "[\"except_block1 = 'except Exception as {0}:'\\n\", \"except_block2 = 'except (TypeError, ValueError) as {0}:'\\n\", 'try_template1 = \"\"\"\\n', 'try_template2 = \"\"\"\\n', 'try_template3 = \"\"\"\\n', 'try_template4 = \"\"\"\\n', 'try_template5 = \"\"\"\\n', 'try_template6 = \"\"\"\\n', 'try_template7 = \"\"\"\\n', 'try_template8 = \"\"\"\\n', 'try_template9 = \"\"\"\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, violations)\\n']",
  "context": "/wemake-python-styleguide/issues/1115\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "991": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_try_block.py",
  "lineno": "261",
  "column": "4",
  "slicing": "[\"except_block1 = 'except Exception as {0}:'\\n\", \"except_block2 = 'except (TypeError, ValueError) as {0}:'\\n\", 'try_template1 = \"\"\"\\n', 'try_template2 = \"\"\"\\n', 'try_template3 = \"\"\"\\n', 'try_template4 = \"\"\"\\n', 'try_template5 = \"\"\"\\n', 'try_template6 = \"\"\"\\n', 'try_template7 = \"\"\"\\n', 'try_template8 = \"\"\"\\n', 'try_template9 = \"\"\"\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    except_block1,\\n', '    except_block2,\\n', '    try_template1,\\n', '    try_template2,\\n', '    try_template3,\\n', '    try_template4,\\n', '    try_template5,\\n', '    try_template6,\\n', '    try_template7,\\n', '    try_template8,\\n', '    try_template9,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, violations)\\n']",
  "context": "1115\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, viol"
 },
 "992": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_with_block.py",
  "lineno": "79",
  "column": "4",
  "slicing": "[\"with1 = 'with open() as {0}:'\\n\", \"with2 = 'with open() as ({0}, second):'\\n\", \"with3 = 'with open() as (first, *{0}):'\\n\", \"with4 = 'with open() as {0}, close() as second:'\\n\", \"with5 = 'with open() as first, close() as {0}:'\\n\", 'with_template1 = \"\"\"\\n', 'with_template2 = \"\"\"\\n', 'with_template3 = \"\"\"\\n', 'with_template4 = \"\"\"\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tation_statement.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "993": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_with_block.py",
  "lineno": "81",
  "column": "4",
  "slicing": "[\"with1 = 'with open() as {0}:'\\n\", \"with2 = 'with open() as ({0}, second):'\\n\", \"with3 = 'with open() as (first, *{0}):'\\n\", \"with4 = 'with open() as {0}, close() as second:'\\n\", \"with5 = 'with open() as first, close() as {0}:'\\n\", 'with_template1 = \"\"\"\\n', 'with_template2 = \"\"\"\\n', 'with_template3 = \"\"\"\\n', 'with_template4 = \"\"\"\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "994": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_with_block.py",
  "lineno": "118",
  "column": "4",
  "slicing": "[\"with1 = 'with open() as {0}:'\\n\", \"with2 = 'with open() as ({0}, second):'\\n\", \"with3 = 'with open() as (first, *{0}):'\\n\", \"with4 = 'with open() as {0}, close() as second:'\\n\", \"with5 = 'with open() as first, close() as {0}:'\\n\", 'with_template1 = \"\"\"\\n', 'with_template2 = \"\"\"\\n', 'with_template3 = \"\"\"\\n', 'with_template4 = \"\"\"\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    'print({0})'.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "995": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_with_block.py",
  "lineno": "120",
  "column": "4",
  "slicing": "[\"with1 = 'with open() as {0}:'\\n\", \"with2 = 'with open() as ({0}, second):'\\n\", \"with3 = 'with open() as (first, *{0}):'\\n\", \"with4 = 'with open() as {0}, close() as second:'\\n\", \"with5 = 'with open() as first, close() as {0}:'\\n\", 'with_template1 = \"\"\"\\n', 'with_template2 = \"\"\"\\n', 'with_template3 = \"\"\"\\n', 'with_template4 = \"\"\"\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "996": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_with_block.py",
  "lineno": "159",
  "column": "4",
  "slicing": "[\"with1 = 'with open() as {0}:'\\n\", \"with2 = 'with open() as ({0}, second):'\\n\", \"with3 = 'with open() as (first, *{0}):'\\n\", \"with4 = 'with open() as {0}, close() as second:'\\n\", \"with5 = 'with open() as first, close() as {0}:'\\n\", 'with_template1 = \"\"\"\\n', 'with_template2 = \"\"\"\\n', 'with_template3 = \"\"\"\\n', 'with_template4 = \"\"\"\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "notation_statement.format(second_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "997": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_with_block.py",
  "lineno": "161",
  "column": "4",
  "slicing": "[\"with1 = 'with open() as {0}:'\\n\", \"with2 = 'with open() as ({0}, second):'\\n\", \"with3 = 'with open() as (first, *{0}):'\\n\", \"with4 = 'with open() as {0}, close() as second:'\\n\", \"with5 = 'with open() as first, close() as {0}:'\\n\", 'with_template1 = \"\"\"\\n', 'with_template2 = \"\"\"\\n', 'with_template3 = \"\"\"\\n', 'with_template4 = \"\"\"\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    with1,\\n', '    with2,\\n', '    with3,\\n', '    with4,\\n', '    with5,\\n', '    with_template1,\\n', '    with_template2,\\n', '    with_template3,\\n', '    with_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "998": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_blocks_overlap.py",
  "lineno": "138",
  "column": "4",
  "slicing": "['import_and_class1 = \"\"\"\\n', 'import_and_class2 = \"\"\"\\n', 'import_and_function1 = \"\"\"\\n', 'import_and_function2 = \"\"\"\\n', 'import_and_try = \"\"\"\\n', 'loop_and_with = \"\"\"\\n', 'loop_and_loop1 = \"\"\"\\n', 'loop_and_loop2 = \"\"\"\\n', 'import_and_walrus = \"\"\"\\n', '    import_and_class1,\\n', '    import_and_class2,\\n', '    import_and_function1,\\n', '    import_and_function2,\\n', '    import_and_try,\\n', '    loop_and_with,\\n', '    loop_and_loop1,\\n', '    loop_and_loop2,\\n', '        import_and_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', \"    assert_error_text(visitor, 'overlap')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat overlaps between blocks are forbidden.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "999": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_blocks_overlap.py",
  "lineno": "140",
  "column": "4",
  "slicing": "['import_and_class1 = \"\"\"\\n', 'import_and_class2 = \"\"\"\\n', 'import_and_function1 = \"\"\"\\n', 'import_and_function2 = \"\"\"\\n', 'import_and_try = \"\"\"\\n', 'loop_and_with = \"\"\"\\n', 'loop_and_loop1 = \"\"\"\\n', 'loop_and_loop2 = \"\"\"\\n', 'import_and_walrus = \"\"\"\\n', '    import_and_class1,\\n', '    import_and_class2,\\n', '    import_and_function1,\\n', '    import_and_function2,\\n', '    import_and_try,\\n', '    loop_and_with,\\n', '    loop_and_loop1,\\n', '    loop_and_loop2,\\n', '        import_and_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', \"    assert_error_text(visitor, 'overlap')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "en.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "1000": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_blocks_overlap.py",
  "lineno": "161",
  "column": "4",
  "slicing": "['import_and_class1 = \"\"\"\\n', 'import_and_class2 = \"\"\"\\n', 'import_and_function1 = \"\"\"\\n', 'import_and_function2 = \"\"\"\\n', 'import_and_try = \"\"\"\\n', 'loop_and_with = \"\"\"\\n', 'loop_and_loop1 = \"\"\"\\n', 'loop_and_loop2 = \"\"\"\\n', 'import_and_walrus = \"\"\"\\n', '    import_and_class1,\\n', '    import_and_class2,\\n', '    import_and_function1,\\n', '    import_and_function2,\\n', '    import_and_try,\\n', '    loop_and_with,\\n', '    loop_and_loop1,\\n', '    loop_and_loop2,\\n', '        import_and_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', \"    assert_error_text(visitor, 'overlap')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  \"\"\"Testing that correct overlaps are ok.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "1001": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_blocks_overlap.py",
  "lineno": "163",
  "column": "4",
  "slicing": "['import_and_class1 = \"\"\"\\n', 'import_and_class2 = \"\"\"\\n', 'import_and_function1 = \"\"\"\\n', 'import_and_function2 = \"\"\"\\n', 'import_and_try = \"\"\"\\n', 'loop_and_with = \"\"\"\\n', 'loop_and_loop1 = \"\"\"\\n', 'loop_and_loop2 = \"\"\"\\n', 'import_and_walrus = \"\"\"\\n', '    import_and_class1,\\n', '    import_and_class2,\\n', '    import_and_function1,\\n', '    import_and_function2,\\n', '    import_and_try,\\n', '    loop_and_with,\\n', '    loop_and_loop1,\\n', '    loop_and_loop2,\\n', '        import_and_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', \"    assert_error_text(visitor, 'overlap')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ok.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1002": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "57",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tation_statement.format(variable_name),\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "1003": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "59",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "name),\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "1004": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "93",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "(variable_name),\n        variable_name,\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "1005": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "95",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_name,\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "1006": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "126",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    'print({0})'.format(variable_name),\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "1007": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "128",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "name),\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1008": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "161",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "notation_statement.format(second_name),\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "1009": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "163",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "name),\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1010": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "197",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ormat(second_name),\n        first_name,\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "1011": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_class_block.py",
  "lineno": "199",
  "column": "4",
  "slicing": "[\"class_def1 = 'class {0}():'\\n\", \"class_def2 = 'class {0}(object):'\\n\", \"class_def3 = 'class {0}:'\\n\", 'class_template1 = \"\"\"\\n', 'class_template2 = \"\"\"\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template1,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    class_def1,\\n', '    class_def2,\\n', '    class_def3,\\n', '    class_template2,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_name,\n    )\n    tree = parse_ast_tree(code)\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1012": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_loop_blocks.py",
  "lineno": "75",
  "column": "4",
  "slicing": "[\"for_loop1 = 'for {0} in some():'\\n\", \"for_loop2 = 'for {0}, second in some():'\\n\", \"for_loop3 = 'for first, *{0} in some():'\\n\", 'for_template1 = \"\"\"\\n', 'for_template2 = \"\"\"\\n', 'for_template3 = \"\"\"\\n', 'for_template4 = \"\"\"\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tation_statement.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "1013": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_loop_blocks.py",
  "lineno": "77",
  "column": "4",
  "slicing": "[\"for_loop1 = 'for {0} in some():'\\n\", \"for_loop2 = 'for {0}, second in some():'\\n\", \"for_loop3 = 'for first, *{0} in some():'\\n\", 'for_template1 = \"\"\"\\n', 'for_template2 = \"\"\"\\n', 'for_template3 = \"\"\"\\n', 'for_template4 = \"\"\"\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Blo"
 },
 "1014": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_loop_blocks.py",
  "lineno": "112",
  "column": "4",
  "slicing": "[\"for_loop1 = 'for {0} in some():'\\n\", \"for_loop2 = 'for {0}, second in some():'\\n\", \"for_loop3 = 'for first, *{0} in some():'\\n\", 'for_template1 = \"\"\"\\n', 'for_template2 = \"\"\"\\n', 'for_template3 = \"\"\"\\n', 'for_template4 = \"\"\"\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    'print({0})'.format(variable_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "1015": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_loop_blocks.py",
  "lineno": "114",
  "column": "4",
  "slicing": "[\"for_loop1 = 'for {0} in some():'\\n\", \"for_loop2 = 'for {0}, second in some():'\\n\", \"for_loop3 = 'for first, *{0} in some():'\\n\", 'for_template1 = \"\"\"\\n', 'for_template2 = \"\"\"\\n', 'for_template3 = \"\"\"\\n', 'for_template4 = \"\"\"\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1016": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_loop_blocks.py",
  "lineno": "151",
  "column": "4",
  "slicing": "[\"for_loop1 = 'for {0} in some():'\\n\", \"for_loop2 = 'for {0}, second in some():'\\n\", \"for_loop3 = 'for first, *{0} in some():'\\n\", 'for_template1 = \"\"\"\\n', 'for_template2 = \"\"\"\\n', 'for_template3 = \"\"\"\\n', 'for_template4 = \"\"\"\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "notation_statement.format(second_name),\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_option"
 },
 "1017": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.blocks.BlockVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_blocks/test_overlap/test_loop_blocks.py",
  "lineno": "153",
  "column": "4",
  "slicing": "[\"for_loop1 = 'for {0} in some():'\\n\", \"for_loop2 = 'for {0}, second in some():'\\n\", \"for_loop3 = 'for first, *{0} in some():'\\n\", 'for_template1 = \"\"\"\\n', 'for_template2 = \"\"\"\\n', 'for_template3 = \"\"\"\\n', 'for_template4 = \"\"\"\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BlockAndLocalOverlapViolation])\\n', '    assert_error_text(visitor, variable_name)\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    for_loop1,\\n', '    for_loop2,\\n', '    for_loop3,\\n', '    for_template1,\\n', '    for_template2,\\n', '    for_template3,\\n', '    for_template4,\\n', '    code = context.format(\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = BlockVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\n    )\n    tree = parse_ast_tree(mode(code))\n\n    visitor = BlockVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1018": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_iterables/test_unpacking.py",
  "lineno": "36",
  "column": "4",
  "slicing": "[\"args_unpacking_in_call = 'f(*args)'\\n\", \"spread_list_definition = '[1, 2, *numbers, 74]'\\n\", \"spread_set_definition = '{1, 2, *numbers, 74}'\\n\", \"spread_tuple_definition = '(1, 2, *numbers, 74)'\\n\", \"spread_assignment = 'first, *_ = [1, 2, 4, 3]'\\n\", '    args_unpacking_in_call,\\n', '    spread_list_definition,\\n', '    spread_set_definition,\\n', '    spread_tuple_definition,\\n', '    spread_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IterableUnpackingVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IterableUnpackingVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IterableUnpackingViolation])\\n']",
  "context": "hat correct iterable unpacking is allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = IterableUnpackingVisitor(default_op"
 },
 "1019": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.iterables.IterableUnpackingVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_iterables/test_unpacking.py",
  "lineno": "38",
  "column": "4",
  "slicing": "[\"args_unpacking_in_call = 'f(*args)'\\n\", \"spread_list_definition = '[1, 2, *numbers, 74]'\\n\", \"spread_set_definition = '{1, 2, *numbers, 74}'\\n\", \"spread_tuple_definition = '(1, 2, *numbers, 74)'\\n\", \"spread_assignment = 'first, *_ = [1, 2, 4, 3]'\\n\", '    args_unpacking_in_call,\\n', '    spread_list_definition,\\n', '    spread_set_definition,\\n', '    spread_tuple_definition,\\n', '    spread_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IterableUnpackingVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IterableUnpackingVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IterableUnpackingViolation])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = IterableUnpackingVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1020": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_iterables/test_unpacking.py",
  "lineno": "57",
  "column": "4",
  "slicing": "[\"args_unpacking_in_call = 'f(*args)'\\n\", \"spread_list_definition = '[1, 2, *numbers, 74]'\\n\", \"spread_set_definition = '{1, 2, *numbers, 74}'\\n\", \"spread_tuple_definition = '(1, 2, *numbers, 74)'\\n\", \"spread_assignment = 'first, *_ = [1, 2, 4, 3]'\\n\", '    args_unpacking_in_call,\\n', '    spread_list_definition,\\n', '    spread_set_definition,\\n', '    spread_tuple_definition,\\n', '    spread_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IterableUnpackingVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IterableUnpackingVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IterableUnpackingViolation])\\n']",
  "context": "ecessary iterable unpacking is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = IterableUnpackingVisitor(default_op"
 },
 "1021": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.iterables.IterableUnpackingVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_iterables/test_unpacking.py",
  "lineno": "59",
  "column": "4",
  "slicing": "[\"args_unpacking_in_call = 'f(*args)'\\n\", \"spread_list_definition = '[1, 2, *numbers, 74]'\\n\", \"spread_set_definition = '{1, 2, *numbers, 74}'\\n\", \"spread_tuple_definition = '(1, 2, *numbers, 74)'\\n\", \"spread_assignment = 'first, *_ = [1, 2, 4, 3]'\\n\", '    args_unpacking_in_call,\\n', '    spread_list_definition,\\n', '    spread_set_definition,\\n', '    spread_tuple_definition,\\n', '    spread_assignment,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IterableUnpackingVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IterableUnpackingVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IterableUnpackingViolation])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = IterableUnpackingVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Ite"
 },
 "1022": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_pass.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'pass')\\n\"]",
  "context": "Testing that `pass` keyword is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongKeywordVisitor(default_options"
 },
 "1023": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_pass.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'pass')\\n\"]",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1024": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_keyword_condition.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['while_template = \"\"\"\\n', \"assert_template = 'assert {0}'\\n\", 'assert_with_message_template = \\'assert {0}, \"message\"\\'\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    while_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "se coniditions in keywords are restricted.\"\"\"\n    tree = parse_ast_tree(code.format(condition))\n\n    visitor = ConstantKeywordVisitor(default_opti"
 },
 "1025": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConstantKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_keyword_condition.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['while_template = \"\"\"\\n', \"assert_template = 'assert {0}'\\n\", 'assert_with_message_template = \\'assert {0}, \"message\"\\'\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    while_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(condition))\n\n    visitor = ConstantKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1026": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_keyword_condition.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['while_template = \"\"\"\\n', \"assert_template = 'assert {0}'\\n\", 'assert_with_message_template = \\'assert {0}, \"message\"\\'\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    while_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "se coniditions in keywords are restricted.\"\"\"\n    tree = parse_ast_tree(code.format(condition))\n\n    visitor = ConstantKeywordVisitor(default_opti"
 },
 "1027": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConstantKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_keyword_condition.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['while_template = \"\"\"\\n', \"assert_template = 'assert {0}'\\n\", 'assert_with_message_template = \\'assert {0}, \"message\"\\'\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    while_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(condition))\n\n    visitor = ConstantKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1028": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_keyword_condition.py",
  "lineno": "113",
  "column": "4",
  "slicing": "['while_template = \"\"\"\\n', \"assert_template = 'assert {0}'\\n\", 'assert_with_message_template = \\'assert {0}, \"message\"\\'\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    while_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " true coniditions in keywords are allowed.\"\"\"\n    tree = parse_ast_tree(code.format(condition))\n\n    visitor = ConstantKeywordVisitor(default_opti"
 },
 "1029": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConstantKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_keyword_condition.py",
  "lineno": "115",
  "column": "4",
  "slicing": "['while_template = \"\"\"\\n', \"assert_template = 'assert {0}'\\n\", 'assert_with_message_template = \\'assert {0}, \"message\"\\'\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    while_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(condition))\n\n    visitor = ConstantKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1030": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_keyword_condition.py",
  "lineno": "135",
  "column": "4",
  "slicing": "['while_template = \"\"\"\\n', \"assert_template = 'assert {0}'\\n\", 'assert_with_message_template = \\'assert {0}, \"message\"\\'\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    while_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " true coniditions in keywords are allowed.\"\"\"\n    tree = parse_ast_tree(code.format(condition))\n\n    visitor = ConstantKeywordVisitor(default_opti"
 },
 "1031": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConstantKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_keyword_condition.py",
  "lineno": "137",
  "column": "4",
  "slicing": "['while_template = \"\"\"\\n', \"assert_template = 'assert {0}'\\n\", 'assert_with_message_template = \\'assert {0}, \"message\"\\'\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordConditionViolation])\\n', '    while_template,\\n', '    assert_template,\\n', '    assert_with_message_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    while_template,\\n', '    tree = parse_ast_tree(code.format(condition))\\n', '    visitor = ConstantKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(condition))\n\n    visitor = ConstantKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1032": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_raise.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['raise_exception_method = \"\"\"\\n', 'raise_exception_function = \"\"\"\\n', 'raise_exception_property = \"\"\"\\n', \"raise_exception_raw = 'raise {0}'\\n\", '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RaiseNotImplementedViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionRaiseViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that `raise NotImplemented` is restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(exception)))\n\n    visitor = WrongRaiseVisitor(default_options, "
 },
 "1033": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongRaiseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_raise.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['raise_exception_method = \"\"\"\\n', 'raise_exception_function = \"\"\"\\n', 'raise_exception_property = \"\"\"\\n', \"raise_exception_raw = 'raise {0}'\\n\", '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RaiseNotImplementedViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionRaiseViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(exception)))\n\n    visitor = WrongRaiseVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Rai"
 },
 "1034": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_raise.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['raise_exception_method = \"\"\"\\n', 'raise_exception_function = \"\"\"\\n', 'raise_exception_property = \"\"\"\\n', \"raise_exception_raw = 'raise {0}'\\n\", '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RaiseNotImplementedViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionRaiseViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ion` and `raise Exception` are restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(exception)))\n\n    visitor = WrongRaiseVisitor(default_options, "
 },
 "1035": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongRaiseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_raise.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['raise_exception_method = \"\"\"\\n', 'raise_exception_function = \"\"\"\\n', 'raise_exception_property = \"\"\"\\n', \"raise_exception_raw = 'raise {0}'\\n\", '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RaiseNotImplementedViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionRaiseViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(exception)))\n\n    visitor = WrongRaiseVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Bas"
 },
 "1036": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_raise.py",
  "lineno": "107",
  "column": "4",
  "slicing": "['raise_exception_method = \"\"\"\\n', 'raise_exception_function = \"\"\"\\n', 'raise_exception_property = \"\"\"\\n', \"raise_exception_raw = 'raise {0}'\\n\", '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RaiseNotImplementedViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionRaiseViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ting that good `raise` usages are allowed.\"\"\"\n    tree = parse_ast_tree(mode(code.format(exception)))\n\n    visitor = WrongRaiseVisitor(default_options, "
 },
 "1037": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongRaiseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_raise.py",
  "lineno": "109",
  "column": "4",
  "slicing": "['raise_exception_method = \"\"\"\\n', 'raise_exception_function = \"\"\"\\n', 'raise_exception_property = \"\"\"\\n', \"raise_exception_raw = 'raise {0}'\\n\", '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RaiseNotImplementedViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionRaiseViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(mode(code.format(exception)))\n\n    visitor = WrongRaiseVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1038": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_raise.py",
  "lineno": "127",
  "column": "4",
  "slicing": "['raise_exception_method = \"\"\"\\n', 'raise_exception_function = \"\"\"\\n', 'raise_exception_property = \"\"\"\\n', \"raise_exception_raw = 'raise {0}'\\n\", '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RaiseNotImplementedViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionRaiseViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "0\n    except Exception:\n        raise\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongRaiseVisitor(default_options, "
 },
 "1039": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongRaiseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_raise.py",
  "lineno": "129",
  "column": "4",
  "slicing": "['raise_exception_method = \"\"\"\\n', 'raise_exception_function = \"\"\"\\n', 'raise_exception_property = \"\"\"\\n', \"raise_exception_raw = 'raise {0}'\\n\", '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RaiseNotImplementedViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BaseExceptionRaiseViolation])\\n', '    raise_exception_method,\\n', '    raise_exception_function,\\n', '    raise_exception_raw,\\n', '    raise_exception_property,\\n', '    tree = parse_ast_tree(mode(code.format(exception)))\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongRaiseVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "aise\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongRaiseVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1040": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_global.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['global_in_module = \"\"\"\\n', 'global_in_function = \"\"\"\\n', 'global_in_method = \"\"\"\\n', '    global_in_module,\\n', '    global_in_function,\\n', '    global_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'global')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'nonlocal')\\n\"]",
  "context": "sting that `global` keyword is restricted.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongKeywordVisitor(default_options"
 },
 "1041": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_global.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['global_in_module = \"\"\"\\n', 'global_in_function = \"\"\"\\n', 'global_in_method = \"\"\"\\n', '    global_in_module,\\n', '    global_in_function,\\n', '    global_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'global')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'nonlocal')\\n\"]",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1042": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_global.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['global_in_module = \"\"\"\\n', 'global_in_function = \"\"\"\\n', 'global_in_method = \"\"\"\\n', '    global_in_module,\\n', '    global_in_function,\\n', '    global_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'global')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'nonlocal')\\n\"]",
  "context": "ing that `nonlocal` keyword is restricted.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongKeywordVisitor(default_options"
 },
 "1043": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_global.py",
  "lineno": "84",
  "column": "4",
  "slicing": "['global_in_module = \"\"\"\\n', 'global_in_function = \"\"\"\\n', 'global_in_method = \"\"\"\\n', '    global_in_module,\\n', '    global_in_function,\\n', '    global_in_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'global')\\n\", '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'nonlocal')\\n\"]",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1044": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_del.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'del')\\n\"]",
  "context": "s/wemake-python-styleguide/issues/493\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongKeywordVisitor(default_options"
 },
 "1045": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongKeywordVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_del.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongKeywordVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongKeywordViolation])\\n', \"    assert_error_text(visitor, 'del')\\n\"]",
  "context": "/493\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongKeywordVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1046": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return_variables.py",
  "lineno": "347",
  "column": "4",
  "slicing": "['correct_example1 = \"\"\"\\n', 'correct_example2 = \"\"\"\\n', 'correct_example3 = \"\"\"\\n', 'correct_example4 = \"\"\"\\n', 'correct_example5 = \"\"\"\\n', 'correct_example6 = \"\"\"\\n', 'correct_example7 = \"\"\"\\n', 'correct_example8 = \"\"\"\\n', 'correct_example9 = \"\"\"\\n', 'correct_example10 = \"\"\"\\n', 'correct_example11 = \"\"\"\\n', 'correct_example12 = \"\"\"\\n', 'correct_example13 = \"\"\"\\n', 'correct_example14 = \"\"\"\\n', 'correct_example15 = \"\"\"\\n', 'correct_example16 = \"\"\"\\n', 'correct_example17 = \"\"\"\\n', 'correct_example18 = \"\"\"\\n', 'correct_example19 = \"\"\"\\n', 'correct_example20 = \"\"\"\\n', 'correct_example21 = \"\"\"\\n', 'correct_example22 = \"\"\"\\n', 'correct_example23 = \"\"\"\\n', 'wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', 'wrong_example6 = \"\"\"\\n', 'wrong_example7 = \"\"\"\\n', 'wrong_example8 = \"\"\"\\n', 'wrong_example9 = \"\"\"\\n', 'wrong_example10 = \"\"\"\\n', 'wrong_example11 = \"\"\"\\n', 'wrong_example12 = \"\"\"\\n', 'wrong_example13 = \"\"\"\\n', 'wrong_example14 = \"\"\"\\n', 'wrong_example15 = \"\"\"\\n', 'double_wrong_example1 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    wrong_example8,\\n', '    wrong_example9,\\n', '    wrong_example10,\\n', '    wrong_example11,\\n', '    wrong_example12,\\n', '    wrong_example13,\\n', '    wrong_example14,\\n', '    wrong_example15,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnVariableViolation])\\n', '    correct_example1,\\n', '    correct_example2,\\n', '    correct_example3,\\n', '    correct_example4,\\n', '    correct_example5,\\n', '    correct_example6,\\n', '    correct_example7,\\n', '    correct_example8,\\n', '    correct_example9,\\n', '    correct_example10,\\n', '    correct_example11,\\n', '    correct_example12,\\n', '    correct_example13,\\n', '    correct_example14,\\n', '    correct_example15,\\n', '    correct_example16,\\n', '    correct_example17,\\n', '    correct_example18,\\n', '    correct_example19,\\n', '    correct_example20,\\n', '    correct_example21,\\n', '    correct_example22,\\n', '    correct_example23,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(double_wrong_example1))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": " \"\"\"Testing incorrect `return` statements.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = ConsistentReturningVariableVisitor(d"
 },
 "1047": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConsistentReturningVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return_variables.py",
  "lineno": "348",
  "column": "4",
  "slicing": "['correct_example1 = \"\"\"\\n', 'correct_example2 = \"\"\"\\n', 'correct_example3 = \"\"\"\\n', 'correct_example4 = \"\"\"\\n', 'correct_example5 = \"\"\"\\n', 'correct_example6 = \"\"\"\\n', 'correct_example7 = \"\"\"\\n', 'correct_example8 = \"\"\"\\n', 'correct_example9 = \"\"\"\\n', 'correct_example10 = \"\"\"\\n', 'correct_example11 = \"\"\"\\n', 'correct_example12 = \"\"\"\\n', 'correct_example13 = \"\"\"\\n', 'correct_example14 = \"\"\"\\n', 'correct_example15 = \"\"\"\\n', 'correct_example16 = \"\"\"\\n', 'correct_example17 = \"\"\"\\n', 'correct_example18 = \"\"\"\\n', 'correct_example19 = \"\"\"\\n', 'correct_example20 = \"\"\"\\n', 'correct_example21 = \"\"\"\\n', 'correct_example22 = \"\"\"\\n', 'correct_example23 = \"\"\"\\n', 'wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', 'wrong_example6 = \"\"\"\\n', 'wrong_example7 = \"\"\"\\n', 'wrong_example8 = \"\"\"\\n', 'wrong_example9 = \"\"\"\\n', 'wrong_example10 = \"\"\"\\n', 'wrong_example11 = \"\"\"\\n', 'wrong_example12 = \"\"\"\\n', 'wrong_example13 = \"\"\"\\n', 'wrong_example14 = \"\"\"\\n', 'wrong_example15 = \"\"\"\\n', 'double_wrong_example1 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    wrong_example8,\\n', '    wrong_example9,\\n', '    wrong_example10,\\n', '    wrong_example11,\\n', '    wrong_example12,\\n', '    wrong_example13,\\n', '    wrong_example14,\\n', '    wrong_example15,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnVariableViolation])\\n', '    correct_example1,\\n', '    correct_example2,\\n', '    correct_example3,\\n', '    correct_example4,\\n', '    correct_example5,\\n', '    correct_example6,\\n', '    correct_example7,\\n', '    correct_example8,\\n', '    correct_example9,\\n', '    correct_example10,\\n', '    correct_example11,\\n', '    correct_example12,\\n', '    correct_example13,\\n', '    correct_example14,\\n', '    correct_example15,\\n', '    correct_example16,\\n', '    correct_example17,\\n', '    correct_example18,\\n', '    correct_example19,\\n', '    correct_example20,\\n', '    correct_example21,\\n', '    correct_example22,\\n', '    correct_example23,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(double_wrong_example1))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "nts.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Inc"
 },
 "1048": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return_variables.py",
  "lineno": "387",
  "column": "4",
  "slicing": "['correct_example1 = \"\"\"\\n', 'correct_example2 = \"\"\"\\n', 'correct_example3 = \"\"\"\\n', 'correct_example4 = \"\"\"\\n', 'correct_example5 = \"\"\"\\n', 'correct_example6 = \"\"\"\\n', 'correct_example7 = \"\"\"\\n', 'correct_example8 = \"\"\"\\n', 'correct_example9 = \"\"\"\\n', 'correct_example10 = \"\"\"\\n', 'correct_example11 = \"\"\"\\n', 'correct_example12 = \"\"\"\\n', 'correct_example13 = \"\"\"\\n', 'correct_example14 = \"\"\"\\n', 'correct_example15 = \"\"\"\\n', 'correct_example16 = \"\"\"\\n', 'correct_example17 = \"\"\"\\n', 'correct_example18 = \"\"\"\\n', 'correct_example19 = \"\"\"\\n', 'correct_example20 = \"\"\"\\n', 'correct_example21 = \"\"\"\\n', 'correct_example22 = \"\"\"\\n', 'correct_example23 = \"\"\"\\n', 'wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', 'wrong_example6 = \"\"\"\\n', 'wrong_example7 = \"\"\"\\n', 'wrong_example8 = \"\"\"\\n', 'wrong_example9 = \"\"\"\\n', 'wrong_example10 = \"\"\"\\n', 'wrong_example11 = \"\"\"\\n', 'wrong_example12 = \"\"\"\\n', 'wrong_example13 = \"\"\"\\n', 'wrong_example14 = \"\"\"\\n', 'wrong_example15 = \"\"\"\\n', 'double_wrong_example1 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    wrong_example8,\\n', '    wrong_example9,\\n', '    wrong_example10,\\n', '    wrong_example11,\\n', '    wrong_example12,\\n', '    wrong_example13,\\n', '    wrong_example14,\\n', '    wrong_example15,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnVariableViolation])\\n', '    correct_example1,\\n', '    correct_example2,\\n', '    correct_example3,\\n', '    correct_example4,\\n', '    correct_example5,\\n', '    correct_example6,\\n', '    correct_example7,\\n', '    correct_example8,\\n', '    correct_example9,\\n', '    correct_example10,\\n', '    correct_example11,\\n', '    correct_example12,\\n', '    correct_example13,\\n', '    correct_example14,\\n', '    correct_example15,\\n', '    correct_example16,\\n', '    correct_example17,\\n', '    correct_example18,\\n', '    correct_example19,\\n', '    correct_example20,\\n', '    correct_example21,\\n', '    correct_example22,\\n', '    correct_example23,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(double_wrong_example1))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "   \"\"\"Testing correct `return` statements.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = ConsistentReturningVariableVisitor(d"
 },
 "1049": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConsistentReturningVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return_variables.py",
  "lineno": "388",
  "column": "4",
  "slicing": "['correct_example1 = \"\"\"\\n', 'correct_example2 = \"\"\"\\n', 'correct_example3 = \"\"\"\\n', 'correct_example4 = \"\"\"\\n', 'correct_example5 = \"\"\"\\n', 'correct_example6 = \"\"\"\\n', 'correct_example7 = \"\"\"\\n', 'correct_example8 = \"\"\"\\n', 'correct_example9 = \"\"\"\\n', 'correct_example10 = \"\"\"\\n', 'correct_example11 = \"\"\"\\n', 'correct_example12 = \"\"\"\\n', 'correct_example13 = \"\"\"\\n', 'correct_example14 = \"\"\"\\n', 'correct_example15 = \"\"\"\\n', 'correct_example16 = \"\"\"\\n', 'correct_example17 = \"\"\"\\n', 'correct_example18 = \"\"\"\\n', 'correct_example19 = \"\"\"\\n', 'correct_example20 = \"\"\"\\n', 'correct_example21 = \"\"\"\\n', 'correct_example22 = \"\"\"\\n', 'correct_example23 = \"\"\"\\n', 'wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', 'wrong_example6 = \"\"\"\\n', 'wrong_example7 = \"\"\"\\n', 'wrong_example8 = \"\"\"\\n', 'wrong_example9 = \"\"\"\\n', 'wrong_example10 = \"\"\"\\n', 'wrong_example11 = \"\"\"\\n', 'wrong_example12 = \"\"\"\\n', 'wrong_example13 = \"\"\"\\n', 'wrong_example14 = \"\"\"\\n', 'wrong_example15 = \"\"\"\\n', 'double_wrong_example1 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    wrong_example8,\\n', '    wrong_example9,\\n', '    wrong_example10,\\n', '    wrong_example11,\\n', '    wrong_example12,\\n', '    wrong_example13,\\n', '    wrong_example14,\\n', '    wrong_example15,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnVariableViolation])\\n', '    correct_example1,\\n', '    correct_example2,\\n', '    correct_example3,\\n', '    correct_example4,\\n', '    correct_example5,\\n', '    correct_example6,\\n', '    correct_example7,\\n', '    correct_example8,\\n', '    correct_example9,\\n', '    correct_example10,\\n', '    correct_example11,\\n', '    correct_example12,\\n', '    correct_example13,\\n', '    correct_example14,\\n', '    correct_example15,\\n', '    correct_example16,\\n', '    correct_example17,\\n', '    correct_example18,\\n', '    correct_example19,\\n', '    correct_example20,\\n', '    correct_example21,\\n', '    correct_example22,\\n', '    correct_example23,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(double_wrong_example1))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "nts.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\n    visitor.run()\n    assert_errors(visitor, [])\n\n"
 },
 "1050": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return_variables.py",
  "lineno": "400",
  "column": "4",
  "slicing": "['correct_example1 = \"\"\"\\n', 'correct_example2 = \"\"\"\\n', 'correct_example3 = \"\"\"\\n', 'correct_example4 = \"\"\"\\n', 'correct_example5 = \"\"\"\\n', 'correct_example6 = \"\"\"\\n', 'correct_example7 = \"\"\"\\n', 'correct_example8 = \"\"\"\\n', 'correct_example9 = \"\"\"\\n', 'correct_example10 = \"\"\"\\n', 'correct_example11 = \"\"\"\\n', 'correct_example12 = \"\"\"\\n', 'correct_example13 = \"\"\"\\n', 'correct_example14 = \"\"\"\\n', 'correct_example15 = \"\"\"\\n', 'correct_example16 = \"\"\"\\n', 'correct_example17 = \"\"\"\\n', 'correct_example18 = \"\"\"\\n', 'correct_example19 = \"\"\"\\n', 'correct_example20 = \"\"\"\\n', 'correct_example21 = \"\"\"\\n', 'correct_example22 = \"\"\"\\n', 'correct_example23 = \"\"\"\\n', 'wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', 'wrong_example6 = \"\"\"\\n', 'wrong_example7 = \"\"\"\\n', 'wrong_example8 = \"\"\"\\n', 'wrong_example9 = \"\"\"\\n', 'wrong_example10 = \"\"\"\\n', 'wrong_example11 = \"\"\"\\n', 'wrong_example12 = \"\"\"\\n', 'wrong_example13 = \"\"\"\\n', 'wrong_example14 = \"\"\"\\n', 'wrong_example15 = \"\"\"\\n', 'double_wrong_example1 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    wrong_example8,\\n', '    wrong_example9,\\n', '    wrong_example10,\\n', '    wrong_example11,\\n', '    wrong_example12,\\n', '    wrong_example13,\\n', '    wrong_example14,\\n', '    wrong_example15,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnVariableViolation])\\n', '    correct_example1,\\n', '    correct_example2,\\n', '    correct_example3,\\n', '    correct_example4,\\n', '    correct_example5,\\n', '    correct_example6,\\n', '    correct_example7,\\n', '    correct_example8,\\n', '    correct_example9,\\n', '    correct_example10,\\n', '    correct_example11,\\n', '    correct_example12,\\n', '    correct_example13,\\n', '    correct_example14,\\n', '    correct_example15,\\n', '    correct_example16,\\n', '    correct_example17,\\n', '    correct_example18,\\n', '    correct_example19,\\n', '    correct_example20,\\n', '    correct_example21,\\n', '    correct_example22,\\n', '    correct_example23,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(double_wrong_example1))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ting double incorrect `return` statements.\"\"\"\n    tree = parse_ast_tree(mode(double_wrong_example1))\n\n    visitor = ConsistentReturningVariableVisitor("
 },
 "1051": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConsistentReturningVariableVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return_variables.py",
  "lineno": "402",
  "column": "4",
  "slicing": "['correct_example1 = \"\"\"\\n', 'correct_example2 = \"\"\"\\n', 'correct_example3 = \"\"\"\\n', 'correct_example4 = \"\"\"\\n', 'correct_example5 = \"\"\"\\n', 'correct_example6 = \"\"\"\\n', 'correct_example7 = \"\"\"\\n', 'correct_example8 = \"\"\"\\n', 'correct_example9 = \"\"\"\\n', 'correct_example10 = \"\"\"\\n', 'correct_example11 = \"\"\"\\n', 'correct_example12 = \"\"\"\\n', 'correct_example13 = \"\"\"\\n', 'correct_example14 = \"\"\"\\n', 'correct_example15 = \"\"\"\\n', 'correct_example16 = \"\"\"\\n', 'correct_example17 = \"\"\"\\n', 'correct_example18 = \"\"\"\\n', 'correct_example19 = \"\"\"\\n', 'correct_example20 = \"\"\"\\n', 'correct_example21 = \"\"\"\\n', 'correct_example22 = \"\"\"\\n', 'correct_example23 = \"\"\"\\n', 'wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', 'wrong_example6 = \"\"\"\\n', 'wrong_example7 = \"\"\"\\n', 'wrong_example8 = \"\"\"\\n', 'wrong_example9 = \"\"\"\\n', 'wrong_example10 = \"\"\"\\n', 'wrong_example11 = \"\"\"\\n', 'wrong_example12 = \"\"\"\\n', 'wrong_example13 = \"\"\"\\n', 'wrong_example14 = \"\"\"\\n', 'wrong_example15 = \"\"\"\\n', 'double_wrong_example1 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    wrong_example8,\\n', '    wrong_example9,\\n', '    wrong_example10,\\n', '    wrong_example11,\\n', '    wrong_example12,\\n', '    wrong_example13,\\n', '    wrong_example14,\\n', '    wrong_example15,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnVariableViolation])\\n', '    correct_example1,\\n', '    correct_example2,\\n', '    correct_example3,\\n', '    correct_example4,\\n', '    correct_example5,\\n', '    correct_example6,\\n', '    correct_example7,\\n', '    correct_example8,\\n', '    correct_example9,\\n', '    correct_example10,\\n', '    correct_example11,\\n', '    correct_example12,\\n', '    correct_example13,\\n', '    correct_example14,\\n', '    correct_example15,\\n', '    correct_example16,\\n', '    correct_example17,\\n', '    correct_example18,\\n', '    correct_example19,\\n', '    correct_example20,\\n', '    correct_example21,\\n', '    correct_example22,\\n', '    correct_example23,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(double_wrong_example1))\\n', '    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": " parse_ast_tree(mode(double_wrong_example1))\n\n    visitor = ConsistentReturningVariableVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1052": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return.py",
  "lineno": "155",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', \"wrong_example6 = '''\\n\", \"wrong_example7 = '''\\n\", 'double_wrong_return1 = \"\"\"\\n', 'double_wrong_return2 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnViolation])\\n', '    double_wrong_return1,\\n', '    double_wrong_return2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Testing incorrect `return` statements.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_"
 },
 "1053": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConsistentReturningVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return.py",
  "lineno": "157",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', \"wrong_example6 = '''\\n\", \"wrong_example7 = '''\\n\", 'double_wrong_return1 = \"\"\"\\n', 'double_wrong_return2 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnViolation])\\n', '    double_wrong_return1,\\n', '    double_wrong_return2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ts.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Inc"
 },
 "1054": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return.py",
  "lineno": "175",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', \"wrong_example6 = '''\\n\", \"wrong_example7 = '''\\n\", 'double_wrong_return1 = \"\"\"\\n', 'double_wrong_return2 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnViolation])\\n', '    double_wrong_return1,\\n', '    double_wrong_return2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ting double incorrect `return` statements.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_"
 },
 "1055": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConsistentReturningVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return.py",
  "lineno": "177",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', \"wrong_example6 = '''\\n\", \"wrong_example7 = '''\\n\", 'double_wrong_return1 = \"\"\"\\n', 'double_wrong_return2 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnViolation])\\n', '    double_wrong_return1,\\n', '    double_wrong_return2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ts.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1056": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return.py",
  "lineno": "205",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', \"wrong_example6 = '''\\n\", \"wrong_example7 = '''\\n\", 'double_wrong_return1 = \"\"\"\\n', 'double_wrong_return2 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnViolation])\\n', '    double_wrong_return1,\\n', '    double_wrong_return2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "   \"\"\"Testing correct `return` statements.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_"
 },
 "1057": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConsistentReturningVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_return.py",
  "lineno": "207",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', 'wrong_example4 = \"\"\"\\n', 'wrong_example5 = \"\"\"\\n', \"wrong_example6 = '''\\n\", \"wrong_example7 = '''\\n\", 'double_wrong_return1 = \"\"\"\\n', 'double_wrong_return2 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    wrong_example4,\\n', '    wrong_example5,\\n', '    wrong_example6,\\n', '    wrong_example7,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentReturnViolation])\\n', '    double_wrong_return1,\\n', '    double_wrong_return2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ts.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1058": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_yield.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentYieldViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  \"\"\"Testing incorrect `yield` statements.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_"
 },
 "1059": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConsistentReturningVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_yield.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentYieldViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ts.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Inc"
 },
 "1060": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_yield.py",
  "lineno": "107",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentYieldViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    \"\"\"Testing correct `yield` statements.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_"
 },
 "1061": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.ConsistentReturningVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_consistency_returning/test_consistency_yield.py",
  "lineno": "109",
  "column": "4",
  "slicing": "['wrong_example1 = \"\"\"\\n', 'wrong_example2 = \"\"\"\\n', 'wrong_example3 = \"\"\"\\n', '    wrong_example1,\\n', '    wrong_example2,\\n', '    wrong_example3,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [InconsistentYieldViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = ConsistentReturningVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ts.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = ConsistentReturningVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1062": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_context_managers/test_context_manager_targets.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['incorrect_count = \"\"\"\\n', 'incorrect_composite_assign = \"\"\"\\n', '    incorrect_count,\\n', '    incorrect_composite_assign,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleContextManagerAssignmentsViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ncorrect count context manager assignment.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongContextManagerVisitor(default_"
 },
 "1063": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongContextManagerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_context_managers/test_context_manager_targets.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['incorrect_count = \"\"\"\\n', 'incorrect_composite_assign = \"\"\"\\n', '    incorrect_count,\\n', '    incorrect_composite_assign,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleContextManagerAssignmentsViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nt.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongContextManagerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Mul"
 },
 "1064": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_context_managers/test_context_manager_targets.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['incorrect_count = \"\"\"\\n', 'incorrect_composite_assign = \"\"\"\\n', '    incorrect_count,\\n', '    incorrect_composite_assign,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleContextManagerAssignmentsViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " correct count context manager assignment.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongContextManagerVisitor(default_"
 },
 "1065": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongContextManagerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_context_managers/test_context_manager_targets.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['incorrect_count = \"\"\"\\n', 'incorrect_composite_assign = \"\"\"\\n', '    incorrect_count,\\n', '    incorrect_composite_assign,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultipleContextManagerAssignmentsViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nt.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongContextManagerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1066": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_context_managers/test_context_managers_definitions.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['context_manager_definition = \"\"\"\\n', '    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ContextManagerVariableDefinitionViolation])\\n', '    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ct definitions context manager assignment.\"\"\"\n    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\n\n    visitor = WrongContextManagerVisitor(default_"
 },
 "1067": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongContextManagerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_context_managers/test_context_managers_definitions.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['context_manager_definition = \"\"\"\\n', '    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ContextManagerVariableDefinitionViolation])\\n', '    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "de(context_manager_definition.format(code)))\n\n    visitor = WrongContextManagerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Con"
 },
 "1068": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_context_managers/test_context_managers_definitions.py",
  "lineno": "54",
  "column": "4",
  "slicing": "['context_manager_definition = \"\"\"\\n', '    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ContextManagerVariableDefinitionViolation])\\n', '    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ct definitions context manager assignment.\"\"\"\n    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\n\n    visitor = WrongContextManagerVisitor(default_"
 },
 "1069": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.WrongContextManagerVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_context_managers/test_context_managers_definitions.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['context_manager_definition = \"\"\"\\n', '    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ContextManagerVariableDefinitionViolation])\\n', '    tree = parse_ast_tree(mode(context_manager_definition.format(code)))\\n', '    visitor = WrongContextManagerVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "de(context_manager_definition.format(code)))\n\n    visitor = WrongContextManagerVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1070": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_consecutive_yields.py",
  "lineno": "114",
  "column": "4",
  "slicing": "['simple_yield = \"\"\"\\n', 'conditional_yield1 = \"\"\"\\n', 'conditional_yield2 = \"\"\"\\n', 'separated_yield1 = \"\"\"\\n', 'separated_yield2 = \"\"\"\\n', 'yield_with_yield_from1 = \"\"\"\\n', 'yield_with_yield_from2 = \"\"\"\\n', '    simple_yield,\\n', '    conditional_yield1,\\n', '    conditional_yield2,\\n', '    separated_yield1,\\n', '    separated_yield2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    yield_with_yield_from1,\\n', '    yield_with_yield_from2,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveYieldsViolation])\\n']",
  "context": "Ensure that `yield` can be used correctly.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = GeneratorKeywordsVisitor(default_op"
 },
 "1071": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.GeneratorKeywordsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_consecutive_yields.py",
  "lineno": "116",
  "column": "4",
  "slicing": "['simple_yield = \"\"\"\\n', 'conditional_yield1 = \"\"\"\\n', 'conditional_yield2 = \"\"\"\\n', 'separated_yield1 = \"\"\"\\n', 'separated_yield2 = \"\"\"\\n', 'yield_with_yield_from1 = \"\"\"\\n', 'yield_with_yield_from2 = \"\"\"\\n', '    simple_yield,\\n', '    conditional_yield1,\\n', '    conditional_yield2,\\n', '    separated_yield1,\\n', '    separated_yield2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    yield_with_yield_from1,\\n', '    yield_with_yield_from2,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveYieldsViolation])\\n']",
  "context": "ly.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1072": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_consecutive_yields.py",
  "lineno": "133",
  "column": "4",
  "slicing": "['simple_yield = \"\"\"\\n', 'conditional_yield1 = \"\"\"\\n', 'conditional_yield2 = \"\"\"\\n', 'separated_yield1 = \"\"\"\\n', 'separated_yield2 = \"\"\"\\n', 'yield_with_yield_from1 = \"\"\"\\n', 'yield_with_yield_from2 = \"\"\"\\n', '    simple_yield,\\n', '    conditional_yield1,\\n', '    conditional_yield2,\\n', '    separated_yield1,\\n', '    separated_yield2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    yield_with_yield_from1,\\n', '    yield_with_yield_from2,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveYieldsViolation])\\n']",
  "context": "Ensure that `yield` can be used correctly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = GeneratorKeywordsVisitor(default_op"
 },
 "1073": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.GeneratorKeywordsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_consecutive_yields.py",
  "lineno": "135",
  "column": "4",
  "slicing": "['simple_yield = \"\"\"\\n', 'conditional_yield1 = \"\"\"\\n', 'conditional_yield2 = \"\"\"\\n', 'separated_yield1 = \"\"\"\\n', 'separated_yield2 = \"\"\"\\n', 'yield_with_yield_from1 = \"\"\"\\n', 'yield_with_yield_from2 = \"\"\"\\n', '    simple_yield,\\n', '    conditional_yield1,\\n', '    conditional_yield2,\\n', '    separated_yield1,\\n', '    separated_yield2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    yield_with_yield_from1,\\n', '    yield_with_yield_from2,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveYieldsViolation])\\n']",
  "context": "orrectly.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1074": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_consecutive_yields.py",
  "lineno": "156",
  "column": "4",
  "slicing": "['simple_yield = \"\"\"\\n', 'conditional_yield1 = \"\"\"\\n', 'conditional_yield2 = \"\"\"\\n', 'separated_yield1 = \"\"\"\\n', 'separated_yield2 = \"\"\"\\n', 'yield_with_yield_from1 = \"\"\"\\n', 'yield_with_yield_from2 = \"\"\"\\n', '    simple_yield,\\n', '    conditional_yield1,\\n', '    conditional_yield2,\\n', '    separated_yield1,\\n', '    separated_yield2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    yield_with_yield_from1,\\n', '    yield_with_yield_from2,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveYieldsViolation])\\n']",
  "context": " that `yield` cannot follow the same node.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = GeneratorKeywordsVisitor(default_op"
 },
 "1075": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.GeneratorKeywordsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_consecutive_yields.py",
  "lineno": "158",
  "column": "4",
  "slicing": "['simple_yield = \"\"\"\\n', 'conditional_yield1 = \"\"\"\\n', 'conditional_yield2 = \"\"\"\\n', 'separated_yield1 = \"\"\"\\n', 'separated_yield2 = \"\"\"\\n', 'yield_with_yield_from1 = \"\"\"\\n', 'yield_with_yield_from2 = \"\"\"\\n', '    simple_yield,\\n', '    conditional_yield1,\\n', '    conditional_yield2,\\n', '    separated_yield1,\\n', '    separated_yield2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    yield_with_yield_from1,\\n', '    yield_with_yield_from2,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveYieldsViolation])\\n']",
  "context": "de.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Con"
 },
 "1076": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_yield_from_type.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['yield_from_template = \"\"\"\\n', '    tree = parse_ast_tree(yield_from_template.format(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IncorrectYieldFromTargetViolation])\\n', '    tree = parse_ast_tree(yield_from_template.format(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " from` does not work with incorrect types.\"\"\"\n    tree = parse_ast_tree(yield_from_template.format(code))\n\n    visitor = GeneratorKeywordsVisitor(default_op"
 },
 "1077": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.GeneratorKeywordsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_yield_from_type.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['yield_from_template = \"\"\"\\n', '    tree = parse_ast_tree(yield_from_template.format(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IncorrectYieldFromTargetViolation])\\n', '    tree = parse_ast_tree(yield_from_template.format(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e_ast_tree(yield_from_template.format(code))\n\n    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Inc"
 },
 "1078": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_yield_from_type.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['yield_from_template = \"\"\"\\n', '    tree = parse_ast_tree(yield_from_template.format(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IncorrectYieldFromTargetViolation])\\n', '    tree = parse_ast_tree(yield_from_template.format(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat `yield from` works with correct types.\"\"\"\n    tree = parse_ast_tree(yield_from_template.format(code))\n\n    visitor = GeneratorKeywordsVisitor(default_op"
 },
 "1079": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.keywords.GeneratorKeywordsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_keywords/test_generator_keywords/test_yield_from_type.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['yield_from_template = \"\"\"\\n', '    tree = parse_ast_tree(yield_from_template.format(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [IncorrectYieldFromTargetViolation])\\n', '    tree = parse_ast_tree(yield_from_template.format(code))\\n', '    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e_ast_tree(yield_from_template.format(code))\n\n    visitor = GeneratorKeywordsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1080": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_function_calls.py",
  "lineno": "36",
  "column": "4",
  "slicing": "[\"regular_call = '{0}(*args, **kwargs)'\\n\", \"assignment_call = 'test_result = {0}(*args, **kwargs)'\\n\", 'nested_function_call = \"\"\"\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_module_and_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_module_and_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(good_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at some built-in functions are restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(bad_function)))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1081": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_function_calls.py",
  "lineno": "38",
  "column": "4",
  "slicing": "[\"regular_call = '{0}(*args, **kwargs)'\\n\", \"assignment_call = 'test_result = {0}(*args, **kwargs)'\\n\", 'nested_function_call = \"\"\"\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_module_and_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_module_and_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(good_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "se_ast_tree(mode(code.format(bad_function)))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1082": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_function_calls.py",
  "lineno": "63",
  "column": "4",
  "slicing": "[\"regular_call = '{0}(*args, **kwargs)'\\n\", \"assignment_call = 'test_result = {0}(*args, **kwargs)'\\n\", 'nested_function_call = \"\"\"\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_module_and_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_module_and_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(good_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " module.function() call can be restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(bad_module_and_function)))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1083": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_function_calls.py",
  "lineno": "65",
  "column": "4",
  "slicing": "[\"regular_call = '{0}(*args, **kwargs)'\\n\", \"assignment_call = 'test_result = {0}(*args, **kwargs)'\\n\", 'nested_function_call = \"\"\"\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_module_and_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_module_and_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(good_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "(mode(code.format(bad_module_and_function)))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1084": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_function_calls.py",
  "lineno": "92",
  "column": "4",
  "slicing": "[\"regular_call = '{0}(*args, **kwargs)'\\n\", \"assignment_call = 'test_result = {0}(*args, **kwargs)'\\n\", 'nested_function_call = \"\"\"\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_module_and_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_module_and_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(good_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "g that other functions are not restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(good_function)))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1085": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_function_calls.py",
  "lineno": "94",
  "column": "4",
  "slicing": "[\"regular_call = '{0}(*args, **kwargs)'\\n\", \"assignment_call = 'test_result = {0}(*args, **kwargs)'\\n\", 'nested_function_call = \"\"\"\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(bad_module_and_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongFunctionCallViolation])\\n', '    assert_error_text(visitor, bad_module_and_function)\\n', '    regular_call,\\n', '    assignment_call,\\n', '    nested_function_call,\\n', '    tree = parse_ast_tree(mode(code.format(good_function)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e_ast_tree(mode(code.format(good_function)))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1086": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_floating_nan.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code))\\n', '    visitor = FloatingNanCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nan = \\'{0}\"{1}\"\\'.format(prefix, nan_variant)\\n', '    tree = parse_ast_tree(code.format(nan))\\n', '    visitor = FloatingNanCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatingNanViolation])\\n']",
  "context": "aN in a proper way is not  as a violation.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FloatingNanCallVisitor(default_opti"
 },
 "1087": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FloatingNanCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_floating_nan.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code))\\n', '    visitor = FloatingNanCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nan = \\'{0}\"{1}\"\\'.format(prefix, nan_variant)\\n', '    tree = parse_ast_tree(code.format(nan))\\n', '    visitor = FloatingNanCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatingNanViolation])\\n']",
  "context": "on.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FloatingNanCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1088": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_floating_nan.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code))\\n', '    visitor = FloatingNanCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nan = \\'{0}\"{1}\"\\'.format(prefix, nan_variant)\\n', '    tree = parse_ast_tree(code.format(nan))\\n', '    visitor = FloatingNanCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatingNanViolation])\\n']",
  "context": " nan = '{0}\"{1}\"'.format(prefix, nan_variant)\n    tree = parse_ast_tree(code.format(nan))\n\n    visitor = FloatingNanCallVisitor(default_opti"
 },
 "1089": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FloatingNanCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_floating_nan.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code))\\n', '    visitor = FloatingNanCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    nan = \\'{0}\"{1}\"\\'.format(prefix, nan_variant)\\n', '    tree = parse_ast_tree(code.format(nan))\\n', '    visitor = FloatingNanCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatingNanViolation])\\n']",
  "context": "\n    tree = parse_ast_tree(code.format(nan))\n\n    visitor = FloatingNanCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Flo"
 },
 "1090": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_getter_without_return.py",
  "lineno": "202",
  "column": "4",
  "slicing": "['getter_function_with_implicit_return = \"\"\"\\n', 'getter_function_with_bare_return = \"\"\"\\n', 'getter_function_with_valued_return = \"\"\"\\n', 'getter_function_with_explicit_none_return = \"\"\"\\n', 'getter_function_with_bare_yield = \"\"\"\\n', 'getter_function_with_valued_yield = \"\"\"\\n', 'getter_function_with_explicit_none_yield = \"\"\"\\n', 'getter_function_with_yield_from = \"\"\"\\n', 'getter_method_with_implicit_return = \"\"\"\\n', 'getter_method_with_bare_return = \"\"\"\\n', 'getter_method_with_valued_return = \"\"\"\\n', 'getter_method_with_explicit_none_return = \"\"\"\\n', 'getter_method_with_bare_yield = \"\"\"\\n', 'getter_method_with_valued_yield = \"\"\"\\n', 'getter_method_with_explicit_none_yield = \"\"\"\\n', 'getter_method_with_yield_from = \"\"\"\\n', 'getter_method_with_branched_return = \"\"\"\\n', 'getter_stub_with_docstring = \"\"\"\\n', 'getter_stub_with_ellipsis = \"\"\"\\n', 'getter_stub_with_raise = \"\"\"\\n', 'getter_stub_with_docstring_and_ellipsis = \"\"\"\\n', 'getter_stub_with_docstring_and_raise = \"\"\"\\n', 'getter_stub_with_extra_statements = \"\"\"\\n', '    getter_function_with_implicit_return,\\n', '    getter_function_with_bare_return,\\n', '    getter_method_with_implicit_return,\\n', '    getter_method_with_bare_return,\\n', '    getter_stub_with_extra_statements,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [GetterWithoutReturnViolation])\\n', '    getter_function_with_valued_return,\\n', '    getter_function_with_explicit_none_return,\\n', '    getter_function_with_bare_yield,\\n', '    getter_function_with_valued_yield,\\n', '    getter_function_with_explicit_none_yield,\\n', '    getter_method_with_valued_return,\\n', '    getter_method_with_explicit_none_return,\\n', '    getter_method_with_bare_yield,\\n', '    getter_method_with_valued_yield,\\n', '    getter_method_with_explicit_none_yield,\\n', '    getter_method_with_branched_return,\\n', '    getter_stub_with_docstring,\\n', '    getter_stub_with_ellipsis,\\n', '    getter_stub_with_raise,\\n', '    getter_stub_with_docstring_and_ellipsis,\\n', '    getter_stub_with_docstring_and_raise,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    getter_function_with_yield_from,\\n', '    getter_method_with_yield_from,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " which do not output values are forbidden.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_op"
 },
 "1091": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionSignatureVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_getter_without_return.py",
  "lineno": "204",
  "column": "4",
  "slicing": "['getter_function_with_implicit_return = \"\"\"\\n', 'getter_function_with_bare_return = \"\"\"\\n', 'getter_function_with_valued_return = \"\"\"\\n', 'getter_function_with_explicit_none_return = \"\"\"\\n', 'getter_function_with_bare_yield = \"\"\"\\n', 'getter_function_with_valued_yield = \"\"\"\\n', 'getter_function_with_explicit_none_yield = \"\"\"\\n', 'getter_function_with_yield_from = \"\"\"\\n', 'getter_method_with_implicit_return = \"\"\"\\n', 'getter_method_with_bare_return = \"\"\"\\n', 'getter_method_with_valued_return = \"\"\"\\n', 'getter_method_with_explicit_none_return = \"\"\"\\n', 'getter_method_with_bare_yield = \"\"\"\\n', 'getter_method_with_valued_yield = \"\"\"\\n', 'getter_method_with_explicit_none_yield = \"\"\"\\n', 'getter_method_with_yield_from = \"\"\"\\n', 'getter_method_with_branched_return = \"\"\"\\n', 'getter_stub_with_docstring = \"\"\"\\n', 'getter_stub_with_ellipsis = \"\"\"\\n', 'getter_stub_with_raise = \"\"\"\\n', 'getter_stub_with_docstring_and_ellipsis = \"\"\"\\n', 'getter_stub_with_docstring_and_raise = \"\"\"\\n', 'getter_stub_with_extra_statements = \"\"\"\\n', '    getter_function_with_implicit_return,\\n', '    getter_function_with_bare_return,\\n', '    getter_method_with_implicit_return,\\n', '    getter_method_with_bare_return,\\n', '    getter_stub_with_extra_statements,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [GetterWithoutReturnViolation])\\n', '    getter_function_with_valued_return,\\n', '    getter_function_with_explicit_none_return,\\n', '    getter_function_with_bare_yield,\\n', '    getter_function_with_valued_yield,\\n', '    getter_function_with_explicit_none_yield,\\n', '    getter_method_with_valued_return,\\n', '    getter_method_with_explicit_none_return,\\n', '    getter_method_with_bare_yield,\\n', '    getter_method_with_valued_yield,\\n', '    getter_method_with_explicit_none_yield,\\n', '    getter_method_with_branched_return,\\n', '    getter_stub_with_docstring,\\n', '    getter_stub_with_ellipsis,\\n', '    getter_stub_with_raise,\\n', '    getter_stub_with_docstring_and_ellipsis,\\n', '    getter_stub_with_docstring_and_raise,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    getter_function_with_yield_from,\\n', '    getter_method_with_yield_from,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "en.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Get"
 },
 "1092": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_getter_without_return.py",
  "lineno": "236",
  "column": "4",
  "slicing": "['getter_function_with_implicit_return = \"\"\"\\n', 'getter_function_with_bare_return = \"\"\"\\n', 'getter_function_with_valued_return = \"\"\"\\n', 'getter_function_with_explicit_none_return = \"\"\"\\n', 'getter_function_with_bare_yield = \"\"\"\\n', 'getter_function_with_valued_yield = \"\"\"\\n', 'getter_function_with_explicit_none_yield = \"\"\"\\n', 'getter_function_with_yield_from = \"\"\"\\n', 'getter_method_with_implicit_return = \"\"\"\\n', 'getter_method_with_bare_return = \"\"\"\\n', 'getter_method_with_valued_return = \"\"\"\\n', 'getter_method_with_explicit_none_return = \"\"\"\\n', 'getter_method_with_bare_yield = \"\"\"\\n', 'getter_method_with_valued_yield = \"\"\"\\n', 'getter_method_with_explicit_none_yield = \"\"\"\\n', 'getter_method_with_yield_from = \"\"\"\\n', 'getter_method_with_branched_return = \"\"\"\\n', 'getter_stub_with_docstring = \"\"\"\\n', 'getter_stub_with_ellipsis = \"\"\"\\n', 'getter_stub_with_raise = \"\"\"\\n', 'getter_stub_with_docstring_and_ellipsis = \"\"\"\\n', 'getter_stub_with_docstring_and_raise = \"\"\"\\n', 'getter_stub_with_extra_statements = \"\"\"\\n', '    getter_function_with_implicit_return,\\n', '    getter_function_with_bare_return,\\n', '    getter_method_with_implicit_return,\\n', '    getter_method_with_bare_return,\\n', '    getter_stub_with_extra_statements,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [GetterWithoutReturnViolation])\\n', '    getter_function_with_valued_return,\\n', '    getter_function_with_explicit_none_return,\\n', '    getter_function_with_bare_yield,\\n', '    getter_function_with_valued_yield,\\n', '    getter_function_with_explicit_none_yield,\\n', '    getter_method_with_valued_return,\\n', '    getter_method_with_explicit_none_return,\\n', '    getter_method_with_bare_yield,\\n', '    getter_method_with_valued_yield,\\n', '    getter_method_with_explicit_none_yield,\\n', '    getter_method_with_branched_return,\\n', '    getter_stub_with_docstring,\\n', '    getter_stub_with_ellipsis,\\n', '    getter_stub_with_raise,\\n', '    getter_stub_with_docstring_and_ellipsis,\\n', '    getter_stub_with_docstring_and_raise,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    getter_function_with_yield_from,\\n', '    getter_method_with_yield_from,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t getters which output values are allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_op"
 },
 "1093": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionSignatureVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_getter_without_return.py",
  "lineno": "238",
  "column": "4",
  "slicing": "['getter_function_with_implicit_return = \"\"\"\\n', 'getter_function_with_bare_return = \"\"\"\\n', 'getter_function_with_valued_return = \"\"\"\\n', 'getter_function_with_explicit_none_return = \"\"\"\\n', 'getter_function_with_bare_yield = \"\"\"\\n', 'getter_function_with_valued_yield = \"\"\"\\n', 'getter_function_with_explicit_none_yield = \"\"\"\\n', 'getter_function_with_yield_from = \"\"\"\\n', 'getter_method_with_implicit_return = \"\"\"\\n', 'getter_method_with_bare_return = \"\"\"\\n', 'getter_method_with_valued_return = \"\"\"\\n', 'getter_method_with_explicit_none_return = \"\"\"\\n', 'getter_method_with_bare_yield = \"\"\"\\n', 'getter_method_with_valued_yield = \"\"\"\\n', 'getter_method_with_explicit_none_yield = \"\"\"\\n', 'getter_method_with_yield_from = \"\"\"\\n', 'getter_method_with_branched_return = \"\"\"\\n', 'getter_stub_with_docstring = \"\"\"\\n', 'getter_stub_with_ellipsis = \"\"\"\\n', 'getter_stub_with_raise = \"\"\"\\n', 'getter_stub_with_docstring_and_ellipsis = \"\"\"\\n', 'getter_stub_with_docstring_and_raise = \"\"\"\\n', 'getter_stub_with_extra_statements = \"\"\"\\n', '    getter_function_with_implicit_return,\\n', '    getter_function_with_bare_return,\\n', '    getter_method_with_implicit_return,\\n', '    getter_method_with_bare_return,\\n', '    getter_stub_with_extra_statements,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [GetterWithoutReturnViolation])\\n', '    getter_function_with_valued_return,\\n', '    getter_function_with_explicit_none_return,\\n', '    getter_function_with_bare_yield,\\n', '    getter_function_with_valued_yield,\\n', '    getter_function_with_explicit_none_yield,\\n', '    getter_method_with_valued_return,\\n', '    getter_method_with_explicit_none_return,\\n', '    getter_method_with_bare_yield,\\n', '    getter_method_with_valued_yield,\\n', '    getter_method_with_explicit_none_yield,\\n', '    getter_method_with_branched_return,\\n', '    getter_stub_with_docstring,\\n', '    getter_stub_with_ellipsis,\\n', '    getter_stub_with_raise,\\n', '    getter_stub_with_docstring_and_ellipsis,\\n', '    getter_stub_with_docstring_and_raise,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    getter_function_with_yield_from,\\n', '    getter_method_with_yield_from,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1094": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_getter_without_return.py",
  "lineno": "260",
  "column": "4",
  "slicing": "['getter_function_with_implicit_return = \"\"\"\\n', 'getter_function_with_bare_return = \"\"\"\\n', 'getter_function_with_valued_return = \"\"\"\\n', 'getter_function_with_explicit_none_return = \"\"\"\\n', 'getter_function_with_bare_yield = \"\"\"\\n', 'getter_function_with_valued_yield = \"\"\"\\n', 'getter_function_with_explicit_none_yield = \"\"\"\\n', 'getter_function_with_yield_from = \"\"\"\\n', 'getter_method_with_implicit_return = \"\"\"\\n', 'getter_method_with_bare_return = \"\"\"\\n', 'getter_method_with_valued_return = \"\"\"\\n', 'getter_method_with_explicit_none_return = \"\"\"\\n', 'getter_method_with_bare_yield = \"\"\"\\n', 'getter_method_with_valued_yield = \"\"\"\\n', 'getter_method_with_explicit_none_yield = \"\"\"\\n', 'getter_method_with_yield_from = \"\"\"\\n', 'getter_method_with_branched_return = \"\"\"\\n', 'getter_stub_with_docstring = \"\"\"\\n', 'getter_stub_with_ellipsis = \"\"\"\\n', 'getter_stub_with_raise = \"\"\"\\n', 'getter_stub_with_docstring_and_ellipsis = \"\"\"\\n', 'getter_stub_with_docstring_and_raise = \"\"\"\\n', 'getter_stub_with_extra_statements = \"\"\"\\n', '    getter_function_with_implicit_return,\\n', '    getter_function_with_bare_return,\\n', '    getter_method_with_implicit_return,\\n', '    getter_method_with_bare_return,\\n', '    getter_stub_with_extra_statements,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [GetterWithoutReturnViolation])\\n', '    getter_function_with_valued_return,\\n', '    getter_function_with_explicit_none_return,\\n', '    getter_function_with_bare_yield,\\n', '    getter_function_with_valued_yield,\\n', '    getter_function_with_explicit_none_yield,\\n', '    getter_method_with_valued_return,\\n', '    getter_method_with_explicit_none_return,\\n', '    getter_method_with_bare_yield,\\n', '    getter_method_with_valued_yield,\\n', '    getter_method_with_explicit_none_yield,\\n', '    getter_method_with_branched_return,\\n', '    getter_stub_with_docstring,\\n', '    getter_stub_with_ellipsis,\\n', '    getter_stub_with_raise,\\n', '    getter_stub_with_docstring_and_ellipsis,\\n', '    getter_stub_with_docstring_and_raise,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    getter_function_with_yield_from,\\n', '    getter_method_with_yield_from,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t be\n    used in ``async`` functions.\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = FunctionSignatureVisitor(default_op"
 },
 "1095": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionSignatureVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_getter_without_return.py",
  "lineno": "262",
  "column": "4",
  "slicing": "['getter_function_with_implicit_return = \"\"\"\\n', 'getter_function_with_bare_return = \"\"\"\\n', 'getter_function_with_valued_return = \"\"\"\\n', 'getter_function_with_explicit_none_return = \"\"\"\\n', 'getter_function_with_bare_yield = \"\"\"\\n', 'getter_function_with_valued_yield = \"\"\"\\n', 'getter_function_with_explicit_none_yield = \"\"\"\\n', 'getter_function_with_yield_from = \"\"\"\\n', 'getter_method_with_implicit_return = \"\"\"\\n', 'getter_method_with_bare_return = \"\"\"\\n', 'getter_method_with_valued_return = \"\"\"\\n', 'getter_method_with_explicit_none_return = \"\"\"\\n', 'getter_method_with_bare_yield = \"\"\"\\n', 'getter_method_with_valued_yield = \"\"\"\\n', 'getter_method_with_explicit_none_yield = \"\"\"\\n', 'getter_method_with_yield_from = \"\"\"\\n', 'getter_method_with_branched_return = \"\"\"\\n', 'getter_stub_with_docstring = \"\"\"\\n', 'getter_stub_with_ellipsis = \"\"\"\\n', 'getter_stub_with_raise = \"\"\"\\n', 'getter_stub_with_docstring_and_ellipsis = \"\"\"\\n', 'getter_stub_with_docstring_and_raise = \"\"\"\\n', 'getter_stub_with_extra_statements = \"\"\"\\n', '    getter_function_with_implicit_return,\\n', '    getter_function_with_bare_return,\\n', '    getter_method_with_implicit_return,\\n', '    getter_method_with_bare_return,\\n', '    getter_stub_with_extra_statements,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [GetterWithoutReturnViolation])\\n', '    getter_function_with_valued_return,\\n', '    getter_function_with_explicit_none_return,\\n', '    getter_function_with_bare_yield,\\n', '    getter_function_with_valued_yield,\\n', '    getter_function_with_explicit_none_yield,\\n', '    getter_method_with_valued_return,\\n', '    getter_method_with_explicit_none_return,\\n', '    getter_method_with_bare_yield,\\n', '    getter_method_with_valued_yield,\\n', '    getter_method_with_explicit_none_yield,\\n', '    getter_method_with_branched_return,\\n', '    getter_stub_with_docstring,\\n', '    getter_stub_with_ellipsis,\\n', '    getter_stub_with_raise,\\n', '    getter_stub_with_docstring_and_ellipsis,\\n', '    getter_stub_with_docstring_and_raise,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    getter_function_with_yield_from,\\n', '    getter_method_with_yield_from,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ons.\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = FunctionSignatureVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1096": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_getter_without_return.py",
  "lineno": "284",
  "column": "4",
  "slicing": "['getter_function_with_implicit_return = \"\"\"\\n', 'getter_function_with_bare_return = \"\"\"\\n', 'getter_function_with_valued_return = \"\"\"\\n', 'getter_function_with_explicit_none_return = \"\"\"\\n', 'getter_function_with_bare_yield = \"\"\"\\n', 'getter_function_with_valued_yield = \"\"\"\\n', 'getter_function_with_explicit_none_yield = \"\"\"\\n', 'getter_function_with_yield_from = \"\"\"\\n', 'getter_method_with_implicit_return = \"\"\"\\n', 'getter_method_with_bare_return = \"\"\"\\n', 'getter_method_with_valued_return = \"\"\"\\n', 'getter_method_with_explicit_none_return = \"\"\"\\n', 'getter_method_with_bare_yield = \"\"\"\\n', 'getter_method_with_valued_yield = \"\"\"\\n', 'getter_method_with_explicit_none_yield = \"\"\"\\n', 'getter_method_with_yield_from = \"\"\"\\n', 'getter_method_with_branched_return = \"\"\"\\n', 'getter_stub_with_docstring = \"\"\"\\n', 'getter_stub_with_ellipsis = \"\"\"\\n', 'getter_stub_with_raise = \"\"\"\\n', 'getter_stub_with_docstring_and_ellipsis = \"\"\"\\n', 'getter_stub_with_docstring_and_raise = \"\"\"\\n', 'getter_stub_with_extra_statements = \"\"\"\\n', '    getter_function_with_implicit_return,\\n', '    getter_function_with_bare_return,\\n', '    getter_method_with_implicit_return,\\n', '    getter_method_with_bare_return,\\n', '    getter_stub_with_extra_statements,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [GetterWithoutReturnViolation])\\n', '    getter_function_with_valued_return,\\n', '    getter_function_with_explicit_none_return,\\n', '    getter_function_with_bare_yield,\\n', '    getter_function_with_valued_yield,\\n', '    getter_function_with_explicit_none_yield,\\n', '    getter_method_with_valued_return,\\n', '    getter_method_with_explicit_none_return,\\n', '    getter_method_with_bare_yield,\\n', '    getter_method_with_valued_yield,\\n', '    getter_method_with_explicit_none_yield,\\n', '    getter_method_with_branched_return,\\n', '    getter_stub_with_docstring,\\n', '    getter_stub_with_ellipsis,\\n', '    getter_stub_with_raise,\\n', '    getter_stub_with_docstring_and_ellipsis,\\n', '    getter_stub_with_docstring_and_raise,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    getter_function_with_yield_from,\\n', '    getter_method_with_yield_from,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "unctions are allowed to not output values.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_op"
 },
 "1097": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionSignatureVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_getter_without_return.py",
  "lineno": "286",
  "column": "4",
  "slicing": "['getter_function_with_implicit_return = \"\"\"\\n', 'getter_function_with_bare_return = \"\"\"\\n', 'getter_function_with_valued_return = \"\"\"\\n', 'getter_function_with_explicit_none_return = \"\"\"\\n', 'getter_function_with_bare_yield = \"\"\"\\n', 'getter_function_with_valued_yield = \"\"\"\\n', 'getter_function_with_explicit_none_yield = \"\"\"\\n', 'getter_function_with_yield_from = \"\"\"\\n', 'getter_method_with_implicit_return = \"\"\"\\n', 'getter_method_with_bare_return = \"\"\"\\n', 'getter_method_with_valued_return = \"\"\"\\n', 'getter_method_with_explicit_none_return = \"\"\"\\n', 'getter_method_with_bare_yield = \"\"\"\\n', 'getter_method_with_valued_yield = \"\"\"\\n', 'getter_method_with_explicit_none_yield = \"\"\"\\n', 'getter_method_with_yield_from = \"\"\"\\n', 'getter_method_with_branched_return = \"\"\"\\n', 'getter_stub_with_docstring = \"\"\"\\n', 'getter_stub_with_ellipsis = \"\"\"\\n', 'getter_stub_with_raise = \"\"\"\\n', 'getter_stub_with_docstring_and_ellipsis = \"\"\"\\n', 'getter_stub_with_docstring_and_raise = \"\"\"\\n', 'getter_stub_with_extra_statements = \"\"\"\\n', '    getter_function_with_implicit_return,\\n', '    getter_function_with_bare_return,\\n', '    getter_method_with_implicit_return,\\n', '    getter_method_with_bare_return,\\n', '    getter_stub_with_extra_statements,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [GetterWithoutReturnViolation])\\n', '    getter_function_with_valued_return,\\n', '    getter_function_with_explicit_none_return,\\n', '    getter_function_with_bare_yield,\\n', '    getter_function_with_valued_yield,\\n', '    getter_function_with_explicit_none_yield,\\n', '    getter_method_with_valued_return,\\n', '    getter_method_with_explicit_none_return,\\n', '    getter_method_with_bare_yield,\\n', '    getter_method_with_valued_yield,\\n', '    getter_method_with_explicit_none_yield,\\n', '    getter_method_with_branched_return,\\n', '    getter_stub_with_docstring,\\n', '    getter_stub_with_ellipsis,\\n', '    getter_stub_with_raise,\\n', '    getter_stub_with_docstring_and_ellipsis,\\n', '    getter_stub_with_docstring_and_raise,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    getter_function_with_yield_from,\\n', '    getter_method_with_yield_from,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "es.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1098": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_isinstance_types.py",
  "lineno": "28",
  "column": "4",
  "slicing": "[\"isinstance_call = 'isinstance(some, {0})'\\n\", '    tree = parse_ast_tree(isinstance_call.format(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(isinstance_call.format(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongIsinstanceWithTupleViolation])\\n']",
  "context": "isinstance is callable with correct types.\"\"\"\n    tree = parse_ast_tree(isinstance_call.format(code))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1099": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_isinstance_types.py",
  "lineno": "30",
  "column": "4",
  "slicing": "[\"isinstance_call = 'isinstance(some, {0})'\\n\", '    tree = parse_ast_tree(isinstance_call.format(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(isinstance_call.format(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongIsinstanceWithTupleViolation])\\n']",
  "context": "parse_ast_tree(isinstance_call.format(code))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1100": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_isinstance_types.py",
  "lineno": "46",
  "column": "4",
  "slicing": "[\"isinstance_call = 'isinstance(some, {0})'\\n\", '    tree = parse_ast_tree(isinstance_call.format(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(isinstance_call.format(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongIsinstanceWithTupleViolation])\\n']",
  "context": "instance is not callable with wrong types.\"\"\"\n    tree = parse_ast_tree(isinstance_call.format(code))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1101": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_isinstance_types.py",
  "lineno": "48",
  "column": "4",
  "slicing": "[\"isinstance_call = 'isinstance(some, {0})'\\n\", '    tree = parse_ast_tree(isinstance_call.format(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(isinstance_call.format(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongIsinstanceWithTupleViolation])\\n']",
  "context": "parse_ast_tree(isinstance_call.format(code))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1102": {
  "name": "correct_calls",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "17",
  "column": "0",
  "slicing": "['correct_calls = (\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", \"@pytest.mark.parametrize('function', correct_calls)\\n\"]",
  "context": "\nwrong_single_argument = '{1}({0}, keyword={0})'\n\ncorrect_calls = (\n    'some',\n    'some.get',\n    'my.main.pop',\n   "
 },
 "1103": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "51",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "passing any arguments as keywords is fine.\"\"\"\n    tree = parse_ast_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1104": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "53",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "st_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1105": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "86",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "passing any arguments as keywords is fine.\"\"\"\n    tree = parse_ast_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1106": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "88",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "st_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1107": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "114",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "passing any arguments as keywords is fine.\"\"\"\n    tree = parse_ast_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1108": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "116",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "st_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1109": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "151",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ing that passing non-boolean args is fine.\"\"\"\n    tree = parse_ast_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1110": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "153",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "st_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1111": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "180",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "booleans as positional args is restricted.\"\"\"\n    tree = parse_ast_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1112": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_boolean_args.py",
  "lineno": "182",
  "column": "4",
  "slicing": "[\"correct_argument = '{1}(0, 1, keyword={0}, other={0})'\\n\", \"correct_three_arguments = '{1}({0}, {0}, {0})'\\n\", \"wrong_argument = '{1}({0}, {0})'\\n\", \"correct_single_argument = '{1}({0})'\\n\", \"wrong_single_argument = '{1}({0}, keyword={0})'\\n\", 'correct_calls = (\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    correct_three_arguments,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    correct_argument,\\n', '    correct_single_argument,\\n', '    wrong_argument,\\n', '    wrong_single_argument,\\n', \"@pytest.mark.parametrize('function', correct_calls)\\n\", '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_argument,\\n', '    tree = parse_ast_tree(template.format(argument, function))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "st_tree(template.format(argument, function))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1113": {
  "name": "all_templates",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_complex_default_values.py",
  "lineno": "54",
  "column": "0",
  "slicing": "['all_templates = (\\n', \"@pytest.mark.parametrize('template', all_templates)\\n\", \"@pytest.mark.parametrize('template', all_templates)\\n\"]",
  "context": "efaults = 'lambda *, arg, with_default={0}: ...'\n\nall_templates = (\n    function_with_defaults,\n    pytest.param(\n    "
 },
 "1114": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_complex_default_values.py",
  "lineno": "105",
  "column": "4",
  "slicing": "['function_with_defaults = \"\"\"\\n', 'function_with_posonly_defaults = \"\"\"\\n', 'function_with_kw_defaults1 = \"\"\"\\n', 'function_with_kw_defaults2 = \"\"\"\\n', 'method_with_defaults = \"\"\"\\n', 'method_with_posonly_defaults = \"\"\"\\n', 'method_with_kw_defaults = \"\"\"\\n', \"lambda_with_defaults = 'lambda with_default={0}: ...'\\n\", \"lambda_with_posonly_defaults = 'lambda with_default={0}, /: ...'\\n\", \"lambda_with_kw_defaults = 'lambda *, arg, with_default={0}: ...'\\n\", 'all_templates = (\\n', '    function_with_defaults,\\n', '        function_with_posonly_defaults,\\n', '    function_with_kw_defaults1,\\n', '    function_with_kw_defaults2,\\n', '    method_with_defaults,\\n', '        method_with_posonly_defaults,\\n', '    method_with_kw_defaults,\\n', '    lambda_with_defaults,\\n', '        lambda_with_posonly_defaults,\\n', '    lambda_with_kw_defaults,\\n', \"@pytest.mark.parametrize('template', all_templates)\\n\", '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"@pytest.mark.parametrize('template', all_templates)\\n\", '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ignored_types=PositionalOnlyArgumentsViolation)\\n']",
  "context": "hat wrong function defaults are forbidden.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    visitor = FunctionSignatureVisitor(default_op"
 },
 "1115": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionSignatureVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_complex_default_values.py",
  "lineno": "107",
  "column": "4",
  "slicing": "['function_with_defaults = \"\"\"\\n', 'function_with_posonly_defaults = \"\"\"\\n', 'function_with_kw_defaults1 = \"\"\"\\n', 'function_with_kw_defaults2 = \"\"\"\\n', 'method_with_defaults = \"\"\"\\n', 'method_with_posonly_defaults = \"\"\"\\n', 'method_with_kw_defaults = \"\"\"\\n', \"lambda_with_defaults = 'lambda with_default={0}: ...'\\n\", \"lambda_with_posonly_defaults = 'lambda with_default={0}, /: ...'\\n\", \"lambda_with_kw_defaults = 'lambda *, arg, with_default={0}: ...'\\n\", 'all_templates = (\\n', '    function_with_defaults,\\n', '        function_with_posonly_defaults,\\n', '    function_with_kw_defaults1,\\n', '    function_with_kw_defaults2,\\n', '    method_with_defaults,\\n', '        method_with_posonly_defaults,\\n', '    method_with_kw_defaults,\\n', '    lambda_with_defaults,\\n', '        lambda_with_posonly_defaults,\\n', '    lambda_with_kw_defaults,\\n', \"@pytest.mark.parametrize('template', all_templates)\\n\", '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"@pytest.mark.parametrize('template', all_templates)\\n\", '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ignored_types=PositionalOnlyArgumentsViolation)\\n']",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    visitor = FunctionSignatureVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "1116": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_complex_default_values.py",
  "lineno": "143",
  "column": "4",
  "slicing": "['function_with_defaults = \"\"\"\\n', 'function_with_posonly_defaults = \"\"\"\\n', 'function_with_kw_defaults1 = \"\"\"\\n', 'function_with_kw_defaults2 = \"\"\"\\n', 'method_with_defaults = \"\"\"\\n', 'method_with_posonly_defaults = \"\"\"\\n', 'method_with_kw_defaults = \"\"\"\\n', \"lambda_with_defaults = 'lambda with_default={0}: ...'\\n\", \"lambda_with_posonly_defaults = 'lambda with_default={0}, /: ...'\\n\", \"lambda_with_kw_defaults = 'lambda *, arg, with_default={0}: ...'\\n\", 'all_templates = (\\n', '    function_with_defaults,\\n', '        function_with_posonly_defaults,\\n', '    function_with_kw_defaults1,\\n', '    function_with_kw_defaults2,\\n', '    method_with_defaults,\\n', '        method_with_posonly_defaults,\\n', '    method_with_kw_defaults,\\n', '    lambda_with_defaults,\\n', '        lambda_with_posonly_defaults,\\n', '    lambda_with_kw_defaults,\\n', \"@pytest.mark.parametrize('template', all_templates)\\n\", '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"@pytest.mark.parametrize('template', all_templates)\\n\", '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ignored_types=PositionalOnlyArgumentsViolation)\\n']",
  "context": "rrect function defaults passes validation.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code)))\n\n    visitor = FunctionSignatureVisitor(default_op"
 },
 "1117": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionSignatureVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_complex_default_values.py",
  "lineno": "145",
  "column": "4",
  "slicing": "['function_with_defaults = \"\"\"\\n', 'function_with_posonly_defaults = \"\"\"\\n', 'function_with_kw_defaults1 = \"\"\"\\n', 'function_with_kw_defaults2 = \"\"\"\\n', 'method_with_defaults = \"\"\"\\n', 'method_with_posonly_defaults = \"\"\"\\n', 'method_with_kw_defaults = \"\"\"\\n', \"lambda_with_defaults = 'lambda with_default={0}: ...'\\n\", \"lambda_with_posonly_defaults = 'lambda with_default={0}, /: ...'\\n\", \"lambda_with_kw_defaults = 'lambda *, arg, with_default={0}: ...'\\n\", 'all_templates = (\\n', '    function_with_defaults,\\n', '        function_with_posonly_defaults,\\n', '    function_with_kw_defaults1,\\n', '    function_with_kw_defaults2,\\n', '    method_with_defaults,\\n', '        method_with_posonly_defaults,\\n', '    method_with_kw_defaults,\\n', '    lambda_with_defaults,\\n', '        lambda_with_posonly_defaults,\\n', '    lambda_with_kw_defaults,\\n', \"@pytest.mark.parametrize('template', all_templates)\\n\", '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n', \"@pytest.mark.parametrize('template', all_templates)\\n\", '    tree = parse_ast_tree(mode(template.format(code)))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ignored_types=PositionalOnlyArgumentsViolation)\\n']",
  "context": " parse_ast_tree(mode(template.format(code)))\n\n    visitor = FunctionSignatureVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [], "
 },
 "1118": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "81",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ng that calling `super` in method is fine.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1119": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ne.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1120": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "102",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ting that calling `super` has limitations.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1121": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "104",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ns.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1122": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "122",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "sible to have two violations with `super`.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1123": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "124",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "r`.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1124": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "153",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "uper` with incorrect access is restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(arg, prop)))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1125": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "155",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "parse_ast_tree(mode(code.format(arg, prop)))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1126": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "183",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "uper` with incorrect access is restricted.\"\"\"\n    tree = parse_ast_tree(mode(code.format(arg, prop)))\n\n    visitor = WrongFunctionCallVisitor(default_op"
 },
 "1127": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_super_call.py",
  "lineno": "185",
  "column": "4",
  "slicing": "['super_call_with_access = \"\"\"\\n', 'correct_super_call = \"\"\"\\n', 'correct_regression520 = \"\"\"\\n', 'super_call_in_module = \"\"\"\\n', 'super_call_in_module_with_arguments = \"\"\"\\n', 'super_call_in_function = \"\"\"\\n', 'super_call_in_function_with_arguments = \"\"\"\\n', 'super_call_in_method_with_arguments = \"\"\"\\n', '    correct_super_call,\\n', '    correct_regression520,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    super_call_in_module,\\n', '    super_call_in_function,\\n', '    super_call_in_method_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongSuperCallViolation])\\n', '    super_call_in_function_with_arguments,\\n', '    super_call_in_module_with_arguments,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    super_call_with_access,\\n', '    tree = parse_ast_tree(mode(code.format(arg, prop)))\\n', '    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "parse_ast_tree(mode(code.format(arg, prop)))\n\n    visitor = WrongFunctionCallVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1128": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "teration` is restricted inside generators.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement, exception)))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1129": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree(mode(code.format(statement, exception)))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sto"
 },
 "1130": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "teration` is restricted inside generators.\"\"\"\n    tree = parse_ast_tree(code.format(statement, exception))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1131": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(code.format(statement, exception))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sto"
 },
 "1132": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "106",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "eration` is allowed inside bare functions.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement, exception)))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1133": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree(mode(code.format(statement, exception)))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1134": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "137",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "r exceptions is allowed inside generators.\"\"\"\n    tree = parse_ast_tree(mode(code.format(statement, exception)))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1135": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "139",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree(mode(code.format(statement, exception)))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1136": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "166",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "r exceptions is allowed inside generators.\"\"\"\n    tree = parse_ast_tree(code.format(statement, exception))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1137": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_stop_iteration.py",
  "lineno": "168",
  "column": "4",
  "slicing": "['stop_iteration_method = \"\"\"\\n', 'stop_iteration_function = \"\"\"\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [StopIterationInsideGeneratorViolation])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(mode(code.format(statement, exception)))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    stop_iteration_method,\\n', '    stop_iteration_function,\\n', '    tree = parse_ast_tree(code.format(statement, exception))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(code.format(statement, exception))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1138": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unnecessary_literals.py",
  "lineno": "24",
  "column": "4",
  "slicing": "[\"regular_call_without_args = '{0}()'\\n\", \"regular_call_with_args = '{0}(*args, **kwargs)'\\n\", '    tree = parse_ast_tree(mode(regular_call_without_args.format(literal)))\\n', '    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnnecessaryLiteralsViolation])\\n', '    tree = parse_ast_tree(mode(regular_call_with_args.format(literal)))\\n', '    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "some literals without args are restricted.\"\"\"\n    tree = parse_ast_tree(mode(regular_call_without_args.format(literal)))\n\n    visitor = UnnecessaryLiteralsVisitor(default_"
 },
 "1139": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.UnnecessaryLiteralsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unnecessary_literals.py",
  "lineno": "26",
  "column": "4",
  "slicing": "[\"regular_call_without_args = '{0}()'\\n\", \"regular_call_with_args = '{0}(*args, **kwargs)'\\n\", '    tree = parse_ast_tree(mode(regular_call_without_args.format(literal)))\\n', '    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnnecessaryLiteralsViolation])\\n', '    tree = parse_ast_tree(mode(regular_call_with_args.format(literal)))\\n', '    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "(regular_call_without_args.format(literal)))\n\n    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unn"
 },
 "1140": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unnecessary_literals.py",
  "lineno": "41",
  "column": "4",
  "slicing": "[\"regular_call_without_args = '{0}()'\\n\", \"regular_call_with_args = '{0}(*args, **kwargs)'\\n\", '    tree = parse_ast_tree(mode(regular_call_without_args.format(literal)))\\n', '    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnnecessaryLiteralsViolation])\\n', '    tree = parse_ast_tree(mode(regular_call_with_args.format(literal)))\\n', '    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat literals with args are not restricted.\"\"\"\n    tree = parse_ast_tree(mode(regular_call_with_args.format(literal)))\n\n    visitor = UnnecessaryLiteralsVisitor(default_"
 },
 "1141": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.UnnecessaryLiteralsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unnecessary_literals.py",
  "lineno": "43",
  "column": "4",
  "slicing": "[\"regular_call_without_args = '{0}()'\\n\", \"regular_call_with_args = '{0}(*args, **kwargs)'\\n\", '    tree = parse_ast_tree(mode(regular_call_without_args.format(literal)))\\n', '    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnnecessaryLiteralsViolation])\\n', '    tree = parse_ast_tree(mode(regular_call_with_args.format(literal)))\\n', '    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ode(regular_call_with_args.format(literal)))\n\n    visitor = UnnecessaryLiteralsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1142": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_implicit_primitive.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitPrimitiveViolation])\\n']",
  "context": "isinstance is callable with correct types.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = UselessLambdaDefinitionVisitor(defa"
 },
 "1143": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.UselessLambdaDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_implicit_primitive.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitPrimitiveViolation])\\n']",
  "context": "ct types.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1144": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_implicit_primitive.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitPrimitiveViolation])\\n']",
  "context": "isinstance is callable with correct types.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = UselessLambdaDefinitionVisitor(defa"
 },
 "1145": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.UselessLambdaDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_implicit_primitive.py",
  "lineno": "63",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitPrimitiveViolation])\\n']",
  "context": "ct types.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "1146": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unused_variables.py",
  "lineno": "136",
  "column": "4",
  "slicing": "['correct_module = \"\"\"\\n', 'correct_class = \"\"\"\\n', 'correct_function = \"\"\"\\n', 'correct_function_with_for = \"\"\"\\n', 'correct_function_with_exception = \"\"\"\\n', 'correct_function_with_unnamed_exception = \"\"\"\\n', 'correct_func_with_re_store_unused_variable1 = \"\"\"\\n', 'correct_func_with_re_store_unused_variable2 = \"\"\"\\n', 'wrong_function1 = \"\"\"\\n', 'wrong_function2 = \"\"\"\\n', 'wrong_function_with_exception = \"\"\"\\n', 'wrong_function_with_with = \"\"\"\\n', 'wrong_function_with_for = \"\"\"\\n', 'wrong_method = \"\"\"\\n', 'wrong_function_with_walrus = \"\"\"\\n', '    correct_module,\\n', '    correct_class,\\n', '    correct_function,\\n', '    correct_function_with_for,\\n', '    correct_function_with_exception,\\n', '    correct_function_with_unnamed_exception,\\n', '    correct_func_with_re_store_unused_variable1,\\n', '    correct_func_with_re_store_unused_variable2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_function1,\\n', '    wrong_function2,\\n', '    wrong_function_with_exception,\\n', '    wrong_function_with_with,\\n', '    wrong_function_with_for,\\n', '    wrong_method,\\n', '        wrong_function_with_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "hat correct usage of variables is allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1147": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unused_variables.py",
  "lineno": "138",
  "column": "4",
  "slicing": "['correct_module = \"\"\"\\n', 'correct_class = \"\"\"\\n', 'correct_function = \"\"\"\\n', 'correct_function_with_for = \"\"\"\\n', 'correct_function_with_exception = \"\"\"\\n', 'correct_function_with_unnamed_exception = \"\"\"\\n', 'correct_func_with_re_store_unused_variable1 = \"\"\"\\n', 'correct_func_with_re_store_unused_variable2 = \"\"\"\\n', 'wrong_function1 = \"\"\"\\n', 'wrong_function2 = \"\"\"\\n', 'wrong_function_with_exception = \"\"\"\\n', 'wrong_function_with_with = \"\"\"\\n', 'wrong_function_with_for = \"\"\"\\n', 'wrong_method = \"\"\"\\n', 'wrong_function_with_walrus = \"\"\"\\n', '    correct_module,\\n', '    correct_class,\\n', '    correct_function,\\n', '    correct_function_with_for,\\n', '    correct_function_with_exception,\\n', '    correct_function_with_unnamed_exception,\\n', '    correct_func_with_re_store_unused_variable1,\\n', '    correct_func_with_re_store_unused_variable2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_function1,\\n', '    wrong_function2,\\n', '    wrong_function_with_exception,\\n', '    wrong_function_with_with,\\n', '    wrong_function_with_for,\\n', '    wrong_method,\\n', '        wrong_function_with_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1148": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unused_variables.py",
  "lineno": "164",
  "column": "4",
  "slicing": "['correct_module = \"\"\"\\n', 'correct_class = \"\"\"\\n', 'correct_function = \"\"\"\\n', 'correct_function_with_for = \"\"\"\\n', 'correct_function_with_exception = \"\"\"\\n', 'correct_function_with_unnamed_exception = \"\"\"\\n', 'correct_func_with_re_store_unused_variable1 = \"\"\"\\n', 'correct_func_with_re_store_unused_variable2 = \"\"\"\\n', 'wrong_function1 = \"\"\"\\n', 'wrong_function2 = \"\"\"\\n', 'wrong_function_with_exception = \"\"\"\\n', 'wrong_function_with_with = \"\"\"\\n', 'wrong_function_with_for = \"\"\"\\n', 'wrong_method = \"\"\"\\n', 'wrong_function_with_walrus = \"\"\"\\n', '    correct_module,\\n', '    correct_class,\\n', '    correct_function,\\n', '    correct_function_with_for,\\n', '    correct_function_with_exception,\\n', '    correct_function_with_unnamed_exception,\\n', '    correct_func_with_re_store_unused_variable1,\\n', '    correct_func_with_re_store_unused_variable2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_function1,\\n', '    wrong_function2,\\n', '    wrong_function_with_exception,\\n', '    wrong_function_with_with,\\n', '    wrong_function_with_for,\\n', '    wrong_method,\\n', '        wrong_function_with_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ming and using variables have limitations.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1149": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unused_variables.py",
  "lineno": "166",
  "column": "4",
  "slicing": "['correct_module = \"\"\"\\n', 'correct_class = \"\"\"\\n', 'correct_function = \"\"\"\\n', 'correct_function_with_for = \"\"\"\\n', 'correct_function_with_exception = \"\"\"\\n', 'correct_function_with_unnamed_exception = \"\"\"\\n', 'correct_func_with_re_store_unused_variable1 = \"\"\"\\n', 'correct_func_with_re_store_unused_variable2 = \"\"\"\\n', 'wrong_function1 = \"\"\"\\n', 'wrong_function2 = \"\"\"\\n', 'wrong_function_with_exception = \"\"\"\\n', 'wrong_function_with_with = \"\"\"\\n', 'wrong_function_with_for = \"\"\"\\n', 'wrong_method = \"\"\"\\n', 'wrong_function_with_walrus = \"\"\"\\n', '    correct_module,\\n', '    correct_class,\\n', '    correct_function,\\n', '    correct_function_with_for,\\n', '    correct_function_with_exception,\\n', '    correct_function_with_unnamed_exception,\\n', '    correct_func_with_re_store_unused_variable1,\\n', '    correct_func_with_re_store_unused_variable2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_function1,\\n', '    wrong_function2,\\n', '    wrong_function_with_exception,\\n', '    wrong_function_with_with,\\n', '    wrong_function_with_for,\\n', '    wrong_method,\\n', '        wrong_function_with_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ns.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unu"
 },
 "1150": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unused_variables.py",
  "lineno": "185",
  "column": "4",
  "slicing": "['correct_module = \"\"\"\\n', 'correct_class = \"\"\"\\n', 'correct_function = \"\"\"\\n', 'correct_function_with_for = \"\"\"\\n', 'correct_function_with_exception = \"\"\"\\n', 'correct_function_with_unnamed_exception = \"\"\"\\n', 'correct_func_with_re_store_unused_variable1 = \"\"\"\\n', 'correct_func_with_re_store_unused_variable2 = \"\"\"\\n', 'wrong_function1 = \"\"\"\\n', 'wrong_function2 = \"\"\"\\n', 'wrong_function_with_exception = \"\"\"\\n', 'wrong_function_with_with = \"\"\"\\n', 'wrong_function_with_for = \"\"\"\\n', 'wrong_method = \"\"\"\\n', 'wrong_function_with_walrus = \"\"\"\\n', '    correct_module,\\n', '    correct_class,\\n', '    correct_function,\\n', '    correct_function_with_for,\\n', '    correct_function_with_exception,\\n', '    correct_function_with_unnamed_exception,\\n', '    correct_func_with_re_store_unused_variable1,\\n', '    correct_func_with_re_store_unused_variable2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_function1,\\n', '    wrong_function2,\\n', '    wrong_function_with_exception,\\n', '    wrong_function_with_with,\\n', '    wrong_function_with_for,\\n', '    wrong_method,\\n', '        wrong_function_with_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "d)\n        print(_should_not_be_used)\n    \"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1151": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_unused_variables.py",
  "lineno": "187",
  "column": "4",
  "slicing": "['correct_module = \"\"\"\\n', 'correct_class = \"\"\"\\n', 'correct_function = \"\"\"\\n', 'correct_function_with_for = \"\"\"\\n', 'correct_function_with_exception = \"\"\"\\n', 'correct_function_with_unnamed_exception = \"\"\"\\n', 'correct_func_with_re_store_unused_variable1 = \"\"\"\\n', 'correct_func_with_re_store_unused_variable2 = \"\"\"\\n', 'wrong_function1 = \"\"\"\\n', 'wrong_function2 = \"\"\"\\n', 'wrong_function_with_exception = \"\"\"\\n', 'wrong_function_with_with = \"\"\"\\n', 'wrong_function_with_for = \"\"\"\\n', 'wrong_method = \"\"\"\\n', 'wrong_function_with_walrus = \"\"\"\\n', '    correct_module,\\n', '    correct_class,\\n', '    correct_function,\\n', '    correct_function_with_for,\\n', '    correct_function_with_exception,\\n', '    correct_function_with_unnamed_exception,\\n', '    correct_func_with_re_store_unused_variable1,\\n', '    correct_func_with_re_store_unused_variable2,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    wrong_function1,\\n', '    wrong_function2,\\n', '    wrong_function_with_exception,\\n', '    wrong_function_with_with,\\n', '    wrong_function_with_for,\\n', '    wrong_method,\\n', '        wrong_function_with_walrus,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnusedVariableIsUsedViolation])\\n', '    code = \"\"\"\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "   \"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1152": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_positional_only.py",
  "lineno": "68",
  "column": "4",
  "slicing": "[\"correct_lambda = 'lambda x, *args, y, z = 1, **kwargs: ...'\\n\", 'correct_function = \"\"\"\\n', 'correct_method = \"\"\"\\n', '    correct_lambda,\\n', '    correct_function,\\n', '    correct_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositionalOnlyArgumentsViolation])\\n']",
  "context": "  \"\"\"Testing that regular code is allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_op"
 },
 "1153": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionSignatureVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_positional_only.py",
  "lineno": "70",
  "column": "4",
  "slicing": "[\"correct_lambda = 'lambda x, *args, y, z = 1, **kwargs: ...'\\n\", 'correct_function = \"\"\"\\n', 'correct_method = \"\"\"\\n', '    correct_lambda,\\n', '    correct_function,\\n', '    correct_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositionalOnlyArgumentsViolation])\\n']",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1154": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_positional_only.py",
  "lineno": "94",
  "column": "4",
  "slicing": "[\"correct_lambda = 'lambda x, *args, y, z = 1, **kwargs: ...'\\n\", 'correct_function = \"\"\"\\n', 'correct_method = \"\"\"\\n', '    correct_lambda,\\n', '    correct_function,\\n', '    correct_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositionalOnlyArgumentsViolation])\\n']",
  "context": "\n    \"\"\"Testing that ``/`` is not allowed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_op"
 },
 "1155": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionSignatureVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_positional_only.py",
  "lineno": "96",
  "column": "4",
  "slicing": "[\"correct_lambda = 'lambda x, *args, y, z = 1, **kwargs: ...'\\n\", 'correct_function = \"\"\"\\n', 'correct_method = \"\"\"\\n', '    correct_lambda,\\n', '    correct_function,\\n', '    correct_method,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionSignatureVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositionalOnlyArgumentsViolation])\\n']",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionSignatureVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Pos"
 },
 "1156": {
  "name": "useless_lambdas",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_useless_lambda.py",
  "lineno": "13",
  "column": "0",
  "slicing": "['useless_lambdas = [\\n', '    useless_lambdas.extend([\\n', \"@pytest.mark.parametrize(('lambda_def', 'call_def'), useless_lambdas)\\n\"]",
  "context": "ambdaDefinitionVisitor,\n)\n\ntemplate = '{0}: {1}'\n\nuseless_lambdas = [\n    ('lambda', 'method()'),\n    ('lambda x', 'meth"
 },
 "1157": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_useless_lambda.py",
  "lineno": "43",
  "column": "4",
  "slicing": "[\"template = '{0}: {1}'\\n\", 'useless_lambdas = [\\n', '    useless_lambdas.extend([\\n', \"@pytest.mark.parametrize(('lambda_def', 'call_def'), useless_lambdas)\\n\", '    tree = parse_ast_tree(template.format(lambda_def, call_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLambdaViolation])\\n', 'valid_calls = (\\n', '    *valid_calls,\\n', '    tree = parse_ast_tree(template.format(lambda_def, inner_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('inner_def', valid_calls)\\n\", \"    tree = parse_ast_tree(template.format('lambda', inner_def))\\n\", '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "  \"\"\"Testing useless lambdas are reported.\"\"\"\n    tree = parse_ast_tree(template.format(lambda_def, call_def))\n\n    visitor = UselessLambdaDefinitionVisitor(defa"
 },
 "1158": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.UselessLambdaDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_useless_lambda.py",
  "lineno": "45",
  "column": "4",
  "slicing": "[\"template = '{0}: {1}'\\n\", 'useless_lambdas = [\\n', '    useless_lambdas.extend([\\n', \"@pytest.mark.parametrize(('lambda_def', 'call_def'), useless_lambdas)\\n\", '    tree = parse_ast_tree(template.format(lambda_def, call_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLambdaViolation])\\n', 'valid_calls = (\\n', '    *valid_calls,\\n', '    tree = parse_ast_tree(template.format(lambda_def, inner_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('inner_def', valid_calls)\\n\", \"    tree = parse_ast_tree(template.format('lambda', inner_def))\\n\", '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_tree(template.format(lambda_def, call_def))\n\n    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "1159": {
  "name": "valid_calls",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_useless_lambda.py",
  "lineno": "51",
  "column": "0",
  "slicing": "['valid_calls = (\\n', '    *valid_calls,\\n', \"@pytest.mark.parametrize('inner_def', valid_calls)\\n\"]",
  "context": "ssert_errors(visitor, [UselessLambdaViolation])\n\n\nvalid_calls = (\n    '[1, 2, 3]',\n    'method',\n    'obj.attr',\n   "
 },
 "1160": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_useless_lambda.py",
  "lineno": "114",
  "column": "4",
  "slicing": "[\"template = '{0}: {1}'\\n\", 'useless_lambdas = [\\n', '    useless_lambdas.extend([\\n', \"@pytest.mark.parametrize(('lambda_def', 'call_def'), useless_lambdas)\\n\", '    tree = parse_ast_tree(template.format(lambda_def, call_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLambdaViolation])\\n', 'valid_calls = (\\n', '    *valid_calls,\\n', '    tree = parse_ast_tree(template.format(lambda_def, inner_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('inner_def', valid_calls)\\n\", \"    tree = parse_ast_tree(template.format('lambda', inner_def))\\n\", '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"Testing correct lambdas are not reported.\"\"\"\n    tree = parse_ast_tree(template.format(lambda_def, inner_def))\n\n    visitor = UselessLambdaDefinitionVisitor(defa"
 },
 "1161": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.UselessLambdaDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_useless_lambda.py",
  "lineno": "116",
  "column": "4",
  "slicing": "[\"template = '{0}: {1}'\\n\", 'useless_lambdas = [\\n', '    useless_lambdas.extend([\\n', \"@pytest.mark.parametrize(('lambda_def', 'call_def'), useless_lambdas)\\n\", '    tree = parse_ast_tree(template.format(lambda_def, call_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLambdaViolation])\\n', 'valid_calls = (\\n', '    *valid_calls,\\n', '    tree = parse_ast_tree(template.format(lambda_def, inner_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('inner_def', valid_calls)\\n\", \"    tree = parse_ast_tree(template.format('lambda', inner_def))\\n\", '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree(template.format(lambda_def, inner_def))\n\n    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1162": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_useless_lambda.py",
  "lineno": "130",
  "column": "4",
  "slicing": "[\"template = '{0}: {1}'\\n\", 'useless_lambdas = [\\n', '    useless_lambdas.extend([\\n', \"@pytest.mark.parametrize(('lambda_def', 'call_def'), useless_lambdas)\\n\", '    tree = parse_ast_tree(template.format(lambda_def, call_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLambdaViolation])\\n', 'valid_calls = (\\n', '    *valid_calls,\\n', '    tree = parse_ast_tree(template.format(lambda_def, inner_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('inner_def', valid_calls)\\n\", \"    tree = parse_ast_tree(template.format('lambda', inner_def))\\n\", '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ng correct empty lambdas are not reported.\"\"\"\n    tree = parse_ast_tree(template.format('lambda', inner_def))\n\n    visitor = UselessLambdaDefinitionVisitor(defa"
 },
 "1163": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.UselessLambdaDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_useless_lambda.py",
  "lineno": "132",
  "column": "4",
  "slicing": "[\"template = '{0}: {1}'\\n\", 'useless_lambdas = [\\n', '    useless_lambdas.extend([\\n', \"@pytest.mark.parametrize(('lambda_def', 'call_def'), useless_lambdas)\\n\", '    tree = parse_ast_tree(template.format(lambda_def, call_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLambdaViolation])\\n', 'valid_calls = (\\n', '    *valid_calls,\\n', '    tree = parse_ast_tree(template.format(lambda_def, inner_def))\\n', '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('inner_def', valid_calls)\\n\", \"    tree = parse_ast_tree(template.format('lambda', inner_def))\\n\", '    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t_tree(template.format('lambda', inner_def))\n\n    visitor = UselessLambdaDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1164": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_descriptors.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['correct_decorator1 = \"\"\"\\n', 'correct_decorator2 = \"\"\"\\n', 'correct_decorator3 = \"\"\"\\n', 'correct_decorator4 = \"\"\"\\n', '    correct_decorator1,\\n', '    correct_decorator2,\\n', '    correct_decorator3,\\n', '    correct_decorator4,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongDescriptorDecoratorViolation])\\n']",
  "context": "that too large amount of decorators works.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1165": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_descriptors.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['correct_decorator1 = \"\"\"\\n', 'correct_decorator2 = \"\"\"\\n', 'correct_decorator3 = \"\"\"\\n', 'correct_decorator4 = \"\"\"\\n', '    correct_decorator1,\\n', '    correct_decorator2,\\n', '    correct_decorator3,\\n', '    correct_decorator4,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongDescriptorDecoratorViolation])\\n']",
  "context": "ks.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1166": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_descriptors.py",
  "lineno": "102",
  "column": "4",
  "slicing": "['correct_decorator1 = \"\"\"\\n', 'correct_decorator2 = \"\"\"\\n', 'correct_decorator3 = \"\"\"\\n', 'correct_decorator4 = \"\"\"\\n', '    correct_decorator1,\\n', '    correct_decorator2,\\n', '    correct_decorator3,\\n', '    correct_decorator4,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongDescriptorDecoratorViolation])\\n']",
  "context": "that too large amount of decorators works.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_o"
 },
 "1167": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.FunctionDefinitionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_wrong_descriptors.py",
  "lineno": "104",
  "column": "4",
  "slicing": "['correct_decorator1 = \"\"\"\\n', 'correct_decorator2 = \"\"\"\\n', 'correct_decorator3 = \"\"\"\\n', 'correct_decorator4 = \"\"\"\\n', '    correct_decorator1,\\n', '    correct_decorator2,\\n', '    correct_decorator3,\\n', '    correct_decorator4,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongDescriptorDecoratorViolation])\\n']",
  "context": "ks.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = FunctionDefinitionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1168": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_open_with.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['context_manager1 = \"\"\"\\n', 'context_manager2 = \"\"\"\\n', 'context_manager3 = \"\"\"\\n', 'context_manager4 = \"\"\"\\n', \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", 'try_finally = \"\"\"\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OpenWithoutContextManagerViolation])\\n']",
  "context": "``open()`` inside a context manager works.\"\"\"\n    tree = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(def"
 },
 "1169": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallContextVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_open_with.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['context_manager1 = \"\"\"\\n', 'context_manager2 = \"\"\"\\n', 'context_manager3 = \"\"\"\\n', 'context_manager4 = \"\"\"\\n', \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", 'try_finally = \"\"\"\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OpenWithoutContextManagerViolation])\\n']",
  "context": "ee = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1170": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_open_with.py",
  "lineno": "101",
  "column": "4",
  "slicing": "['context_manager1 = \"\"\"\\n', 'context_manager2 = \"\"\"\\n', 'context_manager3 = \"\"\"\\n', 'context_manager4 = \"\"\"\\n', \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", 'try_finally = \"\"\"\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OpenWithoutContextManagerViolation])\\n']",
  "context": "):\n    \"\"\"Testing that regular calls work.\"\"\"\n    tree = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(def"
 },
 "1171": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallContextVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_open_with.py",
  "lineno": "103",
  "column": "4",
  "slicing": "['context_manager1 = \"\"\"\\n', 'context_manager2 = \"\"\"\\n', 'context_manager3 = \"\"\"\\n', 'context_manager4 = \"\"\"\\n', \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", 'try_finally = \"\"\"\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OpenWithoutContextManagerViolation])\\n']",
  "context": "ee = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1172": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_open_with.py",
  "lineno": "128",
  "column": "4",
  "slicing": "['context_manager1 = \"\"\"\\n', 'context_manager2 = \"\"\"\\n', 'context_manager3 = \"\"\"\\n', 'context_manager4 = \"\"\"\\n', \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", 'try_finally = \"\"\"\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OpenWithoutContextManagerViolation])\\n']",
  "context": "ithout context managers raise a violation.\"\"\"\n    tree = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(def"
 },
 "1173": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallContextVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_open_with.py",
  "lineno": "130",
  "column": "4",
  "slicing": "['context_manager1 = \"\"\"\\n', 'context_manager2 = \"\"\"\\n', 'context_manager3 = \"\"\"\\n', 'context_manager4 = \"\"\"\\n', \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", 'try_finally = \"\"\"\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    context_manager1,\\n', '    context_manager2,\\n', '    context_manager3,\\n', '    context_manager4,\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    expression,\\n', '    assignment,\\n', '    try_finally,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OpenWithoutContextManagerViolation])\\n']",
  "context": "ee = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Ope"
 },
 "1174": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_type_compare.py",
  "lineno": "60",
  "column": "4",
  "slicing": "[\"simple_compare = '{0} == other'\\n\", \"is_compare = '{0} is other'\\n\", \"nested_compare = '{0} == int and other()'\\n\", \"triple_compare = '{0} == some == other'\\n\", \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", \"annotation = 'some: {0} = int'\\n\", 'try_finally = \"\"\"\\n', 'function_return = \"\"\"\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TypeCompareViolation])\\n']",
  "context": "   \"\"\"Testing that ``type()`` can be used.\"\"\"\n    tree = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(def"
 },
 "1175": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallContextVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_type_compare.py",
  "lineno": "62",
  "column": "4",
  "slicing": "[\"simple_compare = '{0} == other'\\n\", \"is_compare = '{0} is other'\\n\", \"nested_compare = '{0} == int and other()'\\n\", \"triple_compare = '{0} == some == other'\\n\", \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", \"annotation = 'some: {0} = int'\\n\", 'try_finally = \"\"\"\\n', 'function_return = \"\"\"\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TypeCompareViolation])\\n']",
  "context": "ee = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1176": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_type_compare.py",
  "lineno": "96",
  "column": "4",
  "slicing": "[\"simple_compare = '{0} == other'\\n\", \"is_compare = '{0} is other'\\n\", \"nested_compare = '{0} == int and other()'\\n\", \"triple_compare = '{0} == some == other'\\n\", \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", \"annotation = 'some: {0} = int'\\n\", 'try_finally = \"\"\"\\n', 'function_return = \"\"\"\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TypeCompareViolation])\\n']",
  "context": "):\n    \"\"\"Testing that regular calls work.\"\"\"\n    tree = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(def"
 },
 "1177": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallContextVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_type_compare.py",
  "lineno": "98",
  "column": "4",
  "slicing": "[\"simple_compare = '{0} == other'\\n\", \"is_compare = '{0} is other'\\n\", \"nested_compare = '{0} == int and other()'\\n\", \"triple_compare = '{0} == some == other'\\n\", \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", \"annotation = 'some: {0} = int'\\n\", 'try_finally = \"\"\"\\n', 'function_return = \"\"\"\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TypeCompareViolation])\\n']",
  "context": "ee = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1178": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_type_compare.py",
  "lineno": "124",
  "column": "4",
  "slicing": "[\"simple_compare = '{0} == other'\\n\", \"is_compare = '{0} is other'\\n\", \"nested_compare = '{0} == int and other()'\\n\", \"triple_compare = '{0} == some == other'\\n\", \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", \"annotation = 'some: {0} = int'\\n\", 'try_finally = \"\"\"\\n', 'function_return = \"\"\"\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TypeCompareViolation])\\n']",
  "context": "`type()`` cannot be used inside a compare.\"\"\"\n    tree = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(def"
 },
 "1179": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallContextVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_type_compare.py",
  "lineno": "126",
  "column": "4",
  "slicing": "[\"simple_compare = '{0} == other'\\n\", \"is_compare = '{0} is other'\\n\", \"nested_compare = '{0} == int and other()'\\n\", \"triple_compare = '{0} == some == other'\\n\", \"expression = '{0}'\\n\", \"assignment = 'some = {0}'\\n\", \"annotation = 'some: {0} = int'\\n\", 'try_finally = \"\"\"\\n', 'function_return = \"\"\"\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    expression,\\n', '    assignment,\\n', '    annotation,\\n', '    try_finally,\\n', '    function_return,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    simple_compare,\\n', '    is_compare,\\n', '    nested_compare,\\n', '    triple_compare,\\n', '    tree = parse_ast_tree(mode(code.format(call)))\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TypeCompareViolation])\\n']",
  "context": "ee = parse_ast_tree(mode(code.format(call)))\n\n    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Typ"
 },
 "1180": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_range_len.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitEnumerateViolation])\\n']",
  "context": "  \"\"\"Testing that ``range()`` can be used.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFunctionCallContextVisitor(def"
 },
 "1181": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallContextVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_range_len.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitEnumerateViolation])\\n']",
  "context": " be used.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1182": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_range_len.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitEnumerateViolation])\\n']",
  "context": "g that ``range(len(...))`` cannot be used.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFunctionCallContextVisitor(def"
 },
 "1183": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.functions.WrongFunctionCallContextVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_functions/test_call_context/test_range_len.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitEnumerateViolation])\\n']",
  "context": " be used.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongFunctionCallContextVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "1184": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_in.py",
  "lineno": "43",
  "column": "4",
  "slicing": "[\"eq_and = '{0} == some1 and {1} == some2'\\n\", \"noteq_or = '{0} != some1 or {1} != some2'\\n\", \"eq_or = '{0} == some1 or {1} == some2'\\n\", \"noteq_and = '{0} != some1 and {1} != some2'\\n\", '    eq_and,\\n', '    noteq_or,\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_and,\\n', '    noteq_or,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitInConditionViolation])\\n']",
  "context": "ons,\n):\n    \"\"\"Testing regular conditions.\"\"\"\n    tree = parse_ast_tree(code.format(first, second))\n\n    visitor = ImplicitBoolPatternsVisitor(default"
 },
 "1185": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.ImplicitBoolPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_in.py",
  "lineno": "45",
  "column": "4",
  "slicing": "[\"eq_and = '{0} == some1 and {1} == some2'\\n\", \"noteq_or = '{0} != some1 or {1} != some2'\\n\", \"eq_or = '{0} == some1 or {1} == some2'\\n\", \"noteq_and = '{0} != some1 and {1} != some2'\\n\", '    eq_and,\\n', '    noteq_or,\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_and,\\n', '    noteq_or,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitInConditionViolation])\\n']",
  "context": "= parse_ast_tree(code.format(first, second))\n\n    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1186": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_in.py",
  "lineno": "70",
  "column": "4",
  "slicing": "[\"eq_and = '{0} == some1 and {1} == some2'\\n\", \"noteq_or = '{0} != some1 or {1} != some2'\\n\", \"eq_or = '{0} == some1 or {1} == some2'\\n\", \"noteq_and = '{0} != some1 and {1} != some2'\\n\", '    eq_and,\\n', '    noteq_or,\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_and,\\n', '    noteq_or,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitInConditionViolation])\\n']",
  "context": "tions,\n):\n    \"\"\"Testing safe in patterns.\"\"\"\n    tree = parse_ast_tree(code.format(first, second))\n\n    visitor = ImplicitBoolPatternsVisitor(default"
 },
 "1187": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.ImplicitBoolPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_in.py",
  "lineno": "72",
  "column": "4",
  "slicing": "[\"eq_and = '{0} == some1 and {1} == some2'\\n\", \"noteq_or = '{0} != some1 or {1} != some2'\\n\", \"eq_or = '{0} == some1 or {1} == some2'\\n\", \"noteq_and = '{0} != some1 and {1} != some2'\\n\", '    eq_and,\\n', '    noteq_or,\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_and,\\n', '    noteq_or,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitInConditionViolation])\\n']",
  "context": "= parse_ast_tree(code.format(first, second))\n\n    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1188": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_in.py",
  "lineno": "97",
  "column": "4",
  "slicing": "[\"eq_and = '{0} == some1 and {1} == some2'\\n\", \"noteq_or = '{0} != some1 or {1} != some2'\\n\", \"eq_or = '{0} == some1 or {1} == some2'\\n\", \"noteq_and = '{0} != some1 and {1} != some2'\\n\", '    eq_and,\\n', '    noteq_or,\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_and,\\n', '    noteq_or,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitInConditionViolation])\\n']",
  "context": "tions,\n):\n    \"\"\"Testing safe in patterns.\"\"\"\n    tree = parse_ast_tree(code.format(first, second))\n\n    visitor = ImplicitBoolPatternsVisitor(default"
 },
 "1189": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.ImplicitBoolPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_in.py",
  "lineno": "99",
  "column": "4",
  "slicing": "[\"eq_and = '{0} == some1 and {1} == some2'\\n\", \"noteq_or = '{0} != some1 or {1} != some2'\\n\", \"eq_or = '{0} == some1 or {1} == some2'\\n\", \"noteq_and = '{0} != some1 and {1} != some2'\\n\", '    eq_and,\\n', '    noteq_or,\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_and,\\n', '    noteq_or,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    eq_or,\\n', '    noteq_and,\\n', '    tree = parse_ast_tree(code.format(first, second))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitInConditionViolation])\\n']",
  "context": "= parse_ast_tree(code.format(first, second))\n\n    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "1190": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "86",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": ":\n    \"\"\"Testing implicit complex compare.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = ImplicitBoolPatternsVisitor(default"
 },
 "1191": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.ImplicitBoolPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "88",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "1192": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "125",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": ":\n    \"\"\"Testing implicit complex compare.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = ImplicitBoolPatternsVisitor(default"
 },
 "1193": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.ImplicitBoolPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "127",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "1194": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "165",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": ":\n    \"\"\"Testing implicit complex compare.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = ImplicitBoolPatternsVisitor(default"
 },
 "1195": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.ImplicitBoolPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "167",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1196": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "205",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": ":\n    \"\"\"Testing implicit complex compare.\"\"\"\n    tree = parse_ast_tree(code.format(*comparators))\n\n    visitor = ImplicitBoolPatternsVisitor(default"
 },
 "1197": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.ImplicitBoolPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "207",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " = parse_ast_tree(code.format(*comparators))\n\n    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1198": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "227",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": ":\n    \"\"\"Testing implicit complex compare.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ImplicitBoolPatternsVisitor(default"
 },
 "1199": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.ImplicitBoolPatternsVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_implicit_complex_compare.py",
  "lineno": "229",
  "column": "4",
  "slicing": "[\"less_or_less = '{0} < {1} or {2} < {3}'\\n\", \"less_or_more = '{0} < {1} or {2} > {3}'\\n\", \"more_or_more = '{0} > {1} or {2} > {3}'\\n\", \"lesseq_or_less = '{0} <= {1} or {2} < {3}'\\n\", \"less_or_lesseq = '{0} < {1} or {2} <= {3}'\\n\", \"lesseq_or_lesseq = '{0} <= {1} or {2} <= {3}'\\n\", \"lesseq_or_more = '{0} <= {1} or {2} > {3}'\\n\", \"less_or_moreeq = '{0} < {1} or {2} >= {3}'\\n\", \"lesseq_or_moreeq = '{0} <= {1} or {2} >= {3}'\\n\", \"moreeq_or_more = '{0} >= {1} or {2} > {3}'\\n\", \"more_or_moreeq = '{0} > {1} or {2} >= {3}'\\n\", \"moreeq_or_moreeq = '{0} >= {1} or {2} >= {3}'\\n\", \"more_and_more = '{0} > {1} and {2} > {3}'  # a > b > c\\n\", \"less_and_less = '{0} < {1} and {2} < {3}'  # a < b < c\\n\", \"less_and_more = '{0} < {1} and {2} > {3}'  # a < b < c\\n\", \"more_and_less = '{0} > {1} and {2} < {3}'  # a > b > c\\n\", \"moreeq_and_more = '{0} >= {1} and {2} > {3}'\\n\", \"more_and_moreeq = '{0} > {1} and {2} >= {3}'\\n\", \"moreeq_and_moreeq = '{0} >= {1} and {2} >= {3}'\\n\", \"lesseq_and_less = '{0} <= {1} and {2} < {3}'\\n\", \"less_and_lesseq = '{0} < {1} and {2} <= {3}'\\n\", \"lesseq_and_lesseq = '{0} <= {1} and {2} <= {3}'\\n\", \"lesseq_and_more = '{0} <= {1} and {2} > {3}'\\n\", \"less_and_moreeq = '{0} < {1} and {2} >= {3}'\\n\", \"lesseq_and_moreeq = '{0} <= {1} and {2} >= {3}'\\n\", \"moreeq_and_less = '{0} >= {1} and {2} < {3}'\\n\", \"more_and_lesseq = '{0} > {1} and {2} <= {3}'\\n\", \"moreq_and_lesseq = '{0} >= {1} and {2} <= {3}'\\n\", '    more_and_more,\\n', '    less_and_less,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitComplexCompareViolation])\\n', '    more_and_more,\\n', '    moreeq_and_more,\\n', '    more_and_moreeq,\\n', '    moreeq_and_moreeq,\\n', '    less_and_less,\\n', '    lesseq_and_less,\\n', '    less_and_lesseq,\\n', '    lesseq_and_lesseq,\\n', '    less_and_more,\\n', '    lesseq_and_more,\\n', '    less_and_moreeq,\\n', '    lesseq_and_moreeq,\\n', '    more_and_less,\\n', '    moreeq_and_less,\\n', '    more_and_lesseq,\\n', '    moreq_and_lesseq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    less_or_less,\\n', '    less_or_more,\\n', '    more_or_more,\\n', '    lesseq_or_less,\\n', '    less_or_lesseq,\\n', '    lesseq_or_lesseq,\\n', '    lesseq_or_more,\\n', '    less_or_moreeq,\\n', '    lesseq_or_moreeq,\\n', '    moreeq_or_more,\\n', '    more_or_moreeq,\\n', '    moreeq_or_moreeq,\\n', '    tree = parse_ast_tree(code.format(*comparators))\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " compare.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = ImplicitBoolPatternsVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1200": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_unmerged_isinstance_calls.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnmergedIsinstanceCallsViolation])\\n']",
  "context": "  \"\"\"Testing that correct conditions work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_opt"
 },
 "1201": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.BooleanConditionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_unmerged_isinstance_calls.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnmergedIsinstanceCallsViolation])\\n']",
  "context": "ons work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1202": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_unmerged_isinstance_calls.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnmergedIsinstanceCallsViolation])\\n']",
  "context": "  \"\"\"Testing that correct conditions work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_opt"
 },
 "1203": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.BooleanConditionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_unmerged_isinstance_calls.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnmergedIsinstanceCallsViolation])\\n']",
  "context": "ons work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Unm"
 },
 "1204": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_negated_conditions.py",
  "lineno": "54",
  "column": "4",
  "slicing": "[\"if_expression = '1 if {0} else 2'\\n\", 'simple_conditions = \"\"\"\\n', 'complex_elif_conditions = \"\"\"\\n', 'complex_conditions = \"\"\"\\n', 'complex_elif_else_conditions = \"\"\"\\n', '    tree = parse_ast_tree(simple_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(complex_elif_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_expression,\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NegatedConditionsViolation])\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ions,\n):\n    \"\"\"Testing simple conditions.\"\"\"\n    tree = parse_ast_tree(simple_conditions.format(code))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1205": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_negated_conditions.py",
  "lineno": "56",
  "column": "4",
  "slicing": "[\"if_expression = '1 if {0} else 2'\\n\", 'simple_conditions = \"\"\"\\n', 'complex_elif_conditions = \"\"\"\\n', 'complex_conditions = \"\"\"\\n', 'complex_elif_else_conditions = \"\"\"\\n', '    tree = parse_ast_tree(simple_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(complex_elif_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_expression,\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NegatedConditionsViolation])\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "rse_ast_tree(simple_conditions.format(code))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1206": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_negated_conditions.py",
  "lineno": "78",
  "column": "4",
  "slicing": "[\"if_expression = '1 if {0} else 2'\\n\", 'simple_conditions = \"\"\"\\n', 'complex_elif_conditions = \"\"\"\\n', 'complex_conditions = \"\"\"\\n', 'complex_elif_else_conditions = \"\"\"\\n', '    tree = parse_ast_tree(simple_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(complex_elif_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_expression,\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NegatedConditionsViolation])\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "omplex conditions without else expression.\"\"\"\n    tree = parse_ast_tree(complex_elif_conditions.format(code))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1207": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_negated_conditions.py",
  "lineno": "80",
  "column": "4",
  "slicing": "[\"if_expression = '1 if {0} else 2'\\n\", 'simple_conditions = \"\"\"\\n', 'complex_elif_conditions = \"\"\"\\n', 'complex_conditions = \"\"\"\\n', 'complex_elif_else_conditions = \"\"\"\\n', '    tree = parse_ast_tree(simple_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(complex_elif_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_expression,\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NegatedConditionsViolation])\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t_tree(complex_elif_conditions.format(code))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1208": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_negated_conditions.py",
  "lineno": "104",
  "column": "4",
  "slicing": "[\"if_expression = '1 if {0} else 2'\\n\", 'simple_conditions = \"\"\"\\n', 'complex_elif_conditions = \"\"\"\\n', 'complex_conditions = \"\"\"\\n', 'complex_elif_else_conditions = \"\"\"\\n', '    tree = parse_ast_tree(simple_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(complex_elif_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_expression,\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NegatedConditionsViolation])\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " conditions with nagated ``if`` condition.\"\"\"\n    tree = parse_ast_tree(template.format(code))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1209": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_negated_conditions.py",
  "lineno": "106",
  "column": "4",
  "slicing": "[\"if_expression = '1 if {0} else 2'\\n\", 'simple_conditions = \"\"\"\\n', 'complex_elif_conditions = \"\"\"\\n', 'complex_conditions = \"\"\"\\n', 'complex_elif_else_conditions = \"\"\"\\n', '    tree = parse_ast_tree(simple_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(complex_elif_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_expression,\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NegatedConditionsViolation])\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(template.format(code))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Neg"
 },
 "1210": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_negated_conditions.py",
  "lineno": "132",
  "column": "4",
  "slicing": "[\"if_expression = '1 if {0} else 2'\\n\", 'simple_conditions = \"\"\"\\n', 'complex_elif_conditions = \"\"\"\\n', 'complex_conditions = \"\"\"\\n', 'complex_elif_else_conditions = \"\"\"\\n', '    tree = parse_ast_tree(simple_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(complex_elif_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_expression,\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NegatedConditionsViolation])\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ting correctly negated complex conditions.\"\"\"\n    tree = parse_ast_tree(template.format(code))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1211": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_negated_conditions.py",
  "lineno": "134",
  "column": "4",
  "slicing": "[\"if_expression = '1 if {0} else 2'\\n\", 'simple_conditions = \"\"\"\\n', 'complex_elif_conditions = \"\"\"\\n', 'complex_conditions = \"\"\"\\n', 'complex_elif_else_conditions = \"\"\"\\n', '    tree = parse_ast_tree(simple_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(complex_elif_conditions.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    if_expression,\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NegatedConditionsViolation])\\n', '    complex_conditions,\\n', '    complex_elif_else_conditions,\\n', '    tree = parse_ast_tree(template.format(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tree = parse_ast_tree(template.format(code))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1212": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_multiline_conditions.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['incorrect_conditions1 = \"\"\"if some and (\\n', 'incorrect_conditions2 = \"\"\"\\n', 'incorrect_conditions3 = \"\"\"if some and some_function(\\n', 'incorrect_conditions4 = \"\"\"\\n', 'incorrect_conditions5 = \"\"\"\\n', '    incorrect_conditions1,\\n', '    incorrect_conditions2,\\n', '    incorrect_conditions3,\\n', '    incorrect_conditions4,\\n', '    incorrect_conditions5,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineConditionsViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e,\n):\n    \"\"\"Testing multiline conditions.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = IfStatementVisitor(default_options, "
 },
 "1213": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_multiline_conditions.py",
  "lineno": "79",
  "column": "4",
  "slicing": "['incorrect_conditions1 = \"\"\"if some and (\\n', 'incorrect_conditions2 = \"\"\"\\n', 'incorrect_conditions3 = \"\"\"if some and some_function(\\n', 'incorrect_conditions4 = \"\"\"\\n', 'incorrect_conditions5 = \"\"\"\\n', '    incorrect_conditions1,\\n', '    incorrect_conditions2,\\n', '    incorrect_conditions3,\\n', '    incorrect_conditions4,\\n', '    incorrect_conditions5,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineConditionsViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ons.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n    assert_errors(visitor, [Mult"
 },
 "1214": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_multiline_conditions.py",
  "lineno": "98",
  "column": "4",
  "slicing": "['incorrect_conditions1 = \"\"\"if some and (\\n', 'incorrect_conditions2 = \"\"\"\\n', 'incorrect_conditions3 = \"\"\"if some and some_function(\\n', 'incorrect_conditions4 = \"\"\"\\n', 'incorrect_conditions5 = \"\"\"\\n', '    incorrect_conditions1,\\n', '    incorrect_conditions2,\\n', '    incorrect_conditions3,\\n', '    incorrect_conditions4,\\n', '    incorrect_conditions5,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineConditionsViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e,\n):\n    \"\"\"Testing multiline conditions.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = IfStatementVisitor(default_options, "
 },
 "1215": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_multiline_conditions.py",
  "lineno": "99",
  "column": "4",
  "slicing": "['incorrect_conditions1 = \"\"\"if some and (\\n', 'incorrect_conditions2 = \"\"\"\\n', 'incorrect_conditions3 = \"\"\"if some and some_function(\\n', 'incorrect_conditions4 = \"\"\"\\n', 'incorrect_conditions5 = \"\"\"\\n', '    incorrect_conditions1,\\n', '    incorrect_conditions2,\\n', '    incorrect_conditions3,\\n', '    incorrect_conditions4,\\n', '    incorrect_conditions5,\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MultilineConditionsViolation])\\n', '    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ons.\"\"\"\n    tree = parse_ast_tree(mode(code))\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n    assert_errors(visitor, [])\n"
 },
 "1216": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_useless_len_call.py",
  "lineno": "28",
  "column": "4",
  "slicing": "[\"correct_call1 = 'print(len([]))'\\n\", \"correct_call2 = 'assert len([]) == len([])'\\n\", \"correct_call3 = 'if sum(x): ...'\\n\", '    correct_call1,\\n', '    correct_call2,\\n', '    correct_call3,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLenCompareViolation])\\n']",
  "context": "):\n    \"\"\"Testing that correct code works.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1217": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_useless_len_call.py",
  "lineno": "30",
  "column": "4",
  "slicing": "[\"correct_call1 = 'print(len([]))'\\n\", \"correct_call2 = 'assert len([]) == len([])'\\n\", \"correct_call3 = 'if sum(x): ...'\\n\", '    correct_call1,\\n', '    correct_call2,\\n', '    correct_call3,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLenCompareViolation])\\n']",
  "context": "de works.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1218": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_useless_len_call.py",
  "lineno": "47",
  "column": "4",
  "slicing": "[\"correct_call1 = 'print(len([]))'\\n\", \"correct_call2 = 'assert len([]) == len([])'\\n\", \"correct_call3 = 'if sum(x): ...'\\n\", '    correct_call1,\\n', '    correct_call2,\\n', '    correct_call3,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLenCompareViolation])\\n']",
  "context": "ng that incorrect code raises a violation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1219": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_useless_len_call.py",
  "lineno": "49",
  "column": "4",
  "slicing": "[\"correct_call1 = 'print(len([]))'\\n\", \"correct_call2 = 'assert len([]) == len([])'\\n\", \"correct_call3 = 'if sum(x): ...'\\n\", '    correct_call1,\\n', '    correct_call2,\\n', '    correct_call3,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessLenCompareViolation])\\n']",
  "context": "iolation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "1220": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "early returning ifs can not be simplified.\"\"\"\n    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\n\n    visitor = IfStatementVisitor(\n        default"
 },
 "1221": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ple_early_returning_if.format(*comparators))\n\n    visitor = IfStatementVisitor(\n        default_options,\n        tree=tree,\n    )\n"
 },
 "1222": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "98",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "early returning ifs can not be simplified.\"\"\"\n    tree = parse_ast_tree(template.format(*comparators))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1223": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "100",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "arse_ast_tree(template.format(*comparators))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1224": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "117",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hese early returning ifs are simplifiable.\"\"\"\n    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\n\n    visitor = IfStatementVisitor(\n        default"
 },
 "1225": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "119",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ple_early_returning_if.format(*comparators))\n\n    visitor = IfStatementVisitor(\n        default_options,\n        tree=tree,\n    )\n"
 },
 "1226": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "139",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "implifiable, although the else is useless.\"\"\"\n    tree = parse_ast_tree(complex_else.format(*comparators))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1227": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "141",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(complex_else.format(*comparators))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "1228": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "158",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "Statements with elif are not simplifiable.\"\"\"\n    tree = parse_ast_tree(elif_statement.format(*comparators))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1229": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "160",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "st_tree(elif_statement.format(*comparators))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "1230": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "177",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " if and empty parent are not simplifiable.\"\"\"\n    tree = parse_ast_tree(only_if.format(*comparators))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1231": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_simplifiable_if_statements.py",
  "lineno": "179",
  "column": "4",
  "slicing": "['complex_else = \"\"\"\\n', 'simple_early_returning_if = \"\"\"\\n', 'complex_early_returning_if_inside = \"\"\"\\n', 'complex_early_returning_if_outside = \"\"\"\\n', 'elif_statement = \"\"\"\\n', 'only_if = \"\"\"\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    complex_early_returning_if_inside,\\n', '    complex_early_returning_if_outside,\\n', '    tree = parse_ast_tree(template.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(simple_early_returning_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(\\n', '        tree=tree,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SimplifiableReturningIfViolation])\\n', '    tree = parse_ast_tree(complex_else.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(elif_statement.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    tree = parse_ast_tree(only_if.format(*comparators))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "parse_ast_tree(only_if.format(*comparators))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1232": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_same_element.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n']",
  "context": "  \"\"\"Testing that correct conditions work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_opt"
 },
 "1233": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.BooleanConditionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_same_element.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n']",
  "context": "ons work.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1234": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_same_element.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n']",
  "context": "Testing that duplicates raise a violation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_opt"
 },
 "1235": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.BooleanConditionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_same_element.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n']",
  "context": "iolation.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sam"
 },
 "1236": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_same_element.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n']",
  "context": "ting that duplicates raise two violations.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_opt"
 },
 "1237": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.BooleanConditionVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_same_element.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = BooleanConditionVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameElementsInConditionViolation])\\n']",
  "context": "olations.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = BooleanConditionVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sam"
 },
 "1238": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that extra ``else`` blocks can be removed.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code, code)))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1239": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(mode(template.format(code, code)))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "1240": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that extra ``else`` blocks can be removed.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code, code)))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1241": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(mode(template.format(code, code)))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "1242": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "133",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " removed, plus the ``if`` is simplifiable.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code, code)))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1243": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "135",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(mode(template.format(code, code)))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1244": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "162",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that extra ``else`` blocks can be removed.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code, code)))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1245": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "164",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "_ast_tree(mode(template.format(code, code)))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "1246": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "184",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "that extra ``else`` blocks can be removed.\"\"\"\n    tree = parse_ast_tree(template.format(code, code))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1247": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "186",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " parse_ast_tree(template.format(code, code))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Use"
 },
 "1248": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "213",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t extra ``else`` blocks cannot be removed.\"\"\"\n    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1249": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_redundant_returning_else.py",
  "lineno": "215",
  "column": "4",
  "slicing": "['function_level_condition = \"\"\"\\n', 'for_loop_level_condition = \"\"\"\\n', 'while_loop_level_condition = \"\"\"\\n', 'module_level_condition = \"\"\"\\n', 'multiple_ifs1 = \"\"\"\\n', 'multiple_ifs2 = \"\"\"\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    tree = parse_ast_tree(mode(template.format(code, code)))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    module_level_condition,\\n', '    tree = parse_ast_tree(template.format(code, code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UselessReturningElseViolation])\\n', '    function_level_condition,\\n', '    for_loop_level_condition,\\n', '    while_loop_level_condition,\\n', '    module_level_condition,\\n', '    multiple_ifs1,\\n', '    multiple_ifs2,\\n', \"    tree = parse_ast_tree(mode(template.format(code, 'raise ValueError()')))\\n\", '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "emplate.format(code, 'raise ValueError()')))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1250": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_useful_else.py",
  "lineno": "158",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "t extra ``else`` blocks cannot be removed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = IfStatementVisitor(default_options,"
 },
 "1251": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.conditions.IfStatementVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_conditions/test_returning_else/test_useful_else.py",
  "lineno": "160",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(mode(code))\\n', '    visitor = IfStatementVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ed.\"\"\"\n    tree = parse_ast_tree(mode(code))\n\n    visitor = IfStatementVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1252": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_relative_imports.py",
  "lineno": "35",
  "column": "4",
  "slicing": "[\"same_level_relative_import = 'from . import some_thing'\\n\", \"same_level_relative_import_sibling = 'from .some_thing import MyClass'\\n\", \"parent_level_relative_import = 'from .. import some_thing'\\n\", \"parent_level_relative_import_sibling = 'from ..some_thing import MyClass'\\n\", \"grand_level_relative_import_sibling = 'from ...some_thing import MyClass'\\n\", '    same_level_relative_import,\\n', '    same_level_relative_import_sibling,\\n', '    parent_level_relative_import,\\n', '    parent_level_relative_import_sibling,\\n', '    grand_level_relative_import_sibling,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LocalFolderImportViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ve to local folder imports are restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1253": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_relative_imports.py",
  "lineno": "37",
  "column": "4",
  "slicing": "[\"same_level_relative_import = 'from . import some_thing'\\n\", \"same_level_relative_import_sibling = 'from .some_thing import MyClass'\\n\", \"parent_level_relative_import = 'from .. import some_thing'\\n\", \"parent_level_relative_import_sibling = 'from ..some_thing import MyClass'\\n\", \"grand_level_relative_import_sibling = 'from ...some_thing import MyClass'\\n\", '    same_level_relative_import,\\n', '    same_level_relative_import_sibling,\\n', '    parent_level_relative_import,\\n', '    parent_level_relative_import_sibling,\\n', '    grand_level_relative_import_sibling,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LocalFolderImportViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Loc"
 },
 "1254": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_relative_imports.py",
  "lineno": "50",
  "column": "4",
  "slicing": "[\"same_level_relative_import = 'from . import some_thing'\\n\", \"same_level_relative_import_sibling = 'from .some_thing import MyClass'\\n\", \"parent_level_relative_import = 'from .. import some_thing'\\n\", \"parent_level_relative_import_sibling = 'from ..some_thing import MyClass'\\n\", \"grand_level_relative_import_sibling = 'from ...some_thing import MyClass'\\n\", '    same_level_relative_import,\\n', '    same_level_relative_import_sibling,\\n', '    parent_level_relative_import,\\n', '    parent_level_relative_import_sibling,\\n', '    grand_level_relative_import_sibling,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LocalFolderImportViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "\"Testing that regular imports are allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1255": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_relative_imports.py",
  "lineno": "52",
  "column": "4",
  "slicing": "[\"same_level_relative_import = 'from . import some_thing'\\n\", \"same_level_relative_import_sibling = 'from .some_thing import MyClass'\\n\", \"parent_level_relative_import = 'from .. import some_thing'\\n\", \"parent_level_relative_import_sibling = 'from ..some_thing import MyClass'\\n\", \"grand_level_relative_import_sibling = 'from ...some_thing import MyClass'\\n\", '    same_level_relative_import,\\n', '    same_level_relative_import_sibling,\\n', '    parent_level_relative_import,\\n', '    parent_level_relative_import_sibling,\\n', '    grand_level_relative_import_sibling,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LocalFolderImportViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1256": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_protected_import.py",
  "lineno": "31",
  "column": "4",
  "slicing": "[\"import_public = 'import public'\\n\", \"import_protected = 'import _protected'\\n\", \"import_from_protected = 'from _protected import something'\\n\", \"import_from_protected_path = 'from path._protected import something'\\n\", \"import_from_public = 'from public import something'\\n\", \"import_from_public_path = 'from public.path import something'\\n\", '    import_public,\\n', '    import_from_public,\\n', '    import_from_public_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_protected,\\n', '    import_from_protected,\\n', '    import_from_protected_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleMemberViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\"]",
  "context": "\"Testing that correct imports are allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1257": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_protected_import.py",
  "lineno": "33",
  "column": "4",
  "slicing": "[\"import_public = 'import public'\\n\", \"import_protected = 'import _protected'\\n\", \"import_from_protected = 'from _protected import something'\\n\", \"import_from_protected_path = 'from path._protected import something'\\n\", \"import_from_public = 'from public import something'\\n\", \"import_from_public_path = 'from public.path import something'\\n\", '    import_public,\\n', '    import_from_public,\\n', '    import_from_public_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_protected,\\n', '    import_from_protected,\\n', '    import_from_protected_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleMemberViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\"]",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1258": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_protected_import.py",
  "lineno": "52",
  "column": "4",
  "slicing": "[\"import_public = 'import public'\\n\", \"import_protected = 'import _protected'\\n\", \"import_from_protected = 'from _protected import something'\\n\", \"import_from_protected_path = 'from path._protected import something'\\n\", \"import_from_public = 'from public import something'\\n\", \"import_from_public_path = 'from public.path import something'\\n\", '    import_public,\\n', '    import_from_public,\\n', '    import_from_public_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_protected,\\n', '    import_from_protected,\\n', '    import_from_protected_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleMemberViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\"]",
  "context": "rts from protected modules are restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1259": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_protected_import.py",
  "lineno": "54",
  "column": "4",
  "slicing": "[\"import_public = 'import public'\\n\", \"import_protected = 'import _protected'\\n\", \"import_from_protected = 'from _protected import something'\\n\", \"import_from_protected_path = 'from path._protected import something'\\n\", \"import_from_public = 'from public import something'\\n\", \"import_from_public_path = 'from public.path import something'\\n\", '    import_public,\\n', '    import_from_public,\\n', '    import_from_public_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_protected,\\n', '    import_from_protected,\\n', '    import_from_protected_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleMemberViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\"]",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Pro"
 },
 "1260": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_protected_import.py",
  "lineno": "73",
  "column": "4",
  "slicing": "[\"import_public = 'import public'\\n\", \"import_protected = 'import _protected'\\n\", \"import_from_protected = 'from _protected import something'\\n\", \"import_from_protected_path = 'from path._protected import something'\\n\", \"import_from_public = 'from public import something'\\n\", \"import_from_public_path = 'from public.path import something'\\n\", '    import_public,\\n', '    import_from_public,\\n', '    import_from_public_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_protected,\\n', '    import_from_protected,\\n', '    import_from_protected_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleMemberViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\"]",
  "context": "orting of protected objects is restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1261": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_protected_import.py",
  "lineno": "75",
  "column": "4",
  "slicing": "[\"import_public = 'import public'\\n\", \"import_protected = 'import _protected'\\n\", \"import_from_protected = 'from _protected import something'\\n\", \"import_from_protected_path = 'from path._protected import something'\\n\", \"import_from_public = 'from public import something'\\n\", \"import_from_public_path = 'from public.path import something'\\n\", '    import_public,\\n', '    import_from_public,\\n', '    import_from_public_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_protected,\\n', '    import_from_protected,\\n', '    import_from_protected_path,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\", '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ProtectedModuleMemberViolation])\\n', \"    assert_error_text(visitor, '_protected')\\n\"]",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Pro"
 },
 "1262": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "23",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "aliases are allowed.\"\"\"\n    same_alias = 'os'\n    tree = parse_ast_tree(code.format(same_alias))\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1263": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "25",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee = parse_ast_tree(code.format(same_alias))\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sam"
 },
 "1264": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "44",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ases are restricted.\"\"\"\n    same_alias = 'os'\n    tree = parse_ast_tree(code.format(same_alias))\n    custom_options = options(i_control_code=True)\n"
 },
 "1265": {
  "name": "custom_options",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "45",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(same_alias))\n    custom_options = options(i_control_code=True)\n\n    visitor = WrongImportVisitor(custom_options, "
 },
 "1266": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "47",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ustom_options = options(i_control_code=True)\n\n    visitor = WrongImportVisitor(custom_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Sam"
 },
 "1267": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "66",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ases are restricted.\"\"\"\n    same_alias = 'os'\n    tree = parse_ast_tree(code.format(same_alias))\n    custom_options = options(i_control_code=False)"
 },
 "1268": {
  "name": "custom_options",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "67",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(same_alias))\n    custom_options = options(i_control_code=False)\n\n    visitor = WrongImportVisitor(custom_options, "
 },
 "1269": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "69",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stom_options = options(i_control_code=False)\n\n    visitor = WrongImportVisitor(custom_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1270": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "92",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at imports with other aliases are allowed.\"\"\"\n    tree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1271": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_same_alias_import.py",
  "lineno": "94",
  "column": "4",
  "slicing": "[\"regular_import = 'import os as {0}'\\n\", \"from_import = 'from sys import os as {0}'\\n\", '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=True)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [SameAliasImportViolation])\\n', '    assert_error_text(visitor, same_alias)\\n', '    regular_import,\\n', '    from_import,\\n', \"    same_alias = 'os'\\n\", '    tree = parse_ast_tree(code.format(same_alias))\\n', '    custom_options = options(i_control_code=False)\\n', '    visitor = WrongImportVisitor(custom_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    regular_import,\\n', '    from_import,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1272": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_future_imports.py",
  "lineno": "32",
  "column": "4",
  "slicing": "[\"future_import = 'from __future__ import {0}'\\n\", \"future_import_alias = 'from __future__ import {0} as some_alias'\\n\", '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    tree = parse_ast_tree(\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation, FutureImportViolation])\\n', '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import), do_compile=False)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "esting that future imports are restricted.\"\"\"\n    tree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1273": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_future_imports.py",
  "lineno": "34",
  "column": "4",
  "slicing": "[\"future_import = 'from __future__ import {0}'\\n\", \"future_import_alias = 'from __future__ import {0} as some_alias'\\n\", '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    tree = parse_ast_tree(\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation, FutureImportViolation])\\n', '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import), do_compile=False)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Fut"
 },
 "1274": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_future_imports.py",
  "lineno": "47",
  "column": "4",
  "slicing": "[\"future_import = 'from __future__ import {0}'\\n\", \"future_import_alias = 'from __future__ import {0} as some_alias'\\n\", '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    tree = parse_ast_tree(\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation, FutureImportViolation])\\n', '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import), do_compile=False)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at multiple future imports are restricted.\"\"\"\n    tree = parse_ast_tree(\n        'from __future__ import print_function, un"
 },
 "1275": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_future_imports.py",
  "lineno": "51",
  "column": "4",
  "slicing": "[\"future_import = 'from __future__ import {0}'\\n\", \"future_import_alias = 'from __future__ import {0} as some_alias'\\n\", '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    tree = parse_ast_tree(\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation, FutureImportViolation])\\n', '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import), do_compile=False)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ort print_function, unicode_literals',\n    )\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Fut"
 },
 "1276": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_future_imports.py",
  "lineno": "66",
  "column": "4",
  "slicing": "[\"future_import = 'from __future__ import {0}'\\n\", \"future_import_alias = 'from __future__ import {0} as some_alias'\\n\", '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    tree = parse_ast_tree(\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation, FutureImportViolation])\\n', '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import), do_compile=False)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at some future imports are not restricted.\"\"\"\n    tree = parse_ast_tree(code.format(to_import), do_compile=False)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1277": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_future_imports.py",
  "lineno": "68",
  "column": "4",
  "slicing": "[\"future_import = 'from __future__ import {0}'\\n\", \"future_import_alias = 'from __future__ import {0} as some_alias'\\n\", '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    tree = parse_ast_tree(\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FutureImportViolation, FutureImportViolation])\\n', '    future_import,\\n', '    future_import_alias,\\n', '    tree = parse_ast_tree(code.format(to_import), do_compile=False)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ee(code.format(to_import), do_compile=False)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1278": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_nested_imports.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['nested_function_import = \"\"\"\\n', 'nested_function_from_import = \"\"\"\\n', 'nested_conditional_import = \"\"\"\\n', 'nested_method_import = \"\"\"\\n', 'nested_method_from_import = \"\"\"\\n', 'nested_try_import = \"\"\"\\n', '    nested_function_import,\\n', '    nested_function_from_import,\\n', '    nested_method_import,\\n', '    nested_method_from_import,\\n', '    nested_conditional_import,\\n', '    nested_try_import,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedImportViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "esting that nested imports are restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1279": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_nested_imports.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['nested_function_import = \"\"\"\\n', 'nested_function_from_import = \"\"\"\\n', 'nested_conditional_import = \"\"\"\\n', 'nested_method_import = \"\"\"\\n', 'nested_method_from_import = \"\"\"\\n', 'nested_try_import = \"\"\"\\n', '    nested_function_import,\\n', '    nested_function_from_import,\\n', '    nested_method_import,\\n', '    nested_method_from_import,\\n', '    nested_conditional_import,\\n', '    nested_try_import,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedImportViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Nes"
 },
 "1280": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_nested_imports.py",
  "lineno": "91",
  "column": "4",
  "slicing": "['nested_function_import = \"\"\"\\n', 'nested_function_from_import = \"\"\"\\n', 'nested_conditional_import = \"\"\"\\n', 'nested_method_import = \"\"\"\\n', 'nested_method_from_import = \"\"\"\\n', 'nested_try_import = \"\"\"\\n', '    nested_function_import,\\n', '    nested_function_from_import,\\n', '    nested_method_import,\\n', '    nested_method_from_import,\\n', '    nested_conditional_import,\\n', '    nested_try_import,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedImportViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " the TYPE_CHECKING check are allowed.\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1281": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_nested_imports.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['nested_function_import = \"\"\"\\n', 'nested_function_from_import = \"\"\"\\n', 'nested_conditional_import = \"\"\"\\n', 'nested_method_import = \"\"\"\\n', 'nested_method_from_import = \"\"\"\\n', 'nested_try_import = \"\"\"\\n', '    nested_function_import,\\n', '    nested_function_from_import,\\n', '    nested_method_import,\\n', '    nested_method_from_import,\\n', '    nested_conditional_import,\\n', '    nested_try_import,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NestedImportViolation])\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "wed.\n    \"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1282": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_dotted_raw_import.py",
  "lineno": "31",
  "column": "4",
  "slicing": "[\"regular_import = 'import {0}'\\n\", \"regular_import_with_alias = 'import {0} as alias'\\n\", '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DottedRawImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ng that dotted raw imports are restricted.\"\"\"\n    tree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1283": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_dotted_raw_import.py",
  "lineno": "33",
  "column": "4",
  "slicing": "[\"regular_import = 'import {0}'\\n\", \"regular_import_with_alias = 'import {0} as alias'\\n\", '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DottedRawImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Dot"
 },
 "1284": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_dotted_raw_import.py",
  "lineno": "56",
  "column": "4",
  "slicing": "[\"regular_import = 'import {0}'\\n\", \"regular_import_with_alias = 'import {0} as alias'\\n\", '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DottedRawImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "Testing that flat raw imports are allowed.\"\"\"\n    tree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1285": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_dotted_raw_import.py",
  "lineno": "58",
  "column": "4",
  "slicing": "[\"regular_import = 'import {0}'\\n\", \"regular_import_with_alias = 'import {0} as alias'\\n\", '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DottedRawImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1286": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_dotted_raw_import.py",
  "lineno": "81",
  "column": "4",
  "slicing": "[\"regular_import = 'import {0}'\\n\", \"regular_import_with_alias = 'import {0} as alias'\\n\", '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DottedRawImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ng that dotted `from` imports are allowed.\"\"\"\n    tree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1287": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_dotted_raw_import.py",
  "lineno": "83",
  "column": "4",
  "slicing": "[\"regular_import = 'import {0}'\\n\", \"regular_import_with_alias = 'import {0} as alias'\\n\", '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [DottedRawImportViolation])\\n', '    assert_error_text(visitor, to_import)\\n', '    regular_import,\\n', '    regular_import_with_alias,\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    tree = parse_ast_tree(code.format(to_import))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ree = parse_ast_tree(code.format(to_import))\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1288": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_imports_collision.py",
  "lineno": "110",
  "column": "4",
  "slicing": "[\"correct_single_import = 'import public'\\n\", \"correct_single_import_from = 'from utils import public'\\n\", 'correct_no_colliding_imports = \"\"\"\\n', 'correct_similar_imports = \"\"\"\\n', 'correct_no_colliding_imports_from = \"\"\"\\n', 'correct_import_with_alias = \"\"\"\\n', 'correct_import_from_with_alias = \"\"\"\\n', 'correct_multiple_imports_from = \"\"\"\\n', 'correct_imports_from = \"\"\"\\n', 'correct_import_name_module_part = \"\"\"\\n', 'correct_relative_import = \"\"\"\\n', '    correct_single_import,\\n', '    correct_single_import_from,\\n', '    correct_no_colliding_imports,\\n', '    correct_similar_imports,\\n', '    correct_no_colliding_imports_from,\\n', '    correct_import_with_alias,\\n', '    correct_import_from_with_alias,\\n', '    correct_multiple_imports_from,\\n', '    correct_imports_from,\\n', '    correct_import_name_module_part,\\n', '    correct_relative_import,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ignored_types=LocalFolderImportViolation)\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "ing that no colliding imports are allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1289": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_imports_collision.py",
  "lineno": "112",
  "column": "4",
  "slicing": "[\"correct_single_import = 'import public'\\n\", \"correct_single_import_from = 'from utils import public'\\n\", 'correct_no_colliding_imports = \"\"\"\\n', 'correct_similar_imports = \"\"\"\\n', 'correct_no_colliding_imports_from = \"\"\"\\n', 'correct_import_with_alias = \"\"\"\\n', 'correct_import_from_with_alias = \"\"\"\\n', 'correct_multiple_imports_from = \"\"\"\\n', 'correct_imports_from = \"\"\"\\n', 'correct_import_name_module_part = \"\"\"\\n', 'correct_relative_import = \"\"\"\\n', '    correct_single_import,\\n', '    correct_single_import_from,\\n', '    correct_no_colliding_imports,\\n', '    correct_similar_imports,\\n', '    correct_no_colliding_imports_from,\\n', '    correct_import_with_alias,\\n', '    correct_import_from_with_alias,\\n', '    correct_multiple_imports_from,\\n', '    correct_imports_from,\\n', '    correct_import_name_module_part,\\n', '    correct_relative_import,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ignored_types=LocalFolderImportViolation)\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": " allowed.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [], "
 },
 "1290": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_imports_collision.py",
  "lineno": "133",
  "column": "4",
  "slicing": "[\"correct_single_import = 'import public'\\n\", \"correct_single_import_from = 'from utils import public'\\n\", 'correct_no_colliding_imports = \"\"\"\\n', 'correct_similar_imports = \"\"\"\\n', 'correct_no_colliding_imports_from = \"\"\"\\n', 'correct_import_with_alias = \"\"\"\\n', 'correct_import_from_with_alias = \"\"\"\\n', 'correct_multiple_imports_from = \"\"\"\\n', 'correct_imports_from = \"\"\"\\n', 'correct_import_name_module_part = \"\"\"\\n', 'correct_relative_import = \"\"\"\\n', '    correct_single_import,\\n', '    correct_single_import_from,\\n', '    correct_no_colliding_imports,\\n', '    correct_similar_imports,\\n', '    correct_no_colliding_imports_from,\\n', '    correct_import_with_alias,\\n', '    correct_import_from_with_alias,\\n', '    correct_multiple_imports_from,\\n', '    correct_imports_from,\\n', '    correct_import_name_module_part,\\n', '    correct_relative_import,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ignored_types=LocalFolderImportViolation)\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "ing that colliding imports are restricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1291": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_imports_collision.py",
  "lineno": "135",
  "column": "4",
  "slicing": "[\"correct_single_import = 'import public'\\n\", \"correct_single_import_from = 'from utils import public'\\n\", 'correct_no_colliding_imports = \"\"\"\\n', 'correct_similar_imports = \"\"\"\\n', 'correct_no_colliding_imports_from = \"\"\"\\n', 'correct_import_with_alias = \"\"\"\\n', 'correct_import_from_with_alias = \"\"\"\\n', 'correct_multiple_imports_from = \"\"\"\\n', 'correct_imports_from = \"\"\"\\n', 'correct_import_name_module_part = \"\"\"\\n', 'correct_relative_import = \"\"\"\\n', '    correct_single_import,\\n', '    correct_single_import_from,\\n', '    correct_no_colliding_imports,\\n', '    correct_similar_imports,\\n', '    correct_no_colliding_imports_from,\\n', '    correct_import_with_alias,\\n', '    correct_import_from_with_alias,\\n', '    correct_multiple_imports_from,\\n', '    correct_imports_from,\\n', '    correct_import_name_module_part,\\n', '    correct_relative_import,\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [], ignored_types=LocalFolderImportViolation)\\n', '    tree = parse_ast_tree(code)\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '        visitor,\\n']",
  "context": "stricted.\"\"\"\n    tree = parse_ast_tree(code)\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "1292": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_vague_imports.py",
  "lineno": "34",
  "column": "4",
  "slicing": "[\"import_template = 'import {0}'\\n\", \"from_import_template = 'from mod import {0}'\\n\", \"alias_import_template1 = 'from mod import something as {0}'\\n\", \"alias_import_template2 = 'from mod import {0} as correct'\\n\", '    from_import_template,\\n', '    alias_import_template1,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [VagueImportViolation])\\n', '    import_template,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_template,\\n', '    from_import_template,\\n', '    alias_import_template1,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "Testing that vague imports are restricted.\"\"\"\n    tree = parse_ast_tree(code.format(import_name))\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1293": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_vague_imports.py",
  "lineno": "36",
  "column": "4",
  "slicing": "[\"import_template = 'import {0}'\\n\", \"from_import_template = 'from mod import {0}'\\n\", \"alias_import_template1 = 'from mod import something as {0}'\\n\", \"alias_import_template2 = 'from mod import {0} as correct'\\n\", '    from_import_template,\\n', '    alias_import_template1,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [VagueImportViolation])\\n', '    import_template,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_template,\\n', '    from_import_template,\\n', '    alias_import_template1,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e = parse_ast_tree(code.format(import_name))\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [Vag"
 },
 "1294": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_vague_imports.py",
  "lineno": "63",
  "column": "4",
  "slicing": "[\"import_template = 'import {0}'\\n\", \"from_import_template = 'from mod import {0}'\\n\", \"alias_import_template1 = 'from mod import something as {0}'\\n\", \"alias_import_template2 = 'from mod import {0} as correct'\\n\", '    from_import_template,\\n', '    alias_import_template1,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [VagueImportViolation])\\n', '    import_template,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_template,\\n', '    from_import_template,\\n', '    alias_import_template1,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "at some imports are not reported as vague.\"\"\"\n    tree = parse_ast_tree(code.format(import_name))\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1295": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_vague_imports.py",
  "lineno": "65",
  "column": "4",
  "slicing": "[\"import_template = 'import {0}'\\n\", \"from_import_template = 'from mod import {0}'\\n\", \"alias_import_template1 = 'from mod import something as {0}'\\n\", \"alias_import_template2 = 'from mod import {0} as correct'\\n\", '    from_import_template,\\n', '    alias_import_template1,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [VagueImportViolation])\\n', '    import_template,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_template,\\n', '    from_import_template,\\n', '    alias_import_template1,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e = parse_ast_tree(code.format(import_name))\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1296": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_vague_imports.py",
  "lineno": "93",
  "column": "4",
  "slicing": "[\"import_template = 'import {0}'\\n\", \"from_import_template = 'from mod import {0}'\\n\", \"alias_import_template1 = 'from mod import something as {0}'\\n\", \"alias_import_template2 = 'from mod import {0} as correct'\\n\", '    from_import_template,\\n', '    alias_import_template1,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [VagueImportViolation])\\n', '    import_template,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_template,\\n', '    from_import_template,\\n', '    alias_import_template1,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "   \"\"\"Testing that regular imports are ok.\"\"\"\n    tree = parse_ast_tree(code.format(import_name))\n\n    visitor = WrongImportVisitor(default_options,"
 },
 "1297": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.ast.imports.WrongImportVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_ast/test_imports/test_vague_imports.py",
  "lineno": "95",
  "column": "4",
  "slicing": "[\"import_template = 'import {0}'\\n\", \"from_import_template = 'from mod import {0}'\\n\", \"alias_import_template1 = 'from mod import something as {0}'\\n\", \"alias_import_template2 = 'from mod import {0} as correct'\\n\", '    from_import_template,\\n', '    alias_import_template1,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [VagueImportViolation])\\n', '    import_template,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    import_template,\\n', '    from_import_template,\\n', '    alias_import_template1,\\n', '    alias_import_template2,\\n', '    tree = parse_ast_tree(code.format(import_name))\\n', '    visitor = WrongImportVisitor(default_options, tree=tree)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "e = parse_ast_tree(code.format(import_name))\n\n    visitor = WrongImportVisitor(default_options, tree=tree)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1298": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_extra_indentation.py",
  "lineno": "128",
  "column": "4",
  "slicing": "['correct_function_with_docstring = \"\"\"\\n', 'correct_multiple_functions = \"\"\"\\n', 'correct_multiline_tuple = \"\"\"\\n', 'correct_multiline_dict = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', '    correct_function_with_docstring,\\n', '    correct_multiple_functions,\\n', '    correct_multiline_tuple,\\n', '    correct_multiline_dict,\\n', '    correct_multiline_call,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExtraIndentationViolation])\\n']",
  "context": "\"\"\"Ensures that correct indentation works.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = ExtraIndentationVisitor(default_opt"
 },
 "1299": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.statements.ExtraIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_extra_indentation.py",
  "lineno": "130",
  "column": "4",
  "slicing": "['correct_function_with_docstring = \"\"\"\\n', 'correct_multiple_functions = \"\"\"\\n', 'correct_multiline_tuple = \"\"\"\\n', 'correct_multiline_dict = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', '    correct_function_with_docstring,\\n', '    correct_multiple_functions,\\n', '    correct_multiline_tuple,\\n', '    correct_multiline_dict,\\n', '    correct_multiline_call,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExtraIndentationViolation])\\n']",
  "context": "rks.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1300": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_extra_indentation.py",
  "lineno": "151",
  "column": "4",
  "slicing": "['correct_function_with_docstring = \"\"\"\\n', 'correct_multiple_functions = \"\"\"\\n', 'correct_multiline_tuple = \"\"\"\\n', 'correct_multiline_dict = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', '    correct_function_with_docstring,\\n', '    correct_multiple_functions,\\n', '    correct_multiline_tuple,\\n', '    correct_multiline_dict,\\n', '    correct_multiline_call,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExtraIndentationViolation])\\n']",
  "context": "at incorrect indentation raises a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = ExtraIndentationVisitor(default_opt"
 },
 "1301": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.statements.ExtraIndentationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_extra_indentation.py",
  "lineno": "153",
  "column": "4",
  "slicing": "['correct_function_with_docstring = \"\"\"\\n', 'correct_multiple_functions = \"\"\"\\n', 'correct_multiline_tuple = \"\"\"\\n', 'correct_multiline_dict = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', '    correct_function_with_docstring,\\n', '    correct_multiple_functions,\\n', '    correct_multiline_tuple,\\n', '    correct_multiline_dict,\\n', '    correct_multiline_call,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ExtraIndentationViolation])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = ExtraIndentationVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Ext"
 },
 "1302": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_multiline_string.py",
  "lineno": "33",
  "column": "4",
  "slicing": "[\"correct_assignment = '''\\n\", \"correct_docstring = '''\\n\", '    correct_assignment,\\n', '    correct_docstring,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMultilineStringUseViolation])\\n']",
  "context": " that correct multiline strings uses work.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = MultilineStringVisitor(default_opti"
 },
 "1303": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.statements.MultilineStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_multiline_string.py",
  "lineno": "35",
  "column": "4",
  "slicing": "[\"correct_assignment = '''\\n\", \"correct_docstring = '''\\n\", '    correct_assignment,\\n', '    correct_docstring,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMultilineStringUseViolation])\\n']",
  "context": "ork.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1304": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_multiline_string.py",
  "lineno": "80",
  "column": "4",
  "slicing": "[\"correct_assignment = '''\\n\", \"correct_docstring = '''\\n\", '    correct_assignment,\\n', '    correct_docstring,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMultilineStringUseViolation])\\n']",
  "context": "ong multiline string uses raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = MultilineStringVisitor(default_opti"
 },
 "1305": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.statements.MultilineStringVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_multiline_string.py",
  "lineno": "82",
  "column": "4",
  "slicing": "[\"correct_assignment = '''\\n\", \"correct_docstring = '''\\n\", '    correct_assignment,\\n', '    correct_docstring,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMultilineStringUseViolation])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = MultilineStringVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1306": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_bracket_lines.py",
  "lineno": "145",
  "column": "4",
  "slicing": "[\"correct_simple_variable = 'xy = [[], [], ()]'\\n\", \"correct_simple_function_call = 'print([1, 2, 3], (1, 2))'\\n\", \"correct_annotated_variable = 'xy: Optional[int] = some()'\\n\", 'correct_function = \"\"\"\\n', 'correct_multiline_function = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', 'correct_multiline_list = \"\"\"\\n', 'correct_multiline_tuple = \"\"\"\\n', 'correct_multiline_dict = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', 'correct_enclosure_call = \"\"\"\\n', '    correct_simple_variable,\\n', '    correct_simple_function_call,\\n', '    correct_annotated_variable,\\n', '    correct_function,\\n', '    correct_multiline_function,\\n', '    correct_multiline_list,\\n', '    correct_multiline_tuple,\\n', '    correct_multiline_dict,\\n', '    correct_multiline_call,\\n', '    correct_enclosure_call,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongBracketPositionViolation])\\n']",
  "context": "   \"\"\"Ensures that correct brackets works.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = BracketLocationVisitor(default_opti"
 },
 "1307": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.statements.BracketLocationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_bracket_lines.py",
  "lineno": "147",
  "column": "4",
  "slicing": "[\"correct_simple_variable = 'xy = [[], [], ()]'\\n\", \"correct_simple_function_call = 'print([1, 2, 3], (1, 2))'\\n\", \"correct_annotated_variable = 'xy: Optional[int] = some()'\\n\", 'correct_function = \"\"\"\\n', 'correct_multiline_function = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', 'correct_multiline_list = \"\"\"\\n', 'correct_multiline_tuple = \"\"\"\\n', 'correct_multiline_dict = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', 'correct_enclosure_call = \"\"\"\\n', '    correct_simple_variable,\\n', '    correct_simple_function_call,\\n', '    correct_annotated_variable,\\n', '    correct_function,\\n', '    correct_multiline_function,\\n', '    correct_multiline_list,\\n', '    correct_multiline_tuple,\\n', '    correct_multiline_dict,\\n', '    correct_multiline_call,\\n', '    correct_enclosure_call,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongBracketPositionViolation])\\n']",
  "context": "rks.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1308": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_bracket_lines.py",
  "lineno": "168",
  "column": "4",
  "slicing": "[\"correct_simple_variable = 'xy = [[], [], ()]'\\n\", \"correct_simple_function_call = 'print([1, 2, 3], (1, 2))'\\n\", \"correct_annotated_variable = 'xy: Optional[int] = some()'\\n\", 'correct_function = \"\"\"\\n', 'correct_multiline_function = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', 'correct_multiline_list = \"\"\"\\n', 'correct_multiline_tuple = \"\"\"\\n', 'correct_multiline_dict = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', 'correct_enclosure_call = \"\"\"\\n', '    correct_simple_variable,\\n', '    correct_simple_function_call,\\n', '    correct_annotated_variable,\\n', '    correct_function,\\n', '    correct_multiline_function,\\n', '    correct_multiline_list,\\n', '    correct_multiline_tuple,\\n', '    correct_multiline_dict,\\n', '    correct_multiline_call,\\n', '    correct_enclosure_call,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongBracketPositionViolation])\\n']",
  "context": "s that incorrect brackets raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = BracketLocationVisitor(default_opti"
 },
 "1309": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.statements.BracketLocationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_bracket_lines.py",
  "lineno": "170",
  "column": "4",
  "slicing": "[\"correct_simple_variable = 'xy = [[], [], ()]'\\n\", \"correct_simple_function_call = 'print([1, 2, 3], (1, 2))'\\n\", \"correct_annotated_variable = 'xy: Optional[int] = some()'\\n\", 'correct_function = \"\"\"\\n', 'correct_multiline_function = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', 'correct_multiline_list = \"\"\"\\n', 'correct_multiline_tuple = \"\"\"\\n', 'correct_multiline_dict = \"\"\"\\n', 'correct_multiline_call = \"\"\"\\n', 'correct_enclosure_call = \"\"\"\\n', '    correct_simple_variable,\\n', '    correct_simple_function_call,\\n', '    correct_annotated_variable,\\n', '    correct_function,\\n', '    correct_multiline_function,\\n', '    correct_multiline_list,\\n', '    correct_multiline_tuple,\\n', '    correct_multiline_dict,\\n', '    correct_multiline_call,\\n', '    correct_enclosure_call,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongBracketPositionViolation])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1310": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_bracket_empty_line.py",
  "lineno": "149",
  "column": "4",
  "slicing": "[\"correct_empty_module = ''\\n\", \"correct_single_line = 'arr = []'\\n\", \"correct_single_line_items = 'arr = [1, 2, 3]'\\n\", \"correct_single_line_call = 'some(1, 2, 3)'\\n\", 'correct_method = \"\"\"\\n', 'correct_blank_line_in_middle_list = \"\"\"\\n', 'correct_blank_line_in_middle_dict = \"\"\"\\n', 'correct_blank_line_in_middle_parens = \"\"\"\\n', 'correct_comment_start_of_list = \"\"\"\\n', 'correct_comment_in_middle_of_list = \"\"\"\\n', '    correct_empty_module,\\n', '    correct_single_line,\\n', '    correct_single_line_call,\\n', '    correct_single_line_items,\\n', '    correct_method,\\n', '    correct_blank_line_in_middle_list,\\n', '    correct_blank_line_in_middle_dict,\\n', '    correct_blank_line_in_middle_parens,\\n', '    correct_comment_start_of_list,\\n', '    correct_comment_in_middle_of_list,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BracketBlankLineViolation])\\n']",
  "context": " \"\"\"Ensures that correct blank lines work.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = BracketLocationVisitor(default_opti"
 },
 "1311": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.statements.BracketLocationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_bracket_empty_line.py",
  "lineno": "151",
  "column": "4",
  "slicing": "[\"correct_empty_module = ''\\n\", \"correct_single_line = 'arr = []'\\n\", \"correct_single_line_items = 'arr = [1, 2, 3]'\\n\", \"correct_single_line_call = 'some(1, 2, 3)'\\n\", 'correct_method = \"\"\"\\n', 'correct_blank_line_in_middle_list = \"\"\"\\n', 'correct_blank_line_in_middle_dict = \"\"\"\\n', 'correct_blank_line_in_middle_parens = \"\"\"\\n', 'correct_comment_start_of_list = \"\"\"\\n', 'correct_comment_in_middle_of_list = \"\"\"\\n', '    correct_empty_module,\\n', '    correct_single_line,\\n', '    correct_single_line_call,\\n', '    correct_single_line_items,\\n', '    correct_method,\\n', '    correct_blank_line_in_middle_list,\\n', '    correct_blank_line_in_middle_dict,\\n', '    correct_blank_line_in_middle_parens,\\n', '    correct_comment_start_of_list,\\n', '    correct_comment_in_middle_of_list,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BracketBlankLineViolation])\\n']",
  "context": "ork.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1312": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_bracket_empty_line.py",
  "lineno": "173",
  "column": "4",
  "slicing": "[\"correct_empty_module = ''\\n\", \"correct_single_line = 'arr = []'\\n\", \"correct_single_line_items = 'arr = [1, 2, 3]'\\n\", \"correct_single_line_call = 'some(1, 2, 3)'\\n\", 'correct_method = \"\"\"\\n', 'correct_blank_line_in_middle_list = \"\"\"\\n', 'correct_blank_line_in_middle_dict = \"\"\"\\n', 'correct_blank_line_in_middle_parens = \"\"\"\\n', 'correct_comment_start_of_list = \"\"\"\\n', 'correct_comment_in_middle_of_list = \"\"\"\\n', '    correct_empty_module,\\n', '    correct_single_line,\\n', '    correct_single_line_call,\\n', '    correct_single_line_items,\\n', '    correct_method,\\n', '    correct_blank_line_in_middle_list,\\n', '    correct_blank_line_in_middle_dict,\\n', '    correct_blank_line_in_middle_parens,\\n', '    correct_comment_start_of_list,\\n', '    correct_comment_in_middle_of_list,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BracketBlankLineViolation])\\n']",
  "context": "hat incorrect blank lines raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = BracketLocationVisitor(default_opti"
 },
 "1313": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.statements.BracketLocationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_statements/test_bracket_empty_line.py",
  "lineno": "175",
  "column": "4",
  "slicing": "[\"correct_empty_module = ''\\n\", \"correct_single_line = 'arr = []'\\n\", \"correct_single_line_items = 'arr = [1, 2, 3]'\\n\", \"correct_single_line_call = 'some(1, 2, 3)'\\n\", 'correct_method = \"\"\"\\n', 'correct_blank_line_in_middle_list = \"\"\"\\n', 'correct_blank_line_in_middle_dict = \"\"\"\\n', 'correct_blank_line_in_middle_parens = \"\"\"\\n', 'correct_comment_start_of_list = \"\"\"\\n', 'correct_comment_in_middle_of_list = \"\"\"\\n', '    correct_empty_module,\\n', '    correct_single_line,\\n', '    correct_single_line_call,\\n', '    correct_single_line_items,\\n', '    correct_method,\\n', '    correct_blank_line_in_middle_list,\\n', '    correct_blank_line_in_middle_dict,\\n', '    correct_blank_line_in_middle_parens,\\n', '    correct_comment_start_of_list,\\n', '    correct_comment_in_middle_of_list,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BracketBlankLineViolation])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = BracketLocationVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Bra"
 },
 "1314": {
  "name": "template",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/conftest.py",
  "lineno": "27",
  "column": "16",
  "slicing": "['    def factory(template: str) -> str:\\n']",
  "context": "numbers without modifications.\"\"\"\n    def factory(template: str) -> str:\n        return template\n    return factory\n\n\n@pyte"
 },
 "1315": {
  "name": "template",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/conftest.py",
  "lineno": "35",
  "column": "16",
  "slicing": "['    def factory(template: str) -> str:\\n']",
  "context": "re to return negative numbers.\"\"\"\n    def factory(template: str) -> str:\n        return '-{0}'.format(template)\n    return "
 },
 "1316": {
  "name": "template",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/conftest.py",
  "lineno": "43",
  "column": "16",
  "slicing": "['    def factory(template: str) -> str:\\n']",
  "context": "e numbers with explicit ``+``.\"\"\"\n    def factory(template: str) -> str:\n        return '+{0}'.format(template)\n    return "
 },
 "1317": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_suffixes.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadNumberSuffixViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "h suffix not in lowercase raise a warning.\"\"\"\n    file_tokens = parse_tokens(\n        mode(primitives_usages.format(number_sign("
 },
 "1318": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_suffixes.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadNumberSuffixViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s_usages.format(number_sign(number))),\n    )\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Bad"
 },
 "1319": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_suffixes.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadNumberSuffixViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Ensures that correct numbers are fine.\"\"\"\n    file_tokens = parse_tokens(\n        mode(primitives_usages.format(number_sign("
 },
 "1320": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_suffixes.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadNumberSuffixViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s_usages.format(number_sign(number))),\n    )\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1321": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_positive_exponent.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositiveExponentViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "bers with positive exponent are incorrect.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1322": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_positive_exponent.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositiveExponentViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "kens(mode(primitives_usages.format(number)))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Pos"
 },
 "1323": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_positive_exponent.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositiveExponentViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "\"Ensures that correct exponent is allowed.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1324": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_positive_exponent.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositiveExponentViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "kens(mode(primitives_usages.format(number)))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1325": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_positive_exponent.py",
  "lineno": "94",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositiveExponentViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "bers with positive exponent are incorrect.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1326": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_positive_exponent.py",
  "lineno": "96",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PositiveExponentViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(number)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "kens(mode(primitives_usages.format(number)))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1327": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_complex_suffix.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadComplexNumberSuffixViolation])\\n', \"    assert_error_text(visitor, 'J')\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "h suffix not in lowercase raise a warning.\"\"\"\n    file_tokens = parse_tokens(\n        mode(primitives_usages.format(number_sign("
 },
 "1328": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_complex_suffix.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadComplexNumberSuffixViolation])\\n', \"    assert_error_text(visitor, 'J')\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s_usages.format(number_sign(number))),\n    )\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Bad"
 },
 "1329": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_complex_suffix.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadComplexNumberSuffixViolation])\\n', \"    assert_error_text(visitor, 'J')\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "h suffix not in lowercase raise a warning.\"\"\"\n    file_tokens = parse_tokens(\n        mode(primitives_usages.format(number_sign("
 },
 "1330": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_complex_suffix.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [BadComplexNumberSuffixViolation])\\n', \"    assert_error_text(visitor, 'J')\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s_usages.format(number_sign(number))),\n    )\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1331": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_meaningless_zeros.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NumberWithMeaninglessZeroViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "h suffix not in lowercase raise a warning.\"\"\"\n    file_tokens = parse_tokens(\n        mode(primitives_usages.format(number_sign("
 },
 "1332": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_meaningless_zeros.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NumberWithMeaninglessZeroViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s_usages.format(number_sign(number))),\n    )\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Num"
 },
 "1333": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_meaningless_zeros.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NumberWithMeaninglessZeroViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "Ensures that numbers raise two violations.\"\"\"\n    file_tokens = parse_tokens(\n        mode(primitives_usages.format(number_sign("
 },
 "1334": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_meaningless_zeros.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NumberWithMeaninglessZeroViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s_usages.format(number_sign(number))),\n    )\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1335": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_meaningless_zeros.py",
  "lineno": "105",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NumberWithMeaninglessZeroViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Ensures that correct numbers are fine.\"\"\"\n    file_tokens = parse_tokens(\n        mode(primitives_usages.format(number_sign("
 },
 "1336": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_meaningless_zeros.py",
  "lineno": "109",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [NumberWithMeaninglessZeroViolation])\\n', \"    assert_error_text(visitor, number.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s_usages.format(number_sign(number))),\n    )\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1337": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_float_zero.py",
  "lineno": "17",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens(mode(primitives_usages.format('0.0')))\\n\", '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatZeroViolation])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "es that float zeros (0.0) raise a warning.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format('0.0')))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1338": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_float_zero.py",
  "lineno": "19",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens(mode(primitives_usages.format('0.0')))\\n\", '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatZeroViolation])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "okens(mode(primitives_usages.format('0.0')))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Flo"
 },
 "1339": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_float_zero.py",
  "lineno": "40",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens(mode(primitives_usages.format('0.0')))\\n\", '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatZeroViolation])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "nd non-zero numbers don't raise a warning.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1340": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_number_float_zero.py",
  "lineno": "42",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens(mode(primitives_usages.format('0.0')))\\n\", '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [FloatZeroViolation])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1341": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_underscored_numbers.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnderscoredNumberViolation])\\n', \"    assert_error_text(visitor, primitive.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that underscored numbers raise a warning.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1342": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_underscored_numbers.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnderscoredNumberViolation])\\n', \"    assert_error_text(visitor, primitive.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Und"
 },
 "1343": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_underscored_numbers.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnderscoredNumberViolation])\\n', \"    assert_error_text(visitor, primitive.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Ensures that correct numbers are fine.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1344": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_underscored_numbers.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnderscoredNumberViolation])\\n', \"    assert_error_text(visitor, primitive.lstrip('-').lstrip('+'))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1345": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_partial_floats.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PartialFloatViolation])\\n', \"    assert_error_text(visitor, primitive.replace('-', ''))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "sures that partial floats raise a warning.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1346": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_partial_floats.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PartialFloatViolation])\\n', \"    assert_error_text(visitor, primitive.replace('-', ''))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "s(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Par"
 },
 "1347": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_partial_floats.py",
  "lineno": "54",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PartialFloatViolation])\\n', \"    assert_error_text(visitor, primitive.replace('-', ''))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "  \"\"\"Ensures that correct floats are fine.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1348": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_partial_floats.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PartialFloatViolation])\\n', \"    assert_error_text(visitor, primitive.replace('-', ''))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "s(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1349": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_partial_floats.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PartialFloatViolation])\\n', \"    assert_error_text(visitor, primitive.replace('-', ''))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "sures that partial floats raise a warning.\"\"\"\n    file_tokens = parse_tokens(\n        mode(primitives_usages.format(number_sign("
 },
 "1350": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_partial_floats.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PartialFloatViolation])\\n', \"    assert_error_text(visitor, primitive.replace('-', ''))\\n\", '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "sages.format(number_sign(primitive))),\n    )\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1351": {
  "name": "hex_number_templates",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_wrong_hex_case.py",
  "lineno": "11",
  "column": "0",
  "slicing": "['hex_number_templates = [\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", \"@pytest.mark.parametrize('number', hex_number_templates)\\n\"]",
  "context": "imitives import (\n    WrongNumberTokenVisitor,\n)\n\nhex_number_templates = [\n    '0x{0}',\n    '0xA{0}',\n    '0x{0}2',\n    '0xB{"
 },
 "1352": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_wrong_hex_case.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['hex_number_templates = [\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    real_number = number.format(hex_char)\\n', '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongHexNumberCaseViolation])\\n', '    assert_error_text(visitor, real_number)\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    file_tokens = parse_tokens(number_sign(number.format(hex_char)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", \"    real_number = number.format(hex_char).replace('x', 'X')\\n\", '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "\"\"\"\n    real_number = number.format(hex_char)\n    file_tokens = parse_tokens(number_sign(real_number))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1353": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_wrong_hex_case.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['hex_number_templates = [\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    real_number = number.format(hex_char)\\n', '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongHexNumberCaseViolation])\\n', '    assert_error_text(visitor, real_number)\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    file_tokens = parse_tokens(number_sign(number.format(hex_char)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", \"    real_number = number.format(hex_char).replace('x', 'X')\\n\", '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ens = parse_tokens(number_sign(real_number))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1354": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_wrong_hex_case.py",
  "lineno": "52",
  "column": "4",
  "slicing": "['hex_number_templates = [\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    real_number = number.format(hex_char)\\n', '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongHexNumberCaseViolation])\\n', '    assert_error_text(visitor, real_number)\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    file_tokens = parse_tokens(number_sign(number.format(hex_char)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", \"    real_number = number.format(hex_char).replace('x', 'X')\\n\", '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "th correct numbers do not raise a warning.\"\"\"\n    file_tokens = parse_tokens(number_sign(number.format(hex_char)))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1355": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_wrong_hex_case.py",
  "lineno": "54",
  "column": "4",
  "slicing": "['hex_number_templates = [\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    real_number = number.format(hex_char)\\n', '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongHexNumberCaseViolation])\\n', '    assert_error_text(visitor, real_number)\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    file_tokens = parse_tokens(number_sign(number.format(hex_char)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", \"    real_number = number.format(hex_char).replace('x', 'X')\\n\", '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "tokens(number_sign(number.format(hex_char)))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1356": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_wrong_hex_case.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['hex_number_templates = [\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    real_number = number.format(hex_char)\\n', '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongHexNumberCaseViolation])\\n', '    assert_error_text(visitor, real_number)\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    file_tokens = parse_tokens(number_sign(number.format(hex_char)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", \"    real_number = number.format(hex_char).replace('x', 'X')\\n\", '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "r = number.format(hex_char).replace('x', 'X')\n    file_tokens = parse_tokens(number_sign(real_number))\n\n    visitor = WrongNumberTokenVisitor(default_opt"
 },
 "1357": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongNumberTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_numbers/test_wrong_hex_case.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['hex_number_templates = [\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    real_number = number.format(hex_char)\\n', '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongHexNumberCaseViolation])\\n', '    assert_error_text(visitor, real_number)\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", '    file_tokens = parse_tokens(number_sign(number.format(hex_char)))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"@pytest.mark.parametrize('number', hex_number_templates)\\n\", \"    real_number = number.format(hex_char).replace('x', 'X')\\n\", '    file_tokens = parse_tokens(number_sign(real_number))\\n', '    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ens = parse_tokens(number_sign(real_number))\n\n    visitor = WrongNumberTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1358": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unnecessary_raw_strings.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(raw_strings)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(raw_strings)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RawStringNotNeededViolation])\\n']",
  "context": "es that correct usage of raw string works.\"\"\"\n    file_tokens = parse_tokens(raw_strings)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1359": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unnecessary_raw_strings.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(raw_strings)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(raw_strings)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RawStringNotNeededViolation])\\n']",
  "context": "\n    file_tokens = parse_tokens(raw_strings)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1360": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unnecessary_raw_strings.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(raw_strings)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(raw_strings)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RawStringNotNeededViolation])\\n']",
  "context": "f raw string is forbidden if no backslash.\"\"\"\n    file_tokens = parse_tokens(raw_strings)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1361": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unnecessary_raw_strings.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(raw_strings)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(raw_strings)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [RawStringNotNeededViolation])\\n']",
  "context": "\n    file_tokens = parse_tokens(raw_strings)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Raw"
 },
 "1362": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_prefix.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    assert_error_text(visitor, primitive)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(\\'U\"\"\\')))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "res that unicode prefixes raise a warning.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1363": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_prefix.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    assert_error_text(visitor, primitive)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(\\'U\"\"\\')))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "s(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Uni"
 },
 "1364": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_prefix.py",
  "lineno": "54",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    assert_error_text(visitor, primitive)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(\\'U\"\"\\')))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": " \"\"\"Ensures that correct strings are fine.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1365": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_prefix.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    assert_error_text(visitor, primitive)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(\\'U\"\"\\')))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "s(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1366": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_prefix.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    assert_error_text(visitor, primitive)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(\\'U\"\"\\')))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "case unicode string raises two violations.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format('U\"\"')))\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1367": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_prefix.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    assert_error_text(visitor, primitive)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(\\'U\"\"\\')))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "okens(mode(primitives_usages.format('U\"\"')))\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1368": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_escape.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnicodeEscapeViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "hat wrong unicode escape raises a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1369": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_escape.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnicodeEscapeViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1370": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_escape.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnicodeEscapeViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "t unicode escape does not raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1371": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_escape.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnicodeEscapeViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1372": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_escape.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnicodeEscapeViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "t unicode escape does not raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1373": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_escape.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnicodeEscapeViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Uni"
 },
 "1374": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_escape.py",
  "lineno": "91",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnicodeEscapeViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "t unicode escape does not raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1375": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_unicode_escape.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongUnicodeEscapeViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnicodeStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1376": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_modifier.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, modifier, multiple=True)\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "k.\"\"\"\n    string = primitive.format(modifier)\n    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1377": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_modifier.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, modifier, multiple=True)\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "kens(mode(primitives_usages.format(string)))\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "1378": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_modifier.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, modifier, multiple=True)\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "d.\"\"\"\n    string = primitive.format(modifier)\n    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1379": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_modifier.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, modifier, multiple=True)\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "kens(mode(primitives_usages.format(string)))\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "1380": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_modifier.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, modifier, multiple=True)\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "d.\"\"\"\n    string = primitive.format(modifier)\n    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1381": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_modifier.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    assert_error_text(visitor, modifier, multiple=True)\\n', '    string = primitive.format(modifier)\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(string)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "kens(mode(primitives_usages.format(string)))\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1382": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_raw_strings.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitRawStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "that implicit raw strings raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1383": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_raw_strings.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitRawStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "1384": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_raw_strings.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitRawStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "that implicit raw strings raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1385": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_raw_strings.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitRawStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1386": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_raw_strings.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitRawStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "plicit unicode raw string raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1387": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_raw_strings.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitRawStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1388": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_raw_strings.py",
  "lineno": "100",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitRawStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ercase unicode raw string raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1389": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_raw_strings.py",
  "lineno": "102",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitRawStringViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1390": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_string_concatenation.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '        default_options, file_tokens=file_tokens,\\n', '        default_options, file_tokens=file_tokens,\\n']",
  "context": "icit string concatenation raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringConcatenationVisitor(\n  "
 },
 "1391": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringConcatenationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_string_concatenation.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringConcatenationVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitStringConcatenationViolation])\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringConcatenationVisitor(\n        default_options, file_tokens=file_tokens,\n"
 },
 "1392": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_string_concatenation.py",
  "lineno": "95",
  "column": "4",
  "slicing": "['wrong_inline_string_concatenation = \"\"\"\\n', 'wrong_inline_string_concatenation_nextline = \"\"\"\\n', 'wrong_inline_string_concatenation_multiline = \"\"\"\\n', 'wrong_inline_string_concatenation_w_comment = \"\"\"\\n', '    wrong_inline_string_concatenation,\\n', '    wrong_inline_string_concatenation_nextline,\\n', '    wrong_inline_string_concatenation_multiline,\\n', '    wrong_inline_string_concatenation_w_comment,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringConcatenationVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitStringConcatenationViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " \"\"\"Ensures that correct strings are fine.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringConcatenationVisitor(\n  "
 },
 "1393": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringConcatenationVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_implicit_string_concatenation.py",
  "lineno": "97",
  "column": "4",
  "slicing": "['wrong_inline_string_concatenation = \"\"\"\\n', 'wrong_inline_string_concatenation_nextline = \"\"\"\\n', 'wrong_inline_string_concatenation_multiline = \"\"\"\\n', 'wrong_inline_string_concatenation_w_comment = \"\"\"\\n', '    wrong_inline_string_concatenation,\\n', '    wrong_inline_string_concatenation_nextline,\\n', '    wrong_inline_string_concatenation_multiline,\\n', '    wrong_inline_string_concatenation_w_comment,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringConcatenationVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitStringConcatenationViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongStringConcatenationVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ine.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongStringConcatenationVisitor(\n        default_options, file_tokens=file_tokens,\n"
 },
 "1394": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_multiline.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['multiline_single = \"\"\"\\'\\'\\'\\n', 'multiline_double = \\'\\'\\'\"\"\"\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    multiline_single,\\n', '    multiline_double,\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(code.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "incorrect multiline strings are forbidden.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1395": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_multiline.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['multiline_single = \"\"\"\\'\\'\\'\\n', 'multiline_double = \\'\\'\\'\"\"\"\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    multiline_single,\\n', '    multiline_double,\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(code.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(\n        visi"
 },
 "1396": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_multiline.py",
  "lineno": "102",
  "column": "4",
  "slicing": "['multiline_single = \"\"\"\\'\\'\\'\\n', 'multiline_double = \\'\\'\\'\"\"\"\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    multiline_single,\\n', '    multiline_double,\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(code.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat correct multiline strings are allowed.\"\"\"\n    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1397": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_multiline.py",
  "lineno": "104",
  "column": "4",
  "slicing": "['multiline_single = \"\"\"\\'\\'\\'\\n', 'multiline_double = \\'\\'\\'\"\"\"\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    multiline_single,\\n', '    multiline_double,\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(code.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s(mode(primitives_usages.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1398": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_multiline.py",
  "lineno": "134",
  "column": "4",
  "slicing": "['multiline_single = \"\"\"\\'\\'\\'\\n', 'multiline_double = \\'\\'\\'\"\"\"\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    multiline_single,\\n', '    multiline_double,\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(code.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "line and multiline docstrings are allowed.\"\"\"\n    file_tokens = parse_tokens(mode(code.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_opt"
 },
 "1399": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.primitives.WrongStringTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_primitives/test_string_tokens/test_string_multiline.py",
  "lineno": "136",
  "column": "4",
  "slicing": "['multiline_single = \"\"\"\\'\\'\\'\\n', 'multiline_double = \\'\\'\\'\"\"\"\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '        visitor,\\n', '    multiline_single,\\n', '    multiline_double,\\n', '    file_tokens = parse_tokens(mode(primitives_usages.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(mode(code.format(primitive)))\\n', '    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "= parse_tokens(mode(code.format(primitive)))\n\n    visitor = WrongStringTokenVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1400": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_consistency/test_string_newlines.py",
  "lineno": "46",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '        default_options, file_tokens=file_tokens,\\n', '        default_options, file_tokens=file_tokens,\\n']",
  "context": "ete string's line break raise a violation.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        d"
 },
 "1401": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.syntax.WrongKeywordTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_consistency/test_string_newlines.py",
  "lineno": "48",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineCompriseCarriageReturnViolation])\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ion.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        default_options, file_tokens=file_tokens,\n"
 },
 "1402": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_consistency/test_string_newlines.py",
  "lineno": "70",
  "column": "4",
  "slicing": "[\"wrong_newline_single = 'print(1)\\\\r\\\\nprint(2)'\\n\", \"wrong_newline_sequenced1 = 'print(1)\\\\nprint(2)\\\\r\\\\n'\\n\", \"wrong_newline_sequenced2 = 'print(1)\\\\r\\\\nprint(2)\\\\n'\\n\", \"wrong_newline_sequenced3 = 'print(1,\\\\r\\\\n    2)'\\n\", 'wrong_newline_in_multiline = \"\"\"print(2)\\\\r\\n', '    wrong_newline_single,\\n', '    wrong_newline_sequenced1,\\n', '    wrong_newline_sequenced2,\\n', '    wrong_newline_sequenced3,\\n', '    wrong_newline_in_multiline,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineCompriseCarriageReturnViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " that proper string's line break are fine.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        d"
 },
 "1403": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.syntax.WrongKeywordTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_consistency/test_string_newlines.py",
  "lineno": "72",
  "column": "4",
  "slicing": "[\"wrong_newline_single = 'print(1)\\\\r\\\\nprint(2)'\\n\", \"wrong_newline_sequenced1 = 'print(1)\\\\nprint(2)\\\\r\\\\n'\\n\", \"wrong_newline_sequenced2 = 'print(1)\\\\r\\\\nprint(2)\\\\n'\\n\", \"wrong_newline_sequenced3 = 'print(1,\\\\r\\\\n    2)'\\n\", 'wrong_newline_in_multiline = \"\"\"print(2)\\\\r\\n', '    wrong_newline_single,\\n', '    wrong_newline_sequenced1,\\n', '    wrong_newline_sequenced2,\\n', '    wrong_newline_sequenced3,\\n', '    wrong_newline_in_multiline,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineCompriseCarriageReturnViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ine.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        default_options, file_tokens=file_tokens,\n"
 },
 "1404": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_keywords/test_keywords_spaces.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '        default_options, file_tokens=file_tokens,\\n', '        default_options, file_tokens=file_tokens,\\n']",
  "context": "arens right after keyword raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        d"
 },
 "1405": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.syntax.WrongKeywordTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_keywords/test_keywords_spaces.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MissingSpaceBetweenKeywordAndParenViolation])\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        default_options, file_tokens=file_tokens,\n"
 },
 "1406": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_keywords/test_keywords_spaces.py",
  "lineno": "102",
  "column": "4",
  "slicing": "['multiline_error_function = \"\"\"\\n', 'multiline_error_statement = \"\"\"\\n', '    multiline_error_function,\\n', '    multiline_error_statement,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MissingSpaceBetweenKeywordAndParenViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": " there's no violation if space in between.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        d"
 },
 "1407": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.syntax.WrongKeywordTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_keywords/test_keywords_spaces.py",
  "lineno": "104",
  "column": "4",
  "slicing": "['multiline_error_function = \"\"\"\\n', 'multiline_error_statement = \"\"\"\\n', '    multiline_error_function,\\n', '    multiline_error_statement,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [MissingSpaceBetweenKeywordAndParenViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "een.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        default_options, file_tokens=file_tokens,\n"
 },
 "1408": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_keywords/test_starts_with_dot.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '        default_options, file_tokens=file_tokens,\\n', '        default_options, file_tokens=file_tokens,\\n']",
  "context": "t lines cannot be started with ``.`` char.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        d"
 },
 "1409": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.syntax.WrongKeywordTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_keywords/test_starts_with_dot.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineStartsWithDotViolation])\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "har.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        default_options, file_tokens=file_tokens,\n"
 },
 "1410": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_keywords/test_starts_with_dot.py",
  "lineno": "77",
  "column": "4",
  "slicing": "['wrong_dot_start1 = \"\"\"\\n', 'wrong_dot_start2 = \"\"\"\\n', '    wrong_dot_start1,\\n', '    wrong_dot_start2,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineStartsWithDotViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "hat lines can be started with other chars.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        d"
 },
 "1411": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.syntax.WrongKeywordTokenVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_keywords/test_starts_with_dot.py",
  "lineno": "79",
  "column": "4",
  "slicing": "['wrong_dot_start1 = \"\"\"\\n', 'wrong_dot_start2 = \"\"\"\\n', '    wrong_dot_start1,\\n', '    wrong_dot_start2,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [LineStartsWithDotViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongKeywordTokenVisitor(\\n', '        default_options, file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ars.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongKeywordTokenVisitor(\n        default_options, file_tokens=file_tokens,\n"
 },
 "1412": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_conditions/test_implicit_elif.py",
  "lineno": "111",
  "column": "4",
  "slicing": "['elif_cases = \"\"\"\\n', 'if_expression_in_else = \"\"\"\\n', 'not_direct_parent = \"\"\"\\n', 'correct_else_if = \"\"\"\\n', 'implicit_elif = \"\"\"\\n', 'implicit_elif_nested_if = \"\"\"\\n', '    elif_cases,\\n', '    if_expression_in_else,\\n', '    not_direct_parent,\\n', '    correct_else_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    implicit_elif,\\n', '    implicit_elif_nested_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitElifViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ons,\n):\n    \"\"\"Testing regular conditions.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = IfElseVisitor(default_options, file"
 },
 "1413": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.conditions.IfElseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_conditions/test_implicit_elif.py",
  "lineno": "113",
  "column": "4",
  "slicing": "['elif_cases = \"\"\"\\n', 'if_expression_in_else = \"\"\"\\n', 'not_direct_parent = \"\"\"\\n', 'correct_else_if = \"\"\"\\n', 'implicit_elif = \"\"\"\\n', 'implicit_elif_nested_if = \"\"\"\\n', '    elif_cases,\\n', '    if_expression_in_else,\\n', '    not_direct_parent,\\n', '    correct_else_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    implicit_elif,\\n', '    implicit_elif_nested_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitElifViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ons.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1414": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_conditions/test_implicit_elif.py",
  "lineno": "130",
  "column": "4",
  "slicing": "['elif_cases = \"\"\"\\n', 'if_expression_in_else = \"\"\"\\n', 'not_direct_parent = \"\"\"\\n', 'correct_else_if = \"\"\"\\n', 'implicit_elif = \"\"\"\\n', 'implicit_elif_nested_if = \"\"\"\\n', '    elif_cases,\\n', '    if_expression_in_else,\\n', '    not_direct_parent,\\n', '    correct_else_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    implicit_elif,\\n', '    implicit_elif_nested_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitElifViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "    \"\"\"Testing implicit `elif` conditions.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = IfElseVisitor(default_options, file"
 },
 "1415": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.conditions.IfElseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_conditions/test_implicit_elif.py",
  "lineno": "132",
  "column": "4",
  "slicing": "['elif_cases = \"\"\"\\n', 'if_expression_in_else = \"\"\"\\n', 'not_direct_parent = \"\"\"\\n', 'correct_else_if = \"\"\"\\n', 'implicit_elif = \"\"\"\\n', 'implicit_elif_nested_if = \"\"\"\\n', '    elif_cases,\\n', '    if_expression_in_else,\\n', '    not_direct_parent,\\n', '    correct_else_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    implicit_elif,\\n', '    implicit_elif_nested_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitElifViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ons.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Imp"
 },
 "1416": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_conditions/test_implicit_elif.py",
  "lineno": "151",
  "column": "4",
  "slicing": "['elif_cases = \"\"\"\\n', 'if_expression_in_else = \"\"\"\\n', 'not_direct_parent = \"\"\"\\n', 'correct_else_if = \"\"\"\\n', 'implicit_elif = \"\"\"\\n', 'implicit_elif_nested_if = \"\"\"\\n', '    elif_cases,\\n', '    if_expression_in_else,\\n', '    not_direct_parent,\\n', '    correct_else_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    implicit_elif,\\n', '    implicit_elif_nested_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitElifViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ons,\n):\n    \"\"\"Testing regular conditions.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = IfElseVisitor(default_options, file"
 },
 "1417": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.conditions.IfElseVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_conditions/test_implicit_elif.py",
  "lineno": "153",
  "column": "4",
  "slicing": "['elif_cases = \"\"\"\\n', 'if_expression_in_else = \"\"\"\\n', 'not_direct_parent = \"\"\"\\n', 'correct_else_if = \"\"\"\\n', 'implicit_elif = \"\"\"\\n', 'implicit_elif_nested_if = \"\"\"\\n', '    elif_cases,\\n', '    if_expression_in_else,\\n', '    not_direct_parent,\\n', '    correct_else_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    implicit_elif,\\n', '    implicit_elif_nested_if,\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ImplicitElifViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ons.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = IfElseVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1418": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_forbidden_noqa.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ForbiddenInlineIgnoreViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "th forbidden violations raise a violation.\"\"\"\n    file_tokens = parse_tokens(code)\n    options = options(forbidden_inline_ignore=forb"
 },
 "1419": {
  "name": "options",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_forbidden_noqa.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ForbiddenInlineIgnoreViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "tion.\"\"\"\n    file_tokens = parse_tokens(code)\n    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\n    visitor = NoqaVisitor(options, file_tokens=fil"
 },
 "1420": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.NoqaVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_forbidden_noqa.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ForbiddenInlineIgnoreViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "bidden_inline_ignore=forbidden_inline_ignore)\n    visitor = NoqaVisitor(options, file_tokens=file_tokens)\n    visitor.run()\n    assert_errors(visitor, [Forb"
 },
 "1421": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_forbidden_noqa.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ForbiddenInlineIgnoreViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "oper noqa comments do not rise violations.\"\"\"\n    file_tokens = parse_tokens(code)\n    options = options(forbidden_inline_ignore=forb"
 },
 "1422": {
  "name": "options",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_forbidden_noqa.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ForbiddenInlineIgnoreViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "ions.\"\"\"\n    file_tokens = parse_tokens(code)\n    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\n    visitor = NoqaVisitor(options, file_tokens=fil"
 },
 "1423": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.NoqaVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_forbidden_noqa.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ForbiddenInlineIgnoreViolation])\\n', '    file_tokens = parse_tokens(code)\\n', '    options = options(forbidden_inline_ignore=forbidden_inline_ignore)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "bidden_inline_ignore=forbidden_inline_ignore)\n    visitor = NoqaVisitor(options, file_tokens=file_tokens)\n    visitor.run()\n    assert_errors(visitor, [])\n"
 },
 "1424": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_no_cover_comment.py",
  "lineno": "26",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (5 + 1))\\n\", '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoCoverCommentViolation])\\n', \"    assert_error_text(visitor, '6', MAX_NO_COVER_COMMENTS)\\n\"]",
  "context": " that `no cover` overuse raises a warning.\"\"\"\n    file_tokens = parse_tokens('{0}\\n'.format(code) * (5 + 1))\n\n    visitor = WrongCommentVisitor(default_options"
 },
 "1425": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.WrongCommentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_no_cover_comment.py",
  "lineno": "28",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (5 + 1))\\n\", '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoCoverCommentViolation])\\n', \"    assert_error_text(visitor, '6', MAX_NO_COVER_COMMENTS)\\n\"]",
  "context": "parse_tokens('{0}\\n'.format(code) * (5 + 1))\n\n    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Ove"
 },
 "1426": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_count.py",
  "lineno": "25",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (10 + 1))\\n\", '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', '    file_tokens = parse_tokens(\\n', '    options = options(max_noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', \"    file_tokens = parse_tokens('wallet = 10  # noqa: WPS002, WPS114')\\n\", '    options = options(max_noqa_comments=0)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n']",
  "context": "ures that `noqa` overuse raises a warning.\"\"\"\n    file_tokens = parse_tokens('{0}\\n'.format(code) * (10 + 1))\n\n    visitor = NoqaVisitor(default_options, file_t"
 },
 "1427": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.NoqaVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_count.py",
  "lineno": "27",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (10 + 1))\\n\", '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', '    file_tokens = parse_tokens(\\n', '    options = options(max_noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', \"    file_tokens = parse_tokens('wallet = 10  # noqa: WPS002, WPS114')\\n\", '    options = options(max_noqa_comments=0)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n']",
  "context": "arse_tokens('{0}\\n'.format(code) * (10 + 1))\n\n    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Ove"
 },
 "1428": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_count.py",
  "lineno": "39",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (10 + 1))\\n\", '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', '    file_tokens = parse_tokens(\\n', '    options = options(max_noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', \"    file_tokens = parse_tokens('wallet = 10  # noqa: WPS002, WPS114')\\n\", '    options = options(max_noqa_comments=0)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n']",
  "context": "oqa` overuse can be configured by options.\"\"\"\n    file_tokens = parse_tokens(\n        'wallet = 10  # noqa: WPS002, WPS114\\n' * "
 },
 "1429": {
  "name": "options",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_count.py",
  "lineno": "43",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (10 + 1))\\n\", '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', '    file_tokens = parse_tokens(\\n', '    options = options(max_noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', \"    file_tokens = parse_tokens('wallet = 10  # noqa: WPS002, WPS114')\\n\", '    options = options(max_noqa_comments=0)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n']",
  "context": "PS114\\n' * defaults.MAX_NOQA_COMMENTS,\n    )\n\n    options = options(max_noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\n    visitor = NoqaVisitor(options, file_tokens=fil"
 },
 "1430": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.NoqaVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_count.py",
  "lineno": "44",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (10 + 1))\\n\", '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', '    file_tokens = parse_tokens(\\n', '    options = options(max_noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', \"    file_tokens = parse_tokens('wallet = 10  # noqa: WPS002, WPS114')\\n\", '    options = options(max_noqa_comments=0)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n']",
  "context": "noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\n    visitor = NoqaVisitor(options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Ove"
 },
 "1431": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_count.py",
  "lineno": "56",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (10 + 1))\\n\", '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', '    file_tokens = parse_tokens(\\n', '    options = options(max_noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', \"    file_tokens = parse_tokens('wallet = 10  # noqa: WPS002, WPS114')\\n\", '    options = options(max_noqa_comments=0)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n']",
  "context": "qa` comments can be turned off completely.\"\"\"\n    file_tokens = parse_tokens('wallet = 10  # noqa: WPS002, WPS114')\n\n    options = options(max_noqa_comments=0)\n    vi"
 },
 "1432": {
  "name": "options",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_count.py",
  "lineno": "58",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (10 + 1))\\n\", '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', '    file_tokens = parse_tokens(\\n', '    options = options(max_noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', \"    file_tokens = parse_tokens('wallet = 10  # noqa: WPS002, WPS114')\\n\", '    options = options(max_noqa_comments=0)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n']",
  "context": "okens('wallet = 10  # noqa: WPS002, WPS114')\n\n    options = options(max_noqa_comments=0)\n    visitor = NoqaVisitor(options, file_tokens=fil"
 },
 "1433": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.NoqaVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_count.py",
  "lineno": "59",
  "column": "4",
  "slicing": "[\"    file_tokens = parse_tokens('{0}\\\\n'.format(code) * (10 + 1))\\n\", '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', '    file_tokens = parse_tokens(\\n', '    options = options(max_noqa_comments=defaults.MAX_NOQA_COMMENTS - 1)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n', \"    file_tokens = parse_tokens('wallet = 10  # noqa: WPS002, WPS114')\\n\", '    options = options(max_noqa_comments=0)\\n', '    visitor = NoqaVisitor(options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [OveruseOfNoqaCommentViolation])\\n']",
  "context": ")\n\n    options = options(max_noqa_comments=0)\n    visitor = NoqaVisitor(options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Ove"
 },
 "1434": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_comment.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMagicCommentViolation])\\n']",
  "context": "t correct comments do not raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = NoqaVisitor(default_options, file_t"
 },
 "1435": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.NoqaVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_comment.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMagicCommentViolation])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1436": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_comment.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMagicCommentViolation])\\n']",
  "context": "incorrect `noqa` comments raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = NoqaVisitor(default_options, file_t"
 },
 "1437": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.NoqaVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_noqa_comment.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMagicCommentViolation])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = NoqaVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1438": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_wrong_doc_comment.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['constant_doc = \"\"\"\\n', 'attribute_doc = \"\"\"\\n', '    constant_doc,\\n', '    attribute_doc,\\n', '    file_tokens = parse_tokens(code.format(comment))\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    constant_doc,\\n', '    attribute_doc,\\n', '    file_tokens = parse_tokens(code.format(comment))\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongDocCommentViolation])\\n']",
  "context": "t correct comments do not raise a warning.\"\"\"\n    file_tokens = parse_tokens(code.format(comment))\n\n    visitor = WrongCommentVisitor(default_options"
 },
 "1439": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.WrongCommentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_wrong_doc_comment.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['constant_doc = \"\"\"\\n', 'attribute_doc = \"\"\"\\n', '    constant_doc,\\n', '    attribute_doc,\\n', '    file_tokens = parse_tokens(code.format(comment))\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    constant_doc,\\n', '    attribute_doc,\\n', '    file_tokens = parse_tokens(code.format(comment))\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongDocCommentViolation])\\n']",
  "context": "_tokens = parse_tokens(code.format(comment))\n\n    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1440": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_wrong_doc_comment.py",
  "lineno": "63",
  "column": "4",
  "slicing": "['constant_doc = \"\"\"\\n', 'attribute_doc = \"\"\"\\n', '    constant_doc,\\n', '    attribute_doc,\\n', '    file_tokens = parse_tokens(code.format(comment))\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    constant_doc,\\n', '    attribute_doc,\\n', '    file_tokens = parse_tokens(code.format(comment))\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongDocCommentViolation])\\n']",
  "context": "at incorrect doc comments raise a warning.\"\"\"\n    file_tokens = parse_tokens(code.format(comment))\n\n    visitor = WrongCommentVisitor(default_options"
 },
 "1441": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.WrongCommentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_wrong_doc_comment.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['constant_doc = \"\"\"\\n', 'attribute_doc = \"\"\"\\n', '    constant_doc,\\n', '    attribute_doc,\\n', '    file_tokens = parse_tokens(code.format(comment))\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    constant_doc,\\n', '    attribute_doc,\\n', '    file_tokens = parse_tokens(code.format(comment))\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongDocCommentViolation])\\n']",
  "context": "_tokens = parse_tokens(code.format(comment))\n\n    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1442": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_typed_ast.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMagicCommentViolation])\\n']",
  "context": "t correct comments do not raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongCommentVisitor(default_options"
 },
 "1443": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.WrongCommentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_typed_ast.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMagicCommentViolation])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1444": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_typed_ast.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMagicCommentViolation])\\n']",
  "context": "incorrect `type` comments raise a warning.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongCommentVisitor(default_options"
 },
 "1445": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.WrongCommentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_typed_ast.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    file_tokens = parse_tokens(code)\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    file_tokens = parse_tokens(code)\\n', '    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongMagicCommentViolation])\\n']",
  "context": "ing.\"\"\"\n    file_tokens = parse_tokens(code)\n\n    visitor = WrongCommentVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1446": {
  "name": "filename",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/conftest.py",
  "lineno": "14",
  "column": "8",
  "slicing": "['        filename: str,\\n']",
  "context": " non executable file.\"\"\"\n    def factory(\n        filename: str,\n        file_content: str,\n        is_executable: "
 },
 "1447": {
  "name": "file_content",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/conftest.py",
  "lineno": "15",
  "column": "8",
  "slicing": "['        file_content: str,\\n']",
  "context": "\"\n    def factory(\n        filename: str,\n        file_content: str,\n        is_executable: bool,\n    ) -> str:\n       "
 },
 "1448": {
  "name": "is_executable",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/conftest.py",
  "lineno": "16",
  "column": "8",
  "slicing": "['        is_executable: bool,\\n']",
  "context": "filename: str,\n        file_content: str,\n        is_executable: bool,\n    ) -> str:\n        temp_folder = tmp_path / TEM"
 },
 "1449": {
  "name": "path_to_file",
  "type": "make_file",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "35",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "g cases when no errors should be reported.\"\"\"\n    path_to_file = make_file('test_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n"
 },
 "1450": {
  "name": "file_tokens",
  "type": "parse_file_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "36",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n\n    visitor = comments.ShebangVisitor(\n        de"
 },
 "1451": {
  "name": "path_to_file",
  "type": "make_file",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "68",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "g cases when no errors should be reported.\"\"\"\n    path_to_file = make_file('test_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n"
 },
 "1452": {
  "name": "file_tokens",
  "type": "parse_file_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "69",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n\n    visitor = comments.ShebangVisitor(\n        de"
 },
 "1453": {
  "name": "path_to_file",
  "type": "make_file",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "105",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "setattr(comments, 'is_windows', lambda: True)\n    path_to_file = make_file('test_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n"
 },
 "1454": {
  "name": "file_tokens",
  "type": "parse_file_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "106",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n\n    visitor = comments.ShebangVisitor(\n        de"
 },
 "1455": {
  "name": "path_to_file",
  "type": "make_file",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "141",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "g cases when no errors should be reported.\"\"\"\n    path_to_file = make_file('test_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n"
 },
 "1456": {
  "name": "file_tokens",
  "type": "parse_file_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "142",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n\n    visitor = comments.ShebangVisitor(\n        de"
 },
 "1457": {
  "name": "path_to_file",
  "type": "make_file",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "172",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "g cases when no errors should be reported.\"\"\"\n    path_to_file = make_file('test_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n"
 },
 "1458": {
  "name": "file_tokens",
  "type": "parse_file_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "173",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "_file.py', template.format(code), executable)\n    file_tokens = parse_file_tokens(path_to_file)\n\n    visitor = comments.ShebangVisitor(\n        de"
 },
 "1459": {
  "name": "path_to_file",
  "type": "make_file",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "202",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "g cases when no errors should be reported.\"\"\"\n    path_to_file = make_file(\n        'test_file.py', template.format(code), is_"
 },
 "1460": {
  "name": "file_tokens",
  "type": "parse_file_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_shebang.py",
  "lineno": "205",
  "column": "4",
  "slicing": "[\"template_empty = ''\\n\", \"template_regular = '{0}'\\n\", 'template_with_leading_comment = \"\"\"{0}\\n', \"template_regular_comment = 'x = 1{0}'\\n\", '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', '    template_regular_comment,\\n', '    template_empty,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    template_regular,\\n', '    template_with_leading_comment,\\n', \"    path_to_file = make_file('test_file.py', template.format(code), executable)\\n\", '    file_tokens = parse_file_tokens(path_to_file)\\n', '    visitor = comments.ShebangVisitor(\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n', '    template_with_leading_comment,\\n', '    path_to_file = make_file(\\n', '    file_tokens = parse_file_tokens(path_to_file)\\n', '        filename=path_to_file,\\n', '        file_tokens=file_tokens,\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ShebangViolation])\\n']",
  "context": "plate.format(code), is_executable=True,\n    )\n    file_tokens = parse_file_tokens(path_to_file)\n\n    visitor = comments.ShebangVisitor(\n        de"
 },
 "1461": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_empty_comment.py",
  "lineno": "94",
  "column": "4",
  "slicing": "['single_empty_wrapped = \"\"\"\\n', 'multi_empty_wrapped = \"\"\"\\n', 'single_empty_beginning = \"\"\"\\n', 'single_empty_end = \"\"\"\\n', 'multi_empty_beginning = \"\"\"\\n', 'multi_empty_end = \"\"\"\\n', \"non_empty_comment = '# Non empty text'\\n\", \"code_statement = 'my_var = 1'\\n\", '    single_empty_wrapped,\\n', '    multi_empty_wrapped,\\n', '    non_empty_comment,\\n', '    file_tokens = parse_tokens(pattern.format(comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    single_empty_beginning,\\n', '    single_empty_end,\\n', '    multi_empty_beginning,\\n', '    multi_empty_end,\\n', '    non_empty_comment,\\n', '    code_statement,\\n', '    file_tokens = parse_tokens(pattern.format(code_or_comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n', '    file_tokens = parse_tokens(edge_case)\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n']",
  "context": " surrounded with non-empty ones are valid.\"\"\"\n    file_tokens = parse_tokens(pattern.format(comment))\n\n    visitor = EmptyCommentVisitor(default_options"
 },
 "1462": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.EmptyCommentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_empty_comment.py",
  "lineno": "96",
  "column": "4",
  "slicing": "['single_empty_wrapped = \"\"\"\\n', 'multi_empty_wrapped = \"\"\"\\n', 'single_empty_beginning = \"\"\"\\n', 'single_empty_end = \"\"\"\\n', 'multi_empty_beginning = \"\"\"\\n', 'multi_empty_end = \"\"\"\\n', \"non_empty_comment = '# Non empty text'\\n\", \"code_statement = 'my_var = 1'\\n\", '    single_empty_wrapped,\\n', '    multi_empty_wrapped,\\n', '    non_empty_comment,\\n', '    file_tokens = parse_tokens(pattern.format(comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    single_empty_beginning,\\n', '    single_empty_end,\\n', '    multi_empty_beginning,\\n', '    multi_empty_end,\\n', '    non_empty_comment,\\n', '    code_statement,\\n', '    file_tokens = parse_tokens(pattern.format(code_or_comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n', '    file_tokens = parse_tokens(edge_case)\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n']",
  "context": "kens = parse_tokens(pattern.format(comment))\n\n    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1463": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_empty_comment.py",
  "lineno": "120",
  "column": "4",
  "slicing": "['single_empty_wrapped = \"\"\"\\n', 'multi_empty_wrapped = \"\"\"\\n', 'single_empty_beginning = \"\"\"\\n', 'single_empty_end = \"\"\"\\n', 'multi_empty_beginning = \"\"\"\\n', 'multi_empty_end = \"\"\"\\n', \"non_empty_comment = '# Non empty text'\\n\", \"code_statement = 'my_var = 1'\\n\", '    single_empty_wrapped,\\n', '    multi_empty_wrapped,\\n', '    non_empty_comment,\\n', '    file_tokens = parse_tokens(pattern.format(comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    single_empty_beginning,\\n', '    single_empty_end,\\n', '    multi_empty_beginning,\\n', '    multi_empty_end,\\n', '    non_empty_comment,\\n', '    code_statement,\\n', '    file_tokens = parse_tokens(pattern.format(code_or_comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n', '    file_tokens = parse_tokens(edge_case)\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n']",
  "context": " incorrect empty comments raise a warning.\"\"\"\n    file_tokens = parse_tokens(pattern.format(code_or_comment))\n\n    visitor = EmptyCommentVisitor(default_options"
 },
 "1464": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.EmptyCommentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_empty_comment.py",
  "lineno": "122",
  "column": "4",
  "slicing": "['single_empty_wrapped = \"\"\"\\n', 'multi_empty_wrapped = \"\"\"\\n', 'single_empty_beginning = \"\"\"\\n', 'single_empty_end = \"\"\"\\n', 'multi_empty_beginning = \"\"\"\\n', 'multi_empty_end = \"\"\"\\n', \"non_empty_comment = '# Non empty text'\\n\", \"code_statement = 'my_var = 1'\\n\", '    single_empty_wrapped,\\n', '    multi_empty_wrapped,\\n', '    non_empty_comment,\\n', '    file_tokens = parse_tokens(pattern.format(comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    single_empty_beginning,\\n', '    single_empty_end,\\n', '    multi_empty_beginning,\\n', '    multi_empty_end,\\n', '    non_empty_comment,\\n', '    code_statement,\\n', '    file_tokens = parse_tokens(pattern.format(code_or_comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n', '    file_tokens = parse_tokens(edge_case)\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n']",
  "context": "arse_tokens(pattern.format(code_or_comment))\n\n    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Emp"
 },
 "1465": {
  "name": "file_tokens",
  "type": "parse_tokens",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_empty_comment.py",
  "lineno": "141",
  "column": "4",
  "slicing": "['single_empty_wrapped = \"\"\"\\n', 'multi_empty_wrapped = \"\"\"\\n', 'single_empty_beginning = \"\"\"\\n', 'single_empty_end = \"\"\"\\n', 'multi_empty_beginning = \"\"\"\\n', 'multi_empty_end = \"\"\"\\n', \"non_empty_comment = '# Non empty text'\\n\", \"code_statement = 'my_var = 1'\\n\", '    single_empty_wrapped,\\n', '    multi_empty_wrapped,\\n', '    non_empty_comment,\\n', '    file_tokens = parse_tokens(pattern.format(comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    single_empty_beginning,\\n', '    single_empty_end,\\n', '    multi_empty_beginning,\\n', '    multi_empty_end,\\n', '    non_empty_comment,\\n', '    code_statement,\\n', '    file_tokens = parse_tokens(pattern.format(code_or_comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n', '    file_tokens = parse_tokens(edge_case)\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n']",
  "context": " incorrect empty comments raise a warning.\"\"\"\n    file_tokens = parse_tokens(edge_case)\n\n    visitor = EmptyCommentVisitor(default_options"
 },
 "1466": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.tokenize.comments.EmptyCommentVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_tokenize/test_comments/test_empty_comment.py",
  "lineno": "143",
  "column": "4",
  "slicing": "['single_empty_wrapped = \"\"\"\\n', 'multi_empty_wrapped = \"\"\"\\n', 'single_empty_beginning = \"\"\"\\n', 'single_empty_end = \"\"\"\\n', 'multi_empty_beginning = \"\"\"\\n', 'multi_empty_end = \"\"\"\\n', \"non_empty_comment = '# Non empty text'\\n\", \"code_statement = 'my_var = 1'\\n\", '    single_empty_wrapped,\\n', '    multi_empty_wrapped,\\n', '    non_empty_comment,\\n', '    file_tokens = parse_tokens(pattern.format(comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    single_empty_beginning,\\n', '    single_empty_end,\\n', '    multi_empty_beginning,\\n', '    multi_empty_end,\\n', '    non_empty_comment,\\n', '    code_statement,\\n', '    file_tokens = parse_tokens(pattern.format(code_or_comment))\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n', '    file_tokens = parse_tokens(edge_case)\\n', '    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [EmptyCommentViolation])\\n']",
  "context": "\"\"\n    file_tokens = parse_tokens(edge_case)\n\n    visitor = EmptyCommentVisitor(default_options, file_tokens=file_tokens)\n    visitor.run()\n\n    assert_errors(visitor, [Emp"
 },
 "1467": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_redable_name.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreadableNameViolation])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "le characters combinations do not allowed.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Unr"
 },
 "1468": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_redable_name.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreadableNameViolation])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": "\"\"Testing that ordinary naming works well.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1469": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_redable_name.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnreadableNameViolation])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [\\n']",
  "context": " case related to underscore name patterns.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [\n  "
 },
 "1470": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_underscore_number.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnderscoredNumberNameViolation])\\n', \"    assert_error_text(visitor, filename.replace('.py', ''))\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s with underscored numbers are restricted.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Und"
 },
 "1471": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_underscore_number.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [UnderscoredNumberNameViolation])\\n', \"    assert_error_text(visitor, filename.replace('.py', ''))\\n\", '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n']",
  "context": "s with underscored numbers are restricted.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1472": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_underscores.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveUnderscoresInNameViolation])\\n', \"    assert_error_text(visitor, filename.replace('.py', ''))\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [PrivateNameViolation])\\n', \"    assert_error_text(visitor, filename.replace('.py', ''))\\n\"]",
  "context": "sting that correct file names are allowed.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1473": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_underscores.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveUnderscoresInNameViolation])\\n', \"    assert_error_text(visitor, filename.replace('.py', ''))\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [PrivateNameViolation])\\n', \"    assert_error_text(visitor, filename.replace('.py', ''))\\n\"]",
  "context": "\"Ensures incorrect underscores are caught.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Con"
 },
 "1474": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_underscores.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [ConsecutiveUnderscoresInNameViolation])\\n', \"    assert_error_text(visitor, filename.replace('.py', ''))\\n\", '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [PrivateNameViolation])\\n', \"    assert_error_text(visitor, filename.replace('.py', ''))\\n\"]",
  "context": " that names with private names are caught.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Pri"
 },
 "1475": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_name.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleNameViolation])\\n']",
  "context": "Testing that simple file names works well.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1476": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_name.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor = WrongModuleNameVisitor(\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleNameViolation])\\n']",
  "context": "sting that some file names are restricted.\"\"\"\n    visitor = WrongModuleNameVisitor(\n        default_options,\n        filename='{0}.py'"
 },
 "1477": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_name_length.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.min_name_length,\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.max_name_length,\\n\"]",
  "context": "ting that short file names are restricted.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "1478": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_name_length.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.min_name_length,\\n\", '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.max_name_length,\\n\"]",
  "context": "ting that short file names are restricted.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1479": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_name_length.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    filename = 'test.py'\\n\", '    option_values = options(min_name_length=5)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.min_name_length,\\n\", '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    max_length = 55\\n', \"    filename = 'very_long_name_that_should_not_pass_unless_changed_shorter.py'\\n\", '    option_values = options(max_name_length=max_length)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.max_name_length,\\n\"]",
  "context": "me-length` works.\"\"\"\n    filename = 'test.py'\n    option_values = options(min_name_length=5)\n    visitor = WrongModuleNameVisitor(option_values"
 },
 "1480": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_name_length.py",
  "lineno": "46",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    filename = 'test.py'\\n\", '    option_values = options(min_name_length=5)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.min_name_length,\\n\", '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    max_length = 55\\n', \"    filename = 'very_long_name_that_should_not_pass_unless_changed_shorter.py'\\n\", '    option_values = options(max_name_length=max_length)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.max_name_length,\\n\"]",
  "context": "   option_values = options(min_name_length=5)\n    visitor = WrongModuleNameVisitor(option_values, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "1481": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_name_length.py",
  "lineno": "63",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    filename = 'test.py'\\n\", '    option_values = options(min_name_length=5)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.min_name_length,\\n\", '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    max_length = 55\\n', \"    filename = 'very_long_name_that_should_not_pass_unless_changed_shorter.py'\\n\", '    option_values = options(max_name_length=max_length)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.max_name_length,\\n\"]",
  "context": "sting that long file names are restricted.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "1482": {
  "name": "option_values",
  "type": "options",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_name_length.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    filename = 'test.py'\\n\", '    option_values = options(min_name_length=5)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.min_name_length,\\n\", '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    max_length = 55\\n', \"    filename = 'very_long_name_that_should_not_pass_unless_changed_shorter.py'\\n\", '    option_values = options(max_name_length=max_length)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.max_name_length,\\n\"]",
  "context": "at_should_not_pass_unless_changed_shorter.py'\n    option_values = options(max_name_length=max_length)\n    visitor = WrongModuleNameVisitor(option_values"
 },
 "1483": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_name_length.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', \"    filename = 'test.py'\\n\", '    option_values = options(min_name_length=5)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooShortNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.min_name_length,\\n\", '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', '    max_length = 55\\n', \"    filename = 'very_long_name_that_should_not_pass_unless_changed_shorter.py'\\n\", '    option_values = options(max_name_length=max_length)\\n', '    visitor = WrongModuleNameVisitor(option_values, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [TooLongNameViolation])\\n', \"        visitor, filename.replace('.py', ''), option_values.max_name_length,\\n\"]",
  "context": "_values = options(max_name_length=max_length)\n    visitor = WrongModuleNameVisitor(option_values, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Too"
 },
 "1484": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_pattern.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleNamePatternViolation])\\n']",
  "context": "Testing that simple file names works well.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1485": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_pattern.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleNamePatternViolation])\\n']",
  "context": "sting that incorrect names are restricted.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1486": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_magic_name.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleMagicNameViolation])\\n']",
  "context": " that allowed magic file names works well.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [])\n"
 },
 "1487": {
  "name": "visitor",
  "type": "wemake_python_styleguide.visitors.filenames.module.WrongModuleNameVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_visitors/test_filenames/test_module/test_module_magic_name.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [])\\n', '    visitor = WrongModuleNameVisitor(default_options, filename=filename)\\n', '    visitor.run()\\n', '    assert_errors(visitor, [WrongModuleMagicNameViolation])\\n']",
  "context": "sting that some file names are restricted.\"\"\"\n    visitor = WrongModuleNameVisitor(default_options, filename=filename)\n    visitor.run()\n\n    assert_errors(visitor, [Wro"
 },
 "1488": {
  "name": "extra_parens",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/external_plugins.py",
  "lineno": "7",
  "column": "0",
  "slicing": "[\"extra_parens = list((node for node in 'abc'))\\n\"]",
  "context": " sys\nfrom typing import List, Union, Dict\n\n++int\n\nextra_parens = list((node for node in 'abc'))\nsome_tuple = (1, 2, )\nbreaking_pycodestyle=3\n\n# co"
 },
 "1489": {
  "name": "some_tuple",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/external_plugins.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['some_tuple = (1, 2, )\\n']",
  "context": "nt\n\nextra_parens = list((node for node in 'abc'))\nsome_tuple = (1, 2, )\nbreaking_pycodestyle=3\n\n# commented: str = 'commen"
 },
 "1490": {
  "name": "plugin",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/external_plugins.py",
  "lineno": "21",
  "column": "18",
  "slicing": "[\"def function_name(plugin: str ='flake8') ->str:\\n\"]",
  "context": "\nassert True\nipdb.set_trace()\n\n\ndef function_name(plugin: str ='flake8') ->str:\n    \"\"\"Test `wrong`rst code.\"\"\"\n    return plugin\n"
 },
 "1491": {
  "name": "handle",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/formatter/formatter1.py",
  "lineno": "1",
  "column": "6",
  "slicing": "['def s(handle: int) -> int:\\n']",
  "context": "def s(handle: int) -> int:\n    return handle + 2_00\n"
 },
 "1492": {
  "name": "good_name",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/formatter/correct.py",
  "lineno": "8",
  "column": "15",
  "slicing": "['def clear_name(good_name: int) -> int:\\n']",
  "context": "cstring.\n\nThey are required.\n\"\"\"\n\n\ndef clear_name(good_name: int) -> int:\n    \"\"\"All functions should be like this one.\"\"\"\n "
 },
 "1493": {
  "name": "some_int",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "69",
  "column": "0",
  "slicing": "['some_int = 1  # type: int\\n']",
  "context": "   name37,\n    name38,\n)\n\n# Raising and ignoring:\nsome_int = 1  # type: int\n\n\n# =====\n\nfull_name = u'Nikita Sobolev'  # noqa: "
 },
 "1494": {
  "name": "phone_number",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "75",
  "column": "0",
  "slicing": "['phone_number = 555_123_999  # noqa:  WPS303\\n']",
  "context": "==\n\nfull_name = u'Nikita Sobolev'  # noqa: WPS302\nphone_number = 555_123_999  # noqa:  WPS303\npartial_number = .05  # noqa: WPS304\nfloat_zero = "
 },
 "1495": {
  "name": "partial_number",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "76",
  "column": "0",
  "slicing": "['partial_number = .05  # noqa: WPS304\\n']",
  "context": "PS302\nphone_number = 555_123_999  # noqa:  WPS303\npartial_number = .05  # noqa: WPS304\nfloat_zero = 0.0  # noqa: WPS358\nformatted_string "
 },
 "1496": {
  "name": "float_zero",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "77",
  "column": "0",
  "slicing": "['float_zero = 0.0  # noqa: WPS358\\n']",
  "context": "oqa:  WPS303\npartial_number = .05  # noqa: WPS304\nfloat_zero = 0.0  # noqa: WPS358\nformatted_string = f'Hi, {full_name}'  # noqa: WPS"
 },
 "1497": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "-services/wemake-python-styleguide/issues/461\n    anti_wps428 = 1\n\n\ndef foo_func():\n    # See:\n    # https://github."
 },
 "1498": {
  "name": "value",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "118",
  "column": "4",
  "slicing": "['    value: int = 0,  # noqa: WPS110\\n']",
  "context": "qa: WPS614\ndef function_name(  # noqa: WPS614\n    value: int = 0,  # noqa: WPS110\n):\n    # See:\n    # https://github.com/wemake-serv"
 },
 "1499": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "122",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "-services/wemake-python-styleguide/issues/392\n    anti_wps428 = 1\n\n\ndef some():  # noqa: WPS110\n    from my_module i"
 },
 "1500": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "132",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "WPS604\n\n    def nested():  # noqa: WPS430\n        anti_wps428 = 1\n\n    raise NotImplemented  # noqa: WPS423\n\n\ndel {'"
 },
 "1501": {
  "name": "value",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "139",
  "column": "0",
  "slicing": "['value = 1  # noqa: WPS110\\n']",
  "context": "a: WPS420\nhasattr(object, 'some')  # noqa: WPS421\nvalue = 1  # noqa: WPS110\nVALUE = 1  # noqa: WPS110\nx = 2  # noqa: WPS111\n__"
 },
 "1502": {
  "name": "VALUE",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "140",
  "column": "0",
  "slicing": "['VALUE = 1  # noqa: WPS110\\n']",
  "context": "'some')  # noqa: WPS421\nvalue = 1  # noqa: WPS110\nVALUE = 1  # noqa: WPS110\nx = 2  # noqa: WPS111\n__private = 3  # noqa: WPS11"
 },
 "1503": {
  "name": "x",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "141",
  "column": "0",
  "slicing": "['x = 2  # noqa: WPS111\\n']",
  "context": "lue = 1  # noqa: WPS110\nVALUE = 1  # noqa: WPS110\nx = 2  # noqa: WPS111\n__private = 3  # noqa: WPS112\nstar_wars_episode_7 "
 },
 "1504": {
  "name": "__private",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "142",
  "column": "0",
  "slicing": "['__private = 3  # noqa: WPS112\\n']",
  "context": "0\nVALUE = 1  # noqa: WPS110\nx = 2  # noqa: WPS111\n__private = 3  # noqa: WPS112\nstar_wars_episode_7 = 'the worst episode ever afte"
 },
 "1505": {
  "name": "consecutive__underscores",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "144",
  "column": "0",
  "slicing": "['consecutive__underscores = 4  # noqa: WPS116\\n']",
  "context": "worst episode ever after 8 and 9'  # noqa: WPS114\nconsecutive__underscores = 4  # noqa: WPS116\ncls = 5  # noqa: WPS117\n__author__ = 'Nikita Sobol"
 },
 "1506": {
  "name": "cls",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "145",
  "column": "0",
  "slicing": "['cls = 5  # noqa: WPS117\\n']",
  "context": "S114\nconsecutive__underscores = 4  # noqa: WPS116\ncls = 5  # noqa: WPS117\n__author__ = 'Nikita Sobolev'  # noqa: WPS410\nextr"
 },
 "1507": {
  "name": "extremely_long_name_that_needs_to_be_shortened_to_work_fine",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "147",
  "column": "0",
  "slicing": "['extremely_long_name_that_needs_to_be_shortened_to_work_fine = 2  # noqa: WPS118\\n']",
  "context": "117\n__author__ = 'Nikita Sobolev'  # noqa: WPS410\nextremely_long_name_that_needs_to_be_shortened_to_work_fine = 2  # noqa: WPS118\n__ = 'Hello, world!'  # noqa: WPS119"
 },
 "1508": {
  "name": "_should_not_be_used",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "152",
  "column": "4",
  "slicing": "['    _should_not_be_used = 1  # noqa: WPS122\\n', '    my_print(_should_not_be_used)  # noqa: WPS121\\n']",
  "context": " alias'  # noqa: WPS120\n\ndef some_function():\n    _should_not_be_used = 1  # noqa: WPS122\n    my_print(_should_not_be_used)  # noqa: WPS121\n"
 },
 "1509": {
  "name": "used",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "155",
  "column": "0",
  "slicing": "['used, __ = 1, 2  # noqa: WPS123\\n']",
  "context": "   my_print(_should_not_be_used)  # noqa: WPS121\n\nused, __ = 1, 2  # noqa: WPS123\n\nclass Mem0Output(object):  # noqa: WPS124\n    # S"
 },
 "1510": {
  "name": "__",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "155",
  "column": "6",
  "slicing": "['used, __ = 1, 2  # noqa: WPS123\\n']",
  "context": "print(_should_not_be_used)  # noqa: WPS121\n\nused, __ = 1, 2  # noqa: WPS123\n\nclass Mem0Output(object):  # noqa: WPS124\n    # S"
 },
 "1511": {
  "name": "arg1",
  "type": "range",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "168",
  "column": "4",
  "slicing": "['    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\\n']",
  "context": ": WPS437\n\n\ndef many_locals():  # noqa: WPS210\n    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\n\n\ndef many_arguments(_arg1, _arg2, _arg3, _arg4, _"
 },
 "1512": {
  "name": "arg2",
  "type": "range",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "168",
  "column": "10",
  "slicing": "['    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\\n']",
  "context": "37\n\n\ndef many_locals():  # noqa: WPS210\n    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\n\n\ndef many_arguments(_arg1, _arg2, _arg3, _arg4, _"
 },
 "1513": {
  "name": "arg3",
  "type": "range",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "168",
  "column": "16",
  "slicing": "['    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\\n']",
  "context": "ef many_locals():  # noqa: WPS210\n    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\n\n\ndef many_arguments(_arg1, _arg2, _arg3, _arg4, _"
 },
 "1514": {
  "name": "arg4",
  "type": "range",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "168",
  "column": "22",
  "slicing": "['    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\\n']",
  "context": "y_locals():  # noqa: WPS210\n    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\n\n\ndef many_arguments(_arg1, _arg2, _arg3, _arg4, _"
 },
 "1515": {
  "name": "arg5",
  "type": "range",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "168",
  "column": "28",
  "slicing": "['    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\\n']",
  "context": "ls():  # noqa: WPS210\n    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\n\n\ndef many_arguments(_arg1, _arg2, _arg3, _arg4, _"
 },
 "1516": {
  "name": "arg6",
  "type": "range",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "168",
  "column": "34",
  "slicing": "['    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\\n']",
  "context": " # noqa: WPS210\n    arg1, arg2, arg3, arg4, arg5, arg6 = range(6)  # noqa: WPS236\n\n\ndef many_arguments(_arg1, _arg2, _arg3, _arg4, _"
 },
 "1517": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "172",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": " _arg3, _arg4, _arg5, _arg6):  # noqa: WPS211\n    anti_wps428 = 1\n\n\ndef many_returns(xy):  # noqa: WPS212\n    if xy "
 },
 "1518": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "207",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "):  # noqa: WPS214\n    def method1(self):\n        anti_wps428 = 1\n\n    def method2(self):\n        anti_wps428 = 1\n\n "
 },
 "1519": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "210",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "  anti_wps428 = 1\n\n    def method2(self):\n        anti_wps428 = 1\n\n    def method3(self):\n        anti_wps428 = 1\n\n "
 },
 "1520": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "213",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "  anti_wps428 = 1\n\n    def method3(self):\n        anti_wps428 = 1\n\n    def method4(self):\n        anti_wps428 = 1\n\n "
 },
 "1521": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "216",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "  anti_wps428 = 1\n\n    def method4(self):\n        anti_wps428 = 1\n\n    def method5(self):\n        anti_wps428 = 1\n\n "
 },
 "1522": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "219",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "  anti_wps428 = 1\n\n    def method5(self):\n        anti_wps428 = 1\n\n    def method6(self):\n        anti_wps428 = 1\n\n "
 },
 "1523": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "222",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "  anti_wps428 = 1\n\n    def method6(self):\n        anti_wps428 = 1\n\n    def method7(self):\n        anti_wps428 = 1\n\n "
 },
 "1524": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "225",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "  anti_wps428 = 1\n\n    def method7(self):\n        anti_wps428 = 1\n\n    def method8(self):\n        anti_wps428 = 1\n\n\n"
 },
 "1525": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "228",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "  anti_wps428 = 1\n\n    def method8(self):\n        anti_wps428 = 1\n\n\nclass ManyParents(First, Second, Third, Exceptio"
 },
 "1526": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "232",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "t, Second, Third, Exception):  # noqa: WPS215\n    anti_wps428 = 1\n\n\nasync def too_many_awaits():  # noqa: WPS217\n   "
 },
 "1527": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "266",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "line > 4 and line > 5:  # noqa: WPS221,WPS222\n    anti_wps428 = 1\n\nif line:  # noqa: WPS223\n    anti_wps428 = 1\nelif"
 },
 "1528": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "269",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "    anti_wps428 = 1\n\nif line:  # noqa: WPS223\n    anti_wps428 = 1\nelif line > 1:\n    anti_wps428 = 1\nelif line > 2:\n"
 },
 "1529": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "271",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "qa: WPS223\n    anti_wps428 = 1\nelif line > 1:\n    anti_wps428 = 1\nelif line > 2:\n    anti_wps428 = 1\nelif line > 3:\n"
 },
 "1530": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "273",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": " line > 1:\n    anti_wps428 = 1\nelif line > 2:\n    anti_wps428 = 1\nelif line > 3:\n    anti_wps428 = 1\nelif line > 4:\n"
 },
 "1531": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "275",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": " line > 2:\n    anti_wps428 = 1\nelif line > 3:\n    anti_wps428 = 1\nelif line > 4:\n    anti_wps428 = 1\n\n\ntry:  # noqa:"
 },
 "1532": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "277",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": " line > 3:\n    anti_wps428 = 1\nelif line > 4:\n    anti_wps428 = 1\n\n\ntry:  # noqa: WPS225\n    do_some_bad()\nexcept Va"
 },
 "1533": {
  "name": "UPPER_CASE_ATTRIBUTE",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "293",
  "column": "4",
  "slicing": "['    UPPER_CASE_ATTRIBUTE = 12  # noqa: WPS115\\n']",
  "context": "int('type')\n\n\nclass BadClass:  # noqa: WPS306\n    UPPER_CASE_ATTRIBUTE = 12  # noqa: WPS115\n\n    def __del__(self, *_args, **_kwargs):  # noqa"
 },
 "1534": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "296",
  "column": "8",
  "slicing": "['        anti_wps428 = 1  # noqa: WPS442\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "self, *_args, **_kwargs):  # noqa: WPS603\n        anti_wps428 = 1  # noqa: WPS442\n\n    class Nested:  # noqa: WPS306,WPS431\n        "
 },
 "1535": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "299",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "\n    class Nested:  # noqa: WPS306,WPS431\n        anti_wps428 = 1\n\n    async def __eq__(self, other):  # noqa: WPS61"
 },
 "1536": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "302",
  "column": "8",
  "slicing": "['        anti_wps428 = 3  # noqa: WPS442\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": " def __eq__(self, other):  # noqa: WPS610\n        anti_wps428 = 3  # noqa: WPS442\n\n\nmagic_numbers = 13.2 + 50  # noqa: WPS432\n\nasser"
 },
 "1537": {
  "name": "hex_number",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "310",
  "column": "0",
  "slicing": "['hex_number = 0XFF  # noqa: WPS310\\n', 'assert hex_number == hex_number  # noqa: WPS312\\n']",
  "context": ": WPS308\nassert 2 > octal_number  # noqa: WPS309\n\nhex_number = 0XFF  # noqa: WPS310\noctal_number = 0O11  # noqa: WPS310\nbinary_number "
 },
 "1538": {
  "name": "octal_number",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "311",
  "column": "0",
  "slicing": "['octal_number = 0O11  # noqa: WPS310\\n']",
  "context": "# noqa: WPS309\n\nhex_number = 0XFF  # noqa: WPS310\noctal_number = 0O11  # noqa: WPS310\nbinary_number = 0B1001  # noqa: WPS310\nnumber_with"
 },
 "1539": {
  "name": "binary_number",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "312",
  "column": "0",
  "slicing": "['binary_number = 0B1001  # noqa: WPS310\\n']",
  "context": " noqa: WPS310\noctal_number = 0O11  # noqa: WPS310\nbinary_number = 0B1001  # noqa: WPS310\nnumber_with_scientific_notation = 1.5E-10  # noqa:"
 },
 "1540": {
  "name": "number_with_scientific_notation",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "313",
  "column": "0",
  "slicing": "['number_with_scientific_notation = 1.5E-10  # noqa: WPS310\\n']",
  "context": "qa: WPS310\nbinary_number = 0B1001  # noqa: WPS310\nnumber_with_scientific_notation = 1.5E-10  # noqa: WPS310\nnumber_with_useless_plus = +5  # noqa: WPS330\n\nif "
 },
 "1541": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "317",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": " '6' in nodes in '6':  # noqa: WPS311, WPS525\n    anti_wps428 = 1\n\nassert hex_number == hex_number  # noqa: WPS312\n\n"
 },
 "1542": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "327",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "3)  # noqa: WPS313\n\n\nif True:  # noqa: WPS314\n    anti_wps428 = 1\n\n\nclass SomeTestClass(FirstParent, SecondParent, o"
 },
 "1543": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "331",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "arent, SecondParent, object):  # noqa: WPS315\n    anti_wps428 = 1\n\n\nwith some_context as first_context, second_conte"
 },
 "1544": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "335",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "irst_context, second_context:  # noqa: WPS316\n    anti_wps428 = 1\n\n\nclass SomeClass(FirstParent,  # noqa: WPS317\n   "
 },
 "1545": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "341",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "                ThirdParent):  # noqa: WPS319\n    anti_wps428 = 1\n\n\nif SomeClass:\n        my_print(SomeClass)  # noq"
 },
 "1546": {
  "name": "arg",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "353",
  "column": "4",
  "slicing": "['    arg: Optional[  # noqa: WPS320\\n']",
  "context": " noqa: WPS319\n\n\ndef function(  # noqa: WPS320\n    arg: Optional[  # noqa: WPS320\n        str,\n    ]\n) -> Optional[\n    str,\n]:\n    "
 },
 "1547": {
  "name": "some_set",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "359",
  "column": "4",
  "slicing": "[\"full_name = u'Nikita Sobolev'  # noqa: WPS302\\n\", \"formatted_string = f'Hi, {full_name}'  # noqa: WPS305\\n\", 'x = 2  # noqa: WPS111\\n', '    _should_not_be_used = 1  # noqa: WPS122\\n', '    my_print(_should_not_be_used)  # noqa: WPS121\\n', \"type = 'type'  # noqa: WPS125\\n\", 'line = some.call(7 * 2, 3 / 4) / some.run(5 / some, 8 - 2 + 6)  # noqa: WPS221\\n', 'if line and line > 2 and line > 3 and line > 4 and line > 5:  # noqa: WPS221,WPS222\\n', 'if line:  # noqa: WPS223\\n', 'elif line > 1:\\n', 'elif line > 2:\\n', 'elif line > 3:\\n', 'elif line > 4:\\n', 'hex_number = 0XFF  # noqa: WPS310\\n', 'octal_number = 0O11  # noqa: WPS310\\n', 'assert hex_number == hex_number  # noqa: WPS312\\n', '    some_set = {1\\n', \"bad_concatenation = 'a' 'b'  # noqa: WPS326\\n\", 'for literal in bad_concatenation:  # noqa: WPS327, WPS328\\n', 'with open(bad_concatenation):  # noqa: WPS328\\n', '    some_value = 1\\n', '    return some_value  # noqa: WPS331\\n', 'for index in [1, 2]:  # noqa: WPS335\\n', '    my_print(index)\\n', \"file_obj = open('filaname.py')  # noqa: WPS515\\n\", 'my_print(type(file_obj) == int)  # noqa: WPS516\\n', 'xterm += xterm + 1  # noqa: WPS524\\n', 'for range_len in range(len(file_obj)):  # noqa: WPS518\\n', '    my_print(range_len)\\n', 'sum_container = 0\\n', 'for sum_item in file_obj:  # noqa: WPS519\\n', '    sum_container += sum_item\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n', 'nodes = nodes  # noqa: WPS434\\n', 'for loop_index in range(6):  # noqa: WPS426\\n', '    my_print(lambda: loop_index)\\n', 'first, nodes[0] = range(2)  # noqa: WPS414\\n', 'some_if_expr = True if some_set else False  # noqa: WPS502\\n', 'if some_if_expr:  # noqa: WPS502\\n', \"    if full_name != 'Nikita Sobolev':  # noqa: WPS531\\n\", '    if some_set:\\n', '        return some_set\\n', 'for nodes[0] in (1, 2, 3):  # noqa: WPS405\\n', 'my_print(literal)  # noqa: WPS441\\n']",
  "context": "        str,\n    ]\n) -> Optional[\n    str,\n]:\n    some_set = {1\n               }  # noqa: WPS318\n\n\nstring_modifier"
 },
 "1548": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "389",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": " noqa: WPS328\n    pass  # noqa: WPS420\n\n\ntry:\n    anti_wps428 = 1\nexcept Exception as ex:  # noqa: WPS329\n    raise "
 },
 "1549": {
  "name": "some_value",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "394",
  "column": "4",
  "slicing": "['    some_value = 1\\n', '    return some_value  # noqa: WPS331\\n']",
  "context": "S329\n    raise ex\n\ndef some_other_function():\n    some_value = 1\n    return some_value  # noqa: WPS331\n\nmy_print(on"
 },
 "1550": {
  "name": "file_obj",
  "type": "open",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "407",
  "column": "0",
  "slicing": "[\"full_name = u'Nikita Sobolev'  # noqa: WPS302\\n\", \"formatted_string = f'Hi, {full_name}'  # noqa: WPS305\\n\", 'x = 2  # noqa: WPS111\\n', '    _should_not_be_used = 1  # noqa: WPS122\\n', '    my_print(_should_not_be_used)  # noqa: WPS121\\n', 'line = some.call(7 * 2, 3 / 4) / some.run(5 / some, 8 - 2 + 6)  # noqa: WPS221\\n', 'if line and line > 2 and line > 3 and line > 4 and line > 5:  # noqa: WPS221,WPS222\\n', 'if line:  # noqa: WPS223\\n', 'elif line > 1:\\n', 'elif line > 2:\\n', 'elif line > 3:\\n', 'elif line > 4:\\n', 'hex_number = 0XFF  # noqa: WPS310\\n', 'octal_number = 0O11  # noqa: WPS310\\n', 'assert hex_number == hex_number  # noqa: WPS312\\n', \"bad_concatenation = 'a' 'b'  # noqa: WPS326\\n\", 'for literal in bad_concatenation:  # noqa: WPS327, WPS328\\n', 'with open(bad_concatenation):  # noqa: WPS328\\n', '    some_value = 1\\n', '    return some_value  # noqa: WPS331\\n', 'for index in [1, 2]:  # noqa: WPS335\\n', '    my_print(index)\\n', \"file_obj = open('filaname.py')  # noqa: WPS515\\n\", 'my_print(type(file_obj) == int)  # noqa: WPS516\\n', 'for range_len in range(len(file_obj)):  # noqa: WPS518\\n', '    my_print(range_len)\\n', 'for sum_item in file_obj:  # noqa: WPS519\\n', '    sum_container += sum_item\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n', \"    if full_name != 'Nikita Sobolev':  # noqa: WPS531\\n\", 'my_print(literal)  # noqa: WPS441\\n']",
  "context": "y_print(one == 'a' or one == 'b')  # noqa: WPS514\nfile_obj = open('filaname.py')  # noqa: WPS515\nmy_print(type(file_obj) == int)  # noqa: WPS516\n\nm"
 },
 "1551": {
  "name": "pi",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "411",
  "column": "0",
  "slicing": "['pi = 3.14 # noqa: WPS446\\n']",
  "context": "my_print(*[], **{'@': 1})  # noqa: WPS517, WPS445\npi = 3.14 # noqa: WPS446\nmy_print(lambda: 0)  # noqa: WPS522\nxterm += xterm"
 },
 "1552": {
  "name": "sum_container",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "418",
  "column": "0",
  "slicing": "['sum_container = 0\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n']",
  "context": "e_obj)):  # noqa: WPS518\n    my_print(range_len)\n\nsum_container = 0\nfor sum_item in file_obj:  # noqa: WPS519\n    sum_"
 },
 "1553": {
  "name": "sum_container",
  "type": "sum_item",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "420",
  "column": "4",
  "slicing": "['    sum_container += sum_item\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n']",
  "context": "= 0\nfor sum_item in file_obj:  # noqa: WPS519\n    sum_container += sum_item\n\nmy_print(sum_container == [])  # noqa: WPS520\nmy_"
 },
 "1554": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "426",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "int(sum_container is 0)  # noqa: WPS521\n\ntry:\n    anti_wps428 = 1\nexcept BaseException:  # noqa: WPS424\n    anti_wps"
 },
 "1555": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "428",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "428 = 1\nexcept BaseException:  # noqa: WPS424\n    anti_wps428 = 1\n\ncall_with_positional_bool(True, keyword=1)  # noq"
 },
 "1556": {
  "name": "first",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "440",
  "column": "4",
  "slicing": "['    first: int\\n']",
  "context": "bject):\n    \"\"\"Redefines attr from class.\"\"\"\n\n    first: int\n    second = 1\n\n    def __init__(self) -> None:\n  "
 },
 "1557": {
  "name": "second",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "441",
  "column": "4",
  "slicing": "['    second = 1\\n']",
  "context": "Redefines attr from class.\"\"\"\n\n    first: int\n    second = 1\n\n    def __init__(self) -> None:\n        self.firs"
 },
 "1558": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "449",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "WPS601\n\n\nfor symbol in 'abc':  # noqa: WPS500\n    anti_wps428 = 1\nelse:\n    anti_wps428 = 1\n\ntry:  # noqa: WPS501\n  "
 },
 "1559": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "451",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "c':  # noqa: WPS500\n    anti_wps428 = 1\nelse:\n    anti_wps428 = 1\n\ntry:  # noqa: WPS501\n    anti_wps428 = 1\nfinally:"
 },
 "1560": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "454",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "se:\n    anti_wps428 = 1\n\ntry:  # noqa: WPS501\n    anti_wps428 = 1\nfinally:\n    anti_wps428 = 1\n\nnodes = nodes  # noq"
 },
 "1561": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "456",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "  # noqa: WPS501\n    anti_wps428 = 1\nfinally:\n    anti_wps428 = 1\n\nnodes = nodes  # noqa: WPS434\n\n\nclass Example(obj"
 },
 "1562": {
  "name": "nodes",
  "type": "nodes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "458",
  "column": "0",
  "slicing": "[\"full_name = u'Nikita Sobolev'  # noqa: WPS302\\n\", \"formatted_string = f'Hi, {full_name}'  # noqa: WPS305\\n\", 'x = 2  # noqa: WPS111\\n', '    _should_not_be_used = 1  # noqa: WPS122\\n', '    my_print(_should_not_be_used)  # noqa: WPS121\\n', \"type = 'type'  # noqa: WPS125\\n\", 'line = some.call(7 * 2, 3 / 4) / some.run(5 / some, 8 - 2 + 6)  # noqa: WPS221\\n', 'if line and line > 2 and line > 3 and line > 4 and line > 5:  # noqa: WPS221,WPS222\\n', 'if line:  # noqa: WPS223\\n', 'elif line > 1:\\n', 'elif line > 2:\\n', 'elif line > 3:\\n', 'elif line > 4:\\n', 'hex_number = 0XFF  # noqa: WPS310\\n', 'octal_number = 0O11  # noqa: WPS310\\n', 'assert hex_number == hex_number  # noqa: WPS312\\n', \"bad_concatenation = 'a' 'b'  # noqa: WPS326\\n\", 'for literal in bad_concatenation:  # noqa: WPS327, WPS328\\n', 'with open(bad_concatenation):  # noqa: WPS328\\n', '    some_value = 1\\n', '    return some_value  # noqa: WPS331\\n', 'for index in [1, 2]:  # noqa: WPS335\\n', '    my_print(index)\\n', \"file_obj = open('filaname.py')  # noqa: WPS515\\n\", 'my_print(type(file_obj) == int)  # noqa: WPS516\\n', 'xterm += xterm + 1  # noqa: WPS524\\n', 'for range_len in range(len(file_obj)):  # noqa: WPS518\\n', '    my_print(range_len)\\n', 'sum_container = 0\\n', 'for sum_item in file_obj:  # noqa: WPS519\\n', '    sum_container += sum_item\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n', 'nodes = nodes  # noqa: WPS434\\n', 'first, nodes[0] = range(2)  # noqa: WPS414\\n', \"    if full_name != 'Nikita Sobolev':  # noqa: WPS531\\n\", 'for nodes[0] in (1, 2, 3):  # noqa: WPS405\\n', 'my_print(literal)  # noqa: WPS441\\n']",
  "context": "    anti_wps428 = 1\nfinally:\n    anti_wps428 = 1\n\nnodes = nodes  # noqa: WPS434\n\n\nclass Example(object):\n    \"\"\"Correct class docs"
 },
 "1563": {
  "name": "object_",
  "type": "object",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "468",
  "column": "21",
  "slicing": "['    def __eq__(self, object_: object) -> bool:  # noqa: WPS612\\n']",
  "context": "string.\"\"\"\n        yield 10\n\n    def __eq__(self, object_: object) -> bool:  # noqa: WPS612\n        return super().__eq__(object_)\n\n\nfor loop_"
 },
 "1564": {
  "name": "first",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "484",
  "column": "0",
  "slicing": "['first = second = 2  # noqa: WPS429\\n']",
  "context": "print(1)  # noqa: WPS427\n\n\n1 + 2  # noqa: WPS428\n\nfirst = second = 2  # noqa: WPS429\n\nfirst, nodes[0] = range(2)  # noqa: WPS414\n\n\ntry:"
 },
 "1565": {
  "name": "second",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "484",
  "column": "8",
  "slicing": "['first = second = 2  # noqa: WPS429\\n']",
  "context": "  # noqa: WPS427\n\n\n1 + 2  # noqa: WPS428\n\nfirst = second = 2  # noqa: WPS429\n\nfirst, nodes[0] = range(2)  # noqa: WPS414\n\n\ntry:"
 },
 "1566": {
  "name": "first",
  "type": "range",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "486",
  "column": "0",
  "slicing": "['first, nodes[0] = range(2)  # noqa: WPS414\\n']",
  "context": "noqa: WPS428\n\nfirst = second = 2  # noqa: WPS429\n\nfirst, nodes[0] = range(2)  # noqa: WPS414\n\n\ntry:  # noqa: WPS415\n    anti_wps428 = 1\nexcept "
 },
 "1567": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "490",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "nge(2)  # noqa: WPS414\n\n\ntry:  # noqa: WPS415\n    anti_wps428 = 1\nexcept ValueError:\n    anti_wps428 = 1\nexcept Valu"
 },
 "1568": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "492",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "WPS415\n    anti_wps428 = 1\nexcept ValueError:\n    anti_wps428 = 1\nexcept ValueError:\n    anti_wps428 = 1\n\n\nclass MyB"
 },
 "1569": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "494",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "Error:\n    anti_wps428 = 1\nexcept ValueError:\n    anti_wps428 = 1\n\n\nclass MyBadException(BaseException):  # noqa: WP"
 },
 "1570": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "498",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "yBadException(BaseException):  # noqa: WPS418\n    anti_wps428 = 1\n\n\nsome_if_expr = True if some_set else False  # no"
 },
 "1571": {
  "name": "__slots__",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "516",
  "column": "4",
  "slicing": "[\"    __slots__ = ['a', 'a']  # noqa: WPS607\\n\"]",
  "context": "Contents((lambda: object)()):  # noqa: WPS606\n    __slots__ = ['a', 'a']  # noqa: WPS607\n\n    for bad_body_node in range(1):  # noqa: WPS60"
 },
 "1572": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "519",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "ad_body_node in range(1):  # noqa: WPS604\n        anti_wps428 = 1\n\n    def method_with_no_args():  # noqa: WPS605\n  "
 },
 "1573": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "550",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "\n\n\nfor nodes[0] in (1, 2, 3):  # noqa: WPS405\n    anti_wps428 = 1\n\nwith open('some') as MyBadException.custom:  # no"
 },
 "1574": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "553",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '    anti_wps428 == 1\\n']",
  "context": "e') as MyBadException.custom:  # noqa: WPS406\n    anti_wps428 = 1\n\n\nanti_wps428.__truediv__(1)  # noqa: WPS609\n\nif n"
 },
 "1575": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "565",
  "column": "8",
  "slicing": "['        anti_wps428 = 1\\n', '    anti_wps428 == 1\\n']",
  "context": "t('Wrong')\n\ntry:\n    try:  # noqa: WPS505\n        anti_wps428 = 1\n    except ValueError:\n        raise TypeError('Se"
 },
 "1576": {
  "name": "leading_zero",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "585",
  "column": "0",
  "slicing": "['leading_zero = 1.2e01  # noqa: WPS339\\n']",
  "context": "self\n\n    def public(self):\n        return self\n\n\nleading_zero = 1.2e01  # noqa: WPS339\npositive_exponent = 1.1e+1  # noqa: WPS340\nwrong_h"
 },
 "1577": {
  "name": "positive_exponent",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "586",
  "column": "0",
  "slicing": "['positive_exponent = 1.1e+1  # noqa: WPS340\\n']",
  "context": "turn self\n\n\nleading_zero = 1.2e01  # noqa: WPS339\npositive_exponent = 1.1e+1  # noqa: WPS340\nwrong_hex = 0xabc  # noqa: WPS341\nwrong_escape_raw"
 },
 "1578": {
  "name": "wrong_hex",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "587",
  "column": "0",
  "slicing": "['wrong_hex = 0xabc  # noqa: WPS341\\n']",
  "context": "WPS339\npositive_exponent = 1.1e+1  # noqa: WPS340\nwrong_hex = 0xabc  # noqa: WPS341\nwrong_escape_raw_string = '\\\\n'  # noqa: WPS342\nba"
 },
 "1579": {
  "name": "bad_complex",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "589",
  "column": "0",
  "slicing": "[\"full_name = u'Nikita Sobolev'  # noqa: WPS302\\n\", \"formatted_string = f'Hi, {full_name}'  # noqa: WPS305\\n\", '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', 'x = 2  # noqa: WPS111\\n', '    _should_not_be_used = 1  # noqa: WPS122\\n', '    my_print(_should_not_be_used)  # noqa: WPS121\\n', \"type = 'type'  # noqa: WPS125\\n\", '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'line = some.call(7 * 2, 3 / 4) / some.run(5 / some, 8 - 2 + 6)  # noqa: WPS221\\n', 'if line and line > 2 and line > 3 and line > 4 and line > 5:  # noqa: WPS221,WPS222\\n', '    anti_wps428 = 1\\n', 'if line:  # noqa: WPS223\\n', '    anti_wps428 = 1\\n', 'elif line > 1:\\n', '    anti_wps428 = 1\\n', 'elif line > 2:\\n', '    anti_wps428 = 1\\n', 'elif line > 3:\\n', '    anti_wps428 = 1\\n', 'elif line > 4:\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1  # noqa: WPS442\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 3  # noqa: WPS442\\n', 'hex_number = 0XFF  # noqa: WPS310\\n', 'octal_number = 0O11  # noqa: WPS310\\n', '    anti_wps428 = 1\\n', 'assert hex_number == hex_number  # noqa: WPS312\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    some_set = {1\\n', \"bad_concatenation = 'a' 'b'  # noqa: WPS326\\n\", 'for literal in bad_concatenation:  # noqa: WPS327, WPS328\\n', 'with open(bad_concatenation):  # noqa: WPS328\\n', '    anti_wps428 = 1\\n', '    some_value = 1\\n', '    return some_value  # noqa: WPS331\\n', 'for index in [1, 2]:  # noqa: WPS335\\n', '    my_print(index)\\n', \"file_obj = open('filaname.py')  # noqa: WPS515\\n\", 'my_print(type(file_obj) == int)  # noqa: WPS516\\n', 'xterm += xterm + 1  # noqa: WPS524\\n', 'for range_len in range(len(file_obj)):  # noqa: WPS518\\n', '    my_print(range_len)\\n', 'sum_container = 0\\n', 'for sum_item in file_obj:  # noqa: WPS519\\n', '    sum_container += sum_item\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'nodes = nodes  # noqa: WPS434\\n', 'for loop_index in range(6):  # noqa: WPS426\\n', '    my_print(lambda: loop_index)\\n', 'first, nodes[0] = range(2)  # noqa: WPS414\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'some_if_expr = True if some_set else False  # noqa: WPS502\\n', 'if some_if_expr:  # noqa: WPS502\\n', \"    if full_name != 'Nikita Sobolev':  # noqa: WPS531\\n\", '        anti_wps428 = 1\\n', '    if some_set:\\n', '        return some_set\\n', 'for nodes[0] in (1, 2, 3):  # noqa: WPS405\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '        anti_wps428 = 1\\n', '    anti_wps428 == 1\\n', \"    anti_wps428 = 'some text'\\n\", 'bad_complex = 1J  # noqa: WPS343\\n', 'zero_div = bad_complex / 0  # noqa: WPS344\\n', 'mult_one = zero_div * 1  # noqa: WPS345\\n', 'my_print(literal)  # noqa: WPS441\\n']",
  "context": "1\nwrong_escape_raw_string = '\\\\n'  # noqa: WPS342\nbad_complex = 1J  # noqa: WPS343\nzero_div = bad_complex / 0  # noqa: WPS344\nmult_on"
 },
 "1580": {
  "name": "CONSTANT",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "594",
  "column": "0",
  "slicing": "['CONSTANT = []  # noqa: WPS407\\n', 'if numbers == CONSTANT != [2]:  # noqa: WPS409\\n']",
  "context": "1  # noqa: WPS345\nmult_one -= -1  # noqa: WPS346\n\nCONSTANT = []  # noqa: WPS407\n\nnumbers = map(lambda string: int(string), ['1']) "
 },
 "1581": {
  "name": "numbers",
  "type": "map",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "596",
  "column": "0",
  "slicing": "[\"full_name = u'Nikita Sobolev'  # noqa: WPS302\\n\", \"formatted_string = f'Hi, {full_name}'  # noqa: WPS305\\n\", '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', 'x = 2  # noqa: WPS111\\n', '    _should_not_be_used = 1  # noqa: WPS122\\n', '    my_print(_should_not_be_used)  # noqa: WPS121\\n', \"type = 'type'  # noqa: WPS125\\n\", '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'line = some.call(7 * 2, 3 / 4) / some.run(5 / some, 8 - 2 + 6)  # noqa: WPS221\\n', 'if line and line > 2 and line > 3 and line > 4 and line > 5:  # noqa: WPS221,WPS222\\n', '    anti_wps428 = 1\\n', 'if line:  # noqa: WPS223\\n', '    anti_wps428 = 1\\n', 'elif line > 1:\\n', '    anti_wps428 = 1\\n', 'elif line > 2:\\n', '    anti_wps428 = 1\\n', 'elif line > 3:\\n', '    anti_wps428 = 1\\n', 'elif line > 4:\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1  # noqa: WPS442\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 3  # noqa: WPS442\\n', 'hex_number = 0XFF  # noqa: WPS310\\n', 'octal_number = 0O11  # noqa: WPS310\\n', '    anti_wps428 = 1\\n', 'assert hex_number == hex_number  # noqa: WPS312\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    some_set = {1\\n', \"bad_concatenation = 'a' 'b'  # noqa: WPS326\\n\", 'for literal in bad_concatenation:  # noqa: WPS327, WPS328\\n', 'with open(bad_concatenation):  # noqa: WPS328\\n', '    anti_wps428 = 1\\n', '    some_value = 1\\n', '    return some_value  # noqa: WPS331\\n', 'for index in [1, 2]:  # noqa: WPS335\\n', '    my_print(index)\\n', \"file_obj = open('filaname.py')  # noqa: WPS515\\n\", 'my_print(type(file_obj) == int)  # noqa: WPS516\\n', 'xterm += xterm + 1  # noqa: WPS524\\n', 'for range_len in range(len(file_obj)):  # noqa: WPS518\\n', '    my_print(range_len)\\n', 'sum_container = 0\\n', 'for sum_item in file_obj:  # noqa: WPS519\\n', '    sum_container += sum_item\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'nodes = nodes  # noqa: WPS434\\n', 'for loop_index in range(6):  # noqa: WPS426\\n', '    my_print(lambda: loop_index)\\n', 'first, nodes[0] = range(2)  # noqa: WPS414\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'some_if_expr = True if some_set else False  # noqa: WPS502\\n', 'if some_if_expr:  # noqa: WPS502\\n', \"    if full_name != 'Nikita Sobolev':  # noqa: WPS531\\n\", '        anti_wps428 = 1\\n', '    if some_set:\\n', '        return some_set\\n', 'for nodes[0] in (1, 2, 3):  # noqa: WPS405\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '        anti_wps428 = 1\\n', '    anti_wps428 == 1\\n', \"    anti_wps428 = 'some text'\\n\", 'bad_complex = 1J  # noqa: WPS343\\n', 'zero_div = bad_complex / 0  # noqa: WPS344\\n', 'mult_one = zero_div * 1  # noqa: WPS345\\n', \"numbers = map(lambda string: int(string), ['1'])  # noqa: WPS506\\n\", 'if len(numbers) > 0:  # noqa: WPS507\\n', 'if numbers and numbers:  # noqa: WPS408\\n', 'if not numbers == [1]:  # noqa: WPS508\\n', 'if numbers == CONSTANT != [2]:  # noqa: WPS409\\n', 'my_print(numbers in [])  # noqa: WPS510\\n', 'my_print(isinstance(numbers, (int,)))  # noqa: WPS512\\n', 'if numbers:\\n', '    if numbers:  # noqa: WPS513\\n', 'my_print(literal)  # noqa: WPS441\\n']",
  "context": "1  # noqa: WPS346\n\nCONSTANT = []  # noqa: WPS407\n\nnumbers = map(lambda string: int(string), ['1'])  # noqa: WPS506\n\nif len(numbers) > 0:  # noqa: WPS507\n    my_print"
 },
 "1582": {
  "name": "CheckStopIteration",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "639",
  "column": "0",
  "slicing": "['CheckStopIteration = 1  # noqa: WPS440\\n']",
  "context": "oqa: WPS438\n\nbad_unicode = b'\\u1'  # noqa: WPS439\nCheckStopIteration = 1  # noqa: WPS440\nmy_print(literal)  # noqa: WPS441\nunhashable = {[]"
 },
 "1583": {
  "name": "unhashable",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "641",
  "column": "0",
  "slicing": "['unhashable = {[]}  # noqa: WPS443\\n']",
  "context": " # noqa: WPS440\nmy_print(literal)  # noqa: WPS441\nunhashable = {[]}  # noqa: WPS443\nassert []  # noqa: WPS444\nunhashable = [] * 2  # n"
 },
 "1584": {
  "name": "swap_a",
  "type": "swap_b",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "652",
  "column": "0",
  "slicing": "[\"full_name = u'Nikita Sobolev'  # noqa: WPS302\\n\", \"formatted_string = f'Hi, {full_name}'  # noqa: WPS305\\n\", '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', 'x = 2  # noqa: WPS111\\n', '    _should_not_be_used = 1  # noqa: WPS122\\n', '    my_print(_should_not_be_used)  # noqa: WPS121\\n', \"type = 'type'  # noqa: WPS125\\n\", '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'line = some.call(7 * 2, 3 / 4) / some.run(5 / some, 8 - 2 + 6)  # noqa: WPS221\\n', 'if line and line > 2 and line > 3 and line > 4 and line > 5:  # noqa: WPS221,WPS222\\n', '    anti_wps428 = 1\\n', 'if line:  # noqa: WPS223\\n', '    anti_wps428 = 1\\n', 'elif line > 1:\\n', '    anti_wps428 = 1\\n', 'elif line > 2:\\n', '    anti_wps428 = 1\\n', 'elif line > 3:\\n', '    anti_wps428 = 1\\n', 'elif line > 4:\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1  # noqa: WPS442\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 3  # noqa: WPS442\\n', 'hex_number = 0XFF  # noqa: WPS310\\n', 'octal_number = 0O11  # noqa: WPS310\\n', '    anti_wps428 = 1\\n', 'assert hex_number == hex_number  # noqa: WPS312\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    some_set = {1\\n', \"bad_concatenation = 'a' 'b'  # noqa: WPS326\\n\", 'for literal in bad_concatenation:  # noqa: WPS327, WPS328\\n', 'with open(bad_concatenation):  # noqa: WPS328\\n', '    anti_wps428 = 1\\n', '    some_value = 1\\n', '    return some_value  # noqa: WPS331\\n', 'for index in [1, 2]:  # noqa: WPS335\\n', '    my_print(index)\\n', \"file_obj = open('filaname.py')  # noqa: WPS515\\n\", 'my_print(type(file_obj) == int)  # noqa: WPS516\\n', 'xterm += xterm + 1  # noqa: WPS524\\n', 'for range_len in range(len(file_obj)):  # noqa: WPS518\\n', '    my_print(range_len)\\n', 'sum_container = 0\\n', 'for sum_item in file_obj:  # noqa: WPS519\\n', '    sum_container += sum_item\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'nodes = nodes  # noqa: WPS434\\n', 'for loop_index in range(6):  # noqa: WPS426\\n', '    my_print(lambda: loop_index)\\n', 'first, nodes[0] = range(2)  # noqa: WPS414\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'some_if_expr = True if some_set else False  # noqa: WPS502\\n', 'if some_if_expr:  # noqa: WPS502\\n', \"    if full_name != 'Nikita Sobolev':  # noqa: WPS531\\n\", '        anti_wps428 = 1\\n', '    if some_set:\\n', '        return some_set\\n', 'for nodes[0] in (1, 2, 3):  # noqa: WPS405\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '        anti_wps428 = 1\\n', '    anti_wps428 == 1\\n', \"    anti_wps428 = 'some text'\\n\", 'bad_complex = 1J  # noqa: WPS343\\n', 'zero_div = bad_complex / 0  # noqa: WPS344\\n', 'mult_one = zero_div * 1  # noqa: WPS345\\n', 'CONSTANT = []  # noqa: WPS407\\n', \"numbers = map(lambda string: int(string), ['1'])  # noqa: WPS506\\n\", 'if len(numbers) > 0:  # noqa: WPS507\\n', 'if numbers and numbers:  # noqa: WPS408\\n', 'if not numbers == [1]:  # noqa: WPS508\\n', 'if numbers == CONSTANT != [2]:  # noqa: WPS409\\n', 'my_print(numbers in [])  # noqa: WPS510\\n', 'my_print(isinstance(numbers, (int,)))  # noqa: WPS512\\n', 'if numbers:\\n', '    if numbers:  # noqa: WPS513\\n', 'my_print(literal)  # noqa: WPS441\\n', 'swap_a = swap_b\\n', 'swap_b = swap_a  # noqa: WPS523\\n']",
  "context": "ter(...)\n        .exclude(...)  # noqa: WPS348\n)\n\nswap_a = swap_b\nswap_b = swap_a  # noqa: WPS523\n\nmy_print(constant"
 },
 "1585": {
  "name": "swap_b",
  "type": "swap_a",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "653",
  "column": "0",
  "slicing": "[\"full_name = u'Nikita Sobolev'  # noqa: WPS302\\n\", \"formatted_string = f'Hi, {full_name}'  # noqa: WPS305\\n\", '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', 'x = 2  # noqa: WPS111\\n', '    _should_not_be_used = 1  # noqa: WPS122\\n', '    my_print(_should_not_be_used)  # noqa: WPS121\\n', \"type = 'type'  # noqa: WPS125\\n\", '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'line = some.call(7 * 2, 3 / 4) / some.run(5 / some, 8 - 2 + 6)  # noqa: WPS221\\n', 'if line and line > 2 and line > 3 and line > 4 and line > 5:  # noqa: WPS221,WPS222\\n', '    anti_wps428 = 1\\n', 'if line:  # noqa: WPS223\\n', '    anti_wps428 = 1\\n', 'elif line > 1:\\n', '    anti_wps428 = 1\\n', 'elif line > 2:\\n', '    anti_wps428 = 1\\n', 'elif line > 3:\\n', '    anti_wps428 = 1\\n', 'elif line > 4:\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1  # noqa: WPS442\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 3  # noqa: WPS442\\n', 'hex_number = 0XFF  # noqa: WPS310\\n', 'octal_number = 0O11  # noqa: WPS310\\n', '    anti_wps428 = 1\\n', 'assert hex_number == hex_number  # noqa: WPS312\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    some_set = {1\\n', \"bad_concatenation = 'a' 'b'  # noqa: WPS326\\n\", 'for literal in bad_concatenation:  # noqa: WPS327, WPS328\\n', 'with open(bad_concatenation):  # noqa: WPS328\\n', '    anti_wps428 = 1\\n', '    some_value = 1\\n', '    return some_value  # noqa: WPS331\\n', 'for index in [1, 2]:  # noqa: WPS335\\n', '    my_print(index)\\n', \"file_obj = open('filaname.py')  # noqa: WPS515\\n\", 'my_print(type(file_obj) == int)  # noqa: WPS516\\n', 'xterm += xterm + 1  # noqa: WPS524\\n', 'for range_len in range(len(file_obj)):  # noqa: WPS518\\n', '    my_print(range_len)\\n', 'sum_container = 0\\n', 'for sum_item in file_obj:  # noqa: WPS519\\n', '    sum_container += sum_item\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'nodes = nodes  # noqa: WPS434\\n', 'for loop_index in range(6):  # noqa: WPS426\\n', '    my_print(lambda: loop_index)\\n', 'first, nodes[0] = range(2)  # noqa: WPS414\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'some_if_expr = True if some_set else False  # noqa: WPS502\\n', 'if some_if_expr:  # noqa: WPS502\\n', \"    if full_name != 'Nikita Sobolev':  # noqa: WPS531\\n\", '        anti_wps428 = 1\\n', '    if some_set:\\n', '        return some_set\\n', 'for nodes[0] in (1, 2, 3):  # noqa: WPS405\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '        anti_wps428 = 1\\n', '    anti_wps428 == 1\\n', \"    anti_wps428 = 'some text'\\n\", 'bad_complex = 1J  # noqa: WPS343\\n', 'zero_div = bad_complex / 0  # noqa: WPS344\\n', 'mult_one = zero_div * 1  # noqa: WPS345\\n', 'CONSTANT = []  # noqa: WPS407\\n', \"numbers = map(lambda string: int(string), ['1'])  # noqa: WPS506\\n\", 'if len(numbers) > 0:  # noqa: WPS507\\n', 'if numbers and numbers:  # noqa: WPS408\\n', 'if not numbers == [1]:  # noqa: WPS508\\n', 'if numbers == CONSTANT != [2]:  # noqa: WPS409\\n', 'my_print(numbers in [])  # noqa: WPS510\\n', 'my_print(isinstance(numbers, (int,)))  # noqa: WPS512\\n', 'if numbers:\\n', '    if numbers:  # noqa: WPS513\\n', 'my_print(literal)  # noqa: WPS441\\n', 'swap_a = swap_b\\n', 'swap_b = swap_a  # noqa: WPS523\\n']",
  "context": " .exclude(...)  # noqa: WPS348\n)\n\nswap_a = swap_b\nswap_b = swap_a  # noqa: WPS523\n\nmy_print(constant[0:7])  # noqa: WPS349\nvar_a = v"
 },
 "1586": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "679",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n']",
  "context": "       yield wrong_yield\n\ntry: # noqa: WPS448\n    anti_wps428 = 1\nexcept Exception:\n    anti_wps428 = 1\nexcept Value"
 },
 "1587": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "681",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n']",
  "context": " WPS448\n    anti_wps428 = 1\nexcept Exception:\n    anti_wps428 = 1\nexcept ValueError:\n    anti_wps428 = 1\n\n\nbad_froze"
 },
 "1588": {
  "name": "anti_wps428",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "683",
  "column": "4",
  "slicing": "['    anti_wps428 = 1\\n']",
  "context": "ption:\n    anti_wps428 = 1\nexcept ValueError:\n    anti_wps428 = 1\n\n\nbad_frozenset = frozenset([1]) # noqa: WPS527\n\n\n"
 },
 "1589": {
  "name": "bad_frozenset",
  "type": "frozenset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "686",
  "column": "0",
  "slicing": "[\"full_name = u'Nikita Sobolev'  # noqa: WPS302\\n\", \"formatted_string = f'Hi, {full_name}'  # noqa: WPS305\\n\", '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', 'x = 2  # noqa: WPS111\\n', '    _should_not_be_used = 1  # noqa: WPS122\\n', '    my_print(_should_not_be_used)  # noqa: WPS121\\n', \"type = 'type'  # noqa: WPS125\\n\", '    anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'line = some.call(7 * 2, 3 / 4) / some.run(5 / some, 8 - 2 + 6)  # noqa: WPS221\\n', 'if line and line > 2 and line > 3 and line > 4 and line > 5:  # noqa: WPS221,WPS222\\n', '    anti_wps428 = 1\\n', 'if line:  # noqa: WPS223\\n', '    anti_wps428 = 1\\n', 'elif line > 1:\\n', '    anti_wps428 = 1\\n', 'elif line > 2:\\n', '    anti_wps428 = 1\\n', 'elif line > 3:\\n', '    anti_wps428 = 1\\n', 'elif line > 4:\\n', '    anti_wps428 = 1\\n', '        anti_wps428 = 1  # noqa: WPS442\\n', '        anti_wps428 = 1\\n', '        anti_wps428 = 3  # noqa: WPS442\\n', 'hex_number = 0XFF  # noqa: WPS310\\n', 'octal_number = 0O11  # noqa: WPS310\\n', '    anti_wps428 = 1\\n', 'assert hex_number == hex_number  # noqa: WPS312\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    some_set = {1\\n', \"bad_concatenation = 'a' 'b'  # noqa: WPS326\\n\", 'for literal in bad_concatenation:  # noqa: WPS327, WPS328\\n', 'with open(bad_concatenation):  # noqa: WPS328\\n', '    anti_wps428 = 1\\n', '    some_value = 1\\n', '    return some_value  # noqa: WPS331\\n', 'for index in [1, 2]:  # noqa: WPS335\\n', '    my_print(index)\\n', \"file_obj = open('filaname.py')  # noqa: WPS515\\n\", 'my_print(type(file_obj) == int)  # noqa: WPS516\\n', 'xterm += xterm + 1  # noqa: WPS524\\n', 'for range_len in range(len(file_obj)):  # noqa: WPS518\\n', '    my_print(range_len)\\n', 'sum_container = 0\\n', 'for sum_item in file_obj:  # noqa: WPS519\\n', '    sum_container += sum_item\\n', 'my_print(sum_container == [])  # noqa: WPS520\\n', 'my_print(sum_container is 0)  # noqa: WPS521\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'nodes = nodes  # noqa: WPS434\\n', 'for loop_index in range(6):  # noqa: WPS426\\n', '    my_print(lambda: loop_index)\\n', 'first, nodes[0] = range(2)  # noqa: WPS414\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'some_if_expr = True if some_set else False  # noqa: WPS502\\n', 'if some_if_expr:  # noqa: WPS502\\n', \"    if full_name != 'Nikita Sobolev':  # noqa: WPS531\\n\", '        anti_wps428 = 1\\n', '    if some_set:\\n', '        return some_set\\n', 'for nodes[0] in (1, 2, 3):  # noqa: WPS405\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'anti_wps428.__truediv__(1)  # noqa: WPS609\\n', '        anti_wps428 = 1\\n', '    anti_wps428 == 1\\n', \"    anti_wps428 = 'some text'\\n\", 'bad_complex = 1J  # noqa: WPS343\\n', 'zero_div = bad_complex / 0  # noqa: WPS344\\n', 'mult_one = zero_div * 1  # noqa: WPS345\\n', 'CONSTANT = []  # noqa: WPS407\\n', \"numbers = map(lambda string: int(string), ['1'])  # noqa: WPS506\\n\", 'if len(numbers) > 0:  # noqa: WPS507\\n', 'if numbers and numbers:  # noqa: WPS408\\n', 'if not numbers == [1]:  # noqa: WPS508\\n', 'if numbers == CONSTANT != [2]:  # noqa: WPS409\\n', 'my_print(numbers in [])  # noqa: WPS510\\n', 'my_print(isinstance(numbers, (int,)))  # noqa: WPS512\\n', 'if numbers:\\n', '    if numbers:  # noqa: WPS513\\n', 'my_print(literal)  # noqa: WPS441\\n', 'swap_a = swap_b\\n', 'swap_b = swap_a  # noqa: WPS523\\n', 'var_a = var_a + var_b  # noqa: WPS350\\n', '    for wrong_yield in call():  # noqa: WPS526\\n', '        yield wrong_yield\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', '    anti_wps428 = 1\\n', 'bad_frozenset = frozenset([1]) # noqa: WPS527\\n']",
  "context": "s428 = 1\nexcept ValueError:\n    anti_wps428 = 1\n\n\nbad_frozenset = frozenset([1]) # noqa: WPS527\n\n\ndef wrong_yield_from():\n    yield from []  # noq"
 },
 "1590": {
  "name": "annotated",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "708",
  "column": "0",
  "slicing": "['annotated: List[List[List[List[int]]]]  # noqa: WPS234\\n']",
  "context": "a: WPS530\n\ndeep_func(a)(b)(c)(d)  # noqa: WPS233\n\nannotated: List[List[List[List[int]]]]  # noqa: WPS234\n\nextra_new_line = [  # noqa: WPS355\n\n    'wrong',\n"
 },
 "1591": {
  "name": "extra_new_line",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa.py",
  "lineno": "710",
  "column": "0",
  "slicing": "['extra_new_line = [  # noqa: WPS355\\n']",
  "context": "ted: List[List[List[List[int]]]]  # noqa: WPS234\n\nextra_new_line = [  # noqa: WPS355\n\n    'wrong',\n]\n\n*numbers, = [4, 7]  # noqa: WPS35"
 },
 "1592": {
  "name": "iters",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/fixtures/noqa/noqa_pre38.py",
  "lineno": "31",
  "column": "0",
  "slicing": "[\"iters = list((yield letter) for letter in 'ab')  # noqa: WPS416\\n\"]",
  "context": "h()\n@error\ndef decorated():\n    anti_wps428 = 1\n\n\niters = list((yield letter) for letter in 'ab')  # noqa: WPS416\n\n\ndef wrong_comprehension1():\n    return [\n       "
 },
 "1593": {
  "name": "code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/ast_tree.py",
  "lineno": "26",
  "column": "16",
  "slicing": "['    def factory(code: str, do_compile: bool = True) -> ast.AST:\\n']",
  "context": "\n\n    Order is important.\n    \"\"\"\n    def factory(code: str, do_compile: bool = True) -> ast.AST:\n        code_to_parse = dedent(code)\n        if do"
 },
 "1594": {
  "name": "do_compile",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/ast_tree.py",
  "lineno": "26",
  "column": "27",
  "slicing": "['    def factory(code: str, do_compile: bool = True) -> ast.AST:\\n']",
  "context": " is important.\n    \"\"\"\n    def factory(code: str, do_compile: bool = True) -> ast.AST:\n        code_to_parse = dedent(code)\n        if do"
 },
 "1595": {
  "name": "code_to_parse",
  "type": "textwrap.dedent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/ast_tree.py",
  "lineno": "27",
  "column": "8",
  "slicing": "['        code_to_parse = dedent(code)\\n', '            _compile_code(code_to_parse)\\n', '        return transform(ast.parse(code_to_parse))\\n', \"        compile(code_to_parse, '<filename>', 'exec')  # noqa: WPS421\\n\"]",
  "context": "str, do_compile: bool = True) -> ast.AST:\n        code_to_parse = dedent(code)\n        if do_compile:\n            _compile_code(c"
 },
 "1596": {
  "name": "code_to_parse",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/ast_tree.py",
  "lineno": "34",
  "column": "18",
  "slicing": "['def _compile_code(code_to_parse: str) -> None:\\n']",
  "context": "to_parse))\n    return factory\n\n\ndef _compile_code(code_to_parse: str) -> None:\n    \"\"\"\n    Compiles given string to Python's AST."
 },
 "1597": {
  "name": "template",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/async_sync.py",
  "lineno": "7",
  "column": "16",
  "slicing": "['    def factory(template: str) -> str:\\n']",
  "context": "lar functions into async ones.\"\"\"\n    def factory(template: str) -> str:\n        return template.replace(\n            'def "
 },
 "1598": {
  "name": "template",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/async_sync.py",
  "lineno": "21",
  "column": "16",
  "slicing": "['    def factory(template: str) -> str:\\n']",
  "context": "nctions without modifications.\"\"\"\n    def factory(template: str) -> str:\n        return template\n    return factory\n\n\n@pyte"
 },
 "1599": {
  "name": "VIOLATIONS_MODULES",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/violations.py",
  "lineno": "23",
  "column": "0",
  "slicing": "['VIOLATIONS_MODULES = (\\n', '    base_classes = {\\n', '    return issubclass(cls, BaseViolation) and cls not in base_classes\\n', '    for module in VIOLATIONS_MODULES:\\n', '        classes_names_list = inspect.getmembers(module, _is_violation_class)\\n', '        only_classes = map(itemgetter(1), classes_names_list)\\n', \"            module: sorted(only_classes, key=attrgetter('code')),\\n\", '        all_codes[module] = {\\n', '            for violation in all_module_violations[module]\\n']",
  "context": "n,\n    SimpleViolation,\n    TokenizeViolation,\n)\n\nVIOLATIONS_MODULES = (\n    system,\n    naming,\n    complexity,\n    consis"
 },
 "1600": {
  "name": "base_classes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/violations.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    base_classes = {\\n', '    return issubclass(cls, BaseViolation) and cls not in base_classes\\n']",
  "context": "sion'\n\n\ndef _is_violation_class(cls) -> bool:\n    base_classes = {\n        ASTViolation,\n        BaseViolation,\n     "
 },
 "1601": {
  "name": "classes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/violations.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    classes = {}\\n', '        classes.update({\\n', '    return classes\\n', '    for module_classes in classes.values():\\n', '        all_errors_container.extend(module_classes)\\n', '    for module_classes in classes.values():\\n', '        for violation_class in module_classes:\\n', \"            if '--i-control-code' in violation_class.__doc__:\\n\", '                controlled_errors_container.append(violation_class)\\n']",
  "context": "_classes\n\n\ndef _load_all_violation_classes():\n    classes = {}\n    for module in VIOLATIONS_MODULES:\n        clas"
 },
 "1602": {
  "name": "only_classes",
  "type": "map",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/violations.py",
  "lineno": "54",
  "column": "8",
  "slicing": "['VIOLATIONS_MODULES = (\\n', '    base_classes = {\\n', '    return issubclass(cls, BaseViolation) and cls not in base_classes\\n', '    for module in VIOLATIONS_MODULES:\\n', '        classes_names_list = inspect.getmembers(module, _is_violation_class)\\n', '        only_classes = map(itemgetter(1), classes_names_list)\\n', \"            module: sorted(only_classes, key=attrgetter('code')),\\n\", '        all_codes[module] = {\\n', '            for violation in all_module_violations[module]\\n']",
  "context": "t.getmembers(module, _is_violation_class)\n        only_classes = map(itemgetter(1), classes_names_list)\n        classes.update({\n            module: sorte"
 },
 "1603": {
  "name": "classes",
  "type": "_load_all_violation_classes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/violations.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['VIOLATIONS_MODULES = (\\n', '    base_classes = {\\n', '    return issubclass(cls, BaseViolation) and cls not in base_classes\\n', '    classes = {}\\n', '    for module in VIOLATIONS_MODULES:\\n', '        classes_names_list = inspect.getmembers(module, _is_violation_class)\\n', '        only_classes = map(itemgetter(1), classes_names_list)\\n', '        classes.update({\\n', \"            module: sorted(only_classes, key=attrgetter('code')),\\n\", '    return classes\\n', '    classes = _load_all_violation_classes()\\n', '    for module_classes in classes.values():\\n', '        all_errors_container.extend(module_classes)\\n', '    for module_classes in classes.values():\\n', '        for violation_class in module_classes:\\n', \"            if '--i-control-code' in violation_class.__doc__:\\n\", '                controlled_errors_container.append(violation_class)\\n', '        all_codes[module] = {\\n', '            for violation in all_module_violations[module]\\n']",
  "context": " from the package and creates a flat list.\"\"\"\n    classes = _load_all_violation_classes()\n    all_errors_container = []\n    for module_class"
 },
 "1604": {
  "name": "all_errors_container",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/violations.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['    all_errors_container = []\\n', '        all_errors_container.extend(module_classes)\\n', '    return all_errors_container\\n']",
  "context": "\"\n    classes = _load_all_violation_classes()\n    all_errors_container = []\n    for module_classes in classes.values():\n      "
 },
 "1605": {
  "name": "classes",
  "type": "_load_all_violation_classes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/violations.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['VIOLATIONS_MODULES = (\\n', \"_SESSION_SCOPE = 'session'\\n\", '    base_classes = {\\n', '    return issubclass(cls, BaseViolation) and cls not in base_classes\\n', '    classes = {}\\n', '    for module in VIOLATIONS_MODULES:\\n', '        classes_names_list = inspect.getmembers(module, _is_violation_class)\\n', '        only_classes = map(itemgetter(1), classes_names_list)\\n', '        classes.update({\\n', \"            module: sorted(only_classes, key=attrgetter('code')),\\n\", '    return classes\\n', '@pytest.fixture(scope=_SESSION_SCOPE)\\n', '    classes = _load_all_violation_classes()\\n', '    all_errors_container = []\\n', '    for module_classes in classes.values():\\n', '        all_errors_container.extend(module_classes)\\n', '    return all_errors_container\\n', '@pytest.fixture(scope=_SESSION_SCOPE)\\n', '    classes = _load_all_violation_classes()\\n', '    for module_classes in classes.values():\\n', '        for violation_class in module_classes:\\n', \"            if '--i-control-code' in violation_class.__doc__:\\n\", '                controlled_errors_container.append(violation_class)\\n', '@pytest.fixture(scope=_SESSION_SCOPE)\\n', '@pytest.fixture(scope=_SESSION_SCOPE)\\n', '        all_codes[module] = {\\n', '            for violation in all_module_violations[module]\\n']",
  "context": "ich may be tweaked using `i_control_code`.\"\"\"\n    classes = _load_all_violation_classes()\n    controlled_errors_container = []\n    for modul"
 },
 "1606": {
  "name": "controlled_errors_container",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/violations.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['    controlled_errors_container = []\\n', '                controlled_errors_container.append(violation_class)\\n', '    return controlled_errors_container\\n']",
  "context": "\"\n    classes = _load_all_violation_classes()\n    controlled_errors_container = []\n    for module_classes in classes.values():\n      "
 },
 "1607": {
  "name": "all_codes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/violations.py",
  "lineno": "92",
  "column": "4",
  "slicing": "['    all_codes = {}\\n', '        all_codes[module] = {\\n', '    return all_codes\\n']",
  "context": " their violation classes from the package.\"\"\"\n    all_codes = {}\n    for module in all_module_violations.keys():\n  "
 },
 "1608": {
  "name": "code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/tokenize_parser.py",
  "lineno": "11",
  "column": "16",
  "slicing": "['    def factory(code: str):\\n']",
  "context": "\"\"Parses tokens from a string.\"\"\"\n    def factory(code: str):\n        lines = io.StringIO(dedent(code))\n        "
 },
 "1609": {
  "name": "filename",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/plugins/tokenize_parser.py",
  "lineno": "20",
  "column": "16",
  "slicing": "['    def factory(filename: str):\\n']",
  "context": " \"\"\"Parses tokens from a file.\"\"\"\n    def factory(filename: str):\n        with open(filename, 'r', encoding='utf-8')"
 },
 "1610": {
  "name": "file_content",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/tests/plugins/tokenize_parser.py",
  "lineno": "22",
  "column": "12",
  "slicing": "['        lines = io.StringIO(dedent(code))\\n', '        return list(tokenize.generate_tokens(lambda: next(lines)))\\n', \"        with open(filename, 'r', encoding='utf-8') as test_file:\\n\", '            file_content = test_file.read()\\n', '            return parse_tokens(file_content)\\n']",
  "context": " 'r', encoding='utf-8') as test_file:\n            file_content = test_file.read()\n            return parse_tokens(file_content)\n    "
 },
 "1611": {
  "name": "flakes",
  "type": "PyFlakesChecker",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_regressions/test_regression112.py",
  "lineno": "49",
  "column": "4",
  "slicing": "[\"code_that_breaks = '''\\n\", '    module = ast.parse(code_that_breaks)\\n', \"    Checker(tree=module, file_tokens=[], filename='custom.py')\\n\", '    flakes = PyFlakesChecker(module)\\n', '    assert module.wps_context is None  # augmentation happened!\\n', '    assert flakes.root\\n']",
  "context": "xceptHandler' object has no attribute 'depth'\n    flakes = PyFlakesChecker(module)\n\n    assert module.wps_context is None  # augmenta"
 },
 "1612": {
  "name": "output",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_formatter/test_formatter_output.py",
  "lineno": "30",
  "column": "17",
  "slicing": "['def _safe_output(output: str) -> str:\\n', '    return output.replace(current_version_url, general_version_url)\\n', '        _safe_output(stdout),\\n', \"        'formatter_{0}'.format(output),\\n\", '        _safe_output(stdout),\\n', \"        'formatter_correct_{0}'.format(output),\\n\"]",
  "context": "ide.version import pkg_version\n\n\ndef _safe_output(output: str) -> str:\n    \"\"\"\n    Removes version specific things from c"
 },
 "1613": {
  "name": "snapshots",
  "type": "snapshottest.Snapshot",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_formatter/snapshots/snap_test_formatter_output.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['snapshots = Snapshot()\\n', \"snapshots['test_formatter[cli_options0-regular] formatter_regular'] = '''\\n\", \"snapshots['test_formatter[cli_options1-regular_statistic] formatter_regular_statistic'] = '''\\n\", \"snapshots['test_formatter[cli_options2-with_source] formatter_with_source'] = '''\\n\", \"snapshots['test_formatter[cli_options3-with_source_statistic] formatter_with_source_statistic'] = '''\\n\", \"snapshots['test_formatter[cli_options4-statistic_with_source] formatter_statistic_with_source'] = '''\\n\", \"snapshots['test_formatter_correct[cli_options0-regular] formatter_correct_regular'] = ''\\n\", \"snapshots['test_formatter_correct[cli_options1-regular_statistic] formatter_correct_regular_statistic'] = '''\\n\", \"snapshots['test_formatter_correct[cli_options2-with_source] formatter_correct_with_source'] = ''\\n\", \"snapshots['test_formatter_correct[cli_options3-with_source_statistic] formatter_correct_with_source_statistic'] = '''\\n\", \"snapshots['test_formatter_correct[cli_options4-statistic_with_source] formatter_correct_statistic_with_source'] = '''\\n\"]",
  "context": "ode_literals\n\nfrom snapshottest import Snapshot\n\n\nsnapshots = Snapshot()\n\nsnapshots['test_formatter[cli_options0-regular] f"
 },
 "1614": {
  "name": "annotation",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_complexity/test_annotations_complexity.py",
  "lineno": "26",
  "column": "20",
  "slicing": "['    parse_ast_tree, annotation: str, complexity: int,\\n']",
  "context": "st_get_annotation_complexity(\n    parse_ast_tree, annotation: str, complexity: int,\n) -> None:\n    \"\"\"Test get_annotation_complexity f"
 },
 "1615": {
  "name": "complexity",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_complexity/test_annotations_complexity.py",
  "lineno": "26",
  "column": "37",
  "slicing": "['    parse_ast_tree, annotation: str, complexity: int,\\n']",
  "context": "_complexity(\n    parse_ast_tree, annotation: str, complexity: int,\n) -> None:\n    \"\"\"Test get_annotation_complexity f"
 },
 "1616": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_complexity/test_annotations_complexity.py",
  "lineno": "30",
  "column": "4",
  "slicing": "[\"    text = 'def f() -> {annotation}: pass\\\\n'.format(annotation=annotation)\\n\", '    tree = parse_ast_tree(text)\\n', '    node = tree.body[0].returns\\n', '    assert annotations.get_annotation_complexity(node) == complexity\\n']",
  "context": "ation}: pass\\n'.format(annotation=annotation)\n    tree = parse_ast_tree(text)\n    node = tree.body[0].returns\n    assert annotat"
 },
 "1617": {
  "name": "src",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_complexity/test_cognitive/conftest.py",
  "lineno": "30",
  "column": "16",
  "slicing": "['    def factory(src: str) -> int:\\n']",
  "context": "itive complexity the easy way.\"\"\"\n    def factory(src: str) -> int:\n        funcdef = _find_function(parse_ast_tree(sr"
 },
 "1618": {
  "name": "funcdef",
  "type": "_find_function",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_complexity/test_cognitive/conftest.py",
  "lineno": "31",
  "column": "8",
  "slicing": "['def _find_function(tree: ast.AST):\\n', '    for node in ast.walk(tree):\\n', '        if isinstance(node, FunctionNodes):\\n', '            return node\\n', '        funcdef = _find_function(parse_ast_tree(src))\\n', \"        assert funcdef, 'No function definition found'\\n\", '        return cognitive.cognitive_score(funcdef)\\n']",
  "context": "way.\"\"\"\n    def factory(src: str) -> int:\n        funcdef = _find_function(parse_ast_tree(src))\n        assert funcdef, 'No function definition fo"
 },
 "1619": {
  "name": "function_call",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_tree/test_functions.py",
  "lineno": "23",
  "column": "20",
  "slicing": "['    parse_ast_tree, function_call: str, function_name: str,\\n']",
  "context": "ven_function_called_no_split(\n    parse_ast_tree, function_call: str, function_name: str,\n) -> None:\n    \"\"\"Test given_function_called witho"
 },
 "1620": {
  "name": "function_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_tree/test_functions.py",
  "lineno": "23",
  "column": "40",
  "slicing": "['    parse_ast_tree, function_call: str, function_name: str,\\n']",
  "context": "no_split(\n    parse_ast_tree, function_call: str, function_name: str,\n) -> None:\n    \"\"\"Test given_function_called witho"
 },
 "1621": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_tree/test_functions.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(function_call)\\n', '    node = tree.body[0].value\\n', '    called_function = functions.given_function_called(node, [function_name])\\n', '    assert called_function == function_name\\n', '    tree = parse_ast_tree(function_call)\\n', '    node = tree.body[0].value\\n', '        node,\\n', '    assert called_function == function_name\\n']",
  "context": "tion_called without splitting the modules.\"\"\"\n    tree = parse_ast_tree(function_call)\n    node = tree.body[0].value\n    called_function "
 },
 "1622": {
  "name": "function_call",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_tree/test_functions.py",
  "lineno": "49",
  "column": "20",
  "slicing": "['    parse_ast_tree, function_call: str, function_name: str,\\n']",
  "context": "n_function_called_with_split(\n    parse_ast_tree, function_call: str, function_name: str,\n) -> None:\n    \"\"\"Test given_function_called split"
 },
 "1623": {
  "name": "function_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_tree/test_functions.py",
  "lineno": "49",
  "column": "40",
  "slicing": "['    parse_ast_tree, function_call: str, function_name: str,\\n']",
  "context": "th_split(\n    parse_ast_tree, function_call: str, function_name: str,\n) -> None:\n    \"\"\"Test given_function_called split"
 },
 "1624": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_logic/test_tree/test_functions.py",
  "lineno": "52",
  "column": "4",
  "slicing": "['    tree = parse_ast_tree(function_call)\\n', '    node = tree.body[0].value\\n', '    called_function = functions.given_function_called(node, [function_name])\\n', '    assert called_function == function_name\\n', '    tree = parse_ast_tree(function_call)\\n', '    node = tree.body[0].value\\n', '        node,\\n', '    assert called_function == function_name\\n']",
  "context": "ven_function_called splitting the modules.\"\"\"\n    tree = parse_ast_tree(function_call)\n    node = tree.body[0].value\n    called_function "
 },
 "1625": {
  "name": "codes",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_codes.py",
  "lineno": "4",
  "column": "4",
  "slicing": "['    codes = []\\n', '        codes.append(int(violation.code))\\n', '    assert len(set(codes)) == len(all_violations)\\n']",
  "context": "ll violations have unique violation codes.\"\"\"\n    codes = []\n    for violation in all_violations:\n        codes"
 },
 "1626": {
  "name": "starting_code",
  "type": "min",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_codes.py",
  "lineno": "26",
  "column": "8",
  "slicing": "['    codes = []\\n', '    for violation in all_violations:\\n', '        codes.append(int(violation.code))\\n', '    assert len(set(codes)) == len(all_violations)\\n', '    for index, module in enumerate(all_module_violations.keys()):\\n', '        code_number = index * 100\\n', '        for violation_class in all_module_violations[module]:\\n', '                code_number <= violation_class.code <= code_number + 100 - 1\\n', '            ), violation_class.__qualname__\\n', '    for index, module in enumerate(all_module_violations.keys()):\\n', '        starting_code = min(\\n', '            violation_class.code\\n', '            for violation_class in all_module_violations[module]\\n', '        assert starting_code == index * 100\\n']",
  "context": " enumerate(all_module_violations.keys()):\n        starting_code = min(\n            violation_class.code\n            for v"
 },
 "1627": {
  "name": "previous_code",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_codes.py",
  "lineno": "36",
  "column": "8",
  "slicing": "['    codes = []\\n', '    for violation in all_violations:\\n', '        codes.append(int(violation.code))\\n', '    assert len(set(codes)) == len(all_violations)\\n', '    for index, module in enumerate(all_module_violations.keys()):\\n', '        code_number = index * 100\\n', '        for violation_class in all_module_violations[module]:\\n', '                code_number <= violation_class.code <= code_number + 100 - 1\\n', '            ), violation_class.__qualname__\\n', '    for index, module in enumerate(all_module_violations.keys()):\\n', '        starting_code = min(\\n', '            violation_class.code\\n', '            for violation_class in all_module_violations[module]\\n', '        assert starting_code == index * 100\\n', '    for module_codes in all_violation_codes.values():\\n', '        previous_code = None\\n', '        for code in sorted(module_codes.keys()):\\n', '            if previous_code is not None:\\n', '                diff = code - previous_code\\n', '                assert diff == 1 or diff > 2, module_codes[code].__qualname__\\n', '            previous_code = code\\n']",
  "context": "le_codes in all_violation_codes.values():\n        previous_code = None\n        for code in sorted(module_codes.keys()):\n "
 },
 "1628": {
  "name": "previous_code",
  "type": "code",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_codes.py",
  "lineno": "41",
  "column": "12",
  "slicing": "['    codes = []\\n', '    for violation in all_violations:\\n', '        codes.append(int(violation.code))\\n', '    assert len(set(codes)) == len(all_violations)\\n', '    for index, module in enumerate(all_module_violations.keys()):\\n', '        code_number = index * 100\\n', '        for violation_class in all_module_violations[module]:\\n', '                code_number <= violation_class.code <= code_number + 100 - 1\\n', '            ), violation_class.__qualname__\\n', '    for index, module in enumerate(all_module_violations.keys()):\\n', '        starting_code = min(\\n', '            violation_class.code\\n', '            for violation_class in all_module_violations[module]\\n', '        assert starting_code == index * 100\\n', '    for module_codes in all_violation_codes.values():\\n', '        previous_code = None\\n', '        for code in sorted(module_codes.keys()):\\n', '            if previous_code is not None:\\n', '                diff = code - previous_code\\n', '                assert diff == 1 or diff > 2, module_codes[code].__qualname__\\n', '            previous_code = code\\n']",
  "context": " > 2, module_codes[code].__qualname__\n            previous_code = code\n"
 },
 "1629": {
  "name": "visitor",
  "type": "wemake_python_styleguide.violations.base.ASTViolation",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_implementation.py",
  "lineno": "8",
  "column": "4",
  "slicing": "[\"    visitor = ASTViolation(node=ast.parse(''), text='violation')\\n\", \"    visitor.error_template = '{0}'\\n\", '    visitor.code = 1\\n', \"    assert visitor.node_items() == (0, 0, 'WPS001 violation')\\n\"]",
  "context": "Visitor` return correct violation message.\"\"\"\n    visitor = ASTViolation(node=ast.parse(''), text='violation')\n    visitor.error_template = '{0}'\n    visitor.cod"
 },
 "1630": {
  "name": "sorted_by_code",
  "type": "sorted",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_definition_order.py",
  "lineno": "6",
  "column": "4",
  "slicing": "['def _get_sorted_classes(classes):\\n', '    sorted_by_code = sorted(classes, key=lambda cl: cl.code)\\n', '    sorted_by_source = sorted(\\n', '    return sorted_by_code, sorted_by_source\\n', '    for _, classes in all_module_violations.items():\\n', '        sorted_by_code, sorted_by_source = _get_sorted_classes(classes)\\n', '        assert sorted_by_code == sorted_by_source\\n', '    for module, classes in all_module_violations.items():\\n', '        sorted_by_code, _ = _get_sorted_classes(classes)\\n', \"        pattern = re.compile(r'\\\\.\\\\.\\\\sautoclass::\\\\s(\\\\w+)')\\n\", '        sorted_by_autoclass = pattern.findall(module.__doc__)\\n', '        sorted_by_code = [cl.__qualname__ for cl in sorted_by_code]\\n', '        assert sorted_by_code == sorted_by_autoclass\\n']",
  "context": "import re\n\n\ndef _get_sorted_classes(classes):\n    sorted_by_code = sorted(classes, key=lambda cl: cl.code)\n    sorted_by_source = sorted(\n        classes,\n  "
 },
 "1631": {
  "name": "sorted_by_source",
  "type": "sorted",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_definition_order.py",
  "lineno": "7",
  "column": "4",
  "slicing": "['    sorted_by_source = sorted(\\n', '    return sorted_by_code, sorted_by_source\\n', '        assert sorted_by_code == sorted_by_source\\n']",
  "context": "ode = sorted(classes, key=lambda cl: cl.code)\n    sorted_by_source = sorted(\n        classes,\n        key=lambda cl: inspect.fi"
 },
 "1632": {
  "name": "sorted_by_code",
  "type": "_get_sorted_classes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_definition_order.py",
  "lineno": "18",
  "column": "8",
  "slicing": "['def _get_sorted_classes(classes):\\n', '    sorted_by_code = sorted(classes, key=lambda cl: cl.code)\\n', '    sorted_by_source = sorted(\\n', '    return sorted_by_code, sorted_by_source\\n', '    for _, classes in all_module_violations.items():\\n', '        sorted_by_code, sorted_by_source = _get_sorted_classes(classes)\\n', '        assert sorted_by_code == sorted_by_source\\n', '    for module, classes in all_module_violations.items():\\n', '        sorted_by_code, _ = _get_sorted_classes(classes)\\n', \"        pattern = re.compile(r'\\\\.\\\\.\\\\sautoclass::\\\\s(\\\\w+)')\\n\", '        sorted_by_autoclass = pattern.findall(module.__doc__)\\n', '        sorted_by_code = [cl.__qualname__ for cl in sorted_by_code]\\n', '        assert sorted_by_code == sorted_by_autoclass\\n']",
  "context": "classes in all_module_violations.items():\n        sorted_by_code, sorted_by_source = _get_sorted_classes(classes)\n\n        assert sorted_by_code == sorted_by_source"
 },
 "1633": {
  "name": "sorted_by_source",
  "type": "_get_sorted_classes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_definition_order.py",
  "lineno": "18",
  "column": "24",
  "slicing": "['        sorted_by_code, sorted_by_source = _get_sorted_classes(classes)\\n', '        assert sorted_by_code == sorted_by_source\\n']",
  "context": "odule_violations.items():\n        sorted_by_code, sorted_by_source = _get_sorted_classes(classes)\n\n        assert sorted_by_code == sorted_by_source"
 },
 "1634": {
  "name": "sorted_by_code",
  "type": "_get_sorted_classes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_definition_order.py",
  "lineno": "26",
  "column": "8",
  "slicing": "['def _get_sorted_classes(classes):\\n', '    sorted_by_code = sorted(classes, key=lambda cl: cl.code)\\n', '    sorted_by_source = sorted(\\n', '    return sorted_by_code, sorted_by_source\\n', '    for _, classes in all_module_violations.items():\\n', '        sorted_by_code, sorted_by_source = _get_sorted_classes(classes)\\n', '        assert sorted_by_code == sorted_by_source\\n', '    for module, classes in all_module_violations.items():\\n', '        sorted_by_code, _ = _get_sorted_classes(classes)\\n', \"        pattern = re.compile(r'\\\\.\\\\.\\\\sautoclass::\\\\s(\\\\w+)')\\n\", '        sorted_by_autoclass = pattern.findall(module.__doc__)\\n', '        sorted_by_code = [cl.__qualname__ for cl in sorted_by_code]\\n', '        assert sorted_by_code == sorted_by_autoclass\\n']",
  "context": "classes in all_module_violations.items():\n        sorted_by_code, _ = _get_sorted_classes(classes)\n        pattern = re.compile(r'\\.\\.\\sautoclass::\\s"
 },
 "1635": {
  "name": "_",
  "type": "_get_sorted_classes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_definition_order.py",
  "lineno": "26",
  "column": "24",
  "slicing": "['        sorted_by_code, _ = _get_sorted_classes(classes)\\n']",
  "context": "odule_violations.items():\n        sorted_by_code, _ = _get_sorted_classes(classes)\n        pattern = re.compile(r'\\.\\.\\sautoclass::\\s"
 },
 "1636": {
  "name": "sorted_by_code",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_definition_order.py",
  "lineno": "29",
  "column": "8",
  "slicing": "['def _get_sorted_classes(classes):\\n', '    sorted_by_code = sorted(classes, key=lambda cl: cl.code)\\n', '    sorted_by_source = sorted(\\n', '    return sorted_by_code, sorted_by_source\\n', '    for _, classes in all_module_violations.items():\\n', '        sorted_by_code, sorted_by_source = _get_sorted_classes(classes)\\n', '        assert sorted_by_code == sorted_by_source\\n', '    for module, classes in all_module_violations.items():\\n', '        sorted_by_code, _ = _get_sorted_classes(classes)\\n', \"        pattern = re.compile(r'\\\\.\\\\.\\\\sautoclass::\\\\s(\\\\w+)')\\n\", '        sorted_by_autoclass = pattern.findall(module.__doc__)\\n', '        sorted_by_code = [cl.__qualname__ for cl in sorted_by_code]\\n', '        assert sorted_by_code == sorted_by_autoclass\\n']",
  "context": "toclass = pattern.findall(module.__doc__)\n        sorted_by_code = [cl.__qualname__ for cl in sorted_by_code]\n\n        assert sorted_by_code == sorted_by_autocl"
 },
 "1637": {
  "name": "previous_codes",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_docs.py",
  "lineno": "34",
  "column": "8",
  "slicing": "['    for module, classes in all_module_violations.items():\\n', '        for violation_class in classes:\\n', '            assert module.__doc__.count(violation_class.__qualname__) == 2\\n', '    for violation in all_violations:\\n', \"        assert '.. versionadded:: ' in violation.__doc__\\n\", '    for violation in all_violations:\\n', '        class_name = violation.__qualname__\\n', \"        assert class_name.endswith('Violation'), class_name\\n\", '    for violation in all_violations:\\n', \"        assert not violation.error_template.endswith('.'), violation\\n\", '    for violation in all_violations:\\n', \"        previous_codes = getattr(violation, 'previous_codes', None)\\n\", '        if previous_codes is not None:\\n', '            assert violation.__doc__.count(\\n', '            ) >= len(violation.previous_codes)\\n', '            if listed in violation.__doc__:\\n', \"                assert 'Configuration:' in violation.__doc__\\n\", \"                assert 'Default:' in violation.__doc__\\n\"]",
  "context": ".\"\"\"\n    for violation in all_violations:\n        previous_codes = getattr(violation, 'previous_codes', None)\n        if previous_codes is not None:\n           "
 },
 "1638": {
  "name": "option_listed",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_violations/test_docs.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    option_listed = {\\n', '        for listed in option_listed:\\n', '            if listed in violation.__doc__:\\n', '                option_listed[listed] = True\\n', '    for option_item, is_listed in option_listed.items():\\n', '        assert is_listed, option_item\\n']",
  "context": "figuration options are listed in the docs.\"\"\"\n    option_listed = {\n        option.long_option_name: False\n        for"
 },
 "1639": {
  "name": "checker",
  "type": "wemake_python_styleguide.checker.Checker",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_exception_handling.py",
  "lineno": "20",
  "column": "4",
  "slicing": "[\"    checker = Checker(tree=ast.parse(''), file_tokens=[], filename='test.py')\\n\", '    checker._visitors = [_BrokenVisitor]  # noqa: WPS437\\n', '        violation = next(checker.run())\\n', '        assert violation[2][7:] == InternalErrorViolation.error_template\\n']",
  "context": "\"\"\n    Checker.parse_options(default_options)\n    checker = Checker(tree=ast.parse(''), file_tokens=[], filename='test.py')\n    checker._visitors = [_BrokenVisitor]  # noqa: "
 },
 "1640": {
  "name": "violation",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_exception_handling.py",
  "lineno": "24",
  "column": "8",
  "slicing": "[\"    checker = Checker(tree=ast.parse(''), file_tokens=[], filename='test.py')\\n\", '    checker._visitors = [_BrokenVisitor]  # noqa: WPS437\\n', '        violation = next(checker.run())\\n', '        assert violation[2][7:] == InternalErrorViolation.error_template\\n']",
  "context": "WPS437\n\n    with suppress(StopIteration):\n        violation = next(checker.run())\n        assert violation[2][7:] == InternalErrorVi"
 },
 "1641": {
  "name": "checker",
  "type": "wemake_python_styleguide.checker.Checker",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_module_names.py",
  "lineno": "26",
  "column": "4",
  "slicing": "[\"    checker = Checker(tree=ast.parse(''), file_tokens=[], filename=filename)\\n\", '    _line, _col, error_text, _type = next(checker.run())\\n', '    assert int(error_text[3:6]) == error.code\\n']",
  "context": "\"\"\n    Checker.parse_options(default_options)\n    checker = Checker(tree=ast.parse(''), file_tokens=[], filename=filename)\n    _line, _col, error_text, _type = next(checker."
 },
 "1642": {
  "name": "_line",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_module_names.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    _line, _col, error_text, _type = next(checker.run())\\n']",
  "context": "parse(''), file_tokens=[], filename=filename)\n    _line, _col, error_text, _type = next(checker.run())\n\n    assert int(error_text[3:6]) == error.code\n"
 },
 "1643": {
  "name": "_col",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_module_names.py",
  "lineno": "27",
  "column": "11",
  "slicing": "['    _line, _col, error_text, _type = next(checker.run())\\n']",
  "context": "'), file_tokens=[], filename=filename)\n    _line, _col, error_text, _type = next(checker.run())\n\n    assert int(error_text[3:6]) == error.code\n"
 },
 "1644": {
  "name": "error_text",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_module_names.py",
  "lineno": "27",
  "column": "17",
  "slicing": "['    _line, _col, error_text, _type = next(checker.run())\\n', '    assert int(error_text[3:6]) == error.code\\n']",
  "context": "le_tokens=[], filename=filename)\n    _line, _col, error_text, _type = next(checker.run())\n\n    assert int(error_text[3:6]) == error.code\n"
 },
 "1645": {
  "name": "_type",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_module_names.py",
  "lineno": "27",
  "column": "29",
  "slicing": "['    _line, _col, error_text, _type = next(checker.run())\\n']",
  "context": ", filename=filename)\n    _line, _col, error_text, _type = next(checker.run())\n\n    assert int(error_text[3:6]) == error.code\n"
 },
 "1646": {
  "name": "string",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_hypothesis.py",
  "lineno": "30",
  "column": "11",
  "slicing": "['def _fixup(string: str) -> str:\\n']",
  "context": "l(),\n)\nsettings.load_profile('slow')\n\n\ndef _fixup(string: str) -> str:\n    \"\"\"Avoid known issues with tokenize() by editi"
 },
 "1647": {
  "name": "tokens",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_hypothesis.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['        char for char in string\\n', '        if char.isprintable()\\n', \"        tree = parse_ast_tree(str(source_code.encode('utf-8-sig')))\\n\", '    lines = io.StringIO(source_code)\\n', '    tokens = list(tokenize.generate_tokens(lambda: next(lines)))\\n', '    checker = Checker(tree, tokens)\\n', '    for violation in checker.run():\\n', '        assert isinstance(violation[0], int)\\n', '        assert isinstance(violation[1], int)\\n', \"        assert violation[2].startswith('WPS'), violation[2]\\n\", \"        assert 'WPS0' not in violation[2]\\n\", '        assert violation[3] == Checker\\n']",
  "context": "  raise\n\n    lines = io.StringIO(source_code)\n    tokens = list(tokenize.generate_tokens(lambda: next(lines)))\n\n    Checker.parse_options(default_options)\n    ch"
 },
 "1648": {
  "name": "checker",
  "type": "wemake_python_styleguide.checker.Checker",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_hypothesis.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['        char for char in string\\n', '        if char.isprintable()\\n', \"        tree = parse_ast_tree(str(source_code.encode('utf-8-sig')))\\n\", '    lines = io.StringIO(source_code)\\n', '    tokens = list(tokenize.generate_tokens(lambda: next(lines)))\\n', '    checker = Checker(tree, tokens)\\n', '    for violation in checker.run():\\n', '        assert isinstance(violation[0], int)\\n', '        assert isinstance(violation[1], int)\\n', \"        assert violation[2].startswith('WPS'), violation[2]\\n\", \"        assert 'WPS0' not in violation[2]\\n\", '        assert violation[3] == Checker\\n']",
  "context": ")\n\n    Checker.parse_options(default_options)\n    checker = Checker(tree, tokens)\n\n    for violation in checker.run():\n        asser"
 },
 "1649": {
  "name": "tree",
  "type": "parse_ast_tree",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_hypothesis.py",
  "lineno": "53",
  "column": "8",
  "slicing": "['        char for char in string\\n', '        if char.isprintable()\\n', \"        tree = parse_ast_tree(str(source_code.encode('utf-8-sig')))\\n\", '    lines = io.StringIO(source_code)\\n', '    tokens = list(tokenize.generate_tokens(lambda: next(lines)))\\n', '    checker = Checker(tree, tokens)\\n', '    for violation in checker.run():\\n', '        assert isinstance(violation[0], int)\\n', '        assert isinstance(violation[1], int)\\n', \"        assert violation[2].startswith('WPS'), violation[2]\\n\", \"        assert 'WPS0' not in violation[2]\\n\", '        assert violation[3] == Checker\\n']",
  "context": "rash on arbitrary input.\n    \"\"\"\n    try:\n        tree = parse_ast_tree(str(source_code.encode('utf-8-sig')))\n    except (UnicodeEncodeError, SyntaxError):\n    "
 },
 "1650": {
  "name": "IGNORED_VIOLATIONS",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_noqa.py",
  "lineno": "27",
  "column": "0",
  "slicing": "['IGNORED_VIOLATIONS = (\\n', \"            ','.join(IGNORED_VIOLATIONS),\\n\", \"            ','.join(IGNORED_VIOLATIONS),\\n\", '    for violation in IGNORED_VIOLATIONS:\\n', '        assert stdout.count(violation) > 0\\n', \"            ','.join(IGNORED_VIOLATIONS),\\n\"]",
  "context": "ations that we do not cover with `noqa` comments.\nIGNORED_VIOLATIONS = (\n    'WPS201',  # it is a module level violation\n  "
 },
 "1651": {
  "name": "found_errors",
  "type": "collections.Counter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_noqa.py",
  "lineno": "307",
  "column": "4",
  "slicing": "[\"ERROR_PATTERN = re.compile(r'(WPS\\\\d{3})')\\n\", '    found_errors = Counter(\\n', '        (match.group(0) for match in ERROR_PATTERN.finditer(output)),\\n', '    for found_error, found_count in found_errors.items():\\n', \"        assert found_error in errors, 'Violation without a #noqa count'\\n\", '        assert found_count == errors.get(found_error), found_error\\n', '    ) - found_errors.keys() == set()\\n']",
  "context": "rrors,\n    all_violations,\n    total=True,\n):\n    found_errors = Counter(\n        (match.group(0) for match in ERROR_PATTERN"
 },
 "1652": {
  "name": "base_classes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_presets.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    base_classes = {\\n', '    return issubclass(cls, BaseVisitor) and cls not in base_classes\\n']",
  "context": "itor,\n)\n\n\ndef _is_visitor_class(cls) -> bool:\n    base_classes = {\n        BaseFilenameVisitor,\n        BaseNodeVisit"
 },
 "1653": {
  "name": "path",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_presets.py",
  "lineno": "30",
  "column": "27",
  "slicing": "['    base_classes = {\\n', '    return issubclass(cls, BaseVisitor) and cls not in base_classes\\n', 'def _import_module_by_path(path: str):\\n', \"    module_name = path[:-3].replace('/', '.')\\n\", '    spec = importlib.util.spec_from_file_location(\\n', '        module_name,\\n', '        loader=importlib.machinery.SourceFileLoader(module_name, path),\\n', '    module = importlib.util.module_from_spec(spec)\\n', '    spec.loader.exec_module(module)\\n', '    return module\\n', \"    base_path = Path('wemake_python_styleguide')\\n\", \"    excluded_paths = list(Path(base_path, 'presets').glob('**/*.py'))\\n\", '        path for path in\\n', \"        base_path.glob('**/*.py')\\n\", '        if path not in excluded_paths\\n', '    for path in _visitors_paths():\\n', '        module = _import_module_by_path(str(path))\\n', '        classes_names_list = inspect.getmembers(module, _is_visitor_class)\\n', '        visitors.extend(map(itemgetter(1), classes_names_list))\\n']",
  "context": " not in base_classes\n\n\ndef _import_module_by_path(path: str):\n    module_name = path[:-3].replace('/', '.')\n    "
 },
 "1654": {
  "name": "base_path",
  "type": "pathlib.Path",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_presets.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    base_classes = {\\n', '    return issubclass(cls, BaseVisitor) and cls not in base_classes\\n', 'def _import_module_by_path(path: str):\\n', \"    module_name = path[:-3].replace('/', '.')\\n\", '    spec = importlib.util.spec_from_file_location(\\n', '        module_name,\\n', '        loader=importlib.machinery.SourceFileLoader(module_name, path),\\n', '    module = importlib.util.module_from_spec(spec)\\n', '    spec.loader.exec_module(module)\\n', '    return module\\n', \"    base_path = Path('wemake_python_styleguide')\\n\", \"    excluded_paths = list(Path(base_path, 'presets').glob('**/*.py'))\\n\", '        path for path in\\n', \"        base_path.glob('**/*.py')\\n\", '        if path not in excluded_paths\\n', '    for path in _visitors_paths():\\n', '        module = _import_module_by_path(str(path))\\n', '        classes_names_list = inspect.getmembers(module, _is_visitor_class)\\n', '        visitors.extend(map(itemgetter(1), classes_names_list))\\n']",
  "context": "e)\n    return module\n\n\ndef _visitors_paths():\n    base_path = Path('wemake_python_styleguide')\n    excluded_paths = list(Path(base_path, 'presets"
 },
 "1655": {
  "name": "excluded_paths",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_presets.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    base_classes = {\\n', '    return issubclass(cls, BaseVisitor) and cls not in base_classes\\n', 'def _import_module_by_path(path: str):\\n', \"    module_name = path[:-3].replace('/', '.')\\n\", '    spec = importlib.util.spec_from_file_location(\\n', '        module_name,\\n', '        loader=importlib.machinery.SourceFileLoader(module_name, path),\\n', '    module = importlib.util.module_from_spec(spec)\\n', '    spec.loader.exec_module(module)\\n', '    return module\\n', \"    base_path = Path('wemake_python_styleguide')\\n\", \"    excluded_paths = list(Path(base_path, 'presets').glob('**/*.py'))\\n\", '        path for path in\\n', \"        base_path.glob('**/*.py')\\n\", '        if path not in excluded_paths\\n', '    for path in _visitors_paths():\\n', '        module = _import_module_by_path(str(path))\\n', '        classes_names_list = inspect.getmembers(module, _is_visitor_class)\\n', '        visitors.extend(map(itemgetter(1), classes_names_list))\\n']",
  "context": " base_path = Path('wemake_python_styleguide')\n    excluded_paths = list(Path(base_path, 'presets').glob('**/*.py'))\n    return [\n        path for path in\n        base"
 },
 "1656": {
  "name": "visitors",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_presets.py",
  "lineno": "54",
  "column": "4",
  "slicing": "['    visitors = []\\n', '        visitors.extend(map(itemgetter(1), classes_names_list))\\n', '    return set(visitors)\\n']",
  "context": " all visitors into the list to be checked.\"\"\"\n    visitors = []\n    for path in _visitors_paths():\n        module "
 },
 "1657": {
  "name": "module",
  "type": "_import_module_by_path",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_presets.py",
  "lineno": "56",
  "column": "8",
  "slicing": "['    base_classes = {\\n', '    return issubclass(cls, BaseVisitor) and cls not in base_classes\\n', 'def _import_module_by_path(path: str):\\n', \"    module_name = path[:-3].replace('/', '.')\\n\", '    spec = importlib.util.spec_from_file_location(\\n', '        module_name,\\n', '        loader=importlib.machinery.SourceFileLoader(module_name, path),\\n', '    module = importlib.util.module_from_spec(spec)\\n', '    spec.loader.exec_module(module)\\n', '    return module\\n', \"    base_path = Path('wemake_python_styleguide')\\n\", \"    excluded_paths = list(Path(base_path, 'presets').glob('**/*.py'))\\n\", '        path for path in\\n', \"        base_path.glob('**/*.py')\\n\", '        if path not in excluded_paths\\n', '    for path in _visitors_paths():\\n', '        module = _import_module_by_path(str(path))\\n', '        classes_names_list = inspect.getmembers(module, _is_visitor_class)\\n', '        visitors.extend(map(itemgetter(1), classes_names_list))\\n']",
  "context": "s = []\n    for path in _visitors_paths():\n        module = _import_module_by_path(str(path))\n        classes_names_list = inspect.getmembers(mo"
 },
 "1658": {
  "name": "checker_visitors",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/tests/test_checker/test_presets.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['    checker_visitors = {\\n', '        assert visitor.__qualname__ in checker_visitors\\n', '    assert len(all_visitors) == len(checker_visitors)\\n']",
  "context": "t all visitors are contained in a checker.\"\"\"\n    checker_visitors = {\n        klass.__qualname__\n        for klass in Ch"
 },
 "1659": {
  "name": "VisitorClass",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "58",
  "column": "0",
  "slicing": "['VisitorClass = Type[base.BaseVisitor]\\n', '    _visitors: ClassVar[Sequence[VisitorClass]] = (\\n']",
  "context": "om wemake_python_styleguide.visitors import base\n\nVisitorClass = Type[base.BaseVisitor]\n\n\n@final\nclass Checker(object):\n    \"\"\"\n    Implem"
 },
 "1660": {
  "name": "name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['    name: ClassVar[str] = pkg_version.pkg_name\\n']",
  "context": "itors that are run by this checker.\n\n    \"\"\"\n\n    name: ClassVar[str] = pkg_version.pkg_name\n    version: ClassVar[str] = pkg_version.pkg_versi"
 },
 "1661": {
  "name": "version",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['    version: ClassVar[str] = pkg_version.pkg_version\\n']",
  "context": "   name: ClassVar[str] = pkg_version.pkg_name\n    version: ClassVar[str] = pkg_version.pkg_version\n\n    options: types.ConfigurationOptions\n    confi"
 },
 "1662": {
  "name": "options",
  "type": "UnDefined",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['    options: types.ConfigurationOptions\\n', '        cls.options = validate_options(options)\\n']",
  "context": "ion: ClassVar[str] = pkg_version.pkg_version\n\n    options: types.ConfigurationOptions\n    config = Configuration()\n\n    _visitors: Class"
 },
 "1663": {
  "name": "config",
  "type": "wemake_python_styleguide.options.config.Configuration",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['    config = Configuration()\\n']",
  "context": "sion\n\n    options: types.ConfigurationOptions\n    config = Configuration()\n\n    _visitors: ClassVar[Sequence[VisitorClass]] ="
 },
 "1664": {
  "name": "_visitors",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['    _visitors: ClassVar[Sequence[VisitorClass]] = (\\n']",
  "context": "gurationOptions\n    config = Configuration()\n\n    _visitors: ClassVar[Sequence[VisitorClass]] = (\n        *filename_preset.PRESET,\n        *tree_pre"
 },
 "1665": {
  "name": "file_tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "97",
  "column": "8",
  "slicing": "['        file_tokens: Sequence[tokenize.TokenInfo],\\n']",
  "context": "t__(\n        self,\n        tree: ast.AST,\n        file_tokens: Sequence[tokenize.TokenInfo],\n        filename: str = constants.STDIN,\n    ) -> "
 },
 "1666": {
  "name": "filename",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "98",
  "column": "8",
  "slicing": "['        filename: str = constants.STDIN,\\n']",
  "context": "ile_tokens: Sequence[tokenize.TokenInfo],\n        filename: str = constants.STDIN,\n    ) -> None:\n        \"\"\"\n        Creates new che"
 },
 "1667": {
  "name": "cls",
  "type": "wemake_python_styleguide.checker.Checker",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "121",
  "column": "20",
  "slicing": "['    def add_options(cls, parser: OptionManager) -> None:\\n']",
  "context": "file_tokens\n\n    @classmethod\n    def add_options(cls, parser: OptionManager) -> None:\n        \"\"\"\n        ``flake8`` api method to regis"
 },
 "1668": {
  "name": "parser",
  "type": "flake8.options.manager.OptionManager",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "121",
  "column": "25",
  "slicing": "['    def add_options(cls, parser: OptionManager) -> None:\\n']",
  "context": "tokens\n\n    @classmethod\n    def add_options(cls, parser: OptionManager) -> None:\n        \"\"\"\n        ``flake8`` api method to regis"
 },
 "1669": {
  "name": "cls",
  "type": "wemake_python_styleguide.checker.Checker",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/checker.py",
  "lineno": "135",
  "column": "22",
  "slicing": "['    def parse_options(cls, options: types.ConfigurationOptions) -> None:\\n']",
  "context": "s(parser)\n\n    @classmethod\n    def parse_options(cls, options: types.ConfigurationOptions) -> None:\n        \"\"\"Parses registered options for providing"
 },
 "1670": {
  "name": "dist_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/version.py",
  "lineno": "6",
  "column": "17",
  "slicing": "['def _get_version(dist_name: str) -> str:  # pragma: no cover\\n', '        return importlib_metadata.version(dist_name)\\n', 'pkg_name = os.path.basename(os.path.dirname(__file__))\\n', 'pkg_version = _get_version(pkg_name)\\n']",
  "context": "ging import importlib_metadata\n\n\ndef _get_version(dist_name: str) -> str:  # pragma: no cover\n    \"\"\"Fetches distribution version.\"\"\"\n    try:\n "
 },
 "1671": {
  "name": "pkg_name",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/version.py",
  "lineno": "15",
  "column": "0",
  "slicing": "['def _get_version(dist_name: str) -> str:  # pragma: no cover\\n', '        return importlib_metadata.version(dist_name)\\n', 'pkg_name = os.path.basename(os.path.dirname(__file__))\\n', 'pkg_version = _get_version(pkg_name)\\n']",
  "context": "ame. It is basically the name of the root folder.\npkg_name = os.path.basename(os.path.dirname(__file__))\n\n#: We store the version number inside the `pyproj"
 },
 "1672": {
  "name": "pkg_version",
  "type": "_get_version",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/version.py",
  "lineno": "18",
  "column": "0",
  "slicing": "['def _get_version(dist_name: str) -> str:  # pragma: no cover\\n', '        return importlib_metadata.version(dist_name)\\n', 'pkg_name = os.path.basename(os.path.dirname(__file__))\\n', 'pkg_version = _get_version(pkg_name)\\n']",
  "context": "e the version number inside the `pyproject.toml`.\npkg_version = _get_version(pkg_name)\n"
 },
 "1673": {
  "name": "AnyText",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "44",
  "column": "0",
  "slicing": "['AnyText = Union[ast.Str, ast.Bytes]\\n']",
  "context": "use this type to represent all string-like nodes.\nAnyText = Union[ast.Str, ast.Bytes]\n\n#: In cases we need to work with both import type"
 },
 "1674": {
  "name": "AnyImport",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "47",
  "column": "0",
  "slicing": "['AnyImport = Union[ast.Import, ast.ImportFrom]\\n']",
  "context": " In cases we need to work with both import types.\nAnyImport = Union[ast.Import, ast.ImportFrom]\n\n#: In cases we need to work with both function de"
 },
 "1675": {
  "name": "AnyFunctionDef",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "50",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', '    AnyFunctionDef,\\n']",
  "context": "s we need to work with both function definitions.\nAnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\n\n#: In cases we need to work with all function def"
 },
 "1676": {
  "name": "AnyFunctionDefAndLambda",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "53",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', '    AnyFunctionDef,\\n']",
  "context": "ith all function definitions (including lambdas).\nAnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\n\n#: In cases we need to work with both forms of if"
 },
 "1677": {
  "name": "AnyIf",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "56",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyIf = Union[ast.If, ast.IfExp]\\n', '    AnyFunctionDef,\\n']",
  "context": " we need to work with both forms of if functions.\nAnyIf = Union[ast.If, ast.IfExp]\n\n#: In cases we need to work with both sync and as"
 },
 "1678": {
  "name": "AnyFor",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "59",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', '    AnyFunctionDef,\\n']",
  "context": "s we need to work with both sync and async loops.\nAnyFor = Union[ast.For, ast.AsyncFor]\n\n#: In case we need to work with any loop: sync, a"
 },
 "1679": {
  "name": "AnyLoop",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "62",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', '    AnyFunctionDef,\\n']",
  "context": "ed to work with any loop: sync, async, and while.\nAnyLoop = Union[AnyFor, ast.While]\n\n#: All different comprehension types in one place"
 },
 "1680": {
  "name": "AnyComprehension",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "65",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', 'AnyComprehension = Union[\\n', '    AnyFunctionDef,\\n']",
  "context": ": All different comprehension types in one place.\nAnyComprehension = Union[\n    ast.ListComp,\n    ast.DictComp,\n    ast.SetCom"
 },
 "1681": {
  "name": "AnyWith",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "73",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', 'AnyWith = Union[ast.With, ast.AsyncWith]\\n', '    AnyFunctionDef,\\n']",
  "context": "o work with both sync and async context managers.\nAnyWith = Union[ast.With, ast.AsyncWith]\n\n#: Tuple of AST node types for declarative syntax"
 },
 "1682": {
  "name": "AnyNodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "76",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', 'AnyNodes = Tuple[Type[ast.AST], ...]\\n', '    AnyFunctionDef,\\n']",
  "context": ": Tuple of AST node types for declarative syntax.\nAnyNodes = Tuple[Type[ast.AST], ...]\n\n#: When we search for assign elements, we also ne"
 },
 "1683": {
  "name": "AnyAssign",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "79",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', 'AnyAssign = Union[ast.Assign, ast.AnnAssign]\\n', '    AnyFunctionDef,\\n']",
  "context": "h for assign elements, we also need typed assign.\nAnyAssign = Union[ast.Assign, ast.AnnAssign]\n\n#: That's how we define context of operations.\nCo"
 },
 "1684": {
  "name": "ContextNodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "82",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', 'ContextNodes = Union[\\n', '    AnyFunctionDef,\\n']",
  "context": "]\n\n#: That's how we define context of operations.\nContextNodes = Union[\n    ast.Module,\n    ast.ClassDef,\n    AnyFunctionD"
 },
 "1685": {
  "name": "AnyAccess",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "89",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', '    AnyFunctionDef,\\n', 'AnyAccess = Union[\\n']",
  "context": " In cases we need to work with both access types.\nAnyAccess = Union[\n    ast.Attribute,\n    ast.Subscript,\n]\n\n#: In cas"
 },
 "1686": {
  "name": "AnyChainable",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "95",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', '    AnyFunctionDef,\\n', 'AnyChainable = Union[\\n']",
  "context": "case we need to handle types that can be chained.\nAnyChainable = Union[\n    ast.Attribute,\n    ast.Subscript,\n    ast.Call"
 },
 "1687": {
  "name": "AnyTextPrimitive",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "102",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', '    AnyFunctionDef,\\n', 'AnyTextPrimitive = Union[str, bytes]\\n']",
  "context": " with any text-like values. Related to `AnyText`.\nAnyTextPrimitive = Union[str, bytes]\n\n#: Flake8 API format to return error messages.\nCh"
 },
 "1688": {
  "name": "CheckResult",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/types.py",
  "lineno": "105",
  "column": "0",
  "slicing": "['AnyFunctionDef = Union[ast.FunctionDef, ast.AsyncFunctionDef]\\n', 'AnyFunctionDefAndLambda = Union[AnyFunctionDef, ast.Lambda]\\n', 'AnyFor = Union[ast.For, ast.AsyncFor]\\n', 'AnyLoop = Union[AnyFor, ast.While]\\n', '    AnyFunctionDef,\\n', 'CheckResult = Tuple[int, int, str, type]\\n']",
  "context": "]\n\n#: Flake8 API format to return error messages.\nCheckResult = Tuple[int, int, str, type]\n\n\n@final\nclass ConfigurationOptions(Protocol):\n   "
 },
 "1689": {
  "name": "FUNCTIONS_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "20",
  "column": "0",
  "slicing": "['FUNCTIONS_BLACKLIST: Final = frozenset((\\n']",
  "context": "ort Final\n\n#: List of functions we forbid to use.\nFUNCTIONS_BLACKLIST: Final = frozenset((\n    # Code generation:\n    'eval',\n    'exec',\n   "
 },
 "1690": {
  "name": "MODULE_METADATA_VARIABLES_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "63",
  "column": "0",
  "slicing": "['MODULE_METADATA_VARIABLES_BLACKLIST: Final = frozenset((\\n']",
  "context": "\n))\n\n#: List of module metadata we forbid to use.\nMODULE_METADATA_VARIABLES_BLACKLIST: Final = frozenset((\n    '__author__',\n    '__all__',\n    '__version__'"
 },
 "1691": {
  "name": "VARIABLE_NAMES_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "71",
  "column": "0",
  "slicing": "['VARIABLE_NAMES_BLACKLIST: Final = frozenset((\\n']",
  "context": ",\n))\n\n#: List of variable names we forbid to use.\nVARIABLE_NAMES_BLACKLIST: Final = frozenset((\n    # Meaningless words:\n    'data',\n    'result',"
 },
 "1692": {
  "name": "UNREADABLE_CHARACTER_COMBINATIONS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "112",
  "column": "0",
  "slicing": "['UNREADABLE_CHARACTER_COMBINATIONS: Final = frozenset((\\n']",
  "context": "ist of character sequences that are hard to read.\nUNREADABLE_CHARACTER_COMBINATIONS: Final = frozenset((\n    '1l',\n    '1I',\n    '0O',\n    'O0',\n    # Not "
 },
 "1693": {
  "name": "SPECIAL_ARGUMENT_NAMES_WHITELIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "122",
  "column": "0",
  "slicing": "['SPECIAL_ARGUMENT_NAMES_WHITELIST: Final = frozenset((\\n']",
  "context": " that are used only as first argument in methods.\nSPECIAL_ARGUMENT_NAMES_WHITELIST: Final = frozenset((\n    'self',\n    'cls',\n    'mcs',\n))\n\n#: List of a"
 },
 "1694": {
  "name": "ALL_MAGIC_METHODS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "129",
  "column": "0",
  "slicing": "['ALL_MAGIC_METHODS: Final = frozenset((\\n', 'YIELD_MAGIC_METHODS_BLACKLIST: Final = ALL_MAGIC_METHODS.difference({\\n', 'ASYNC_MAGIC_METHODS_BLACKLIST: Final = ALL_MAGIC_METHODS.difference({\\n']",
  "context": ": List of all magic methods from the python docs.\nALL_MAGIC_METHODS: Final = frozenset((\n    '__new__',\n    '__init__',\n    '__del__',\n\n   "
 },
 "1695": {
  "name": "MAGIC_METHODS_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "241",
  "column": "0",
  "slicing": "['MAGIC_METHODS_BLACKLIST: Final = frozenset((\\n']",
  "context": " List of magic methods that are forbidden to use.\nMAGIC_METHODS_BLACKLIST: Final = frozenset((\n    # Since we don't use `del`:\n    '__del__',\n   "
 },
 "1696": {
  "name": "YIELD_MAGIC_METHODS_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "256",
  "column": "0",
  "slicing": "['YIELD_MAGIC_METHODS_BLACKLIST: Final = ALL_MAGIC_METHODS.difference({\\n']",
  "context": "ic methods that are not allowed to be generators.\nYIELD_MAGIC_METHODS_BLACKLIST: Final = ALL_MAGIC_METHODS.difference({\n    # Allowed to be used with ``yield`` keyword:\n "
 },
 "1697": {
  "name": "ASYNC_MAGIC_METHODS_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "263",
  "column": "0",
  "slicing": "['ASYNC_MAGIC_METHODS_BLACKLIST: Final = ALL_MAGIC_METHODS.difference({\\n']",
  "context": "f magic methods that are not allowed to be async.\nASYNC_MAGIC_METHODS_BLACKLIST: Final = ALL_MAGIC_METHODS.difference({\n    # In order of appearance on\n    # https://docs"
 },
 "1698": {
  "name": "ALLOWED_BUILTIN_CLASSES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "274",
  "column": "0",
  "slicing": "['ALLOWED_BUILTIN_CLASSES: Final = frozenset((\\n']",
  "context": " of builtin classes that are allowed to subclass.\nALLOWED_BUILTIN_CLASSES: Final = frozenset((\n    'type',\n    'object',\n))\n\n#: List of nested fu"
 },
 "1699": {
  "name": "NESTED_FUNCTIONS_WHITELIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "280",
  "column": "0",
  "slicing": "['NESTED_FUNCTIONS_WHITELIST: Final = frozenset((\\n']",
  "context": " List of nested functions' names we allow to use.\nNESTED_FUNCTIONS_WHITELIST: Final = frozenset((\n    'decorator',\n    'factory',\n    'wrapper',\n))\n"
 },
 "1700": {
  "name": "FUTURE_IMPORTS_WHITELIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "287",
  "column": "0",
  "slicing": "['FUTURE_IMPORTS_WHITELIST: Final = frozenset((\\n']",
  "context": "',\n))\n\n#: List of allowed ``__future__`` imports.\nFUTURE_IMPORTS_WHITELIST: Final = frozenset((\n    'annotations',\n    'generator_stop',\n))\n\n#: Li"
 },
 "1701": {
  "name": "MODULE_NAMES_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "293",
  "column": "0",
  "slicing": "['MODULE_NAMES_BLACKLIST: Final = frozenset((\\n']",
  "context": "r_stop',\n))\n\n#: List of blacklisted module names.\nMODULE_NAMES_BLACKLIST: Final = frozenset((\n    'util',\n    'utils',\n    'utilities',\n    'hel"
 },
 "1702": {
  "name": "MAGIC_MODULE_NAMES_WHITELIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "301",
  "column": "0",
  "slicing": "['MAGIC_MODULE_NAMES_WHITELIST: Final = frozenset((\\n']",
  "context": "pers',\n))\n\n#: List of allowed module magic names.\nMAGIC_MODULE_NAMES_WHITELIST: Final = frozenset((\n    '__init__',\n    '__main__',\n))\n\n#: List of bad"
 },
 "1703": {
  "name": "MAGIC_MODULE_NAMES_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "307",
  "column": "0",
  "slicing": "['MAGIC_MODULE_NAMES_BLACKLIST: Final = frozenset((\\n']",
  "context": "in__',\n))\n\n#: List of bad magic module functions.\nMAGIC_MODULE_NAMES_BLACKLIST: Final = frozenset((\n    '__getattr__',\n    '__dir__',\n))\n\n#: Regex pat"
 },
 "1704": {
  "name": "MODULE_NAME_PATTERN",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "313",
  "column": "0",
  "slicing": "[\"MODULE_NAME_PATTERN: Final = re.compile(r'^_?_?[a-z][a-z\\\\d_]*[a-z\\\\d](__)?$')\\n\"]",
  "context": " '__dir__',\n))\n\n#: Regex pattern to name modules.\nMODULE_NAME_PATTERN: Final = re.compile(r'^_?_?[a-z][a-z\\d_]*[a-z\\d](__)?$')\n\n#: Common numbers that are allowed to be used wit"
 },
 "1705": {
  "name": "MAGIC_NUMBERS_WHITELIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "316",
  "column": "0",
  "slicing": "['MAGIC_NUMBERS_WHITELIST: Final = frozenset((\\n']",
  "context": " allowed to be used without being called \"magic\".\nMAGIC_NUMBERS_WHITELIST: Final = frozenset((\n    0,  # both int and float\n    0.1,\n    0.5,\n   "
 },
 "1706": {
  "name": "MAX_NO_COVER_COMMENTS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "331",
  "column": "0",
  "slicing": "['MAX_NO_COVER_COMMENTS: Final = 5\\n']",
  "context": "mount of ``pragma`` no-cover comments per module.\nMAX_NO_COVER_COMMENTS: Final = 5\n\n#: Maximum length of ``yield`` ``tuple`` expressi"
 },
 "1707": {
  "name": "MAX_LEN_YIELD_TUPLE",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "334",
  "column": "0",
  "slicing": "['MAX_LEN_YIELD_TUPLE: Final = 5\\n']",
  "context": "aximum length of ``yield`` ``tuple`` expressions.\nMAX_LEN_YIELD_TUPLE: Final = 5\n\n#: Maximum number of compare nodes in a single ex"
 },
 "1708": {
  "name": "MAX_COMPARES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "337",
  "column": "0",
  "slicing": "['MAX_COMPARES: Final = 2\\n']",
  "context": "m number of compare nodes in a single expression.\nMAX_COMPARES: Final = 2\n\n#: Maximum number of conditions in a single ``if`"
 },
 "1709": {
  "name": "MAX_CONDITIONS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "340",
  "column": "0",
  "slicing": "['MAX_CONDITIONS: Final = 4\\n']",
  "context": "itions in a single ``if`` or ``while`` statement.\nMAX_CONDITIONS: Final = 4\n\n#: Maximum number of `elif` blocks in a single `i"
 },
 "1710": {
  "name": "MAX_ELIFS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "343",
  "column": "0",
  "slicing": "['MAX_ELIFS: Final = 3\\n']",
  "context": "mber of `elif` blocks in a single `if` condition:\nMAX_ELIFS: Final = 3\n\n#: Maximum number of ``except`` cases in a single"
 },
 "1711": {
  "name": "MAX_EXCEPT_CASES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "346",
  "column": "0",
  "slicing": "['MAX_EXCEPT_CASES: Final = 3\\n']",
  "context": "r of ``except`` cases in a single ``try`` clause.\nMAX_EXCEPT_CASES: Final = 3\n\n#: Approximate constants which real values should"
 },
 "1712": {
  "name": "MATH_APPROXIMATE_CONSTANTS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "349",
  "column": "0",
  "slicing": "['MATH_APPROXIMATE_CONSTANTS: Final = frozenset((\\n']",
  "context": " real values should be imported from math module.\nMATH_APPROXIMATE_CONSTANTS: Final = frozenset((\n    math.pi,\n    math.e,\n    math.tau,\n))\n\n#: List"
 },
 "1713": {
  "name": "VAGUE_IMPORTS_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "356",
  "column": "0",
  "slicing": "['VAGUE_IMPORTS_BLACKLIST: Final = frozenset((\\n']",
  "context": "names that may cause confusion if imported as is:\nVAGUE_IMPORTS_BLACKLIST: Final = frozenset((\n    'read',\n    'write',\n    'load',\n    'loads',\n"
 },
 "1714": {
  "name": "LITERALS_BLACKLIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "373",
  "column": "0",
  "slicing": "['LITERALS_BLACKLIST: Final = frozenset((\\n']",
  "context": "t of literals without arguments we forbid to use.\nLITERALS_BLACKLIST: Final = frozenset((\n    'int',\n    'float',\n    'str',\n    'bytes',\n  "
 },
 "1715": {
  "name": "TUPLE_ARGUMENTS_METHODS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "383",
  "column": "0",
  "slicing": "['TUPLE_ARGUMENTS_METHODS: Final = frozenset((\\n']",
  "context": "t of functions in which arguments must be tuples.\nTUPLE_ARGUMENTS_METHODS: Final = frozenset((\n    'frozenset',\n))\n\n#: Conditions that can appear"
 },
 "1716": {
  "name": "ALLOWED_NESTED_IMPORTS_CONDITIONS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "388",
  "column": "0",
  "slicing": "['ALLOWED_NESTED_IMPORTS_CONDITIONS: Final = frozenset((\\n']",
  "context": " in the ``if`` statement to allow nested imports.\nALLOWED_NESTED_IMPORTS_CONDITIONS: Final = frozenset((\n    'TYPE_CHECKING',\n))\n\n#: List of commonly used "
 },
 "1717": {
  "name": "ALIAS_NAMES_WHITELIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "393",
  "column": "0",
  "slicing": "['ALIAS_NAMES_WHITELIST: Final = frozenset((\\n']",
  "context": "E_CHECKING',\n))\n\n#: List of commonly used aliases\nALIAS_NAMES_WHITELIST: Final = frozenset((\n    'np',\n    'pd',\n    'df',\n    'plt',\n    'sns'"
 },
 "1718": {
  "name": "STDIN",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "413",
  "column": "0",
  "slicing": "[\"STDIN: Final = 'stdin'\\n\"]",
  "context": "efault filename, when it is not passed by flake8:\nSTDIN: Final = 'stdin'\n\n# Used to specify as a placeholder for `__init__`"
 },
 "1719": {
  "name": "INIT",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "416",
  "column": "0",
  "slicing": "[\"INIT: Final = '__init__'\\n\"]",
  "context": " Used to specify as a placeholder for `__init__`:\nINIT: Final = '__init__'\n\n# Used to determine when we are running on Window"
 },
 "1720": {
  "name": "WINDOWS_OS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "419",
  "column": "0",
  "slicing": "[\"WINDOWS_OS: Final = 'nt'\\n\"]",
  "context": "Used to determine when we are running on Windows:\nWINDOWS_OS: Final = 'nt'\n\n# Used as a placeholder for special `_` variable:"
 },
 "1721": {
  "name": "UNUSED_PLACEHOLDER",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/constants.py",
  "lineno": "422",
  "column": "0",
  "slicing": "[\"UNUSED_PLACEHOLDER: Final = '_'\\n\"]",
  "context": "# Used as a placeholder for special `_` variable:\nUNUSED_PLACEHOLDER: Final = '_'\n"
 },
 "1722": {
  "name": "DOCS_URL_TEMPLATE",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "42",
  "column": "0",
  "slicing": "['DOCS_URL_TEMPLATE: Final = (\\n', '    _doc_url: ClassVar[str] = DOCS_URL_TEMPLATE.format(pkg_version)\\n']",
  "context": "n\n\n#: That url is generated and hosted by Sphinx.\nDOCS_URL_TEMPLATE: Final = (\n    'https://wemake-python-stylegui.de/en/{0}/page"
 },
 "1723": {
  "name": "_doc_url",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['    _doc_url: ClassVar[str] = DOCS_URL_TEMPLATE.format(pkg_version)\\n']",
  "context": "lete and non-informative statistics\n\n    \"\"\"\n\n    _doc_url: ClassVar[str] = DOCS_URL_TEMPLATE.format(pkg_version)\n\n    # API:\n\n    def after_init(self):\n        \"\"\""
 },
 "1724": {
  "name": "error",
  "type": "flake8.style_guide.Violation",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "75",
  "column": "21",
  "slicing": "['    def handle(self, error: Violation) -> None:  # noqa: WPS110\\n']",
  "context": "      self._error_count = 0\n\n    def handle(self, error: Violation) -> None:  # noqa: WPS110\n        \"\"\"Processes each :term:`violation` to pri"
 },
 "1725": {
  "name": "error",
  "type": "flake8.style_guide.Violation",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "84",
  "column": "21",
  "slicing": "['    def format(self, error: Violation) -> str:  # noqa: WPS125\\n']",
  "context": "     self._error_count += 1\n\n    def format(self, error: Violation) -> str:  # noqa: WPS125\n        \"\"\"Called to format each individual :term:"
 },
 "1726": {
  "name": "error",
  "type": "flake8.style_guide.Violation",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "93",
  "column": "26",
  "slicing": "['    def show_source(self, error: Violation) -> str:\\n']",
  "context": "umn_number),\n        )\n\n    def show_source(self, error: Violation) -> str:\n        \"\"\"Called when ``--show-source`` option is"
 },
 "1727": {
  "name": "adjust",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "99",
  "column": "8",
  "slicing": "['DOCS_URL_TEMPLATE: Final = (\\n', '    _doc_url: ClassVar[str] = DOCS_URL_TEMPLATE.format(pkg_version)\\n', '        formatted_line = error.physical_line.lstrip()\\n', '        adjust = len(error.physical_line) - len(formatted_line)\\n', '            formatted_line,\\n', \"            spacing=' ' * (error.column_number - 1 - adjust),\\n\"]",
  "context": "atted_line = error.physical_line.lstrip()\n        adjust = len(error.physical_line) - len(formatted_line)\n\n        code = _highlight(\n            formatted_"
 },
 "1728": {
  "name": "code",
  "type": "_highlight",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "101",
  "column": "8",
  "slicing": "['DOCS_URL_TEMPLATE: Final = (\\n', '    _doc_url: ClassVar[str] = DOCS_URL_TEMPLATE.format(pkg_version)\\n', '        formatted_line = error.physical_line.lstrip()\\n', '        adjust = len(error.physical_line) - len(formatted_line)\\n', '        code = _highlight(\\n', '            formatted_line,\\n', '            code=code,\\n', \"            spacing=' ' * (error.column_number - 1 - adjust),\\n\"]",
  "context": "ror.physical_line) - len(formatted_line)\n\n        code = _highlight(\n            formatted_line,\n            self._lexe"
 },
 "1729": {
  "name": "statistics",
  "type": "flake8.statistics.Statistics",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "112",
  "column": "30",
  "slicing": "['    def show_statistics(self, statistics: Statistics) -> None:  # noqa: WPS210\\n']",
  "context": "adjust),\n        )\n\n    def show_statistics(self, statistics: Statistics) -> None:  # noqa: WPS210\n        \"\"\"Called when ``--statistic`` option is p"
 },
 "1730": {
  "name": "statistic",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "117",
  "column": "12",
  "slicing": "['DOCS_URL_TEMPLATE: Final = (\\n', '    _doc_url: ClassVar[str] = DOCS_URL_TEMPLATE.format(pkg_version)\\n', '        formatted_line = error.physical_line.lstrip()\\n', '        adjust = len(error.physical_line) - len(formatted_line)\\n', '        code = _highlight(\\n', '            formatted_line,\\n', '            code=code,\\n', \"            spacing=' ' * (error.column_number - 1 - adjust),\\n\", '        all_errors = 0\\n', '        for error_code in statistics.error_codes():\\n', '            stats_for_error_code = statistics.statistics_for(error_code)\\n', '            statistic = next(stats_for_error_code)\\n', '            count = statistic.count\\n', '            count += sum(stat.count for stat in stats_for_error_code)\\n', '            all_errors += count\\n', '            error_by_file = _count_per_filename(statistics, error_code)\\n', '                statistic,\\n', '                error_code,\\n', '                count,\\n', '                error_by_file,\\n', \"        self._write(_underline(_bold('All errors: {0}'.format(all_errors))))\\n\", \"            message = '{0}Full list of violations and explanations:{0}{1}'\\n\", '            self._write(message.format(self.newline, self._doc_url))\\n', '                error_code=_bold(error_code),\\n', '                message=statistic.message,\\n', '        for filename, error_count in error_by_file.items():\\n', '                    error_count=error_count,\\n', '                    filename=filename,\\n', \"        self._write(_underline('Total: {0}'.format(count)))\\n\", '    stats_for_error_code = statistics.statistics_for(error_code)\\n', '    for stat in stats_for_error_code:\\n', '        filenames[stat.filename] += stat.count\\n']",
  "context": "statistics.statistics_for(error_code)\n            statistic = next(stats_for_error_code)\n\n            count = statistic.count\n            c"
 },
 "1731": {
  "name": "count",
  "type": "sum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "120",
  "column": "12",
  "slicing": "['            count += sum(stat.count for stat in stats_for_error_code)\\n', '            all_errors += count\\n', '                count,\\n', \"        self._write(_underline(_bold('All errors: {0}'.format(all_errors))))\\n\", \"        self._write(_underline('Total: {0}'.format(count)))\\n\"]",
  "context": "\n\n            count = statistic.count\n            count += sum(stat.count for stat in stats_for_error_code)\n            all_errors += count\n            error_"
 },
 "1732": {
  "name": "all_errors",
  "type": "count",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "121",
  "column": "12",
  "slicing": "['            all_errors += count\\n', \"        self._write(_underline(_bold('All errors: {0}'.format(all_errors))))\\n\"]",
  "context": "unt for stat in stats_for_error_code)\n            all_errors += count\n            error_by_file = _count_per_filename(st"
 },
 "1733": {
  "name": "error_by_file",
  "type": "_count_per_filename",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "122",
  "column": "12",
  "slicing": "['DOCS_URL_TEMPLATE: Final = (\\n', '    _doc_url: ClassVar[str] = DOCS_URL_TEMPLATE.format(pkg_version)\\n', '        formatted_line = error.physical_line.lstrip()\\n', '        adjust = len(error.physical_line) - len(formatted_line)\\n', '        code = _highlight(\\n', '            formatted_line,\\n', '            code=code,\\n', \"            spacing=' ' * (error.column_number - 1 - adjust),\\n\", '        all_errors = 0\\n', '        for error_code in statistics.error_codes():\\n', '            stats_for_error_code = statistics.statistics_for(error_code)\\n', '            statistic = next(stats_for_error_code)\\n', '            count = statistic.count\\n', '            count += sum(stat.count for stat in stats_for_error_code)\\n', '            all_errors += count\\n', '            error_by_file = _count_per_filename(statistics, error_code)\\n', '                statistic,\\n', '                error_code,\\n', '                count,\\n', '                error_by_file,\\n', \"        self._write(_underline(_bold('All errors: {0}'.format(all_errors))))\\n\", \"            message = '{0}Full list of violations and explanations:{0}{1}'\\n\", '            self._write(message.format(self.newline, self._doc_url))\\n', '                error_code=_bold(error_code),\\n', '                message=statistic.message,\\n', '        for filename, error_count in error_by_file.items():\\n', '                    error_count=error_count,\\n', '                    filename=filename,\\n', \"        self._write(_underline('Total: {0}'.format(count)))\\n\", '    stats_for_error_code = statistics.statistics_for(error_code)\\n', '    for stat in stats_for_error_code:\\n', '        filenames[stat.filename] += stat.count\\n']",
  "context": "code)\n            all_errors += count\n            error_by_file = _count_per_filename(statistics, error_code)\n\n            self._print_violation_per_file(\n     "
 },
 "1734": {
  "name": "filename",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "142",
  "column": "28",
  "slicing": "['    def _print_header(self, filename: str) -> None:\\n']",
  "context": "  # Our own methods:\n\n    def _print_header(self, filename: str) -> None:\n        self._write(\n            '{newline}{filena"
 },
 "1735": {
  "name": "statistic",
  "type": "flake8.statistics.Statistics",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "152",
  "column": "8",
  "slicing": "['        statistic: Statistics,\\n']",
  "context": " _print_violation_per_file(\n        self,\n        statistic: Statistics,\n        error_code: str,\n        count: int,\n     "
 },
 "1736": {
  "name": "error_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "153",
  "column": "8",
  "slicing": "['        error_code: str,\\n']",
  "context": "     self,\n        statistic: Statistics,\n        error_code: str,\n        count: int,\n        error_by_file: Default"
 },
 "1737": {
  "name": "count",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "154",
  "column": "8",
  "slicing": "['        count: int,\\n']",
  "context": "tic: Statistics,\n        error_code: str,\n        count: int,\n        error_by_file: DefaultDict[str, int],\n    "
 },
 "1738": {
  "name": "error_by_file",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "155",
  "column": "8",
  "slicing": "['        error_by_file: DefaultDict[str, int],\\n']",
  "context": "     error_code: str,\n        count: int,\n        error_by_file: DefaultDict[str, int],\n    ):\n        self._write(\n            '{newline}"
 },
 "1739": {
  "name": "error",
  "type": "flake8.style_guide.Violation",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "173",
  "column": "34",
  "slicing": "['    def _should_show_source(self, error: Violation) -> bool:\\n']",
  "context": "ormat(count)))\n\n    def _should_show_source(self, error: Violation) -> bool:\n        return self.options.show_source and error."
 },
 "1740": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "179",
  "column": "10",
  "slicing": "['def _bold(text: str) -> str:\\n']",
  "context": "_line is not None\n\n\n# Formatting text:\n\ndef _bold(text: str) -> str:\n    r\"\"\"\n    Returns bold formatted text.\n\n    >>>"
 },
 "1741": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "190",
  "column": "15",
  "slicing": "['def _underline(text: str) -> str:\\n']",
  "context": "'\\033[1m{0}\\033[0m'.format(text)\n\n\ndef _underline(text: str) -> str:\n    r\"\"\"\n    Returns underlined formatted text.\n\n "
 },
 "1742": {
  "name": "source",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "201",
  "column": "15",
  "slicing": "['def _highlight(source: str, lexer, formatter) -> str:\\n']",
  "context": "'\\033[4m{0}\\033[0m'.format(text)\n\n\ndef _highlight(source: str, lexer, formatter) -> str:\n    \"\"\"\n    Highlights source code. Might fail.\n\n "
 },
 "1743": {
  "name": "statistics",
  "type": "flake8.statistics.Statistics",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "220",
  "column": "4",
  "slicing": "['    statistics: Statistics,\\n']",
  "context": "source\n\n\n# Helpers:\n\ndef _count_per_filename(\n    statistics: Statistics,\n    error_code: str,\n) -> DefaultDict[str, int]:\n "
 },
 "1744": {
  "name": "error_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "221",
  "column": "4",
  "slicing": "['    error_code: str,\\n']",
  "context": "unt_per_filename(\n    statistics: Statistics,\n    error_code: str,\n) -> DefaultDict[str, int]:\n    filenames: Default"
 },
 "1745": {
  "name": "filenames",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/formatter.py",
  "lineno": "223",
  "column": "4",
  "slicing": "['    filenames: DefaultDict[str, int] = defaultdict(int)\\n', '        filenames[stat.filename] += stat.count\\n', '    return filenames\\n']",
  "context": " error_code: str,\n) -> DefaultDict[str, int]:\n    filenames: DefaultDict[str, int] = defaultdict(int)\n    stats_for_error_code = statistics.statistics_f"
 },
 "1746": {
  "name": "TextNodes",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/aliases.py",
  "lineno": "16",
  "column": "0",
  "slicing": "['TextNodes: Final = (ast.Str, ast.Bytes)\\n']",
  "context": "ple to easily work with both types of text nodes:\nTextNodes: Final = (ast.Str, ast.Bytes)\n\n#: We need this tuple to easily check that this i"
 },
 "1747": {
  "name": "AssignNodes",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/aliases.py",
  "lineno": "19",
  "column": "0",
  "slicing": "['AssignNodes: Final = (ast.Assign, ast.AnnAssign)\\n', 'AssignNodesWithWalrus: Final = (*AssignNodes, NamedExpr)\\n']",
  "context": " to easily check that this is a real assign node.\nAssignNodes: Final = (ast.Assign, ast.AnnAssign)\n\n#: We need this tuple for cases where we use full"
 },
 "1748": {
  "name": "AssignNodesWithWalrus",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/aliases.py",
  "lineno": "22",
  "column": "0",
  "slicing": "['AssignNodesWithWalrus: Final = (*AssignNodes, NamedExpr)\\n']",
  "context": "s tuple for cases where we use full assign power.\nAssignNodesWithWalrus: Final = (*AssignNodes, NamedExpr)\n\n#: We need this tuple since ``async def`` now has"
 },
 "1749": {
  "name": "FunctionNodes",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/aliases.py",
  "lineno": "25",
  "column": "0",
  "slicing": "['FunctionNodes: Final = (ast.FunctionDef, ast.AsyncFunctionDef)\\n']",
  "context": "le since ``async def`` now has its own ast class.\nFunctionNodes: Final = (ast.FunctionDef, ast.AsyncFunctionDef)\n\n#: We need this tuple since ``ast.AsyncFor``` was"
 },
 "1750": {
  "name": "ForNodes",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/aliases.py",
  "lineno": "28",
  "column": "0",
  "slicing": "['ForNodes: Final = (ast.For, ast.AsyncFor)\\n']",
  "context": "his tuple since ``ast.AsyncFor``` was introduced.\nForNodes: Final = (ast.For, ast.AsyncFor)\n\n#: We need this tuple since ``ast.AsyncWith`` was"
 },
 "1751": {
  "name": "WithNodes",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/aliases.py",
  "lineno": "31",
  "column": "0",
  "slicing": "['WithNodes: Final = (ast.With, ast.AsyncWith)\\n']",
  "context": "his tuple since ``ast.AsyncWith`` was introduced.\nWithNodes: Final = (ast.With, ast.AsyncWith)\n"
 },
 "1752": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/functions.py",
  "lineno": "10",
  "column": "4",
  "slicing": "['    node: Union[AnyAssignWithWalrus, ast.AugAssign],\\n']",
  "context": "unctionDefAndLambda\n\n\ndef get_assign_targets(\n    node: Union[AnyAssignWithWalrus, ast.AugAssign],\n) -> List[ast.expr]:\n    \"\"\"Returns list of assign"
 },
 "1753": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDefAndLambda",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/functions.py",
  "lineno": "18",
  "column": "20",
  "slicing": "['def get_posonlyargs(node: AnyFunctionDefAndLambda) -> List[ast.arg]:\\n']",
  "context": "et]\n    return node.targets\n\n\ndef get_posonlyargs(node: AnyFunctionDefAndLambda) -> List[ast.arg]:\n    \"\"\"\n    Function to get posonlyargs in all ver"
 },
 "1754": {
  "name": "AnyAssignWithWalrus",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/types.py",
  "lineno": "7",
  "column": "0",
  "slicing": "['AnyAssignWithWalrus = Union[AnyAssign, NamedExpr]\\n']",
  "context": "h for assign elements, we also need typed assign.\nAnyAssignWithWalrus = Union[AnyAssign, NamedExpr]\n"
 },
 "1755": {
  "name": "_CONST_NODE_TYPE_NAMES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/routing.py",
  "lineno": "10",
  "column": "0",
  "slicing": "['_CONST_NODE_TYPE_NAMES: Final = types.MappingProxyType({\\n', '            type_name = _CONST_NODE_TYPE_NAMES.get(type(node.value))\\n', \"            'visit_{0}'.format(type_name),\\n\"]",
  "context": "and ast types map to each other, copied from ast.\n_CONST_NODE_TYPE_NAMES: Final = types.MappingProxyType({\n    bool: 'NameConstant',  # should be before int\n"
 },
 "1756": {
  "name": "PY38",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/constants.py",
  "lineno": "6",
  "column": "0",
  "slicing": "['PY38: Final = sys.version_info >= (3, 8)\\n']",
  "context": " This indicates that we are running on python3.8+\nPY38: Final = sys.version_info >= (3, 8)\n"
 },
 "1757": {
  "name": "value",
  "type": "UnDefined",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/nodes.py",
  "lineno": "23",
  "column": "8",
  "slicing": "['        value: ast.expr  # noqa: WPS110\\n']",
  "context": "   Copied from ast.pyi file.\n        \"\"\"\n\n        value: ast.expr  # noqa: WPS110\n        target: ast.expr\n\n    class Constant(ast.e"
 },
 "1758": {
  "name": "target",
  "type": "UnDefined",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/nodes.py",
  "lineno": "24",
  "column": "8",
  "slicing": "['        target: ast.expr\\n']",
  "context": "\n\n        value: ast.expr  # noqa: WPS110\n        target: ast.expr\n\n    class Constant(ast.expr):  # noqa: WPS440\n   "
 },
 "1759": {
  "name": "value",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/nodes.py",
  "lineno": "41",
  "column": "8",
  "slicing": "['        value: Any  # noqa: WPS110\\n']",
  "context": "   Copied from ast.pyi file.\n        \"\"\"\n\n        value: Any  # noqa: WPS110\n        kind: Optional[str]\n\n        s: Any  # noq"
 },
 "1760": {
  "name": "kind",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/nodes.py",
  "lineno": "42",
  "column": "8",
  "slicing": "['        kind: Optional[str]\\n']",
  "context": "  \"\"\"\n\n        value: Any  # noqa: WPS110\n        kind: Optional[str]\n\n        s: Any  # noqa: WPS111\n        n: complex"
 },
 "1761": {
  "name": "s",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/nodes.py",
  "lineno": "44",
  "column": "8",
  "slicing": "['        s: Any  # noqa: WPS111\\n']",
  "context": "noqa: WPS110\n        kind: Optional[str]\n\n        s: Any  # noqa: WPS111\n        n: complex  # noqa: WPS111\n"
 },
 "1762": {
  "name": "n",
  "type": "complex",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/compat/nodes.py",
  "lineno": "45",
  "column": "8",
  "slicing": "['        n: complex  # noqa: WPS111\\n']",
  "context": "onal[str]\n\n        s: Any  # noqa: WPS111\n        n: complex  # noqa: WPS111\n"
 },
 "1763": {
  "name": "PRESET",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/presets/types/tree.py",
  "lineno": "26",
  "column": "0",
  "slicing": "['PRESET: Final = (\\n']",
  "context": "l general visitors to be later passed to checker:\nPRESET: Final = (\n    # General:\n    statements.StatementsWithBodies"
 },
 "1764": {
  "name": "PRESET",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/presets/types/filename.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['PRESET: Final = (\\n']",
  "context": ")\n\n#: Here we define all filename-based visitors.\nPRESET: Final = (\n    WrongModuleNameVisitor,\n)\n"
 },
 "1765": {
  "name": "PRESET",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/presets/types/file_tokens.py",
  "lineno": "12",
  "column": "0",
  "slicing": "['PRESET: Final = (\\n']",
  "context": "n related visitors to be later passed to checker:\nPRESET: Final = (\n    comments.WrongCommentVisitor,\n    comments.She"
 },
 "1766": {
  "name": "PRESET",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/presets/topics/complexity.py",
  "lineno": "18",
  "column": "0",
  "slicing": "['PRESET: Final = (\\n']",
  "context": "y related visitors to be later passed to checker:\nPRESET: Final = (\n    function.FunctionComplexityVisitor,\n    functi"
 },
 "1767": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "7",
  "column": "17",
  "slicing": "['def _convert_num(node: Optional[ast.AST]):\\n', 'def _convert_signed_num(node: Optional[ast.AST]):\\n', '    unary_operators = (ast.UAdd, ast.USub)\\n', '    if isinstance(node, ast.UnaryOp) and isinstance(node.op, unary_operators):\\n', '        operand = _convert_num(node.operand)\\n', '        return +operand if isinstance(node.op, ast.UAdd) else -operand\\n', '    return _convert_num(node)\\n', 'def _convert_complex(node: ast.BinOp) -> Optional[complex]:\\n', '    left = _convert_signed_num(node.left)\\n', '    right = _convert_num(node.right)\\n', '    if isinstance(left, (int, float)) and isinstance(right, complex):\\n', '        if isinstance(node.op, ast.Add):\\n', '            return left + right\\n', '        return left - right\\n', 'def _convert_iterable(node: Union[ast.Tuple, ast.List, ast.Set, ast.Dict]):\\n', '    if isinstance(node, ast.Tuple):\\n', '        return tuple(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.List):\\n', '        return list(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.Set):\\n', '        return set(map(literal_eval_with_names, node.elts))\\n', '        map(literal_eval_with_names, node.keys),\\n', '        map(literal_eval_with_names, node.values),\\n', '    binary_operators = (ast.Add, ast.Sub)\\n', '    if isinstance(node, (Constant, ast.NameConstant)):\\n', '        return node.value\\n', '    elif isinstance(node, (ast.Str, ast.Bytes, ast.Num)):  # pragma: py-gte-38\\n', '        return node.n if isinstance(node, ast.Num) else \\'\"{0!r}\"\\'.format(node.s)\\n', '    elif isinstance(node, (ast.Tuple, ast.List, ast.Set, ast.Dict)):\\n', '        return _convert_iterable(node)\\n', '    elif isinstance(node, ast.BinOp) and isinstance(node.op, binary_operators):\\n', '        maybe_complex = _convert_complex(node)\\n', '        if maybe_complex is not None:\\n', '            return maybe_complex\\n', '    return _convert_signed_num(node)\\n']",
  "context": "e.compat.nodes import Constant\n\n\ndef _convert_num(node: Optional[ast.AST]):\n    if isinstance(node, Constant):  # pragma: py-l"
 },
 "1768": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "20",
  "column": "24",
  "slicing": "['def _convert_num(node: Optional[ast.AST]):\\n', 'def _convert_signed_num(node: Optional[ast.AST]):\\n', '    unary_operators = (ast.UAdd, ast.USub)\\n', '    if isinstance(node, ast.UnaryOp) and isinstance(node.op, unary_operators):\\n', '        operand = _convert_num(node.operand)\\n', '        return +operand if isinstance(node.op, ast.UAdd) else -operand\\n', '    return _convert_num(node)\\n', 'def _convert_complex(node: ast.BinOp) -> Optional[complex]:\\n', '    left = _convert_signed_num(node.left)\\n', '    right = _convert_num(node.right)\\n', '    if isinstance(left, (int, float)) and isinstance(right, complex):\\n', '        if isinstance(node.op, ast.Add):\\n', '            return left + right\\n', '        return left - right\\n', 'def _convert_iterable(node: Union[ast.Tuple, ast.List, ast.Set, ast.Dict]):\\n', '    if isinstance(node, ast.Tuple):\\n', '        return tuple(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.List):\\n', '        return list(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.Set):\\n', '        return set(map(literal_eval_with_names, node.elts))\\n', '        map(literal_eval_with_names, node.keys),\\n', '        map(literal_eval_with_names, node.values),\\n', '    binary_operators = (ast.Add, ast.Sub)\\n', '    if isinstance(node, (Constant, ast.NameConstant)):\\n', '        return node.value\\n', '    elif isinstance(node, (ast.Str, ast.Bytes, ast.Num)):  # pragma: py-gte-38\\n', '        return node.n if isinstance(node, ast.Num) else \\'\"{0!r}\"\\'.format(node.s)\\n', '    elif isinstance(node, (ast.Tuple, ast.List, ast.Set, ast.Dict)):\\n', '        return _convert_iterable(node)\\n', '    elif isinstance(node, ast.BinOp) and isinstance(node.op, binary_operators):\\n', '        maybe_complex = _convert_complex(node)\\n', '        if maybe_complex is not None:\\n', '            return maybe_complex\\n', '    return _convert_signed_num(node)\\n']",
  "context": "g: {0!r}'.format(node))\n\n\ndef _convert_signed_num(node: Optional[ast.AST]):\n    unary_operators = (ast.UAdd, ast.USub)\n    if "
 },
 "1769": {
  "name": "unary_operators",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    unary_operators = (ast.UAdd, ast.USub)\\n', '    if isinstance(node, ast.UnaryOp) and isinstance(node.op, unary_operators):\\n']",
  "context": "_convert_signed_num(node: Optional[ast.AST]):\n    unary_operators = (ast.UAdd, ast.USub)\n    if isinstance(node, ast.UnaryOp) and isinstanc"
 },
 "1770": {
  "name": "operand",
  "type": "_convert_num",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "23",
  "column": "8",
  "slicing": "['def _convert_num(node: Optional[ast.AST]):\\n', 'def _convert_signed_num(node: Optional[ast.AST]):\\n', '    unary_operators = (ast.UAdd, ast.USub)\\n', '    if isinstance(node, ast.UnaryOp) and isinstance(node.op, unary_operators):\\n', '        operand = _convert_num(node.operand)\\n', '        return +operand if isinstance(node.op, ast.UAdd) else -operand\\n', '    return _convert_num(node)\\n', 'def _convert_complex(node: ast.BinOp) -> Optional[complex]:\\n', '    left = _convert_signed_num(node.left)\\n', '    right = _convert_num(node.right)\\n', '    if isinstance(left, (int, float)) and isinstance(right, complex):\\n', '        if isinstance(node.op, ast.Add):\\n', '            return left + right\\n', '        return left - right\\n', 'def _convert_iterable(node: Union[ast.Tuple, ast.List, ast.Set, ast.Dict]):\\n', '    if isinstance(node, ast.Tuple):\\n', '        return tuple(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.List):\\n', '        return list(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.Set):\\n', '        return set(map(literal_eval_with_names, node.elts))\\n', '        map(literal_eval_with_names, node.keys),\\n', '        map(literal_eval_with_names, node.values),\\n', '    binary_operators = (ast.Add, ast.Sub)\\n', '    if isinstance(node, (Constant, ast.NameConstant)):\\n', '        return node.value\\n', '    elif isinstance(node, (ast.Str, ast.Bytes, ast.Num)):  # pragma: py-gte-38\\n', '        return node.n if isinstance(node, ast.Num) else \\'\"{0!r}\"\\'.format(node.s)\\n', '    elif isinstance(node, (ast.Tuple, ast.List, ast.Set, ast.Dict)):\\n', '        return _convert_iterable(node)\\n', '    elif isinstance(node, ast.BinOp) and isinstance(node.op, binary_operators):\\n', '        maybe_complex = _convert_complex(node)\\n', '        if maybe_complex is not None:\\n', '            return maybe_complex\\n', '    return _convert_signed_num(node)\\n']",
  "context": "and isinstance(node.op, unary_operators):\n        operand = _convert_num(node.operand)\n        return +operand if isinstance(node.op, ast"
 },
 "1771": {
  "name": "left",
  "type": "_convert_signed_num",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['def _convert_num(node: Optional[ast.AST]):\\n', 'def _convert_signed_num(node: Optional[ast.AST]):\\n', '    unary_operators = (ast.UAdd, ast.USub)\\n', '    if isinstance(node, ast.UnaryOp) and isinstance(node.op, unary_operators):\\n', '        operand = _convert_num(node.operand)\\n', '        return +operand if isinstance(node.op, ast.UAdd) else -operand\\n', '    return _convert_num(node)\\n', 'def _convert_complex(node: ast.BinOp) -> Optional[complex]:\\n', '    left = _convert_signed_num(node.left)\\n', '    right = _convert_num(node.right)\\n', '    if isinstance(left, (int, float)) and isinstance(right, complex):\\n', '        if isinstance(node.op, ast.Add):\\n', '            return left + right\\n', '        return left - right\\n', 'def _convert_iterable(node: Union[ast.Tuple, ast.List, ast.Set, ast.Dict]):\\n', '    if isinstance(node, ast.Tuple):\\n', '        return tuple(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.List):\\n', '        return list(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.Set):\\n', '        return set(map(literal_eval_with_names, node.elts))\\n', '        map(literal_eval_with_names, node.keys),\\n', '        map(literal_eval_with_names, node.values),\\n', '    binary_operators = (ast.Add, ast.Sub)\\n', '    if isinstance(node, (Constant, ast.NameConstant)):\\n', '        return node.value\\n', '    elif isinstance(node, (ast.Str, ast.Bytes, ast.Num)):  # pragma: py-gte-38\\n', '        return node.n if isinstance(node, ast.Num) else \\'\"{0!r}\"\\'.format(node.s)\\n', '    elif isinstance(node, (ast.Tuple, ast.List, ast.Set, ast.Dict)):\\n', '        return _convert_iterable(node)\\n', '    elif isinstance(node, ast.BinOp) and isinstance(node.op, binary_operators):\\n', '        maybe_complex = _convert_complex(node)\\n', '        if maybe_complex is not None:\\n', '            return maybe_complex\\n', '    return _convert_signed_num(node)\\n']",
  "context": "omplex(node: ast.BinOp) -> Optional[complex]:\n    left = _convert_signed_num(node.left)\n    right = _convert_num(node.right)\n    if isinst"
 },
 "1772": {
  "name": "right",
  "type": "_convert_num",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['def _convert_num(node: Optional[ast.AST]):\\n', 'def _convert_signed_num(node: Optional[ast.AST]):\\n', '    unary_operators = (ast.UAdd, ast.USub)\\n', '    if isinstance(node, ast.UnaryOp) and isinstance(node.op, unary_operators):\\n', '        operand = _convert_num(node.operand)\\n', '        return +operand if isinstance(node.op, ast.UAdd) else -operand\\n', '    return _convert_num(node)\\n', 'def _convert_complex(node: ast.BinOp) -> Optional[complex]:\\n', '    left = _convert_signed_num(node.left)\\n', '    right = _convert_num(node.right)\\n', '    if isinstance(left, (int, float)) and isinstance(right, complex):\\n', '        if isinstance(node.op, ast.Add):\\n', '            return left + right\\n', '        return left - right\\n', 'def _convert_iterable(node: Union[ast.Tuple, ast.List, ast.Set, ast.Dict]):\\n', '    if isinstance(node, ast.Tuple):\\n', '        return tuple(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.List):\\n', '        return list(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.Set):\\n', '        return set(map(literal_eval_with_names, node.elts))\\n', '        map(literal_eval_with_names, node.keys),\\n', '        map(literal_eval_with_names, node.values),\\n', '    binary_operators = (ast.Add, ast.Sub)\\n', '    if isinstance(node, (Constant, ast.NameConstant)):\\n', '        return node.value\\n', '    elif isinstance(node, (ast.Str, ast.Bytes, ast.Num)):  # pragma: py-gte-38\\n', '        return node.n if isinstance(node, ast.Num) else \\'\"{0!r}\"\\'.format(node.s)\\n', '    elif isinstance(node, (ast.Tuple, ast.List, ast.Set, ast.Dict)):\\n', '        return _convert_iterable(node)\\n', '    elif isinstance(node, ast.BinOp) and isinstance(node.op, binary_operators):\\n', '        maybe_complex = _convert_complex(node)\\n', '        if maybe_complex is not None:\\n', '            return maybe_complex\\n', '    return _convert_signed_num(node)\\n']",
  "context": "x]:\n    left = _convert_signed_num(node.left)\n    right = _convert_num(node.right)\n    if isinstance(left, (int, float)) and isinstan"
 },
 "1773": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "38",
  "column": "22",
  "slicing": "['def _convert_num(node: Optional[ast.AST]):\\n', 'def _convert_signed_num(node: Optional[ast.AST]):\\n', '    unary_operators = (ast.UAdd, ast.USub)\\n', '    if isinstance(node, ast.UnaryOp) and isinstance(node.op, unary_operators):\\n', '        operand = _convert_num(node.operand)\\n', '        return +operand if isinstance(node.op, ast.UAdd) else -operand\\n', '    return _convert_num(node)\\n', 'def _convert_complex(node: ast.BinOp) -> Optional[complex]:\\n', '    left = _convert_signed_num(node.left)\\n', '    right = _convert_num(node.right)\\n', '    if isinstance(left, (int, float)) and isinstance(right, complex):\\n', '        if isinstance(node.op, ast.Add):\\n', '            return left + right\\n', '        return left - right\\n', 'def _convert_iterable(node: Union[ast.Tuple, ast.List, ast.Set, ast.Dict]):\\n', '    if isinstance(node, ast.Tuple):\\n', '        return tuple(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.List):\\n', '        return list(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.Set):\\n', '        return set(map(literal_eval_with_names, node.elts))\\n', '        map(literal_eval_with_names, node.keys),\\n', '        map(literal_eval_with_names, node.values),\\n', '    binary_operators = (ast.Add, ast.Sub)\\n', '    if isinstance(node, (Constant, ast.NameConstant)):\\n', '        return node.value\\n', '    elif isinstance(node, (ast.Str, ast.Bytes, ast.Num)):  # pragma: py-gte-38\\n', '        return node.n if isinstance(node, ast.Num) else \\'\"{0!r}\"\\'.format(node.s)\\n', '    elif isinstance(node, (ast.Tuple, ast.List, ast.Set, ast.Dict)):\\n', '        return _convert_iterable(node)\\n', '    elif isinstance(node, ast.BinOp) and isinstance(node.op, binary_operators):\\n', '        maybe_complex = _convert_complex(node)\\n', '        if maybe_complex is not None:\\n', '            return maybe_complex\\n', '    return _convert_signed_num(node)\\n']",
  "context": "t - right\n    return None\n\n\ndef _convert_iterable(node: Union[ast.Tuple, ast.List, ast.Set, ast.Dict]):\n    if isinstance(node, ast.Tuple):\n        return"
 },
 "1774": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "52",
  "column": "4",
  "slicing": "['    node: Optional[ast.AST],\\n']",
  "context": "\ndef literal_eval_with_names(  # noqa: WPS231\n    node: Optional[ast.AST],\n) -> Any:\n    \"\"\"\n    Safely evaluate constants an"
 },
 "1775": {
  "name": "binary_operators",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['def _convert_num(node: Optional[ast.AST]):\\n', 'def _convert_signed_num(node: Optional[ast.AST]):\\n', '    unary_operators = (ast.UAdd, ast.USub)\\n', '    if isinstance(node, ast.UnaryOp) and isinstance(node.op, unary_operators):\\n', '        operand = _convert_num(node.operand)\\n', '        return +operand if isinstance(node.op, ast.UAdd) else -operand\\n', '    return _convert_num(node)\\n', 'def _convert_complex(node: ast.BinOp) -> Optional[complex]:\\n', '    left = _convert_signed_num(node.left)\\n', '    right = _convert_num(node.right)\\n', '    if isinstance(left, (int, float)) and isinstance(right, complex):\\n', '        if isinstance(node.op, ast.Add):\\n', '            return left + right\\n', '        return left - right\\n', 'def _convert_iterable(node: Union[ast.Tuple, ast.List, ast.Set, ast.Dict]):\\n', '    if isinstance(node, ast.Tuple):\\n', '        return tuple(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.List):\\n', '        return list(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.Set):\\n', '        return set(map(literal_eval_with_names, node.elts))\\n', '        map(literal_eval_with_names, node.keys),\\n', '        map(literal_eval_with_names, node.values),\\n', '    binary_operators = (ast.Add, ast.Sub)\\n', '    if isinstance(node, (Constant, ast.NameConstant)):\\n', '        return node.value\\n', '    elif isinstance(node, (ast.Str, ast.Bytes, ast.Num)):  # pragma: py-gte-38\\n', '        return node.n if isinstance(node, ast.Num) else \\'\"{0!r}\"\\'.format(node.s)\\n', '    elif isinstance(node, (ast.Tuple, ast.List, ast.Set, ast.Dict)):\\n', '        return _convert_iterable(node)\\n', '    elif isinstance(node, ast.BinOp) and isinstance(node.op, binary_operators):\\n', '        maybe_complex = _convert_complex(node)\\n', '        if maybe_complex is not None:\\n', '            return maybe_complex\\n', '    return _convert_signed_num(node)\\n']",
  "context": "e to the original source as possible.\n    \"\"\"\n    binary_operators = (ast.Add, ast.Sub)\n    if isinstance(node, (Constant, ast.NameConstan"
 },
 "1776": {
  "name": "maybe_complex",
  "type": "_convert_complex",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/safe_eval.py",
  "lineno": "77",
  "column": "8",
  "slicing": "['def _convert_num(node: Optional[ast.AST]):\\n', 'def _convert_signed_num(node: Optional[ast.AST]):\\n', '    unary_operators = (ast.UAdd, ast.USub)\\n', '    if isinstance(node, ast.UnaryOp) and isinstance(node.op, unary_operators):\\n', '        operand = _convert_num(node.operand)\\n', '        return +operand if isinstance(node.op, ast.UAdd) else -operand\\n', '    return _convert_num(node)\\n', 'def _convert_complex(node: ast.BinOp) -> Optional[complex]:\\n', '    left = _convert_signed_num(node.left)\\n', '    right = _convert_num(node.right)\\n', '    if isinstance(left, (int, float)) and isinstance(right, complex):\\n', '        if isinstance(node.op, ast.Add):\\n', '            return left + right\\n', '        return left - right\\n', 'def _convert_iterable(node: Union[ast.Tuple, ast.List, ast.Set, ast.Dict]):\\n', '    if isinstance(node, ast.Tuple):\\n', '        return tuple(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.List):\\n', '        return list(map(literal_eval_with_names, node.elts))\\n', '    elif isinstance(node, ast.Set):\\n', '        return set(map(literal_eval_with_names, node.elts))\\n', '        map(literal_eval_with_names, node.keys),\\n', '        map(literal_eval_with_names, node.values),\\n', '    binary_operators = (ast.Add, ast.Sub)\\n', '    if isinstance(node, (Constant, ast.NameConstant)):\\n', '        return node.value\\n', '    elif isinstance(node, (ast.Str, ast.Bytes, ast.Num)):  # pragma: py-gte-38\\n', '        return node.n if isinstance(node, ast.Num) else \\'\"{0!r}\"\\'.format(node.s)\\n', '    elif isinstance(node, (ast.Tuple, ast.List, ast.Set, ast.Dict)):\\n', '        return _convert_iterable(node)\\n', '    elif isinstance(node, ast.BinOp) and isinstance(node.op, binary_operators):\\n', '        maybe_complex = _convert_complex(node)\\n', '        if maybe_complex is not None:\\n', '            return maybe_complex\\n', '    return _convert_signed_num(node)\\n']",
  "context": "nd isinstance(node.op, binary_operators):\n        maybe_complex = _convert_complex(node)\n        if maybe_complex is not None:\n            "
 },
 "1777": {
  "name": "MATCHING",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tokens.py",
  "lineno": "5",
  "column": "0",
  "slicing": "['MATCHING: Mapping[int, int] = types.MappingProxyType({\\n', 'NEWLINES: FrozenSet[int] = frozenset((\\n', '    *NEWLINES,\\n', '    *MATCHING.values(),\\n', '    split = string.split(string[-1])\\n', \"    return split[0], string.replace(split[0], '', 1)\\n\", '    for token in tokens:\\n', '        if token.exact_type not in container:\\n', '    return token.string[1:].strip()\\n', '    index = list(MATCHING.values()).index(bracket.exact_type)\\n', '    return list(MATCHING.keys())[index]\\n', '        tokens[index + 1:],\\n', '        NEWLINES.union({tokenize.COMMENT}),\\n']",
  "context": "ainer, FrozenSet, Iterable, List, Mapping, Tuple\n\nMATCHING: Mapping[int, int] = types.MappingProxyType({\n    tokenize.LBRACE: tokenize.RBRACE,\n    tokenize"
 },
 "1778": {
  "name": "NEWLINES",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tokens.py",
  "lineno": "11",
  "column": "0",
  "slicing": "['NEWLINES: FrozenSet[int] = frozenset((\\n', '    *NEWLINES,\\n', '        NEWLINES.union({tokenize.COMMENT}),\\n']",
  "context": "enize.RSQB,\n    tokenize.LPAR: tokenize.RPAR,\n})\n\nNEWLINES: FrozenSet[int] = frozenset((\n    tokenize.NL,\n    tokenize.NEWLINE,\n))\n\nALLOWED"
 },
 "1779": {
  "name": "ALLOWED_EMPTY_LINE_TOKENS",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tokens.py",
  "lineno": "16",
  "column": "0",
  "slicing": "['ALLOWED_EMPTY_LINE_TOKENS: FrozenSet[int] = frozenset((\\n']",
  "context": "nset((\n    tokenize.NL,\n    tokenize.NEWLINE,\n))\n\nALLOWED_EMPTY_LINE_TOKENS: FrozenSet[int] = frozenset((\n    *NEWLINES,\n    *MATCHING.values(),\n))\n\n\ndef sp"
 },
 "1780": {
  "name": "string",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tokens.py",
  "lineno": "22",
  "column": "19",
  "slicing": "['def split_prefixes(string: str) -> Tuple[str, str]:\\n']",
  "context": ",\n    *MATCHING.values(),\n))\n\n\ndef split_prefixes(string: str) -> Tuple[str, str]:\n    \"\"\"\n    Splits string repr by prefixes and the"
 },
 "1781": {
  "name": "string_contents",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tokens.py",
  "lineno": "39",
  "column": "29",
  "slicing": "['def has_triple_string_quotes(string_contents: str) -> bool:\\n']",
  "context": "e(split[0], '', 1)\n\n\ndef has_triple_string_quotes(string_contents: str) -> bool:\n    \"\"\"Tells whether string token is written as in"
 },
 "1782": {
  "name": "tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tokens.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['    tokens: Iterable[tokenize.TokenInfo],\\n', '        tokens[index + 1:],\\n']",
  "context": "rn True\n    return False\n\n\ndef only_contains(\n    tokens: Iterable[tokenize.TokenInfo],\n    container: Container[int],\n) -> bool:\n    \"\"\"D"
 },
 "1783": {
  "name": "container",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tokens.py",
  "lineno": "50",
  "column": "4",
  "slicing": "['    container: Container[int],\\n', '        if token.exact_type not in container:\\n']",
  "context": "ns(\n    tokens: Iterable[tokenize.TokenInfo],\n    container: Container[int],\n) -> bool:\n    \"\"\"Determines that only tokens from"
 },
 "1784": {
  "name": "tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tokens.py",
  "lineno": "79",
  "column": "17",
  "slicing": "['def last_bracket(tokens: List[tokenize.TokenInfo], index: int) -> bool:\\n']",
  "context": "n list(MATCHING.keys())[index]\n\n\ndef last_bracket(tokens: List[tokenize.TokenInfo], index: int) -> bool:\n    \"\"\"Tells whether the given index is the last b"
 },
 "1785": {
  "name": "index",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tokens.py",
  "lineno": "79",
  "column": "51",
  "slicing": "['def last_bracket(tokens: List[tokenize.TokenInfo], index: int) -> bool:\\n']",
  "context": "ef last_bracket(tokens: List[tokenize.TokenInfo], index: int) -> bool:\n    \"\"\"Tells whether the given index is the last b"
 },
 "1786": {
  "name": "filename",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/system.py",
  "lineno": "6",
  "column": "23",
  "slicing": "['def is_executable_file(filename: str) -> bool:\\n']",
  "context": "stants import WINDOWS_OS\n\n\ndef is_executable_file(filename: str) -> bool:\n    \"\"\"Checks if a file is executable.\"\"\"\n    retu"
 },
 "1787": {
  "name": "file_path",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/filenames.py",
  "lineno": "4",
  "column": "13",
  "slicing": "['def get_stem(file_path: str) -> str:\\n']",
  "context": "from pathlib import PurePath\n\n\ndef get_stem(file_path: str) -> str:\n    \"\"\"\n    Returns the last element of path witho"
 },
 "1788": {
  "name": "_SubnodeType",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/walk.py",
  "lineno": "7",
  "column": "0",
  "slicing": "[\"_SubnodeType = TypeVar('_SubnodeType', bound=ast.AST)\\n\", '    subnodes_type: Type[_SubnodeType],\\n', ') -> Iterator[_SubnodeType]:\\n']",
  "context": "m wemake_python_styleguide.types import AnyNodes\n\n_SubnodeType = TypeVar('_SubnodeType', bound=ast.AST)\n_IsInstanceContainer = Union[AnyNodes, type]\n\n\ndef"
 },
 "1789": {
  "name": "_IsInstanceContainer",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/walk.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['_IsInstanceContainer = Union[AnyNodes, type]\\n', '    to_check: _IsInstanceContainer,\\n', '    parents: _IsInstanceContainer,\\n']",
  "context": "nodeType = TypeVar('_SubnodeType', bound=ast.AST)\n_IsInstanceContainer = Union[AnyNodes, type]\n\n\ndef is_contained(\n    node: ast.AST,\n    to_chec"
 },
 "1790": {
  "name": "to_check",
  "type": "_IsInstanceContainer",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/walk.py",
  "lineno": "13",
  "column": "4",
  "slicing": "['    to_check: _IsInstanceContainer,\\n']",
  "context": " type]\n\n\ndef is_contained(\n    node: ast.AST,\n    to_check: _IsInstanceContainer,\n) -> bool:\n    \"\"\"\n    Checks whether node does co"
 },
 "1791": {
  "name": "parents",
  "type": "_IsInstanceContainer",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/walk.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    parents: _IsInstanceContainer,\\n']",
  "context": "\n\n\ndef get_closest_parent(\n    node: ast.AST,\n    parents: _IsInstanceContainer,\n) -> Optional[ast.AST]:\n    \"\"\"Returns the closes "
 },
 "1792": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/walk.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['_IsInstanceContainer = Union[AnyNodes, type]\\n', '    to_check: _IsInstanceContainer,\\n', '    for child in ast.walk(node):\\n', '        if isinstance(child, to_check):\\n', '    parents: _IsInstanceContainer,\\n', '    parent = get_parent(node)\\n', '        if parent is None:\\n', '        if isinstance(parent, parents):\\n', '            return parent\\n', '        parent = get_parent(parent)\\n', '    parent = get_parent(node)\\n', '        if parent is None:\\n', '        if parent == container:\\n', '        parent = get_parent(parent)\\n', '        if isinstance(child, subnodes_type):\\n', '            yield child\\n']",
  "context": "loses parent of a node of requested types.\"\"\"\n    parent = get_parent(node)\n    while True:\n        if parent is None:\n       "
 },
 "1793": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/walk.py",
  "lineno": "37",
  "column": "8",
  "slicing": "['_IsInstanceContainer = Union[AnyNodes, type]\\n', '    to_check: _IsInstanceContainer,\\n', '    for child in ast.walk(node):\\n', '        if isinstance(child, to_check):\\n', '    parents: _IsInstanceContainer,\\n', '    parent = get_parent(node)\\n', '        if parent is None:\\n', '        if isinstance(parent, parents):\\n', '            return parent\\n', '        parent = get_parent(parent)\\n', '    parent = get_parent(node)\\n', '        if parent is None:\\n', '        if parent == container:\\n', '        parent = get_parent(parent)\\n', '        if isinstance(child, subnodes_type):\\n', '            yield child\\n']",
  "context": "rent, parents):\n            return parent\n        parent = get_parent(parent)\n\n\ndef is_contained_by(node: ast.AST, container: as"
 },
 "1794": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/walk.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['_IsInstanceContainer = Union[AnyNodes, type]\\n', '    to_check: _IsInstanceContainer,\\n', '    for child in ast.walk(node):\\n', '        if isinstance(child, to_check):\\n', '    parents: _IsInstanceContainer,\\n', '    parent = get_parent(node)\\n', '        if parent is None:\\n', '        if isinstance(parent, parents):\\n', '            return parent\\n', '        parent = get_parent(parent)\\n', '    parent = get_parent(node)\\n', '        if parent is None:\\n', '        if parent == container:\\n', '        parent = get_parent(parent)\\n', '        if isinstance(child, subnodes_type):\\n', '            yield child\\n']",
  "context": "s.\n    Works with specific instances.\n    \"\"\"\n    parent = get_parent(node)\n    while True:\n        if parent is None:\n       "
 },
 "1795": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/walk.py",
  "lineno": "53",
  "column": "8",
  "slicing": "['_IsInstanceContainer = Union[AnyNodes, type]\\n', '    to_check: _IsInstanceContainer,\\n', '    for child in ast.walk(node):\\n', '        if isinstance(child, to_check):\\n', '    parents: _IsInstanceContainer,\\n', '    parent = get_parent(node)\\n', '        if parent is None:\\n', '        if isinstance(parent, parents):\\n', '            return parent\\n', '        parent = get_parent(parent)\\n', '    parent = get_parent(node)\\n', '        if parent is None:\\n', '        if parent == container:\\n', '        parent = get_parent(parent)\\n', '        if isinstance(child, subnodes_type):\\n', '            yield child\\n']",
  "context": "ent == container:\n            return True\n        parent = get_parent(parent)\n\n\ndef get_subnodes_by_type(\n    node: ast.AST,\n   "
 },
 "1796": {
  "name": "subnodes_type",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/walk.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['    subnodes_type: Type[_SubnodeType],\\n']",
  "context": "\ndef get_subnodes_by_type(\n    node: ast.AST,\n    subnodes_type: Type[_SubnodeType],\n) -> Iterator[_SubnodeType]:\n    \"\"\"Returns the li"
 },
 "1797": {
  "name": "text_data",
  "type": "wemake_python_styleguide.types.AnyTextPrimitive",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/source.py",
  "lineno": "13",
  "column": "18",
  "slicing": "['def render_string(text_data: AnyTextPrimitive) -> str:\\n']",
  "context": "astor.to_source(node).strip()\n\n\ndef render_string(text_data: AnyTextPrimitive) -> str:\n    \"\"\"\n    Method to render ``Str``, ``Bytes``, a"
 },
 "1798": {
  "name": "same_args",
  "type": "_has_same_args",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    same_args = _has_same_args(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n']",
  "context": "all`` is matched by arguments of ``node``.\"\"\"\n    same_args = _has_same_args(node, call)\n    same_vararg = _has_same_vararg(node, call)\n   "
 },
 "1799": {
  "name": "same_vararg",
  "type": "_has_same_vararg",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    same_vararg = _has_same_vararg(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n']",
  "context": "\"\"\n    same_args = _has_same_args(node, call)\n    same_vararg = _has_same_vararg(node, call)\n    same_kwarg = _has_same_kwarg(node, call)\n    s"
 },
 "1800": {
  "name": "same_kwarg",
  "type": "_has_same_kwarg",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    same_kwarg = _has_same_kwarg(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n']",
  "context": "   same_vararg = _has_same_vararg(node, call)\n    same_kwarg = _has_same_kwarg(node, call)\n    same_kw_args = _has_same_kw_args(node, call)\n "
 },
 "1801": {
  "name": "same_kw_args",
  "type": "_has_same_kw_args",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    same_kw_args = _has_same_kw_args(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n']",
  "context": "\n    same_kwarg = _has_same_kwarg(node, call)\n    same_kw_args = _has_same_kw_args(node, call)\n    return same_args and same_vararg and same_kwar"
 },
 "1802": {
  "name": "vararg_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['    vararg_name: Optional[str] = None\\n', '    if vararg_name and node.args.vararg:\\n', '        return node.args.vararg.arg == vararg_name\\n', '    return node.args.vararg == vararg_name  # type: ignore\\n']",
  "context": "has the same vararg ``*args`` as ``node``.\"\"\"\n    vararg_name: Optional[str] = None\n    for starred_arg in get_starred_args(call):\n   "
 },
 "1803": {
  "name": "kwarg_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['    kwarg_name: Optional[str] = None\\n', '    if node.args.kwarg and kwarg_name:\\n', '        return node.args.kwarg.arg == kwarg_name\\n', '    return node.args.kwarg == kwarg_name  # type: ignore\\n']",
  "context": " ``call`` has the same kwargs as ``node``.\"\"\"\n    kwarg_name: Optional[str] = None\n    null_arg_keywords = filter(lambda key: key.arg"
 },
 "1804": {
  "name": "null_arg_keywords",
  "type": "filter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['    same_args = _has_same_args(node, call)\\n', '    same_vararg = _has_same_vararg(node, call)\\n', '    same_kwarg = _has_same_kwarg(node, call)\\n', '    same_kw_args = _has_same_kw_args(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n', '    node: types.AnyFunctionDefAndLambda,\\n', '    node_args = get_posonlyargs(node) + node.args.args\\n', '    if not node_args or isinstance(node, ast.Lambda):\\n', '        return node_args\\n', '    if node_args[0].arg not in constants.SPECIAL_ARGUMENT_NAMES_WHITELIST:\\n', '        return node_args\\n', '    return node_args[1:]\\n', '    vararg_name: Optional[str] = None\\n', '    for starred_arg in get_starred_args(call):\\n', '        if isinstance(starred_arg.value, ast.Name):\\n', '            vararg_name = starred_arg.value.id\\n', '    if vararg_name and node.args.vararg:\\n', '        return node.args.vararg.arg == vararg_name\\n', '    return node.args.vararg == vararg_name  # type: ignore\\n', '    kwarg_name: Optional[str] = None\\n', '    null_arg_keywords = filter(lambda key: key.arg is None, call.keywords)\\n', '    for keyword in null_arg_keywords:\\n', '        if isinstance(keyword.value, ast.Name):\\n', '            kwarg_name = keyword.value.id\\n', '    if node.args.kwarg and kwarg_name:\\n', '        return node.args.kwarg.arg == kwarg_name\\n', '    return node.args.kwarg == kwarg_name  # type: ignore\\n', '    node_args = _get_args_without_special_argument(node)\\n', '    paired_arguments = zip_longest(call.args, node_args)\\n', '    for call_arg, func_arg in paired_arguments:\\n', '        if isinstance(call_arg, ast.Starred):\\n', '            if isinstance(func_arg, ast.arg):\\n', '        elif isinstance(call_arg, ast.Name):\\n', '            if not func_arg or call_arg.id != func_arg.arg:\\n', '    call: ast.Call,\\n', '    prepared_kw_args = {}\\n', '    real_kw_args = []\\n', '    for kw in call.keywords:\\n', '        if isinstance(kw.value, ast.Name) and kw.arg == kw.value.id:\\n', '            prepared_kw_args[kw.arg] = kw\\n', '        if not (isinstance(kw.value, ast.Name) and kw.arg is None):\\n', '            real_kw_args.append(kw)\\n', '    return prepared_kw_args, real_kw_args\\n', '    prepared_kw_args, real_kw_args = _clean_call_keyword_args(call)\\n', '    for func_arg in node.args.kwonlyargs:\\n', \"        func_arg_name = getattr(func_arg, 'arg', None)\\n\", '        call_arg = prepared_kw_args.get(func_arg_name)\\n', '        if func_arg and not call_arg:\\n', '    return len(real_kw_args) == len(node.args.kwonlyargs)\\n']",
  "context": "de``.\"\"\"\n    kwarg_name: Optional[str] = None\n    null_arg_keywords = filter(lambda key: key.arg is None, call.keywords)\n    for keyword in null_arg_keywords:\n        # `a"
 },
 "1805": {
  "name": "node_args",
  "type": "_get_args_without_special_argument",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['    same_args = _has_same_args(node, call)\\n', '    same_vararg = _has_same_vararg(node, call)\\n', '    same_kwarg = _has_same_kwarg(node, call)\\n', '    same_kw_args = _has_same_kw_args(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n', '    node: types.AnyFunctionDefAndLambda,\\n', '    node_args = get_posonlyargs(node) + node.args.args\\n', '    if not node_args or isinstance(node, ast.Lambda):\\n', '        return node_args\\n', '    if node_args[0].arg not in constants.SPECIAL_ARGUMENT_NAMES_WHITELIST:\\n', '        return node_args\\n', '    return node_args[1:]\\n', '    vararg_name: Optional[str] = None\\n', '    for starred_arg in get_starred_args(call):\\n', '        if isinstance(starred_arg.value, ast.Name):\\n', '            vararg_name = starred_arg.value.id\\n', '    if vararg_name and node.args.vararg:\\n', '        return node.args.vararg.arg == vararg_name\\n', '    return node.args.vararg == vararg_name  # type: ignore\\n', '    kwarg_name: Optional[str] = None\\n', '    null_arg_keywords = filter(lambda key: key.arg is None, call.keywords)\\n', '    for keyword in null_arg_keywords:\\n', '        if isinstance(keyword.value, ast.Name):\\n', '            kwarg_name = keyword.value.id\\n', '    if node.args.kwarg and kwarg_name:\\n', '        return node.args.kwarg.arg == kwarg_name\\n', '    return node.args.kwarg == kwarg_name  # type: ignore\\n', '    node_args = _get_args_without_special_argument(node)\\n', '    paired_arguments = zip_longest(call.args, node_args)\\n', '    for call_arg, func_arg in paired_arguments:\\n', '        if isinstance(call_arg, ast.Starred):\\n', '            if isinstance(func_arg, ast.arg):\\n', '        elif isinstance(call_arg, ast.Name):\\n', '            if not func_arg or call_arg.id != func_arg.arg:\\n', '    call: ast.Call,\\n', '    prepared_kw_args = {}\\n', '    real_kw_args = []\\n', '    for kw in call.keywords:\\n', '        if isinstance(kw.value, ast.Name) and kw.arg == kw.value.id:\\n', '            prepared_kw_args[kw.arg] = kw\\n', '        if not (isinstance(kw.value, ast.Name) and kw.arg is None):\\n', '            real_kw_args.append(kw)\\n', '    return prepared_kw_args, real_kw_args\\n', '    prepared_kw_args, real_kw_args = _clean_call_keyword_args(call)\\n', '    for func_arg in node.args.kwonlyargs:\\n', \"        func_arg_name = getattr(func_arg, 'arg', None)\\n\", '        call_arg = prepared_kw_args.get(func_arg_name)\\n', '        if func_arg and not call_arg:\\n', '    return len(real_kw_args) == len(node.args.kwonlyargs)\\n']",
  "context": "r ``/`` arguments as they also known.\n    \"\"\"\n    node_args = _get_args_without_special_argument(node)\n    paired_arguments = zip_longest(call.args, node"
 },
 "1806": {
  "name": "paired_arguments",
  "type": "itertools.zip_longest",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['    same_args = _has_same_args(node, call)\\n', '    same_vararg = _has_same_vararg(node, call)\\n', '    same_kwarg = _has_same_kwarg(node, call)\\n', '    same_kw_args = _has_same_kw_args(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n', '    node: types.AnyFunctionDefAndLambda,\\n', '    node_args = get_posonlyargs(node) + node.args.args\\n', '    if not node_args or isinstance(node, ast.Lambda):\\n', '        return node_args\\n', '    if node_args[0].arg not in constants.SPECIAL_ARGUMENT_NAMES_WHITELIST:\\n', '        return node_args\\n', '    return node_args[1:]\\n', '    vararg_name: Optional[str] = None\\n', '    for starred_arg in get_starred_args(call):\\n', '        if isinstance(starred_arg.value, ast.Name):\\n', '            vararg_name = starred_arg.value.id\\n', '    if vararg_name and node.args.vararg:\\n', '        return node.args.vararg.arg == vararg_name\\n', '    return node.args.vararg == vararg_name  # type: ignore\\n', '    kwarg_name: Optional[str] = None\\n', '    null_arg_keywords = filter(lambda key: key.arg is None, call.keywords)\\n', '    for keyword in null_arg_keywords:\\n', '        if isinstance(keyword.value, ast.Name):\\n', '            kwarg_name = keyword.value.id\\n', '    if node.args.kwarg and kwarg_name:\\n', '        return node.args.kwarg.arg == kwarg_name\\n', '    return node.args.kwarg == kwarg_name  # type: ignore\\n', '    node_args = _get_args_without_special_argument(node)\\n', '    paired_arguments = zip_longest(call.args, node_args)\\n', '    for call_arg, func_arg in paired_arguments:\\n', '        if isinstance(call_arg, ast.Starred):\\n', '            if isinstance(func_arg, ast.arg):\\n', '        elif isinstance(call_arg, ast.Name):\\n', '            if not func_arg or call_arg.id != func_arg.arg:\\n', '    call: ast.Call,\\n', '    prepared_kw_args = {}\\n', '    real_kw_args = []\\n', '    for kw in call.keywords:\\n', '        if isinstance(kw.value, ast.Name) and kw.arg == kw.value.id:\\n', '            prepared_kw_args[kw.arg] = kw\\n', '        if not (isinstance(kw.value, ast.Name) and kw.arg is None):\\n', '            real_kw_args.append(kw)\\n', '    return prepared_kw_args, real_kw_args\\n', '    prepared_kw_args, real_kw_args = _clean_call_keyword_args(call)\\n', '    for func_arg in node.args.kwonlyargs:\\n', \"        func_arg_name = getattr(func_arg, 'arg', None)\\n\", '        call_arg = prepared_kw_args.get(func_arg_name)\\n', '        if func_arg and not call_arg:\\n', '    return len(real_kw_args) == len(node.args.kwonlyargs)\\n']",
  "context": "gs = _get_args_without_special_argument(node)\n    paired_arguments = zip_longest(call.args, node_args)\n    for call_arg, func_arg in paired_arguments:\n  "
 },
 "1807": {
  "name": "prepared_kw_args",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "107",
  "column": "4",
  "slicing": "['    same_args = _has_same_args(node, call)\\n', '    same_vararg = _has_same_vararg(node, call)\\n', '    same_kwarg = _has_same_kwarg(node, call)\\n', '    same_kw_args = _has_same_kw_args(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n', '    node: types.AnyFunctionDefAndLambda,\\n', '    node_args = get_posonlyargs(node) + node.args.args\\n', '    if not node_args or isinstance(node, ast.Lambda):\\n', '        return node_args\\n', '    if node_args[0].arg not in constants.SPECIAL_ARGUMENT_NAMES_WHITELIST:\\n', '        return node_args\\n', '    return node_args[1:]\\n', '    vararg_name: Optional[str] = None\\n', '    for starred_arg in get_starred_args(call):\\n', '        if isinstance(starred_arg.value, ast.Name):\\n', '            vararg_name = starred_arg.value.id\\n', '    if vararg_name and node.args.vararg:\\n', '        return node.args.vararg.arg == vararg_name\\n', '    return node.args.vararg == vararg_name  # type: ignore\\n', '    kwarg_name: Optional[str] = None\\n', '    null_arg_keywords = filter(lambda key: key.arg is None, call.keywords)\\n', '    for keyword in null_arg_keywords:\\n', '        if isinstance(keyword.value, ast.Name):\\n', '            kwarg_name = keyword.value.id\\n', '    if node.args.kwarg and kwarg_name:\\n', '        return node.args.kwarg.arg == kwarg_name\\n', '    return node.args.kwarg == kwarg_name  # type: ignore\\n', '    node_args = _get_args_without_special_argument(node)\\n', '    paired_arguments = zip_longest(call.args, node_args)\\n', '    for call_arg, func_arg in paired_arguments:\\n', '        if isinstance(call_arg, ast.Starred):\\n', '            if isinstance(func_arg, ast.arg):\\n', '        elif isinstance(call_arg, ast.Name):\\n', '            if not func_arg or call_arg.id != func_arg.arg:\\n', '    call: ast.Call,\\n', '    prepared_kw_args = {}\\n', '    real_kw_args = []\\n', '    for kw in call.keywords:\\n', '        if isinstance(kw.value, ast.Name) and kw.arg == kw.value.id:\\n', '            prepared_kw_args[kw.arg] = kw\\n', '        if not (isinstance(kw.value, ast.Name) and kw.arg is None):\\n', '            real_kw_args.append(kw)\\n', '    return prepared_kw_args, real_kw_args\\n', '    prepared_kw_args, real_kw_args = _clean_call_keyword_args(call)\\n', '    for func_arg in node.args.kwonlyargs:\\n', \"        func_arg_name = getattr(func_arg, 'arg', None)\\n\", '        call_arg = prepared_kw_args.get(func_arg_name)\\n', '        if func_arg and not call_arg:\\n', '    return len(real_kw_args) == len(node.args.kwonlyargs)\\n']",
  "context": "apping[str, ast.keyword], List[ast.keyword]]:\n    prepared_kw_args = {}\n    real_kw_args = []\n    for kw in call.keywords:"
 },
 "1808": {
  "name": "real_kw_args",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['    real_kw_args = []\\n', '            real_kw_args.append(kw)\\n', '    return prepared_kw_args, real_kw_args\\n', '    return len(real_kw_args) == len(node.args.kwonlyargs)\\n']",
  "context": "List[ast.keyword]]:\n    prepared_kw_args = {}\n    real_kw_args = []\n    for kw in call.keywords:\n        if isinstance"
 },
 "1809": {
  "name": "prepared_kw_args",
  "type": "_clean_call_keyword_args",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "123",
  "column": "4",
  "slicing": "['    same_args = _has_same_args(node, call)\\n', '    same_vararg = _has_same_vararg(node, call)\\n', '    same_kwarg = _has_same_kwarg(node, call)\\n', '    same_kw_args = _has_same_kw_args(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n', '    node: types.AnyFunctionDefAndLambda,\\n', '    node_args = get_posonlyargs(node) + node.args.args\\n', '    if not node_args or isinstance(node, ast.Lambda):\\n', '        return node_args\\n', '    if node_args[0].arg not in constants.SPECIAL_ARGUMENT_NAMES_WHITELIST:\\n', '        return node_args\\n', '    return node_args[1:]\\n', '    vararg_name: Optional[str] = None\\n', '    for starred_arg in get_starred_args(call):\\n', '        if isinstance(starred_arg.value, ast.Name):\\n', '            vararg_name = starred_arg.value.id\\n', '    if vararg_name and node.args.vararg:\\n', '        return node.args.vararg.arg == vararg_name\\n', '    return node.args.vararg == vararg_name  # type: ignore\\n', '    kwarg_name: Optional[str] = None\\n', '    null_arg_keywords = filter(lambda key: key.arg is None, call.keywords)\\n', '    for keyword in null_arg_keywords:\\n', '        if isinstance(keyword.value, ast.Name):\\n', '            kwarg_name = keyword.value.id\\n', '    if node.args.kwarg and kwarg_name:\\n', '        return node.args.kwarg.arg == kwarg_name\\n', '    return node.args.kwarg == kwarg_name  # type: ignore\\n', '    node_args = _get_args_without_special_argument(node)\\n', '    paired_arguments = zip_longest(call.args, node_args)\\n', '    for call_arg, func_arg in paired_arguments:\\n', '        if isinstance(call_arg, ast.Starred):\\n', '            if isinstance(func_arg, ast.arg):\\n', '        elif isinstance(call_arg, ast.Name):\\n', '            if not func_arg or call_arg.id != func_arg.arg:\\n', '    call: ast.Call,\\n', '    prepared_kw_args = {}\\n', '    real_kw_args = []\\n', '    for kw in call.keywords:\\n', '        if isinstance(kw.value, ast.Name) and kw.arg == kw.value.id:\\n', '            prepared_kw_args[kw.arg] = kw\\n', '        if not (isinstance(kw.value, ast.Name) and kw.arg is None):\\n', '            real_kw_args.append(kw)\\n', '    return prepared_kw_args, real_kw_args\\n', '    prepared_kw_args, real_kw_args = _clean_call_keyword_args(call)\\n', '    for func_arg in node.args.kwonlyargs:\\n', \"        func_arg_name = getattr(func_arg, 'arg', None)\\n\", '        call_arg = prepared_kw_args.get(func_arg_name)\\n', '        if func_arg and not call_arg:\\n', '    return len(real_kw_args) == len(node.args.kwonlyargs)\\n']",
  "context": "as the same keyword-only args as ``node``.\"\"\"\n    prepared_kw_args, real_kw_args = _clean_call_keyword_args(call)\n    for func_arg in node.args.kwonlyargs:\n        "
 },
 "1810": {
  "name": "real_kw_args",
  "type": "_clean_call_keyword_args",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "123",
  "column": "22",
  "slicing": "['    prepared_kw_args, real_kw_args = _clean_call_keyword_args(call)\\n', '    return len(real_kw_args) == len(node.args.kwonlyargs)\\n']",
  "context": "d-only args as ``node``.\"\"\"\n    prepared_kw_args, real_kw_args = _clean_call_keyword_args(call)\n    for func_arg in node.args.kwonlyargs:\n        "
 },
 "1811": {
  "name": "func_arg_name",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/function_args.py",
  "lineno": "125",
  "column": "8",
  "slicing": "['    same_args = _has_same_args(node, call)\\n', '    same_vararg = _has_same_vararg(node, call)\\n', '    same_kwarg = _has_same_kwarg(node, call)\\n', '    same_kw_args = _has_same_kw_args(node, call)\\n', '    return same_args and same_vararg and same_kwarg and same_kw_args\\n', '    node: types.AnyFunctionDefAndLambda,\\n', '    node_args = get_posonlyargs(node) + node.args.args\\n', '    if not node_args or isinstance(node, ast.Lambda):\\n', '        return node_args\\n', '    if node_args[0].arg not in constants.SPECIAL_ARGUMENT_NAMES_WHITELIST:\\n', '        return node_args\\n', '    return node_args[1:]\\n', '    vararg_name: Optional[str] = None\\n', '    for starred_arg in get_starred_args(call):\\n', '        if isinstance(starred_arg.value, ast.Name):\\n', '            vararg_name = starred_arg.value.id\\n', '    if vararg_name and node.args.vararg:\\n', '        return node.args.vararg.arg == vararg_name\\n', '    return node.args.vararg == vararg_name  # type: ignore\\n', '    kwarg_name: Optional[str] = None\\n', '    null_arg_keywords = filter(lambda key: key.arg is None, call.keywords)\\n', '    for keyword in null_arg_keywords:\\n', '        if isinstance(keyword.value, ast.Name):\\n', '            kwarg_name = keyword.value.id\\n', '    if node.args.kwarg and kwarg_name:\\n', '        return node.args.kwarg.arg == kwarg_name\\n', '    return node.args.kwarg == kwarg_name  # type: ignore\\n', '    node_args = _get_args_without_special_argument(node)\\n', '    paired_arguments = zip_longest(call.args, node_args)\\n', '    for call_arg, func_arg in paired_arguments:\\n', '        if isinstance(call_arg, ast.Starred):\\n', '            if isinstance(func_arg, ast.arg):\\n', '        elif isinstance(call_arg, ast.Name):\\n', '            if not func_arg or call_arg.id != func_arg.arg:\\n', '    call: ast.Call,\\n', '    prepared_kw_args = {}\\n', '    real_kw_args = []\\n', '    for kw in call.keywords:\\n', '        if isinstance(kw.value, ast.Name) and kw.arg == kw.value.id:\\n', '            prepared_kw_args[kw.arg] = kw\\n', '        if not (isinstance(kw.value, ast.Name) and kw.arg is None):\\n', '            real_kw_args.append(kw)\\n', '    return prepared_kw_args, real_kw_args\\n', '    prepared_kw_args, real_kw_args = _clean_call_keyword_args(call)\\n', '    for func_arg in node.args.kwonlyargs:\\n', \"        func_arg_name = getattr(func_arg, 'arg', None)\\n\", '        call_arg = prepared_kw_args.get(func_arg_name)\\n', '        if func_arg and not call_arg:\\n', '    return len(real_kw_args) == len(node.args.kwonlyargs)\\n']",
  "context": "    for func_arg in node.args.kwonlyargs:\n        func_arg_name = getattr(func_arg, 'arg', None)\n        call_arg = prepared_kw_args.get(func_arg_n"
 },
 "1812": {
  "name": "class_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "5",
  "column": "42",
  "slicing": "['def is_ordinary_super_call(node: ast.AST, class_name: str) -> bool:\\n']",
  "context": "ional\n\n\ndef is_ordinary_super_call(node: ast.AST, class_name: str) -> bool:\n    \"\"\"\n    Tells whether super ``call`` is ordina"
 },
 "1813": {
  "name": "call",
  "type": "_get_super_call",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    call = _get_super_call(node)\\n', '    if call is None:\\n', '    args_number = len(call.args) + len(call.keywords)\\n', '    if args_number == 0:\\n', '    return args_number == 2 and _is_super_called_with(\\n', '        call,\\n', '    call: ast.Call,\\n', '    *names: str,\\n', '    keyword_args = {}\\n', '    for keyword in call.keywords:\\n', '        if keyword.arg in names:\\n', '            keyword_args[keyword.arg] = keyword.value\\n', '    return keyword_args\\n', '    if len(call.args) == 2:  # branch for super(Test, self)\\n', '        arg1: Optional[ast.expr] = call.args[0]\\n', '        arg2: Optional[ast.expr] = call.args[1]\\n', '    elif len(call.keywords) == 2:  # branch for super(t=Test, obj=self)\\n', \"        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\\n\", \"        arg1 = keyword_args.get('t')\\n\", \"        arg2 = keyword_args.get('obj')\\n\", '        arg1 = call.args[0]\\n', '        arg2 = call.keywords[0].value\\n', '    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\\n', '    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\\n', '    return is_expected_type and is_expected_object\\n']",
  "context": "red as expected by\n    this function.\n    \"\"\"\n    call = _get_super_call(node)\n    if call is None:\n        return False\n    args"
 },
 "1814": {
  "name": "args_number",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    call = _get_super_call(node)\\n', '    if call is None:\\n', '    args_number = len(call.args) + len(call.keywords)\\n', '    if args_number == 0:\\n', '    return args_number == 2 and _is_super_called_with(\\n', '        call,\\n', '    call: ast.Call,\\n', '    *names: str,\\n', '    keyword_args = {}\\n', '    for keyword in call.keywords:\\n', '        if keyword.arg in names:\\n', '            keyword_args[keyword.arg] = keyword.value\\n', '    return keyword_args\\n', '    if len(call.args) == 2:  # branch for super(Test, self)\\n', '        arg1: Optional[ast.expr] = call.args[0]\\n', '        arg2: Optional[ast.expr] = call.args[1]\\n', '    elif len(call.keywords) == 2:  # branch for super(t=Test, obj=self)\\n', \"        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\\n\", \"        arg1 = keyword_args.get('t')\\n\", \"        arg2 = keyword_args.get('obj')\\n\", '        arg1 = call.args[0]\\n', '        arg2 = call.keywords[0].value\\n', '    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\\n', '    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\\n', '    return is_expected_type and is_expected_object\\n']",
  "context": "de)\n    if call is None:\n        return False\n    args_number = len(call.args) + len(call.keywords)\n    if args_number == 0:\n        return True\n    r"
 },
 "1815": {
  "name": "keyword_args",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['    call = _get_super_call(node)\\n', '    if call is None:\\n', '    args_number = len(call.args) + len(call.keywords)\\n', '    if args_number == 0:\\n', '    return args_number == 2 and _is_super_called_with(\\n', '        call,\\n', '    call: ast.Call,\\n', '    *names: str,\\n', '    keyword_args = {}\\n', '    for keyword in call.keywords:\\n', '        if keyword.arg in names:\\n', '            keyword_args[keyword.arg] = keyword.value\\n', '    return keyword_args\\n', '    if len(call.args) == 2:  # branch for super(Test, self)\\n', '        arg1: Optional[ast.expr] = call.args[0]\\n', '        arg2: Optional[ast.expr] = call.args[1]\\n', '    elif len(call.keywords) == 2:  # branch for super(t=Test, obj=self)\\n', \"        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\\n\", \"        arg1 = keyword_args.get('t')\\n\", \"        arg2 = keyword_args.get('obj')\\n\", '        arg1 = call.args[0]\\n', '        arg2 = call.keywords[0].value\\n', '    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\\n', '    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\\n', '    return is_expected_type and is_expected_object\\n']",
  "context": "ywords of ``call`` by specified ``names``.\"\"\"\n    keyword_args = {}\n    for keyword in call.keywords:\n        if keywo"
 },
 "1816": {
  "name": "type_",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "47",
  "column": "42",
  "slicing": "['def _is_super_called_with(call: ast.Call, type_: str, object_: str) -> bool:\\n']",
  "context": "_args\n\n\ndef _is_super_called_with(call: ast.Call, type_: str, object_: str) -> bool:\n    \"\"\"Tells whether super ``call`` was done with "
 },
 "1817": {
  "name": "object_",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "47",
  "column": "54",
  "slicing": "['def _is_super_called_with(call: ast.Call, type_: str, object_: str) -> bool:\\n']",
  "context": "_is_super_called_with(call: ast.Call, type_: str, object_: str) -> bool:\n    \"\"\"Tells whether super ``call`` was done with "
 },
 "1818": {
  "name": "arg1",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "50",
  "column": "8",
  "slicing": "['    call = _get_super_call(node)\\n', '    if call is None:\\n', '    args_number = len(call.args) + len(call.keywords)\\n', '    if args_number == 0:\\n', '    return args_number == 2 and _is_super_called_with(\\n', '        call,\\n', '    call: ast.Call,\\n', '    *names: str,\\n', '    keyword_args = {}\\n', '    for keyword in call.keywords:\\n', '        if keyword.arg in names:\\n', '            keyword_args[keyword.arg] = keyword.value\\n', '    return keyword_args\\n', '    if len(call.args) == 2:  # branch for super(Test, self)\\n', '        arg1: Optional[ast.expr] = call.args[0]\\n', '        arg2: Optional[ast.expr] = call.args[1]\\n', '    elif len(call.keywords) == 2:  # branch for super(t=Test, obj=self)\\n', \"        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\\n\", \"        arg1 = keyword_args.get('t')\\n\", \"        arg2 = keyword_args.get('obj')\\n\", '        arg1 = call.args[0]\\n', '        arg2 = call.keywords[0].value\\n', '    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\\n', '    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\\n', '    return is_expected_type and is_expected_object\\n']",
  "context": "gs) == 2:  # branch for super(Test, self)\n        arg1: Optional[ast.expr] = call.args[0]\n        arg2: Optional[ast.expr] = call.args[1]\n  "
 },
 "1819": {
  "name": "arg2",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "51",
  "column": "8",
  "slicing": "['    call = _get_super_call(node)\\n', '    if call is None:\\n', '    args_number = len(call.args) + len(call.keywords)\\n', '    if args_number == 0:\\n', '    return args_number == 2 and _is_super_called_with(\\n', '        call,\\n', '    call: ast.Call,\\n', '    *names: str,\\n', '    keyword_args = {}\\n', '    for keyword in call.keywords:\\n', '        if keyword.arg in names:\\n', '            keyword_args[keyword.arg] = keyword.value\\n', '    return keyword_args\\n', '    if len(call.args) == 2:  # branch for super(Test, self)\\n', '        arg1: Optional[ast.expr] = call.args[0]\\n', '        arg2: Optional[ast.expr] = call.args[1]\\n', '    elif len(call.keywords) == 2:  # branch for super(t=Test, obj=self)\\n', \"        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\\n\", \"        arg1 = keyword_args.get('t')\\n\", \"        arg2 = keyword_args.get('obj')\\n\", '        arg1 = call.args[0]\\n', '        arg2 = call.keywords[0].value\\n', '    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\\n', '    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\\n', '    return is_expected_type and is_expected_object\\n']",
  "context": "  arg1: Optional[ast.expr] = call.args[0]\n        arg2: Optional[ast.expr] = call.args[1]\n    elif len(call.keywords) == 2:  # branch for su"
 },
 "1820": {
  "name": "is_expected_type",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['    call = _get_super_call(node)\\n', '    if call is None:\\n', '    args_number = len(call.args) + len(call.keywords)\\n', '    if args_number == 0:\\n', '    return args_number == 2 and _is_super_called_with(\\n', '        call,\\n', '    call: ast.Call,\\n', '    *names: str,\\n', '    keyword_args = {}\\n', '    for keyword in call.keywords:\\n', '        if keyword.arg in names:\\n', '            keyword_args[keyword.arg] = keyword.value\\n', '    return keyword_args\\n', '    if len(call.args) == 2:  # branch for super(Test, self)\\n', '        arg1: Optional[ast.expr] = call.args[0]\\n', '        arg2: Optional[ast.expr] = call.args[1]\\n', '    elif len(call.keywords) == 2:  # branch for super(t=Test, obj=self)\\n', \"        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\\n\", \"        arg1 = keyword_args.get('t')\\n\", \"        arg2 = keyword_args.get('obj')\\n\", '        arg1 = call.args[0]\\n', '        arg2 = call.keywords[0].value\\n', '    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\\n', '    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\\n', '    return is_expected_type and is_expected_object\\n']",
  "context": "args[0]\n        arg2 = call.keywords[0].value\n    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\n    is_expected_object = isinstance(arg2, ast.Name"
 },
 "1821": {
  "name": "is_expected_object",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['    call = _get_super_call(node)\\n', '    if call is None:\\n', '    args_number = len(call.args) + len(call.keywords)\\n', '    if args_number == 0:\\n', '    return args_number == 2 and _is_super_called_with(\\n', '        call,\\n', '    call: ast.Call,\\n', '    *names: str,\\n', '    keyword_args = {}\\n', '    for keyword in call.keywords:\\n', '        if keyword.arg in names:\\n', '            keyword_args[keyword.arg] = keyword.value\\n', '    return keyword_args\\n', '    if len(call.args) == 2:  # branch for super(Test, self)\\n', '        arg1: Optional[ast.expr] = call.args[0]\\n', '        arg2: Optional[ast.expr] = call.args[1]\\n', '    elif len(call.keywords) == 2:  # branch for super(t=Test, obj=self)\\n', \"        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\\n\", \"        arg1 = keyword_args.get('t')\\n\", \"        arg2 = keyword_args.get('obj')\\n\", '        arg1 = call.args[0]\\n', '        arg2 = call.keywords[0].value\\n', '    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\\n', '    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\\n', '    return is_expected_type and is_expected_object\\n']",
  "context": "instance(arg1, ast.Name) and arg1.id == type_\n    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\n    return is_expected_type and is_expected_object"
 },
 "1822": {
  "name": "keyword_args",
  "type": "_get_keyword_args_by_names",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "53",
  "column": "8",
  "slicing": "['    call = _get_super_call(node)\\n', '    if call is None:\\n', '    args_number = len(call.args) + len(call.keywords)\\n', '    if args_number == 0:\\n', '    return args_number == 2 and _is_super_called_with(\\n', '        call,\\n', '    call: ast.Call,\\n', '    *names: str,\\n', '    keyword_args = {}\\n', '    for keyword in call.keywords:\\n', '        if keyword.arg in names:\\n', '            keyword_args[keyword.arg] = keyword.value\\n', '    return keyword_args\\n', '    if len(call.args) == 2:  # branch for super(Test, self)\\n', '        arg1: Optional[ast.expr] = call.args[0]\\n', '        arg2: Optional[ast.expr] = call.args[1]\\n', '    elif len(call.keywords) == 2:  # branch for super(t=Test, obj=self)\\n', \"        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\\n\", \"        arg1 = keyword_args.get('t')\\n\", \"        arg2 = keyword_args.get('obj')\\n\", '        arg1 = call.args[0]\\n', '        arg2 = call.keywords[0].value\\n', '    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\\n', '    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\\n', '    return is_expected_type and is_expected_object\\n']",
  "context": " 2:  # branch for super(t=Test, obj=self)\n        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\n        arg1 = keyword_args.get('t')\n        arg2 "
 },
 "1823": {
  "name": "arg1",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/arguments/super_args.py",
  "lineno": "57",
  "column": "8",
  "slicing": "['    call = _get_super_call(node)\\n', '    if call is None:\\n', '    args_number = len(call.args) + len(call.keywords)\\n', '    if args_number == 0:\\n', '    return args_number == 2 and _is_super_called_with(\\n', '        call,\\n', '    call: ast.Call,\\n', '    *names: str,\\n', '    keyword_args = {}\\n', '    for keyword in call.keywords:\\n', '        if keyword.arg in names:\\n', '            keyword_args[keyword.arg] = keyword.value\\n', '    return keyword_args\\n', '    if len(call.args) == 2:  # branch for super(Test, self)\\n', '        arg1: Optional[ast.expr] = call.args[0]\\n', '        arg2: Optional[ast.expr] = call.args[1]\\n', '    elif len(call.keywords) == 2:  # branch for super(t=Test, obj=self)\\n', \"        keyword_args = _get_keyword_args_by_names(call, 't', 'obj')\\n\", \"        arg1 = keyword_args.get('t')\\n\", \"        arg2 = keyword_args.get('obj')\\n\", '        arg1 = call.args[0]\\n', '        arg2 = call.keywords[0].value\\n', '    is_expected_type = isinstance(arg1, ast.Name) and arg1.id == type_\\n', '    is_expected_object = isinstance(arg2, ast.Name) and arg2.id == object_\\n', '    return is_expected_type and is_expected_object\\n']",
  "context": "else:  # branch for super(Test, obj=self)\n        arg1 = call.args[0]\n        arg2 = call.keywords[0].value\n    is_expec"
 },
 "1824": {
  "name": "_OVERLOAD_EXCEPTIONS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/predicates.py",
  "lineno": "11",
  "column": "0",
  "slicing": "[\"_OVERLOAD_EXCEPTIONS: Final = frozenset(('overload', 'typing.overload'))\\n\", '            if node_to_string(decorator) in _OVERLOAD_EXCEPTIONS:\\n']",
  "context": "That's what we expect from `@overload` decorator:\n_OVERLOAD_EXCEPTIONS: Final = frozenset(('overload', 'typing.overload'))\n\n#: That's what we expect from `@property` decorat"
 },
 "1825": {
  "name": "_PROPERTY_EXCEPTIONS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/predicates.py",
  "lineno": "14",
  "column": "0",
  "slicing": "[\"_PROPERTY_EXCEPTIONS: Final = frozenset(('property', '.setter'))\\n\", '            if node_to_string(decorator) in _PROPERTY_EXCEPTIONS:\\n']",
  "context": "That's what we expect from `@property` decorator:\n_PROPERTY_EXCEPTIONS: Final = frozenset(('property', '.setter'))\n\n\n# Name predicates:\n\ndef is_function_overload(nod"
 },
 "1826": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/predicates.py",
  "lineno": "44",
  "column": "39",
  "slicing": "['def is_same_value_reuse(node: ast.AST, names: Set[str]) -> bool:\\n']",
  "context": "edicates:\n\ndef is_same_value_reuse(node: ast.AST, names: Set[str]) -> bool:\n    \"\"\"Checks if the given names are reused by the"
 },
 "1827": {
  "name": "used_names",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/predicates.py",
  "lineno": "47",
  "column": "8",
  "slicing": "['        used_names = {\\n', '        if not names.difference(used_names):\\n']",
  "context": "stance(node, AssignNodes) and node.value:\n        used_names = {\n            name_node.id\n            for name_node"
 },
 "1828": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/predicates.py",
  "lineno": "57",
  "column": "44",
  "slicing": "['def is_same_try_except_cases(node: ast.AST, names: Set[str]) -> bool:\\n']",
  "context": "lse\n\n\ndef is_same_try_except_cases(node: ast.AST, names: Set[str]) -> bool:\n    \"\"\"Same names in different ``except`` blocks a"
 },
 "1829": {
  "name": "_ContextStore",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "12",
  "column": "0",
  "slicing": "['_ContextStore = DefaultDict[ContextNodes, Set[str]]\\n', '    _block_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '    _local_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '    def _get_scope(self, *, is_local: bool = False) -> _ContextStore:\\n', '    _scopes: ClassVar[_ContextStore] = defaultdict(set)\\n']",
  "context": "w we represent scopes that are bound to contexts.\n_ContextStore = DefaultDict[ContextNodes, Set[str]]\n\n\nclass _BaseScope(object):\n    \"\"\"Base class for "
 },
 "1830": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "24",
  "column": "27",
  "slicing": "['    def add_to_scope(self, names: Set[str]) -> None:  # pragma: no cover\\n']",
  "context": "_context(self._node))\n\n    def add_to_scope(self, names: Set[str]) -> None:  # pragma: no cover\n        \"\"\"Adds a given set of names to some scope"
 },
 "1831": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "28",
  "column": "24",
  "slicing": "['    def shadowing(self, names: Set[str]) -> Set[str]:  # pragma: no cover\\n']",
  "context": "se NotImplementedError()\n\n    def shadowing(self, names: Set[str]) -> Set[str]:  # pragma: no cover\n        \"\"\"Tells either some shadowing exist betwe"
 },
 "1832": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "33",
  "column": "30",
  "slicing": "['    def _exclude_unused(self, names: Set[str]) -> Set[str]:\\n']",
  "context": "Error()\n\n    @final\n    def _exclude_unused(self, names: Set[str]) -> Set[str]:\n        \"\"\"Removes unused variables from set of na"
 },
 "1833": {
  "name": "_block_scopes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['    _block_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n']",
  "context": "#: Updated when we have a new block variable.\n    _block_scopes: ClassVar[_ContextStore] = defaultdict(set)\n\n    #: Updated when we have a new local variable."
 },
 "1834": {
  "name": "_local_scopes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "50",
  "column": "4",
  "slicing": "['    _local_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n']",
  "context": "#: Updated when we have a new local variable.\n    _local_scopes: ClassVar[_ContextStore] = defaultdict(set)\n\n    def add_to_scope(\n        self,\n        names"
 },
 "1835": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "54",
  "column": "8",
  "slicing": "['        names: Set[str],\\n']",
  "context": "set)\n\n    def add_to_scope(\n        self,\n        names: Set[str],\n        *,\n        is_local: bool = False,\n    ) -"
 },
 "1836": {
  "name": "scope",
  "type": "collections.defaultdict",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "59",
  "column": "8",
  "slicing": "['_ContextStore = DefaultDict[ContextNodes, Set[str]]\\n', '            for var_name in names\\n', '            if not access.is_unused(var_name)\\n', '    _block_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '    _local_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        scope = self._get_scope(is_local=is_local)\\n', '        scope[self._context] = scope[self._context].union(\\n', '        scope = self._get_scope(is_local=not is_local)\\n', '        current_names = scope[self._context]\\n', '            scope = self._get_scope(is_local=is_local)\\n', '            current_names = current_names.union(scope[self._context])\\n', '        return set(current_names).intersection(names)\\n', '    def _get_scope(self, *, is_local: bool = False) -> _ContextStore:\\n', '    _scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        return set(current_names).intersection(names)\\n']",
  "context": "a set of names to the specified scope.\"\"\"\n        scope = self._get_scope(is_local=is_local)\n        scope[self._context] = scope[self._context"
 },
 "1837": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "66",
  "column": "8",
  "slicing": "['        names: Set[str],\\n']",
  "context": "      )\n\n    def shadowing(\n        self,\n        names: Set[str],\n        *,\n        is_local: bool = False,\n    ) -"
 },
 "1838": {
  "name": "scope",
  "type": "collections.defaultdict",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "74",
  "column": "8",
  "slicing": "['_ContextStore = DefaultDict[ContextNodes, Set[str]]\\n', '            for var_name in names\\n', '            if not access.is_unused(var_name)\\n', '    _block_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '    _local_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        scope = self._get_scope(is_local=is_local)\\n', '        scope[self._context] = scope[self._context].union(\\n', '        scope = self._get_scope(is_local=not is_local)\\n', '        current_names = scope[self._context]\\n', '            scope = self._get_scope(is_local=is_local)\\n', '            current_names = current_names.union(scope[self._context])\\n', '        return set(current_names).intersection(names)\\n', '    def _get_scope(self, *, is_local: bool = False) -> _ContextStore:\\n', '    _scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        return set(current_names).intersection(names)\\n']",
  "context": "  if not names:\n            return set()\n\n        scope = self._get_scope(is_local=not is_local)\n        current_names = scope[self._context]\n\n    "
 },
 "1839": {
  "name": "current_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "75",
  "column": "8",
  "slicing": "['_ContextStore = DefaultDict[ContextNodes, Set[str]]\\n', '            for var_name in names\\n', '            if not access.is_unused(var_name)\\n', '    _block_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '    _local_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        scope = self._get_scope(is_local=is_local)\\n', '        scope[self._context] = scope[self._context].union(\\n', '        scope = self._get_scope(is_local=not is_local)\\n', '        current_names = scope[self._context]\\n', '            scope = self._get_scope(is_local=is_local)\\n', '            current_names = current_names.union(scope[self._context])\\n', '        return set(current_names).intersection(names)\\n', '    def _get_scope(self, *, is_local: bool = False) -> _ContextStore:\\n', '    _scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        return set(current_names).intersection(names)\\n']",
  "context": " = self._get_scope(is_local=not is_local)\n        current_names = scope[self._context]\n\n        if not is_local:\n            # Why do we "
 },
 "1840": {
  "name": "scope",
  "type": "collections.defaultdict",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "80",
  "column": "12",
  "slicing": "['_ContextStore = DefaultDict[ContextNodes, Set[str]]\\n', '            for var_name in names\\n', '            if not access.is_unused(var_name)\\n', '    _block_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '    _local_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        scope = self._get_scope(is_local=is_local)\\n', '        scope[self._context] = scope[self._context].union(\\n', '        scope = self._get_scope(is_local=not is_local)\\n', '        current_names = scope[self._context]\\n', '            scope = self._get_scope(is_local=is_local)\\n', '            current_names = current_names.union(scope[self._context])\\n', '        return set(current_names).intersection(names)\\n', '    def _get_scope(self, *, is_local: bool = False) -> _ContextStore:\\n', '    _scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        return set(current_names).intersection(names)\\n']",
  "context": "k variables cannot shadow each other.\n            scope = self._get_scope(is_local=is_local)\n            current_names = current_names.union(sc"
 },
 "1841": {
  "name": "_scopes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['    _scopes: ClassVar[_ContextStore] = defaultdict(set)\\n']",
  "context": "ts scoping store to check name shadowing.\"\"\"\n\n    _scopes: ClassVar[_ContextStore] = defaultdict(set)\n\n    def add_to_scope(self, names: Set[str]) -> No"
 },
 "1842": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "95",
  "column": "27",
  "slicing": "['    def add_to_scope(self, names: Set[str]) -> None:\\n']",
  "context": "e] = defaultdict(set)\n\n    def add_to_scope(self, names: Set[str]) -> None:\n        \"\"\"Adds a set of variables to the context "
 },
 "1843": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "105",
  "column": "24",
  "slicing": "['    def shadowing(self, names: Set[str]) -> Set[str]:\\n']",
  "context": "unused(names),\n        )\n\n    def shadowing(self, names: Set[str]) -> Set[str]:\n        \"\"\"Calculates the intersection for a set o"
 },
 "1844": {
  "name": "outer_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "115",
  "column": "8",
  "slicing": "['_ContextStore = DefaultDict[ContextNodes, Set[str]]\\n', '            for var_name in names\\n', '            if not access.is_unused(var_name)\\n', '    _block_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '    _local_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        scope = self._get_scope(is_local=is_local)\\n', '        scope[self._context] = scope[self._context].union(\\n', '        scope = self._get_scope(is_local=not is_local)\\n', '        current_names = scope[self._context]\\n', '            scope = self._get_scope(is_local=is_local)\\n', '            current_names = current_names.union(scope[self._context])\\n', '        return set(current_names).intersection(names)\\n', '    def _get_scope(self, *, is_local: bool = False) -> _ContextStore:\\n', '    _scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        current_names = self._build_outer_context()\\n', '        return set(current_names).intersection(names)\\n', '        outer_names: Set[str] = set()\\n', '        context = self._context\\n', '            context = cast(ContextNodes, get_context(context))\\n', '            outer_names = outer_names.union(self._scopes[context])\\n', '            if not context:\\n', '        return outer_names\\n']",
  "context": "f _build_outer_context(self) -> Set[str]:\n        outer_names: Set[str] = set()\n        context = self._context\n\n        while Tru"
 },
 "1845": {
  "name": "context",
  "type": "typing.cast",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/scopes/defs.py",
  "lineno": "119",
  "column": "12",
  "slicing": "['_ContextStore = DefaultDict[ContextNodes, Set[str]]\\n', '            for var_name in names\\n', '            if not access.is_unused(var_name)\\n', '    _block_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '    _local_scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        scope = self._get_scope(is_local=is_local)\\n', '        scope[self._context] = scope[self._context].union(\\n', '        scope = self._get_scope(is_local=not is_local)\\n', '        current_names = scope[self._context]\\n', '            scope = self._get_scope(is_local=is_local)\\n', '            current_names = current_names.union(scope[self._context])\\n', '        return set(current_names).intersection(names)\\n', '    def _get_scope(self, *, is_local: bool = False) -> _ContextStore:\\n', '    _scopes: ClassVar[_ContextStore] = defaultdict(set)\\n', '        current_names = self._build_outer_context()\\n', '        return set(current_names).intersection(names)\\n', '        outer_names: Set[str] = set()\\n', '        context = self._context\\n', '            context = cast(ContextNodes, get_context(context))\\n', '            outer_names = outer_names.union(self._scopes[context])\\n', '            if not context:\\n', '        return outer_names\\n']",
  "context": " = self._context\n\n        while True:\n            context = cast(ContextNodes, get_context(context))\n            outer_names = outer_names.union(self._"
 },
 "1846": {
  "name": "_AnnNodes",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/overuses.py",
  "lineno": "10",
  "column": "0",
  "slicing": "['_AnnNodes = (ast.AnnAssign, ast.arg)\\n', '    parent = walk.get_closest_parent(node, FunctionNodes)\\n', '    if isinstance(parent, FunctionNodes) and parent.decorator_list:\\n', '            for decorator in parent.decorator_list\\n', '    self_node: Union[ast.Attribute, ast.Subscript, None] = None\\n', '        self_node = node.func\\n', '        self_node = node\\n', '        self_node and\\n', '        isinstance(self_node.value, ast.Name) and\\n', '        self_node.value.id in SPECIAL_ARGUMENT_NAMES_WHITELIST,\\n', '    annotated = walk.get_closest_parent(node, (*_AnnNodes, *FunctionNodes))\\n', '    if isinstance(annotated, FunctionNodes):\\n', '            annotated.returns and\\n', '            walk.is_contained_by(node, annotated.returns),\\n', '        return node == annotated.returns or contains_node\\n', '    elif isinstance(annotated, _AnnNodes):\\n', '            annotated.annotation and\\n', '            walk.is_contained_by(node, annotated.annotation),\\n', '        return node == annotated.annotation or contains_node\\n']",
  "context": "import call_args\n\n#: Nodes that can be annotated.\n_AnnNodes = (ast.AnnAssign, ast.arg)\n\n\ndef is_class_context(node: ast.AST) -> bool:\n   "
 },
 "1847": {
  "name": "self_node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/overuses.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['    self_node: Union[ast.Attribute, ast.Subscript, None] = None\\n', '        self_node and\\n', '        isinstance(self_node.value, ast.Name) and\\n', '        self_node.value.id in SPECIAL_ARGUMENT_NAMES_WHITELIST,\\n']",
  "context": "ute`` nodes\n    are globally ignored.\n    \"\"\"\n    self_node: Union[ast.Attribute, ast.Subscript, None] = None\n    if isinstance(node, ast.Call) and isinstance(n"
 },
 "1848": {
  "name": "self_node",
  "type": "node",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/overuses.py",
  "lineno": "66",
  "column": "8",
  "slicing": "['    parent = walk.get_closest_parent(node, FunctionNodes)\\n', '    if isinstance(parent, FunctionNodes) and parent.decorator_list:\\n', '            for decorator in parent.decorator_list\\n', '        self_node = node\\n', '        self_node and\\n', '        isinstance(self_node.value, ast.Name) and\\n', '        self_node.value.id in SPECIAL_ARGUMENT_NAMES_WHITELIST,\\n']",
  "context": "    elif isinstance(node, ast.Subscript):\n        self_node = node\n\n    return bool(\n        self_node and\n        is"
 },
 "1849": {
  "name": "contains_node",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/overuses.py",
  "lineno": "87",
  "column": "8",
  "slicing": "['_AnnNodes = (ast.AnnAssign, ast.arg)\\n', '    parent = walk.get_closest_parent(node, FunctionNodes)\\n', '    if isinstance(parent, FunctionNodes) and parent.decorator_list:\\n', '            for decorator in parent.decorator_list\\n', '    self_node: Union[ast.Attribute, ast.Subscript, None] = None\\n', '        self_node = node.func\\n', '        self_node = node\\n', '        self_node and\\n', '        isinstance(self_node.value, ast.Name) and\\n', '        self_node.value.id in SPECIAL_ARGUMENT_NAMES_WHITELIST,\\n', '    annotated = walk.get_closest_parent(node, (*_AnnNodes, *FunctionNodes))\\n', '    if isinstance(annotated, FunctionNodes):\\n', '        contains_node = bool(\\n', '            annotated.returns and\\n', '            walk.is_contained_by(node, annotated.returns),\\n', '        return node == annotated.returns or contains_node\\n', '    elif isinstance(annotated, _AnnNodes):\\n', '            annotated.annotation and\\n', '            walk.is_contained_by(node, annotated.annotation),\\n', '        return node == annotated.annotation or contains_node\\n']",
  "context": " if isinstance(annotated, FunctionNodes):\n        contains_node = bool(\n            annotated.returns and\n            walk"
 },
 "1850": {
  "name": "contains_node",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/overuses.py",
  "lineno": "93",
  "column": "8",
  "slicing": "['_AnnNodes = (ast.AnnAssign, ast.arg)\\n', '    parent = walk.get_closest_parent(node, FunctionNodes)\\n', '    if isinstance(parent, FunctionNodes) and parent.decorator_list:\\n', '            for decorator in parent.decorator_list\\n', '    self_node: Union[ast.Attribute, ast.Subscript, None] = None\\n', '        self_node = node.func\\n', '        self_node = node\\n', '        self_node and\\n', '        isinstance(self_node.value, ast.Name) and\\n', '        self_node.value.id in SPECIAL_ARGUMENT_NAMES_WHITELIST,\\n', '    annotated = walk.get_closest_parent(node, (*_AnnNodes, *FunctionNodes))\\n', '    if isinstance(annotated, FunctionNodes):\\n', '        contains_node = bool(\\n', '            annotated.returns and\\n', '            walk.is_contained_by(node, annotated.returns),\\n', '        return node == annotated.returns or contains_node\\n', '    elif isinstance(annotated, _AnnNodes):\\n', '        contains_node = bool(\\n', '            annotated.annotation and\\n', '            walk.is_contained_by(node, annotated.annotation),\\n', '        return node == annotated.annotation or contains_node\\n']",
  "context": "   elif isinstance(annotated, _AnnNodes):\n        contains_node = bool(\n            annotated.annotation and\n            w"
 },
 "1851": {
  "name": "FunctionCounter",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "13",
  "column": "0",
  "slicing": "['FunctionCounter = DefaultDict[AnyFunctionDef, int]\\n', 'def _default_factory() -> FunctionCounter:\\n', '    returns: FunctionCounter = attr.ib(factory=_default_factory)\\n', '    raises: FunctionCounter = attr.ib(factory=_default_factory)\\n', '    awaits: FunctionCounter = attr.ib(factory=_default_factory)\\n', '    asserts: FunctionCounter = attr.ib(factory=_default_factory)\\n', '    expressions: FunctionCounter = attr.ib(factory=_default_factory)\\n']",
  "context": "nDefAndLambda,\n)\n\n#: Function complexity counter.\nFunctionCounter = DefaultDict[AnyFunctionDef, int]\n\n#: Function and lambda complexity counter.\nFuncti"
 },
 "1852": {
  "name": "FunctionCounterWithLambda",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "16",
  "column": "0",
  "slicing": "['FunctionCounterWithLambda = DefaultDict[AnyFunctionDefAndLambda, int]\\n', '    arguments: FunctionCounterWithLambda = attr.ib(factory=_default_factory)\\n']",
  "context": " int]\n\n#: Function and lambda complexity counter.\nFunctionCounterWithLambda = DefaultDict[AnyFunctionDefAndLambda, int]\n\n#: Function and their variables.\nFunctionNames = "
 },
 "1853": {
  "name": "FunctionNames",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "19",
  "column": "0",
  "slicing": "['FunctionNames = DefaultDict[AnyFunctionDef, List[str]]\\n', '    variables: FunctionNames = attr.ib(factory=lambda: defaultdict(list))\\n']",
  "context": "AndLambda, int]\n\n#: Function and their variables.\nFunctionNames = DefaultDict[AnyFunctionDef, List[str]]\n\n\ndef _default_factory() -> FunctionCounter:\n    \""
 },
 "1854": {
  "name": "returns",
  "type": "FunctionCounter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    returns: FunctionCounter = attr.ib(factory=_default_factory)\\n']",
  "context": ".\n    There are quite a lot of them!\n    \"\"\"\n\n    returns: FunctionCounter = attr.ib(factory=_default_factory)\n    raises: FunctionCounter = attr.ib(factory=_def"
 },
 "1855": {
  "name": "raises",
  "type": "FunctionCounter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['    raises: FunctionCounter = attr.ib(factory=_default_factory)\\n']",
  "context": "onCounter = attr.ib(factory=_default_factory)\n    raises: FunctionCounter = attr.ib(factory=_default_factory)\n    awaits: FunctionCounter = attr.ib(factory=_def"
 },
 "1856": {
  "name": "awaits",
  "type": "FunctionCounter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['    awaits: FunctionCounter = attr.ib(factory=_default_factory)\\n']",
  "context": "onCounter = attr.ib(factory=_default_factory)\n    awaits: FunctionCounter = attr.ib(factory=_default_factory)\n    asserts: FunctionCounter = attr.ib(factory=_de"
 },
 "1857": {
  "name": "asserts",
  "type": "FunctionCounter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['    asserts: FunctionCounter = attr.ib(factory=_default_factory)\\n']",
  "context": "onCounter = attr.ib(factory=_default_factory)\n    asserts: FunctionCounter = attr.ib(factory=_default_factory)\n    expressions: FunctionCounter = attr.ib(factory"
 },
 "1858": {
  "name": "expressions",
  "type": "FunctionCounter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    expressions: FunctionCounter = attr.ib(factory=_default_factory)\\n']",
  "context": "onCounter = attr.ib(factory=_default_factory)\n    expressions: FunctionCounter = attr.ib(factory=_default_factory)\n    arguments: FunctionCounterWithLambda = attr.ib"
 },
 "1859": {
  "name": "arguments",
  "type": "FunctionCounterWithLambda",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    arguments: FunctionCounterWithLambda = attr.ib(factory=_default_factory)\\n']",
  "context": "onCounter = attr.ib(factory=_default_factory)\n    arguments: FunctionCounterWithLambda = attr.ib(factory=_default_factory)\n    variables: FunctionNames = attr.ib(factory=lam"
 },
 "1860": {
  "name": "variables",
  "type": "FunctionNames",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/functions.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    variables: FunctionNames = attr.ib(factory=lambda: defaultdict(list))\\n']",
  "context": "ithLambda = attr.ib(factory=_default_factory)\n    variables: FunctionNames = attr.ib(factory=lambda: defaultdict(list))\n"
 },
 "1861": {
  "name": "_CONTROL_FLOW_BREAKERS",
  "type": "wemake_python_styleguide.types.AnyNodes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "25",
  "column": "0",
  "slicing": "['_CONTROL_FLOW_BREAKERS: AnyNodes = (\\n', '    elif isinstance(node, _CONTROL_FLOW_BREAKERS):\\n']",
  "context": "trol flow nodes that increment and can be nested.\n_CONTROL_FLOW_BREAKERS: AnyNodes = (\n    ast.If,\n    ast.For,\n    ast.AsyncFor,\n    ast"
 },
 "1862": {
  "name": "_SHORT_CIRCUITS",
  "type": "wemake_python_styleguide.types.AnyNodes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "34",
  "column": "0",
  "slicing": "['_SHORT_CIRCUITS: AnyNodes = (\\n', '    if isinstance(node, _SHORT_CIRCUITS):\\n']",
  "context": "t.IfExp,\n)\n\n#: Control flow nodes that increment.\n_SHORT_CIRCUITS: AnyNodes = (\n    ast.Break,\n    ast.Continue,\n    ast.Raise,\n)\n"
 },
 "1863": {
  "name": "_INCREMENTERS",
  "type": "wemake_python_styleguide.types.AnyNodes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "41",
  "column": "0",
  "slicing": "['_INCREMENTERS: AnyNodes = (\\n', '    elif isinstance(node, _INCREMENTERS):\\n']",
  "context": "st.Raise,\n)\n\n#: Basic nodes to be counted as `1`.\n_INCREMENTERS: AnyNodes = (\n    ast.FunctionDef,\n    ast.AsyncFunctionDef,\n   "
 },
 "1864": {
  "name": "increment_by",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "50",
  "column": "4",
  "slicing": "['    increment_by: int,\\n', '            increment_by,\\n']",
  "context": "\ndef _process_child_nodes(\n    node: ast.AST,\n    increment_by: int,\n    complexity_calculator: Callable[[ast.AST, int]"
 },
 "1865": {
  "name": "complexity_calculator",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    complexity_calculator: Callable[[ast.AST, int], int],\\n', '        child_complexity += complexity_calculator(\\n', '    return child_complexity\\n', '            _get_cognitive_complexity_for_node,\\n', '    return base_complexity + child_complexity\\n']",
  "context": "es(\n    node: ast.AST,\n    increment_by: int,\n    complexity_calculator: Callable[[ast.AST, int], int],\n) -> int:\n    child_complexity = 0\n\n    for node_n"
 },
 "1866": {
  "name": "child_complexity",
  "type": "max",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "60",
  "column": "16",
  "slicing": "['                child_complexity += max(1, increment_by)\\n', '    return child_complexity\\n', '    return base_complexity + child_complexity\\n']",
  "context": "ept body\n            if node_num:\n                child_complexity += max(1, increment_by)\n        child_complexity += complexity_calculator("
 },
 "1867": {
  "name": "child_complexity",
  "type": "complexity_calculator",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "61",
  "column": "8",
  "slicing": "['        child_complexity += complexity_calculator(\\n', '    return child_complexity\\n', '    return base_complexity + child_complexity\\n']",
  "context": " child_complexity += max(1, increment_by)\n        child_complexity += complexity_calculator(\n            child_node,\n            increment_by,\n"
 },
 "1868": {
  "name": "increment_by",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['    increment_by: int,\\n', '        increment_by,\\n', '            increment_by,\\n']",
  "context": "\ndef _process_node_itself(\n    node: ast.AST,\n    increment_by: int,\n) -> Tuple[int, int, bool]:\n    if isinstance(node"
 },
 "1869": {
  "name": "base_complexity",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "83",
  "column": "8",
  "slicing": "['_CONTROL_FLOW_BREAKERS: AnyNodes = (\\n', '_SHORT_CIRCUITS: AnyNodes = (\\n', '_INCREMENTERS: AnyNodes = (\\n', '    child_complexity = 0\\n', '    for node_num, child_node in enumerate(ast.iter_child_nodes(node)):\\n', '            if node_num == 1:\\n', '                increment_by += 1  # add +1 for all try nodes except body\\n', '            if node_num:\\n', '                child_complexity += max(1, increment_by)\\n', '        child_complexity += complexity_calculator(\\n', '            child_node,\\n', '            increment_by,\\n', '    return child_complexity\\n', '    if isinstance(node, _SHORT_CIRCUITS):\\n', '        return increment_by, max(1, increment_by), True\\n', '    elif isinstance(node, _CONTROL_FLOW_BREAKERS):\\n', '        increment_by += 1\\n', '        return increment_by, max(1, increment_by), True\\n', '    elif isinstance(node, _INCREMENTERS):\\n', '        increment_by += 1\\n', '        return increment_by, 0, True\\n', '        inner_boolops_amount = bools.count_boolops(node)\\n', '        base_complexity = inner_boolops_amount * max(increment_by, 1)\\n', '        return increment_by, base_complexity, False\\n', '    return increment_by, 0, True\\n', '        increment_by,\\n', '            increment_by,\\n', '    return base_complexity + child_complexity\\n']",
  "context": "oolops_amount = bools.count_boolops(node)\n        base_complexity = inner_boolops_amount * max(increment_by, 1)\n        return increment_by, base_complexity, Fals"
 },
 "1870": {
  "name": "increment_by",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "90",
  "column": "4",
  "slicing": "['    increment_by: int = 0,\\n']",
  "context": "itive_complexity_for_node(\n    node: ast.AST,\n    increment_by: int = 0,\n) -> int:\n    increment_by, base_complexity, shoul"
 },
 "1871": {
  "name": "increment_by",
  "type": "_process_node_itself",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "92",
  "column": "4",
  "slicing": "['    increment_by, base_complexity, should_iter_children = _process_node_itself(\\n', '        increment_by,\\n', '            increment_by,\\n']",
  "context": "ast.AST,\n    increment_by: int = 0,\n) -> int:\n    increment_by, base_complexity, should_iter_children = _process_node_itself(\n        node,\n        increment_by,\n    )\n\n    chi"
 },
 "1872": {
  "name": "base_complexity",
  "type": "_process_node_itself",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "92",
  "column": "18",
  "slicing": "['    increment_by, base_complexity, should_iter_children = _process_node_itself(\\n', '    return base_complexity + child_complexity\\n']",
  "context": "ncrement_by: int = 0,\n) -> int:\n    increment_by, base_complexity, should_iter_children = _process_node_itself(\n        node,\n        increment_by,\n    )\n\n    chi"
 },
 "1873": {
  "name": "should_iter_children",
  "type": "_process_node_itself",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "92",
  "column": "35",
  "slicing": "['    increment_by, base_complexity, should_iter_children = _process_node_itself(\\n', '    if should_iter_children:\\n']",
  "context": "= 0,\n) -> int:\n    increment_by, base_complexity, should_iter_children = _process_node_itself(\n        node,\n        increment_by,\n    )\n\n    chi"
 },
 "1874": {
  "name": "child_complexity",
  "type": "_process_child_nodes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "99",
  "column": "8",
  "slicing": "['        child_complexity += _process_child_nodes(\\n', '    return base_complexity + child_complexity\\n']",
  "context": "mplexity = 0\n    if should_iter_children:\n        child_complexity += _process_child_nodes(\n            node,\n            increment_by,\n      "
 },
 "1875": {
  "name": "funcdef",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "108",
  "column": "20",
  "slicing": "['def cognitive_score(funcdef: AnyFunctionDef) -> int:\\n']",
  "context": "mplexity + child_complexity\n\n\ndef cognitive_score(funcdef: AnyFunctionDef) -> int:\n    \"\"\"\n    A thin wrapper around 3rd party depend"
 },
 "1876": {
  "name": "complexity",
  "type": "sum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "115",
  "column": "4",
  "slicing": "['_CONTROL_FLOW_BREAKERS: AnyNodes = (\\n', '_SHORT_CIRCUITS: AnyNodes = (\\n', '_INCREMENTERS: AnyNodes = (\\n', '    node: ast.AST,\\n', '    increment_by: int,\\n', '    complexity_calculator: Callable[[ast.AST, int], int],\\n', '    child_complexity = 0\\n', '    for node_num, child_node in enumerate(ast.iter_child_nodes(node)):\\n', '            if node_num == 1:\\n', '                increment_by += 1  # add +1 for all try nodes except body\\n', '            if node_num:\\n', '                child_complexity += max(1, increment_by)\\n', '        child_complexity += complexity_calculator(\\n', '            child_node,\\n', '            increment_by,\\n', '    return child_complexity\\n', '    node: ast.AST,\\n', '    increment_by: int,\\n', '    if isinstance(node, _SHORT_CIRCUITS):\\n', '        return increment_by, max(1, increment_by), True\\n', '    elif isinstance(node, _CONTROL_FLOW_BREAKERS):\\n', '        increment_by += 1\\n', '        return increment_by, max(1, increment_by), True\\n', '    elif isinstance(node, _INCREMENTERS):\\n', '        increment_by += 1\\n', '        return increment_by, 0, True\\n', '        inner_boolops_amount = bools.count_boolops(node)\\n', '        base_complexity = inner_boolops_amount * max(increment_by, 1)\\n', '        return increment_by, base_complexity, False\\n', '    return increment_by, 0, True\\n', '    node: ast.AST,\\n', '    increment_by, base_complexity, should_iter_children = _process_node_itself(\\n', '        node,\\n', '        increment_by,\\n', '    child_complexity = 0\\n', '    if should_iter_children:\\n', '        child_complexity += _process_child_nodes(\\n', '            node,\\n', '            increment_by,\\n', '            _get_cognitive_complexity_for_node,\\n', '    return base_complexity + child_complexity\\n', '    complexity = sum(\\n', '        _get_cognitive_complexity_for_node(node)\\n', '        for node in funcdef.body\\n', '    return complexity\\n']",
  "context": "y\n    related to some 3rd party code.\n    \"\"\"\n    complexity = sum(\n        _get_cognitive_complexity_for_node(node)\n "
 },
 "1877": {
  "name": "complexity",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/cognitive.py",
  "lineno": "120",
  "column": "8",
  "slicing": "['        complexity += 1\\n', '    return complexity\\n']",
  "context": "f recursion.has_recursive_calls(funcdef):\n        complexity += 1\n    return complexity\n"
 },
 "1878": {
  "name": "_Annotation",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/annotations.py",
  "lineno": "15",
  "column": "0",
  "slicing": "['_Annotation = Union[\\n', 'def get_annotation_complexity(annotation_node: _Annotation) -> int:\\n']",
  "context": "tyleguide.compat.functions import get_slice_expr\n\n_Annotation = Union[\n    ast.expr,\n    ast.Str,\n]\n\n\ndef get_annotation_"
 },
 "1879": {
  "name": "annotation_node",
  "type": "_Annotation",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/complexity/annotations.py",
  "lineno": "21",
  "column": "30",
  "slicing": "['def get_annotation_complexity(annotation_node: _Annotation) -> int:\\n']",
  "context": "r,\n    ast.Str,\n]\n\n\ndef get_annotation_complexity(annotation_node: _Annotation) -> int:\n    \"\"\"\n    Recursively counts complexity of annot"
 },
 "1880": {
  "name": "children",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/calls.py",
  "lineno": "6",
  "column": "4",
  "slicing": "['    children = list(ast.iter_child_nodes(iterator))\\n', '    if isinstance(children[0], ast.Call):\\n', '        return children[0]\\n']",
  "context": "tem(iterator: ast.AST) -> Optional[ast.Call]:\n    children = list(ast.iter_child_nodes(iterator))\n    if isinstance(children[0], ast.Call):\n        "
 },
 "1881": {
  "name": "chained_item",
  "type": "_chained_item",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/calls.py",
  "lineno": "19",
  "column": "8",
  "slicing": "['def _chained_item(iterator: ast.AST) -> Optional[ast.Call]:\\n', '    children = list(ast.iter_child_nodes(iterator))\\n', '    if isinstance(children[0], ast.Call):\\n', '        return children[0]\\n', '    iterator: ast.Call = node\\n', '        yield iterator\\n', '        chained_item = _chained_item(iterator)\\n', '        if chained_item is None:\\n', '        iterator = chained_item\\n']",
  "context": "\n\n    while True:\n        yield iterator\n\n        chained_item = _chained_item(iterator)\n        if chained_item is None:\n            retur"
 },
 "1882": {
  "name": "iterator",
  "type": "chained_item",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/calls.py",
  "lineno": "22",
  "column": "8",
  "slicing": "['def _chained_item(iterator: ast.AST) -> Optional[ast.Call]:\\n', '    children = list(ast.iter_child_nodes(iterator))\\n', '    if isinstance(children[0], ast.Call):\\n', '        return children[0]\\n', '    iterator: ast.Call = node\\n', '        yield iterator\\n', '        chained_item = _chained_item(iterator)\\n', '        if chained_item is None:\\n', '        iterator = chained_item\\n']",
  "context": " chained_item is None:\n            return\n        iterator = chained_item\n"
 },
 "1883": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/operators.py",
  "lineno": "40",
  "column": "8",
  "slicing": "['        node = node.operand\\n', '    if isinstance(node, ast.Starred):\\n', '        return node.value\\n', '    return node\\n', '        parent = get_parent(node)\\n', '        if parent is None or not isinstance(parent, ast.UnaryOp):\\n', '            return parent\\n', '        node = parent\\n', '    parent = get_parent(node)\\n', '    if parent is None or not isinstance(parent, ast.UnaryOp):\\n', '    if isinstance(parent.op, operator):\\n', '        return count_unary_operator(parent, operator, amount + 1)\\n', '    return count_unary_operator(parent, operator, amount)\\n']",
  "context": "eturn ``Assign``\n\n    \"\"\"\n    while True:\n        parent = get_parent(node)\n        if parent is None or not isinstance(parent"
 },
 "1884": {
  "name": "node",
  "type": "parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/operators.py",
  "lineno": "43",
  "column": "8",
  "slicing": "['        node = node.operand\\n', '    if isinstance(node, ast.Starred):\\n', '        return node.value\\n', '    return node\\n', '        parent = get_parent(node)\\n', '        if parent is None or not isinstance(parent, ast.UnaryOp):\\n', '            return parent\\n', '        node = parent\\n', '    parent = get_parent(node)\\n', '    if parent is None or not isinstance(parent, ast.UnaryOp):\\n', '    if isinstance(parent.op, operator):\\n', '        return count_unary_operator(parent, operator, amount + 1)\\n', '    return count_unary_operator(parent, operator, amount)\\n']",
  "context": ", ast.UnaryOp):\n            return parent\n        node = parent\n\n\ndef count_unary_operator(\n    node: ast.AST,\n   "
 },
 "1885": {
  "name": "operator",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/operators.py",
  "lineno": "48",
  "column": "4",
  "slicing": "['    operator: Type[ast.unaryop],\\n']",
  "context": "\ndef count_unary_operator(\n    node: ast.AST,\n    operator: Type[ast.unaryop],\n    amount: int = 0,\n) -> int:\n    \"\"\"Returns amou"
 },
 "1886": {
  "name": "amount",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/operators.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['    amount: int = 0,\\n']",
  "context": "de: ast.AST,\n    operator: Type[ast.unaryop],\n    amount: int = 0,\n) -> int:\n    \"\"\"Returns amount of unary operators"
 },
 "1887": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/operators.py",
  "lineno": "52",
  "column": "4",
  "slicing": "['        node = node.operand\\n', '    if isinstance(node, ast.Starred):\\n', '        return node.value\\n', '    return node\\n', '        parent = get_parent(node)\\n', '        if parent is None or not isinstance(parent, ast.UnaryOp):\\n', '            return parent\\n', '        node = parent\\n', '    parent = get_parent(node)\\n', '    if parent is None or not isinstance(parent, ast.UnaryOp):\\n', '    if isinstance(parent.op, operator):\\n', '        return count_unary_operator(parent, operator, amount + 1)\\n', '    return count_unary_operator(parent, operator, amount)\\n']",
  "context": " amount of unary operators matching input.\"\"\"\n    parent = get_parent(node)\n    if parent is None or not isinstance(parent, as"
 },
 "1888": {
  "name": "exception_func",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    exception = node.exc\\n', '    if exception is None:\\n', \"    exception_func = getattr(exception, 'func', None)\\n\", '    if exception_func:\\n', '        exception = exception_func\\n', \"    return getattr(exception, 'id', None)\\n\"]",
  "context": "   if exception is None:\n        return None\n\n    exception_func = getattr(exception, 'func', None)\n    if exception_func:\n        exception = excepti"
 },
 "1889": {
  "name": "exception",
  "type": "exception_func",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "18",
  "column": "8",
  "slicing": "['    exception = node.exc\\n', '    if exception is None:\\n', \"    exception_func = getattr(exception, 'func', None)\\n\", '    if exception_func:\\n', '        exception = exception_func\\n', \"    return getattr(exception, 'id', None)\\n\"]",
  "context": "ion, 'func', None)\n    if exception_func:\n        exception = exception_func\n\n    return getattr(exception, 'id', None)\n\n\ndef g"
 },
 "1890": {
  "name": "exceptions",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    exceptions: List[str] = []\\n', '            exceptions.append(source.node_to_string(exc_handler.type))\\n', '            exceptions.extend([\\n', '    return exceptions\\n']",
  "context": "st of all exceptions names in ``ast.Try``.\"\"\"\n    exceptions: List[str] = []\n    for exc_handler in node.handlers:\n        # Th"
 },
 "1891": {
  "name": "builtin_exceptions",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    builtin_exceptions=None,\\n']",
  "context": "exceptions\n\n\ndef traverse_exception(\n    cls,\n    builtin_exceptions=None,\n) -> Mapping[str, Tuple[str]]:\n    \"\"\"\n    Returns"
 },
 "1892": {
  "name": "builtin_exceptions",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    exception = node.exc\\n', '    if exception is None:\\n', \"    exception_func = getattr(exception, 'func', None)\\n\", '    if exception_func:\\n', '        exception = exception_func\\n', \"    return getattr(exception, 'id', None)\\n\", '    exceptions: List[str] = []\\n', '    for exc_handler in node.handlers:\\n', '        if isinstance(exc_handler.type, ast.Name):\\n', '            exceptions.append(source.node_to_string(exc_handler.type))\\n', '        elif isinstance(exc_handler.type, ast.Tuple):\\n', '            exceptions.extend([\\n', '                for node in exc_handler.type.elts\\n', '    return exceptions\\n', '    builtin_exceptions = builtin_exceptions or {}\\n', '    if cls.__name__ not in builtin_exceptions:\\n', '        builtin_exceptions[cls.__name__] = ()\\n', '        builtin_exceptions[exc.__name__] = tuple(\\n', '        traverse_exception(exc, builtin_exceptions)\\n', '    return builtin_exceptions\\n', '        for line in node.body\\n', '        for except_handler in node.handlers\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.orelse\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.finalbody\\n']",
  "context": "Original code: https://bit.ly/36HVPk2\n    \"\"\"\n    builtin_exceptions = builtin_exceptions or {}\n\n    if cls.__name__ not in builtin_exceptions:\n  "
 },
 "1893": {
  "name": "bad_returning_nodes",
  "type": "wemake_python_styleguide.types.AnyNodes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    bad_returning_nodes: AnyNodes,\\n']",
  "context": "\ndef find_returning_nodes(\n    node: ast.Try,\n    bad_returning_nodes: AnyNodes,\n) -> Tuple[bool, bool, bool, bool]:\n    \"\"\"Find no"
 },
 "1894": {
  "name": "try_has",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['    exception = node.exc\\n', '    if exception is None:\\n', \"    exception_func = getattr(exception, 'func', None)\\n\", '    if exception_func:\\n', '        exception = exception_func\\n', \"    return getattr(exception, 'id', None)\\n\", '    exceptions: List[str] = []\\n', '    for exc_handler in node.handlers:\\n', '        if isinstance(exc_handler.type, ast.Name):\\n', '            exceptions.append(source.node_to_string(exc_handler.type))\\n', '        elif isinstance(exc_handler.type, ast.Tuple):\\n', '            exceptions.extend([\\n', '                for node in exc_handler.type.elts\\n', '    return exceptions\\n', '    builtin_exceptions = builtin_exceptions or {}\\n', '    if cls.__name__ not in builtin_exceptions:\\n', '        builtin_exceptions[cls.__name__] = ()\\n', '    for exc in cls.__subclasses__():\\n', '        builtin_exceptions[exc.__name__] = tuple(\\n', '            for base in getmro(exc)\\n', '                issubclass(base, BaseException) and\\n', '                base.__name__ != exc.__name__\\n', '        traverse_exception(exc, builtin_exceptions)\\n', '    return builtin_exceptions\\n', '    try_has = any(\\n', '        for line in node.body\\n', '        for except_handler in node.handlers\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.orelse\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.finalbody\\n', '    return try_has, except_has, else_has, finally_has\\n']",
  "context": "ue and are inside try/except/else/finally.\"\"\"\n    try_has = any(\n        is_contained(line, bad_returning_nodes)\n  "
 },
 "1895": {
  "name": "except_has",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "79",
  "column": "4",
  "slicing": "['    exception = node.exc\\n', '    if exception is None:\\n', \"    exception_func = getattr(exception, 'func', None)\\n\", '    if exception_func:\\n', '        exception = exception_func\\n', \"    return getattr(exception, 'id', None)\\n\", '    exceptions: List[str] = []\\n', '    for exc_handler in node.handlers:\\n', '        if isinstance(exc_handler.type, ast.Name):\\n', '            exceptions.append(source.node_to_string(exc_handler.type))\\n', '        elif isinstance(exc_handler.type, ast.Tuple):\\n', '            exceptions.extend([\\n', '                for node in exc_handler.type.elts\\n', '    return exceptions\\n', '    builtin_exceptions = builtin_exceptions or {}\\n', '    if cls.__name__ not in builtin_exceptions:\\n', '        builtin_exceptions[cls.__name__] = ()\\n', '    for exc in cls.__subclasses__():\\n', '        builtin_exceptions[exc.__name__] = tuple(\\n', '            for base in getmro(exc)\\n', '                issubclass(base, BaseException) and\\n', '                base.__name__ != exc.__name__\\n', '        traverse_exception(exc, builtin_exceptions)\\n', '    return builtin_exceptions\\n', '        for line in node.body\\n', '    except_has = any(\\n', '        for except_handler in node.handlers\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.orelse\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.finalbody\\n', '    return try_has, except_has, else_has, finally_has\\n']",
  "context": "ng_nodes)\n        for line in node.body\n    )\n    except_has = any(\n        is_contained(except_handler, bad_returning"
 },
 "1896": {
  "name": "else_has",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['    exception = node.exc\\n', '    if exception is None:\\n', \"    exception_func = getattr(exception, 'func', None)\\n\", '    if exception_func:\\n', '        exception = exception_func\\n', \"    return getattr(exception, 'id', None)\\n\", '    exceptions: List[str] = []\\n', '    for exc_handler in node.handlers:\\n', '        if isinstance(exc_handler.type, ast.Name):\\n', '            exceptions.append(source.node_to_string(exc_handler.type))\\n', '        elif isinstance(exc_handler.type, ast.Tuple):\\n', '            exceptions.extend([\\n', '                for node in exc_handler.type.elts\\n', '    return exceptions\\n', '    builtin_exceptions = builtin_exceptions or {}\\n', '    if cls.__name__ not in builtin_exceptions:\\n', '        builtin_exceptions[cls.__name__] = ()\\n', '    for exc in cls.__subclasses__():\\n', '        builtin_exceptions[exc.__name__] = tuple(\\n', '            for base in getmro(exc)\\n', '                issubclass(base, BaseException) and\\n', '                base.__name__ != exc.__name__\\n', '        traverse_exception(exc, builtin_exceptions)\\n', '    return builtin_exceptions\\n', '        for line in node.body\\n', '        for except_handler in node.handlers\\n', '    else_has = any(\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.orelse\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.finalbody\\n', '    return try_has, except_has, else_has, finally_has\\n']",
  "context": "    for except_handler in node.handlers\n    )\n    else_has = any(\n        is_contained(line, bad_returning_nodes)\n  "
 },
 "1897": {
  "name": "finally_has",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/exceptions.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['    exception = node.exc\\n', '    if exception is None:\\n', \"    exception_func = getattr(exception, 'func', None)\\n\", '    if exception_func:\\n', '        exception = exception_func\\n', \"    return getattr(exception, 'id', None)\\n\", '    exceptions: List[str] = []\\n', '    for exc_handler in node.handlers:\\n', '        if isinstance(exc_handler.type, ast.Name):\\n', '            exceptions.append(source.node_to_string(exc_handler.type))\\n', '        elif isinstance(exc_handler.type, ast.Tuple):\\n', '            exceptions.extend([\\n', '                for node in exc_handler.type.elts\\n', '    return exceptions\\n', '    builtin_exceptions = builtin_exceptions or {}\\n', '    if cls.__name__ not in builtin_exceptions:\\n', '        builtin_exceptions[cls.__name__] = ()\\n', '    for exc in cls.__subclasses__():\\n', '        builtin_exceptions[exc.__name__] = tuple(\\n', '            for base in getmro(exc)\\n', '                issubclass(base, BaseException) and\\n', '                base.__name__ != exc.__name__\\n', '        traverse_exception(exc, builtin_exceptions)\\n', '    return builtin_exceptions\\n', '        for line in node.body\\n', '        for except_handler in node.handlers\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.orelse\\n', '    finally_has = any(\\n', '        is_contained(line, bad_returning_nodes)\\n', '        for line in node.finalbody\\n', '    return try_has, except_has, else_has, finally_has\\n']",
  "context": "_nodes)\n        for line in node.orelse\n    )\n    finally_has = any(\n        is_contained(line, bad_returning_nodes)\n  "
 },
 "1898": {
  "name": "module",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/imports.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    module: str\\n']",
  "context": "    \"\"\"Information about imported object.\"\"\"\n\n    module: str\n    node: AnyImport\n\n\ndef get_import_parts(node: A"
 },
 "1899": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyImport",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/imports.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    node: AnyImport\\n', \"    module_path = getattr(node, 'module', '') or ''\\n\", \"    return module_path.split('.')\\n\"]",
  "context": "on about imported object.\"\"\"\n\n    module: str\n    node: AnyImport\n\n\ndef get_import_parts(node: AnyImport) -> List[st"
 },
 "1900": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyImport",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/imports.py",
  "lineno": "19",
  "column": "21",
  "slicing": "['def get_import_parts(node: AnyImport) -> List[str]:\\n']",
  "context": "e: str\n    node: AnyImport\n\n\ndef get_import_parts(node: AnyImport) -> List[str]:\n    \"\"\"Returns list of import modules.\"\"\"\n    modu"
 },
 "1901": {
  "name": "module_path",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/imports.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    node: AnyImport\\n', \"    module_path = getattr(node, 'module', '') or ''\\n\", \"    return module_path.split('.')\\n\"]",
  "context": "r]:\n    \"\"\"Returns list of import modules.\"\"\"\n    module_path = getattr(node, 'module', '') or ''\n    return module_path.split('.')\n\n\ndef is_vague_i"
 },
 "1902": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/imports.py",
  "lineno": "25",
  "column": "20",
  "slicing": "['def is_vague_import(name: str) -> bool:\\n']",
  "context": "turn module_path.split('.')\n\n\ndef is_vague_import(name: str) -> bool:\n    \"\"\"\n    Tells whether this import name is vagu"
 },
 "1903": {
  "name": "blacklisted",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/imports.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    node: AnyImport\\n', \"    module_path = getattr(node, 'module', '') or ''\\n\", \"    return module_path.split('.')\\n\", '    blacklisted = name in constants.VAGUE_IMPORTS_BLACKLIST\\n', '    return blacklisted or with_from_or_to or too_short\\n']",
  "context": "is_vague_import('regular')\n    False\n\n    \"\"\"\n    blacklisted = name in constants.VAGUE_IMPORTS_BLACKLIST\n    with_from_or_to = (\n        name.startswith('f"
 },
 "1904": {
  "name": "with_from_or_to",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/imports.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    with_from_or_to = (\\n', '    return blacklisted or with_from_or_to or too_short\\n']",
  "context": "d = name in constants.VAGUE_IMPORTS_BLACKLIST\n    with_from_or_to = (\n        name.startswith('from_') or\n        name.s"
 },
 "1905": {
  "name": "checked_condition",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/imports.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['    checked_condition = None\\n', '    return checked_condition in constants.ALLOWED_NESTED_IMPORTS_CONDITIONS\\n']",
  "context": "ether ``if`` checks for ``TYPE_CHECKING``.\"\"\"\n    checked_condition = None\n    if isinstance(parent, ast.If):\n        if isin"
 },
 "1906": {
  "name": "_AnyControlTransfers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "13",
  "column": "0",
  "slicing": "['_AnyControlTransfers = Union[\\n', '_ControlTransferIterable = Iterable[_AnyControlTransfers]\\n', 'def get_function_exit_nodes(node: AnyFunctionDef) -> _ControlTransferIterable:\\n']",
  "context": "sions that causes control transfer from a routine\n_AnyControlTransfers = Union[\n    Return,\n    Yield,\n    YieldFrom,\n]\n\n#: Type a"
 },
 "1907": {
  "name": "_ControlTransferIterable",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "20",
  "column": "0",
  "slicing": "['_AnyControlTransfers = Union[\\n', '_ControlTransferIterable = Iterable[_AnyControlTransfers]\\n', 'def get_function_exit_nodes(node: AnyFunctionDef) -> _ControlTransferIterable:\\n']",
  "context": "otation for an iterable of control transfer nodes\n_ControlTransferIterable = Iterable[_AnyControlTransfers]\n\n#: Type annotation for a tuple of control transfe"
 },
 "1908": {
  "name": "_ControlTransferTuple",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "23",
  "column": "0",
  "slicing": "['_AnyControlTransfers = Union[\\n', '_ControlTransferIterable = Iterable[_AnyControlTransfers]\\n', '_ControlTransferTuple = Tuple[\\n', 'def get_function_exit_nodes(node: AnyFunctionDef) -> _ControlTransferIterable:\\n']",
  "context": " annotation for a tuple of control transfer nodes\n_ControlTransferTuple = Tuple[\n    Type[Return],\n    Type[Yield],\n    Type[YieldF"
 },
 "1909": {
  "name": "node",
  "type": "ast.Call",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['    node: Call,\\n']",
  "context": "pe[YieldFrom],\n]\n\n\ndef given_function_called(\n    node: Call,\n    to_check: Container[str],\n    *,\n    split_mod"
 },
 "1910": {
  "name": "to_check",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    to_check: Container[str],\\n']",
  "context": "\n\n\ndef given_function_called(\n    node: Call,\n    to_check: Container[str],\n    *,\n    split_modules: bool = False,\n) -> str:\n"
 },
 "1911": {
  "name": "function_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "44",
  "column": "8",
  "slicing": "['_AnyControlTransfers = Union[\\n', '_ControlTransferIterable = Iterable[_AnyControlTransfers]\\n', '    function_name = source.node_to_string(node.func)\\n', \"        function_name = function_name.split('.')[-1]\\n\", '    if function_name in to_check:\\n', '        return function_name\\n', 'def get_function_exit_nodes(node: AnyFunctionDef) -> _ControlTransferIterable:\\n']",
  "context": "o_string(node.func)\n    if split_modules:\n        function_name = function_name.split('.')[-1]\n    if function_name in to_check:\n        return f"
 },
 "1912": {
  "name": "function_type",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "50",
  "column": "14",
  "slicing": "['def is_method(function_type: Optional[str]) -> bool:\\n']",
  "context": "eturn function_name\n    return ''\n\n\ndef is_method(function_type: Optional[str]) -> bool:\n    \"\"\"\n    Returns whether a given function type "
 },
 "1913": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDefAndLambda",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "76",
  "column": "22",
  "slicing": "['def get_all_arguments(node: AnyFunctionDefAndLambda) -> List[arg]:\\n']",
  "context": "smethod', 'staticmethod'}\n\n\ndef get_all_arguments(node: AnyFunctionDefAndLambda) -> List[arg]:\n    \"\"\"\n    Returns list of all arguments that exi"
 },
 "1914": {
  "name": "names",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['    names = [\\n', '        names.append(node.args.vararg)\\n', '    names.extend(node.args.kwonlyargs)\\n', '        names.append(node.args.kwarg)\\n', '    return names\\n']",
  "context": " are ignoring this type of arguments.\n    \"\"\"\n    names = [\n        *get_posonlyargs(node),\n        *node.args"
 },
 "1915": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDefAndLambda",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "103",
  "column": "22",
  "slicing": "['def is_first_argument(node: AnyFunctionDefAndLambda, name: str) -> bool:\\n']",
  "context": ".kwarg)\n\n    return names\n\n\ndef is_first_argument(node: AnyFunctionDefAndLambda, name: str) -> bool:\n    \"\"\"Tells whether an argument name is the logic"
 },
 "1916": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "103",
  "column": "53",
  "slicing": "['def is_first_argument(node: AnyFunctionDefAndLambda, name: str) -> bool:\\n']",
  "context": " is_first_argument(node: AnyFunctionDefAndLambda, name: str) -> bool:\n    \"\"\"Tells whether an argument name is the logic"
 },
 "1917": {
  "name": "positional_args",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "105",
  "column": "4",
  "slicing": "['    positional_args = [\\n', '    if not positional_args:\\n', '    return name == positional_args[0].arg\\n']",
  "context": "t name is the logically first in function.\"\"\"\n    positional_args = [\n        *get_posonlyargs(node),\n        *node.args"
 },
 "1918": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "116",
  "column": "17",
  "slicing": "['def is_generator(node: AnyFunctionDef) -> bool:\\n']",
  "context": "name == positional_args[0].arg\n\n\ndef is_generator(node: AnyFunctionDef) -> bool:\n    \"\"\"Tells whether a given function is a generat"
 },
 "1919": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "124",
  "column": "28",
  "slicing": "['def get_function_exit_nodes(node: AnyFunctionDef) -> _ControlTransferIterable:\\n']",
  "context": "ue\n    return False\n\n\ndef get_function_exit_nodes(node: AnyFunctionDef) -> _ControlTransferIterable:\n    \"\"\"Yields nodes that cause a control transfer "
 },
 "1920": {
  "name": "control_transfer_nodes",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/functions.py",
  "lineno": "126",
  "column": "4",
  "slicing": "['_AnyControlTransfers = Union[\\n', '_ControlTransferIterable = Iterable[_AnyControlTransfers]\\n', '    function_name = source.node_to_string(node.func)\\n', \"        function_name = function_name.split('.')[-1]\\n\", '    if function_name in to_check:\\n', '        return function_name\\n', '    names = [\\n', '        names.append(node.args.vararg)\\n', '    names.extend(node.args.kwonlyargs)\\n', '        names.append(node.args.kwarg)\\n', '    return names\\n', '    positional_args = [\\n', '    if not positional_args:\\n', '    return name == positional_args[0].arg\\n', '    for body_item in node.body:\\n', '        if is_contained(node=body_item, to_check=(Yield, YieldFrom)):\\n', 'def get_function_exit_nodes(node: AnyFunctionDef) -> _ControlTransferIterable:\\n', '    control_transfer_nodes = (Return, Yield, YieldFrom)\\n', '        for sub_node in walk(body_item):\\n', '            if isinstance(sub_node, control_transfer_nodes):\\n', '                yield sub_node\\n']",
  "context": " cause a control transfer from a function.\"\"\"\n    control_transfer_nodes = (Return, Yield, YieldFrom)\n    for body_item in node.body:\n        for sub_no"
 },
 "1921": {
  "name": "loop",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/loops.py",
  "lineno": "9",
  "column": "4",
  "slicing": "['    loop: Optional[AnyLoop],\\n', '    for inner_node in ast.walk(loop):\\n', '        if to_check is inner_node:\\n', '                closest_loop, subnode,\\n']",
  "context": "Loop, AnyNodes\n\n\ndef _does_loop_contain_node(\n    loop: Optional[AnyLoop],\n    to_check: ast.AST,\n) -> bool:\n    \"\"\"\n    Help"
 },
 "1922": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyLoop",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/loops.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    node: AnyLoop,\\n']",
  "context": "return True\n    return False\n\n\ndef has_break(\n    node: AnyLoop,\n    *,\n    break_nodes: AnyNodes,\n) -> bool:\n    \""
 },
 "1923": {
  "name": "closest_loop",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/loops.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    closest_loop = None\\n', '                closest_loop, subnode,\\n']",
  "context": "s whether loop contains a break statement.\"\"\"\n    closest_loop = None\n\n    for subnode in ast.walk(node):\n        if isi"
 },
 "1924": {
  "name": "closest_loop",
  "type": "subnode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/loops.py",
  "lineno": "38",
  "column": "12",
  "slicing": "['    for inner_node in ast.walk(loop):\\n', '        if to_check is inner_node:\\n', '    for subnode in ast.walk(node):\\n', '        if isinstance(subnode, (*ForNodes, ast.While)) and subnode is not node:\\n', '            closest_loop = subnode\\n', '        if isinstance(subnode, break_nodes):\\n', '                closest_loop, subnode,\\n']",
  "context": " ast.While)) and subnode is not node:\n            closest_loop = subnode\n\n        if isinstance(subnode, break_nodes):\n    "
 },
 "1925": {
  "name": "is_nested_break",
  "type": "_does_loop_contain_node",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/loops.py",
  "lineno": "41",
  "column": "12",
  "slicing": "['    loop: Optional[AnyLoop],\\n', '    to_check: ast.AST,\\n', '    for inner_node in ast.walk(loop):\\n', '        if to_check is inner_node:\\n', '    closest_loop = None\\n', '    for subnode in ast.walk(node):\\n', '        if isinstance(subnode, (*ForNodes, ast.While)) and subnode is not node:\\n', '            closest_loop = subnode\\n', '        if isinstance(subnode, break_nodes):\\n', '            is_nested_break = _does_loop_contain_node(\\n', '                closest_loop, subnode,\\n', '            if not is_nested_break:\\n']",
  "context": " if isinstance(subnode, break_nodes):\n            is_nested_break = _does_loop_contain_node(\n                closest_loop, subnode,\n           "
 },
 "1926": {
  "name": "iterable",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/slices.py",
  "lineno": "8",
  "column": "4",
  "slicing": "['    iterable: str,\\n']",
  "context": "uide.logic import source\n\n\ndef is_same_slice(\n    iterable: str,\n    target: str,\n    node: ast.Subscript,\n) -> boo"
 },
 "1927": {
  "name": "target",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/slices.py",
  "lineno": "9",
  "column": "4",
  "slicing": "['    target: str,\\n']",
  "context": "ource\n\n\ndef is_same_slice(\n    iterable: str,\n    target: str,\n    node: ast.Subscript,\n) -> bool:\n    \"\"\"Used to"
 },
 "1928": {
  "name": "_NodeType",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "15",
  "column": "0",
  "slicing": "[\"_NodeType = TypeVar('_NodeType')\\n\", '    node_types: Tuple[Type[_NodeType], ...],\\n', ') -> Iterable[Sequence[_NodeType]]:\\n', '    node_sequence: List[_NodeType] = []\\n', '            node_sequence.append(cast(_NodeType, previous_node))\\n', '        elif node_sequence:\\n', '            yield [*node_sequence, cast(_NodeType, previous_node)]\\n', '    sequence: Iterable[_NodeType],\\n', ') -> Union[_NodeType, _DefaultType, None]:\\n']",
  "context": "e,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n)\n\n_NodeType = TypeVar('_NodeType')\n_DefaultType = TypeVar('_DefaultType')\n\n\ndef norma"
 },
 "1929": {
  "name": "_DefaultType",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "16",
  "column": "0",
  "slicing": "[\"_DefaultType = TypeVar('_DefaultType')\\n\", '    default: Optional[_DefaultType] = None,\\n', ') -> Union[_NodeType, _DefaultType, None]:\\n']",
  "context": "on,\n    cast,\n)\n\n_NodeType = TypeVar('_NodeType')\n_DefaultType = TypeVar('_DefaultType')\n\n\ndef normalize_dict_elements(node: ast.Dict) -> S"
 },
 "1930": {
  "name": "elements",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    elements: List[ast.AST] = []\\n', '            elements.append(dict_value)\\n', '            elements.append(dict_key)\\n', '    return elements\\n']",
  "context": "/wemake-python-styleguide/issues/450\n\n    \"\"\"\n    elements: List[ast.AST] = []\n    for dict_key, dict_value in zip(node.keys, nod"
 },
 "1931": {
  "name": "node_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['    node_types: Tuple[Type[_NodeType], ...],\\n']",
  "context": ")\n    return elements\n\n\ndef sequence_of_node(\n    node_types: Tuple[Type[_NodeType], ...],\n    sequence: Sequence[ast.stmt],\n) -> Iterable[Se"
 },
 "1932": {
  "name": "sequence",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "48",
  "column": "4",
  "slicing": "['    sequence: Sequence[ast.stmt],\\n']",
  "context": "\n    node_types: Tuple[Type[_NodeType], ...],\n    sequence: Sequence[ast.stmt],\n) -> Iterable[Sequence[_NodeType]]:\n    \"\"\"Find se"
 },
 "1933": {
  "name": "is_desired_type",
  "type": "functools.partial",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "51",
  "column": "4",
  "slicing": "[\"_NodeType = TypeVar('_NodeType')\\n\", '    elements: List[ast.AST] = []\\n', '    for dict_key, dict_value in zip(node.keys, node.values):\\n', '        if dict_key is None:\\n', '            elements.append(dict_value)\\n', '            elements.append(dict_key)\\n', '    return elements\\n', '    node_types: Tuple[Type[_NodeType], ...],\\n', ') -> Iterable[Sequence[_NodeType]]:\\n', '    is_desired_type = partial(\\n', '    node_sequence: List[_NodeType] = []\\n', '        if all(map(is_desired_type, (previous_node, current_node))):\\n', '            node_sequence.append(cast(_NodeType, previous_node))\\n', '        elif node_sequence:\\n', '            yield [*node_sequence, cast(_NodeType, previous_node)]\\n', '    sequence: Iterable[_NodeType],\\n', ') -> Union[_NodeType, _DefaultType, None]:\\n']",
  "context": "e]]:\n    \"\"\"Find sequence of node by type.\"\"\"\n    is_desired_type = partial(\n        lambda types, node: isinstance(node, types"
 },
 "1934": {
  "name": "sequence_iterator",
  "type": "iter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "55",
  "column": "4",
  "slicing": "[\"_NodeType = TypeVar('_NodeType')\\n\", '    elements: List[ast.AST] = []\\n', '    for dict_key, dict_value in zip(node.keys, node.values):\\n', '        if dict_key is None:\\n', '            elements.append(dict_value)\\n', '            elements.append(dict_key)\\n', '    return elements\\n', '    node_types: Tuple[Type[_NodeType], ...],\\n', ') -> Iterable[Sequence[_NodeType]]:\\n', '    is_desired_type = partial(\\n', '    sequence_iterator = iter(sequence)\\n', '    previous_node = next(sequence_iterator, None)\\n', '    node_sequence: List[_NodeType] = []\\n', '    while previous_node is not None:\\n', '        current_node = next(sequence_iterator, None)\\n', '        if all(map(is_desired_type, (previous_node, current_node))):\\n', '            node_sequence.append(cast(_NodeType, previous_node))\\n', '        elif node_sequence:\\n', '            yield [*node_sequence, cast(_NodeType, previous_node)]\\n', '            node_sequence = []\\n', '        previous_node = current_node\\n', '    sequence: Iterable[_NodeType],\\n', ') -> Union[_NodeType, _DefaultType, None]:\\n']",
  "context": ": isinstance(node, types), node_types,\n    )\n\n    sequence_iterator = iter(sequence)\n    previous_node = next(sequence_iterator, None)\n"
 },
 "1935": {
  "name": "previous_node",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "56",
  "column": "4",
  "slicing": "[\"_NodeType = TypeVar('_NodeType')\\n\", '    elements: List[ast.AST] = []\\n', '    for dict_key, dict_value in zip(node.keys, node.values):\\n', '        if dict_key is None:\\n', '            elements.append(dict_value)\\n', '            elements.append(dict_key)\\n', '    return elements\\n', '    node_types: Tuple[Type[_NodeType], ...],\\n', ') -> Iterable[Sequence[_NodeType]]:\\n', '    is_desired_type = partial(\\n', '    sequence_iterator = iter(sequence)\\n', '    previous_node = next(sequence_iterator, None)\\n', '    node_sequence: List[_NodeType] = []\\n', '    while previous_node is not None:\\n', '        current_node = next(sequence_iterator, None)\\n', '        if all(map(is_desired_type, (previous_node, current_node))):\\n', '            node_sequence.append(cast(_NodeType, previous_node))\\n', '        elif node_sequence:\\n', '            yield [*node_sequence, cast(_NodeType, previous_node)]\\n', '            node_sequence = []\\n', '        previous_node = current_node\\n', '    sequence: Iterable[_NodeType],\\n', ') -> Union[_NodeType, _DefaultType, None]:\\n']",
  "context": "    )\n\n    sequence_iterator = iter(sequence)\n    previous_node = next(sequence_iterator, None)\n    node_sequence: List[_NodeType] = []\n\n    while"
 },
 "1936": {
  "name": "node_sequence",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    node_sequence: List[_NodeType] = []\\n', '            node_sequence.append(cast(_NodeType, previous_node))\\n', '        elif node_sequence:\\n', '            yield [*node_sequence, cast(_NodeType, previous_node)]\\n']",
  "context": "previous_node = next(sequence_iterator, None)\n    node_sequence: List[_NodeType] = []\n\n    while previous_node is not None:\n        curr"
 },
 "1937": {
  "name": "current_node",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "60",
  "column": "8",
  "slicing": "[\"_NodeType = TypeVar('_NodeType')\\n\", '    elements: List[ast.AST] = []\\n', '    for dict_key, dict_value in zip(node.keys, node.values):\\n', '        if dict_key is None:\\n', '            elements.append(dict_value)\\n', '            elements.append(dict_key)\\n', '    return elements\\n', '    node_types: Tuple[Type[_NodeType], ...],\\n', ') -> Iterable[Sequence[_NodeType]]:\\n', '    is_desired_type = partial(\\n', '    sequence_iterator = iter(sequence)\\n', '    previous_node = next(sequence_iterator, None)\\n', '    node_sequence: List[_NodeType] = []\\n', '    while previous_node is not None:\\n', '        current_node = next(sequence_iterator, None)\\n', '        if all(map(is_desired_type, (previous_node, current_node))):\\n', '            node_sequence.append(cast(_NodeType, previous_node))\\n', '        elif node_sequence:\\n', '            yield [*node_sequence, cast(_NodeType, previous_node)]\\n', '            node_sequence = []\\n', '        previous_node = current_node\\n', '    sequence: Iterable[_NodeType],\\n', ') -> Union[_NodeType, _DefaultType, None]:\\n']",
  "context": " []\n\n    while previous_node is not None:\n        current_node = next(sequence_iterator, None)\n\n        if all(map(is_desired_type, (previous_nod"
 },
 "1938": {
  "name": "previous_node",
  "type": "current_node",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "68",
  "column": "8",
  "slicing": "[\"_NodeType = TypeVar('_NodeType')\\n\", '    elements: List[ast.AST] = []\\n', '    for dict_key, dict_value in zip(node.keys, node.values):\\n', '        if dict_key is None:\\n', '            elements.append(dict_value)\\n', '            elements.append(dict_key)\\n', '    return elements\\n', '    node_types: Tuple[Type[_NodeType], ...],\\n', ') -> Iterable[Sequence[_NodeType]]:\\n', '    is_desired_type = partial(\\n', '    sequence_iterator = iter(sequence)\\n', '    previous_node = next(sequence_iterator, None)\\n', '    node_sequence: List[_NodeType] = []\\n', '    while previous_node is not None:\\n', '        current_node = next(sequence_iterator, None)\\n', '        if all(map(is_desired_type, (previous_node, current_node))):\\n', '            node_sequence.append(cast(_NodeType, previous_node))\\n', '        elif node_sequence:\\n', '            yield [*node_sequence, cast(_NodeType, previous_node)]\\n', '            node_sequence = []\\n', '        previous_node = current_node\\n', '    sequence: Iterable[_NodeType],\\n', ') -> Union[_NodeType, _DefaultType, None]:\\n']",
  "context": "us_node)]\n            node_sequence = []\n\n        previous_node = current_node\n\n\ndef first(\n    sequence: Iterable[_NodeType],\n  "
 },
 "1939": {
  "name": "node_sequence",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "66",
  "column": "12",
  "slicing": "['            node_sequence = []\\n']",
  "context": "ence, cast(_NodeType, previous_node)]\n            node_sequence = []\n\n        previous_node = current_node\n\n\ndef first("
 },
 "1940": {
  "name": "sequence",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    sequence: Iterable[_NodeType],\\n']",
  "context": "    previous_node = current_node\n\n\ndef first(\n    sequence: Iterable[_NodeType],\n    default: Optional[_DefaultType] = None,\n) -> U"
 },
 "1941": {
  "name": "default",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/collections.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['    default: Optional[_DefaultType] = None,\\n']",
  "context": "def first(\n    sequence: Iterable[_NodeType],\n    default: Optional[_DefaultType] = None,\n) -> Union[_NodeType, _DefaultType, None]:\n    \"\"\""
 },
 "1942": {
  "name": "returns",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/keywords.py",
  "lineno": "12",
  "column": "4",
  "slicing": "['    returns: List[ast.Return] = []\\n', '            returns.append(sub_node)\\n', '    return returns, has_values\\n']",
  "context": "``return`` or ``yield`` nodes with values.\"\"\"\n    returns: List[ast.Return] = []\n    has_values = False\n    for sub_node in ast.wal"
 },
 "1943": {
  "name": "has_values",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/keywords.py",
  "lineno": "13",
  "column": "4",
  "slicing": "['    has_values = False\\n', '    return returns, has_values\\n']",
  "context": "values.\"\"\"\n    returns: List[ast.Return] = []\n    has_values = False\n    for sub_node in ast.walk(node):\n        contex"
 },
 "1944": {
  "name": "context_node",
  "type": "wemake_python_styleguide.logic.nodes.get_context",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/keywords.py",
  "lineno": "15",
  "column": "8",
  "slicing": "['    for sub_node in ast.walk(node):\\n', '        context_node = get_context(sub_node)\\n', '        if isinstance(sub_node, returning_type) and context_node == node:\\n', '            if sub_node.value:\\n', '            returns.append(sub_node)\\n']",
  "context": "False\n    for sub_node in ast.walk(node):\n        context_node = get_context(sub_node)\n        if isinstance(sub_node, returning_type) an"
 },
 "1945": {
  "name": "has_values",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/keywords.py",
  "lineno": "18",
  "column": "16",
  "slicing": "['                has_values = True\\n', '    return returns, has_values\\n']",
  "context": "e:\n            if sub_node.value:\n                has_values = True\n            returns.append(sub_node)\n    return re"
 },
 "1946": {
  "name": "is_return",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/keywords.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    returns: List[ast.Return] = []\\n', '    has_values = False\\n', '    for sub_node in ast.walk(node):\\n', '        context_node = get_context(sub_node)\\n', '        if isinstance(sub_node, returning_type) and context_node == node:\\n', '            if sub_node.value:\\n', '                has_values = True\\n', '            returns.append(sub_node)\\n', '    return returns, has_values\\n', '    is_return = isinstance(node, ast.Return)\\n', '    if is_return:\\n']",
  "context": "turn node would return a boolean constant.\"\"\"\n    is_return = isinstance(node, ast.Return)\n    if is_return:\n        return_value = getattr(n"
 },
 "1947": {
  "name": "return_value",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/keywords.py",
  "lineno": "27",
  "column": "8",
  "slicing": "['    returns: List[ast.Return] = []\\n', '    has_values = False\\n', '    for sub_node in ast.walk(node):\\n', '        context_node = get_context(sub_node)\\n', '        if isinstance(sub_node, returning_type) and context_node == node:\\n', '            if sub_node.value:\\n', '                has_values = True\\n', '            returns.append(sub_node)\\n', '    return returns, has_values\\n', '    is_return = isinstance(node, ast.Return)\\n', '    if is_return:\\n', \"        return_value = getattr(node, 'value', None)\\n\", '        if isinstance(return_value, ast.NameConstant):\\n', '            return isinstance(return_value.value, bool)\\n']",
  "context": "tance(node, ast.Return)\n    if is_return:\n        return_value = getattr(node, 'value', None)\n        if isinstance(return_value, ast.NameConsta"
 },
 "1948": {
  "name": "body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/keywords.py",
  "lineno": "33",
  "column": "21",
  "slicing": "['def is_simple_return(body: Sequence[ast.stmt]) -> bool:\\n']",
  "context": "ue, bool)\n    return False\n\n\ndef is_simple_return(body: Sequence[ast.stmt]) -> bool:\n    \"\"\"Check if a statement only returns a boolean"
 },
 "1949": {
  "name": "body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/keywords.py",
  "lineno": "40",
  "column": "27",
  "slicing": "['def next_node_returns_bool(body: Sequence[ast.stmt], index: int) -> bool:\\n']",
  "context": "_bool_const(body[0])\n\n\ndef next_node_returns_bool(body: Sequence[ast.stmt], index: int) -> bool:\n    \"\"\"Check if the node after exiting the context"
 },
 "1950": {
  "name": "index",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/keywords.py",
  "lineno": "40",
  "column": "53",
  "slicing": "['def next_node_returns_bool(body: Sequence[ast.stmt], index: int) -> bool:\\n']",
  "context": " next_node_returns_bool(body: Sequence[ast.stmt], index: int) -> bool:\n    \"\"\"Check if the node after exiting the context"
 },
 "1951": {
  "name": "lower_bound",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    lower_bound: Set[ast.Compare] = attr.ib(factory=set)\\n']",
  "context": "e to calculate the similar compare nodes.\"\"\"\n\n    lower_bound: Set[ast.Compare] = attr.ib(factory=set)\n    upper_bound: Set[ast.Compare] = attr.ib(factor"
 },
 "1952": {
  "name": "upper_bound",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    upper_bound: Set[ast.Compare] = attr.ib(factory=set)\\n']",
  "context": "ound: Set[ast.Compare] = attr.ib(factory=set)\n    upper_bound: Set[ast.Compare] = attr.ib(factory=set)\n\n\n_MultipleCompareOperators = Tuple[Type[ast.cmpop"
 },
 "1953": {
  "name": "_MultipleCompareOperators",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "21",
  "column": "0",
  "slicing": "['_MultipleCompareOperators = Tuple[Type[ast.cmpop], ...]\\n', '    _MultipleCompareOperators,\\n', ') -> Union[Type[ast.cmpop], _MultipleCompareOperators]:\\n']",
  "context": "_bound: Set[ast.Compare] = attr.ib(factory=set)\n\n\n_MultipleCompareOperators = Tuple[Type[ast.cmpop], ...]\n\n#: Type to represent `SIMILAR_OPERATORS` constant"
 },
 "1954": {
  "name": "_ComparesMapping",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "24",
  "column": "0",
  "slicing": "['_MultipleCompareOperators = Tuple[Type[ast.cmpop], ...]\\n', '_ComparesMapping = Mapping[\\n', '    _MultipleCompareOperators,\\n', 'SIMILAR_OPERATORS: Final[_ComparesMapping] = types.MappingProxyType({\\n', ') -> Union[Type[ast.cmpop], _MultipleCompareOperators]:\\n', '    return SIMILAR_OPERATORS.get(operator_type, operator_type)\\n']",
  "context": ": Type to represent `SIMILAR_OPERATORS` constant.\n_ComparesMapping = Mapping[\n    Type[ast.cmpop],\n    _MultipleCompareOperators"
 },
 "1955": {
  "name": "_OperatorUsages",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "30",
  "column": "0",
  "slicing": "['_MultipleCompareOperators = Tuple[Type[ast.cmpop], ...]\\n', '    _MultipleCompareOperators,\\n', '_OperatorUsages = DefaultDict[str, _Bounds]\\n', ') -> Union[Type[ast.cmpop], _MultipleCompareOperators]:\\n', '        self._uses: _OperatorUsages = defaultdict(_Bounds)\\n', '    def _build_bounds(self) -> _OperatorUsages:\\n']",
  "context": "the operator usages in `a > b and b >c` compares.\n_OperatorUsages = DefaultDict[str, _Bounds]\n\n#: Constant to define similar operators.\nSIMILAR_"
 },
 "1956": {
  "name": "SIMILAR_OPERATORS",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "33",
  "column": "0",
  "slicing": "['SIMILAR_OPERATORS: Final[_ComparesMapping] = types.MappingProxyType({\\n', '    return SIMILAR_OPERATORS.get(operator_type, operator_type)\\n']",
  "context": "Bounds]\n\n#: Constant to define similar operators.\nSIMILAR_OPERATORS: Final[_ComparesMapping] = types.MappingProxyType({\n    ast.Gt: (ast.Gt, ast.GtE),\n    ast.GtE: (ast.G"
 },
 "1957": {
  "name": "num_shared",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "70",
  "column": "12",
  "slicing": "['_MultipleCompareOperators = Tuple[Type[ast.cmpop], ...]\\n', '_ComparesMapping = Mapping[\\n', '    _MultipleCompareOperators,\\n', '_OperatorUsages = DefaultDict[str, _Bounds]\\n', 'SIMILAR_OPERATORS: Final[_ComparesMapping] = types.MappingProxyType({\\n', ') -> Union[Type[ast.cmpop], _MultipleCompareOperators]:\\n', '    operator_type = operator.__class__\\n', '    return SIMILAR_OPERATORS.get(operator_type, operator_type)\\n', '        self._uses: _OperatorUsages = defaultdict(_Bounds)\\n', '        local_uses = self._build_bounds().values()\\n', '        for bounds in local_uses:\\n', '            num_shared = len(\\n', '                bounds.lower_bound.intersection(bounds.upper_bound),\\n', '            num_lower_bounds = len(bounds.lower_bound)\\n', '            num_upper_bounds = len(bounds.upper_bound)\\n', '            if num_shared < num_lower_bounds and num_shared < num_upper_bounds:\\n', '    def _build_bounds(self) -> _OperatorUsages:\\n']",
  "context": "s()\n        for bounds in local_uses:\n            num_shared = len(\n                bounds.lower_bound.intersection(bo"
 },
 "1958": {
  "name": "num_lower_bounds",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "73",
  "column": "12",
  "slicing": "['_MultipleCompareOperators = Tuple[Type[ast.cmpop], ...]\\n', '_ComparesMapping = Mapping[\\n', '    _MultipleCompareOperators,\\n', '_OperatorUsages = DefaultDict[str, _Bounds]\\n', 'SIMILAR_OPERATORS: Final[_ComparesMapping] = types.MappingProxyType({\\n', ') -> Union[Type[ast.cmpop], _MultipleCompareOperators]:\\n', '    operator_type = operator.__class__\\n', '    return SIMILAR_OPERATORS.get(operator_type, operator_type)\\n', '        self._uses: _OperatorUsages = defaultdict(_Bounds)\\n', '        local_uses = self._build_bounds().values()\\n', '        for bounds in local_uses:\\n', '                bounds.lower_bound.intersection(bounds.upper_bound),\\n', '            num_lower_bounds = len(bounds.lower_bound)\\n', '            num_upper_bounds = len(bounds.upper_bound)\\n', '            if num_shared < num_lower_bounds and num_shared < num_upper_bounds:\\n', '    def _build_bounds(self) -> _OperatorUsages:\\n']",
  "context": "on(bounds.upper_bound),\n            )\n            num_lower_bounds = len(bounds.lower_bound)\n            num_upper_bounds = len(bounds.upper_bo"
 },
 "1959": {
  "name": "num_upper_bounds",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "74",
  "column": "12",
  "slicing": "['_MultipleCompareOperators = Tuple[Type[ast.cmpop], ...]\\n', '_ComparesMapping = Mapping[\\n', '    _MultipleCompareOperators,\\n', '_OperatorUsages = DefaultDict[str, _Bounds]\\n', 'SIMILAR_OPERATORS: Final[_ComparesMapping] = types.MappingProxyType({\\n', ') -> Union[Type[ast.cmpop], _MultipleCompareOperators]:\\n', '    operator_type = operator.__class__\\n', '    return SIMILAR_OPERATORS.get(operator_type, operator_type)\\n', '        self._uses: _OperatorUsages = defaultdict(_Bounds)\\n', '        local_uses = self._build_bounds().values()\\n', '        for bounds in local_uses:\\n', '                bounds.lower_bound.intersection(bounds.upper_bound),\\n', '            num_lower_bounds = len(bounds.lower_bound)\\n', '            num_upper_bounds = len(bounds.upper_bound)\\n', '            if num_shared < num_lower_bounds and num_shared < num_upper_bounds:\\n', '    def _build_bounds(self) -> _OperatorUsages:\\n']",
  "context": "ower_bounds = len(bounds.lower_bound)\n            num_upper_bounds = len(bounds.upper_bound)\n            if num_shared < num_lower_bounds and n"
 },
 "1960": {
  "name": "comparators",
  "type": "zip",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "90",
  "column": "8",
  "slicing": "['_MultipleCompareOperators = Tuple[Type[ast.cmpop], ...]\\n', '_ComparesMapping = Mapping[\\n', '    _MultipleCompareOperators,\\n', '_OperatorUsages = DefaultDict[str, _Bounds]\\n', 'SIMILAR_OPERATORS: Final[_ComparesMapping] = types.MappingProxyType({\\n', ') -> Union[Type[ast.cmpop], _MultipleCompareOperators]:\\n', '    operator_type = operator.__class__\\n', '    return SIMILAR_OPERATORS.get(operator_type, operator_type)\\n', '        self._uses: _OperatorUsages = defaultdict(_Bounds)\\n', '        local_uses = self._build_bounds().values()\\n', '        for bounds in local_uses:\\n', '            num_shared = len(\\n', '                bounds.lower_bound.intersection(bounds.upper_bound),\\n', '            num_lower_bounds = len(bounds.lower_bound)\\n', '            num_upper_bounds = len(bounds.upper_bound)\\n', '            if num_shared < num_lower_bounds and num_shared < num_upper_bounds:\\n', '    def _build_bounds(self) -> _OperatorUsages:\\n', '        for comparison_node in self._node.values:\\n', '            if isinstance(comparison_node, ast.Compare):\\n', '                self._find_lower_upper_bounds(comparison_node)\\n', '        left_operand = comparison_node.left\\n', '        comparators = zip(comparison_node.ops, comparison_node.comparators)\\n', '        for operator, right_operand in comparators:\\n', '            for operand in (left_operand, right_operand):\\n', '                    comparison_node,\\n', '                    operator,\\n', '                    source.node_to_string(operand),\\n', '                    operand is left_operand,\\n', '            left_operand = right_operand\\n', '        if isinstance(operator, (ast.Lt, ast.LtE)):\\n', '        elif isinstance(operator, (ast.Gt, ast.GtE)):\\n', '            getattr(self._uses[name], key_name).add(comparison_node)\\n']",
  "context": "      left_operand = comparison_node.left\n        comparators = zip(comparison_node.ops, comparison_node.comparators)\n\n        for operator, right_operand in comparator"
 },
 "1961": {
  "name": "left_operand",
  "type": "right_operand",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "100",
  "column": "12",
  "slicing": "['_MultipleCompareOperators = Tuple[Type[ast.cmpop], ...]\\n', '_ComparesMapping = Mapping[\\n', '    _MultipleCompareOperators,\\n', '_OperatorUsages = DefaultDict[str, _Bounds]\\n', 'SIMILAR_OPERATORS: Final[_ComparesMapping] = types.MappingProxyType({\\n', ') -> Union[Type[ast.cmpop], _MultipleCompareOperators]:\\n', '    operator_type = operator.__class__\\n', '    return SIMILAR_OPERATORS.get(operator_type, operator_type)\\n', '        self._uses: _OperatorUsages = defaultdict(_Bounds)\\n', '        local_uses = self._build_bounds().values()\\n', '        for bounds in local_uses:\\n', '            num_shared = len(\\n', '                bounds.lower_bound.intersection(bounds.upper_bound),\\n', '            num_lower_bounds = len(bounds.lower_bound)\\n', '            num_upper_bounds = len(bounds.upper_bound)\\n', '            if num_shared < num_lower_bounds and num_shared < num_upper_bounds:\\n', '    def _build_bounds(self) -> _OperatorUsages:\\n', '        for comparison_node in self._node.values:\\n', '            if isinstance(comparison_node, ast.Compare):\\n', '                self._find_lower_upper_bounds(comparison_node)\\n', '        left_operand = comparison_node.left\\n', '        comparators = zip(comparison_node.ops, comparison_node.comparators)\\n', '        for operator, right_operand in comparators:\\n', '            for operand in (left_operand, right_operand):\\n', '                    comparison_node,\\n', '                    operator,\\n', '                    source.node_to_string(operand),\\n', '                    operand is left_operand,\\n', '            left_operand = right_operand\\n', '        if isinstance(operator, (ast.Lt, ast.LtE)):\\n', '        elif isinstance(operator, (ast.Gt, ast.GtE)):\\n', '            getattr(self._uses[name], key_name).add(comparison_node)\\n']",
  "context": "nd is left_operand,\n                )\n            left_operand = right_operand\n\n    def _mutate(\n        self,\n        comparison"
 },
 "1962": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "106",
  "column": "8",
  "slicing": "['        name: str,\\n']",
  "context": "ast.Compare,\n        operator: ast.cmpop,\n        name: str,\n        is_left: bool,\n    ) -> None:\n        key_"
 },
 "1963": {
  "name": "is_left",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "107",
  "column": "8",
  "slicing": "['        is_left: bool,\\n']",
  "context": "  operator: ast.cmpop,\n        name: str,\n        is_left: bool,\n    ) -> None:\n        key_name = None\n        if "
 },
 "1964": {
  "name": "key_name",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/compares.py",
  "lineno": "109",
  "column": "8",
  "slicing": "['        key_name = None\\n', '        if key_name:\\n', '            getattr(self._uses[name], key_name).add(comparison_node)\\n']",
  "context": "tr,\n        is_left: bool,\n    ) -> None:\n        key_name = None\n        if isinstance(operator, (ast.Lt, ast.LtE))"
 },
 "1965": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyChainable",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/attributes.py",
  "lineno": "15",
  "column": "10",
  "slicing": "['def parts(node: AnyChainable) -> Iterable[ast.AST]:\\n']",
  "context": " return iterator.func\n    return None\n\n\ndef parts(node: AnyChainable) -> Iterable[ast.AST]:\n    \"\"\"\n    Returns all ``.`` separated elements f"
 },
 "1966": {
  "name": "chained_item",
  "type": "_chained_item",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/attributes.py",
  "lineno": "32",
  "column": "8",
  "slicing": "['def _chained_item(iterator: ast.AST) -> Optional[ast.AST]:\\n', '    iterator: ast.AST = node\\n', '        yield iterator\\n', '        chained_item = _chained_item(iterator)\\n', '        if chained_item is None:\\n', '        iterator = chained_item\\n']",
  "context": "\n\n    while True:\n        yield iterator\n\n        chained_item = _chained_item(iterator)\n        if chained_item is None:\n            retur"
 },
 "1967": {
  "name": "iterator",
  "type": "chained_item",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/attributes.py",
  "lineno": "35",
  "column": "8",
  "slicing": "['def _chained_item(iterator: ast.AST) -> Optional[ast.AST]:\\n', '    iterator: ast.AST = node\\n', '        yield iterator\\n', '        chained_item = _chained_item(iterator)\\n', '        if chained_item is None:\\n', '        iterator = chained_item\\n']",
  "context": " chained_item is None:\n            return\n        iterator = chained_item\n"
 },
 "1968": {
  "name": "_VarDefinition",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/variables.py",
  "lineno": "4",
  "column": "0",
  "slicing": "['_VarDefinition = Union[ast.AST, ast.expr]\\n', 'def is_valid_block_variable_definition(node: _VarDefinition) -> bool:\\n', 'def _is_valid_single(node: _VarDefinition) -> bool:\\n']",
  "context": "import ast\nfrom typing import Union\n\n_VarDefinition = Union[ast.AST, ast.expr]\n_LocalVariable = Union[ast.Name, ast.ExceptHandler"
 },
 "1969": {
  "name": "_LocalVariable",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/variables.py",
  "lineno": "5",
  "column": "0",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', 'def get_variable_name(node: _LocalVariable) -> str:\\n']",
  "context": " Union\n\n_VarDefinition = Union[ast.AST, ast.expr]\n_LocalVariable = Union[ast.Name, ast.ExceptHandler]\n\n\ndef get_variable_name(node: _LocalVariable) -> s"
 },
 "1970": {
  "name": "node",
  "type": "_LocalVariable",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/variables.py",
  "lineno": "8",
  "column": "22",
  "slicing": "['def get_variable_name(node: _LocalVariable) -> str:\\n']",
  "context": ".Name, ast.ExceptHandler]\n\n\ndef get_variable_name(node: _LocalVariable) -> str:\n    \"\"\"Used to get variable names from all definit"
 },
 "1971": {
  "name": "node",
  "type": "_VarDefinition",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/variables.py",
  "lineno": "15",
  "column": "39",
  "slicing": "['def is_valid_block_variable_definition(node: _VarDefinition) -> bool:\\n']",
  "context": "me', '')\n\n\ndef is_valid_block_variable_definition(node: _VarDefinition) -> bool:\n    \"\"\"Is used to check either block variables are"
 },
 "1972": {
  "name": "node",
  "type": "_VarDefinition",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/variables.py",
  "lineno": "25",
  "column": "21",
  "slicing": "['def _is_valid_single(node: _VarDefinition) -> bool:\\n']",
  "context": "urn _is_valid_single(node)\n\n\ndef _is_valid_single(node: _VarDefinition) -> bool:\n    return (\n        isinstance(node, ast.Name) or"
 },
 "1973": {
  "name": "_IfAndElifASTNode",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/ifs.py",
  "lineno": "6",
  "column": "0",
  "slicing": "['_IfAndElifASTNode = Union[ast.If, List[ast.stmt]]\\n', '    last_elem = tuple(chain(node))[-1]\\n', '    return bool(last_elem)\\n', 'def chain(node: ast.If) -> Iterable[_IfAndElifASTNode]:\\n', '    iterator: _IfAndElifASTNode = node\\n', '    yield iterator\\n', '        if not isinstance(iterator, ast.If):\\n', '        next_if = iterator.orelse\\n', '        if len(next_if) == 1 and isinstance(next_if[0], ast.If):\\n', '            yield next_if[0]\\n', '            iterator = next_if[0]\\n', '            yield next_if\\n', '            iterator = next_if\\n']",
  "context": "m wemake_python_styleguide.types import AnyNodes\n\n_IfAndElifASTNode = Union[ast.If, List[ast.stmt]]\n\n\ndef is_elif(node: ast.If) -> bool:\n    \"\"\"Tells "
 },
 "1974": {
  "name": "last_elem",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/ifs.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    last_elem = tuple(chain(node))[-1]\\n', '    return bool(last_elem)\\n']",
  "context": "`` chain ends with an ``else`` expression.\"\"\"\n    last_elem = tuple(chain(node))[-1]\n    return bool(last_elem)\n\n\ndef root_if(node: ast"
 },
 "1975": {
  "name": "iterator",
  "type": "_IfAndElifASTNode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/ifs.py",
  "lineno": "50",
  "column": "4",
  "slicing": "['_IfAndElifASTNode = Union[ast.If, List[ast.stmt]]\\n', '    last_elem = tuple(chain(node))[-1]\\n', '    return bool(last_elem)\\n', 'def chain(node: ast.If) -> Iterable[_IfAndElifASTNode]:\\n', '    iterator: _IfAndElifASTNode = node\\n', '    yield iterator\\n', '        if not isinstance(iterator, ast.If):\\n', '        next_if = iterator.orelse\\n', '        if len(next_if) == 1 and isinstance(next_if[0], ast.If):\\n', '            yield next_if[0]\\n', '            iterator = next_if[0]\\n', '            yield next_if\\n', '            iterator = next_if\\n']",
  "context": "t that's how ``ast`` works in python.\n    \"\"\"\n    iterator: _IfAndElifASTNode = node\n    yield iterator\n\n    while True:\n        if not"
 },
 "1976": {
  "name": "iterator",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/ifs.py",
  "lineno": "60",
  "column": "12",
  "slicing": "['_IfAndElifASTNode = Union[ast.If, List[ast.stmt]]\\n', '    last_elem = tuple(chain(node))[-1]\\n', '    return bool(last_elem)\\n', 'def chain(node: ast.If) -> Iterable[_IfAndElifASTNode]:\\n', '    iterator: _IfAndElifASTNode = node\\n', '    yield iterator\\n', '        if not isinstance(iterator, ast.If):\\n', '        next_if = iterator.orelse\\n', '        if len(next_if) == 1 and isinstance(next_if[0], ast.If):\\n', '            yield next_if[0]\\n', '            iterator = next_if[0]\\n', '            yield next_if\\n', '            iterator = next_if\\n']",
  "context": "ast.If):\n            yield next_if[0]\n            iterator = next_if[0]\n        else:\n            yield next_if\n          "
 },
 "1977": {
  "name": "iterator",
  "type": "next_if",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/ifs.py",
  "lineno": "63",
  "column": "12",
  "slicing": "['_IfAndElifASTNode = Union[ast.If, List[ast.stmt]]\\n', '    last_elem = tuple(chain(node))[-1]\\n', '    return bool(last_elem)\\n', 'def chain(node: ast.If) -> Iterable[_IfAndElifASTNode]:\\n', '    iterator: _IfAndElifASTNode = node\\n', '    yield iterator\\n', '        if not isinstance(iterator, ast.If):\\n', '        next_if = iterator.orelse\\n', '        if len(next_if) == 1 and isinstance(next_if[0], ast.If):\\n', '            yield next_if[0]\\n', '            iterator = next_if[0]\\n', '            yield next_if\\n', '            iterator = next_if\\n']",
  "context": "      else:\n            yield next_if\n            iterator = next_if\n\n\ndef has_nodes(\n    to_check: AnyNodes,\n    itera"
 },
 "1978": {
  "name": "to_check",
  "type": "wemake_python_styleguide.types.AnyNodes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/ifs.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['    to_check: AnyNodes,\\n']",
  "context": "          iterator = next_if\n\n\ndef has_nodes(\n    to_check: AnyNodes,\n    iterable: Iterable[ast.AST],\n) -> bool:\n    \"\""
 },
 "1979": {
  "name": "iterable",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/ifs.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['    iterable: Iterable[ast.AST],\\n']",
  "context": "t_if\n\n\ndef has_nodes(\n    to_check: AnyNodes,\n    iterable: Iterable[ast.AST],\n) -> bool:\n    \"\"\"Finds the given nodes types in `"
 },
 "1980": {
  "name": "func",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/recursion.py",
  "lineno": "8",
  "column": "18",
  "slicing": "['def _is_self_call(func: AnyFunctionDef, node: AST) -> bool:\\n', '        if _is_self_call(func, node)\\n', '        node for node in walk(func)\\n', '        if isinstance(node, Call) and given_function_called(node, {func.name})\\n', '    if isinstance(get_context(func), ClassDef):\\n', '        return _check_method_recursion(func)\\n', '    return _check_function_recursion(func)\\n']",
  "context": "e.types import AnyFunctionDef\n\n\ndef _is_self_call(func: AnyFunctionDef, node: AST) -> bool:\n    return (\n        isinstance(node, Call) and\n  "
 },
 "1981": {
  "name": "node",
  "type": "ast.AST",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/recursion.py",
  "lineno": "8",
  "column": "40",
  "slicing": "['def _is_self_call(func: AnyFunctionDef, node: AST) -> bool:\\n', '        if _is_self_call(func, node)\\n', '        node for node in walk(func)\\n', '        if isinstance(node, Call) and given_function_called(node, {func.name})\\n']",
  "context": "tionDef\n\n\ndef _is_self_call(func: AnyFunctionDef, node: AST) -> bool:\n    return (\n        isinstance(node, Call) and\n  "
 },
 "1982": {
  "name": "func",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/recursion.py",
  "lineno": "16",
  "column": "28",
  "slicing": "['def _check_method_recursion(func: AnyFunctionDef) -> bool:\\n', '        return _check_method_recursion(func)\\n', '    return _check_function_recursion(func)\\n']",
  "context": "func.name)}))\n    )\n\n\ndef _check_method_recursion(func: AnyFunctionDef) -> bool:\n    return bool([\n        node for node in walk(fu"
 },
 "1983": {
  "name": "func",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/recursion.py",
  "lineno": "23",
  "column": "30",
  "slicing": "['def _check_function_recursion(func: AnyFunctionDef) -> bool:\\n', '    return _check_function_recursion(func)\\n']",
  "context": "unc, node)\n    ])\n\n\ndef _check_function_recursion(func: AnyFunctionDef) -> bool:\n    return bool([\n        node for node in walk(fu"
 },
 "1984": {
  "name": "func",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/recursion.py",
  "lineno": "30",
  "column": "24",
  "slicing": "['def has_recursive_calls(func: AnyFunctionDef) -> bool:\\n']",
  "context": "de, {func.name})\n    ])\n\n\ndef has_recursive_calls(func: AnyFunctionDef) -> bool:\n    \"\"\"\n    Determines whether function has recurs"
 },
 "1985": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/stubs.py",
  "lineno": "6",
  "column": "12",
  "slicing": "['def is_stub(node: AnyFunctionDef) -> bool:\\n']",
  "context": "leguide.types import AnyFunctionDef\n\n\ndef is_stub(node: AnyFunctionDef) -> bool:\n    \"\"\"\n    Checks if a function is a stub.\n\n    A"
 },
 "1986": {
  "name": "function_has_docstring",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/stubs.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    function_has_docstring = (\\n', '    if function_has_docstring:\\n']",
  "context": "  - a docstring + a `raise` statement\n    \"\"\"\n    function_has_docstring = (\n        isinstance(node.body[0], Expr) and\n       "
 },
 "1987": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/stubs.py",
  "lineno": "26",
  "column": "28",
  "slicing": "['def _is_stub_with_docstring(node: AnyFunctionDef) -> bool:\\n']",
  "context": "out_docstring(node)\n\n\ndef _is_stub_with_docstring(node: AnyFunctionDef) -> bool:\n    statements_in_body = len(node.body)\n    if sta"
 },
 "1988": {
  "name": "statements_in_body",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/stubs.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    function_has_docstring = (\\n', '    if function_has_docstring:\\n', '    statements_in_body = len(node.body)\\n', '    if statements_in_body == 1:\\n', '    elif statements_in_body == 2:\\n']",
  "context": "with_docstring(node: AnyFunctionDef) -> bool:\n    statements_in_body = len(node.body)\n    if statements_in_body == 1:\n        return Tru"
 },
 "1989": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/stubs.py",
  "lineno": "38",
  "column": "31",
  "slicing": "['def _is_stub_without_docstring(node: AnyFunctionDef) -> bool:\\n']",
  "context": "    return False\n\n\ndef _is_stub_without_docstring(node: AnyFunctionDef) -> bool:\n    return (\n        len(node.body) == 1 and\n     "
 },
 "1990": {
  "name": "node",
  "type": "ast.AST",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/stubs.py",
  "lineno": "48",
  "column": "17",
  "slicing": "['def _is_ellipsis(node: AST) -> bool:\\n']",
  "context": "ody[0], Raise)\n        )\n    )\n\n\ndef _is_ellipsis(node: AST) -> bool:\n    return (\n        isinstance(node, Expr) and\n  "
 },
 "1991": {
  "name": "_AllAttributes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/classes.py",
  "lineno": "11",
  "column": "0",
  "slicing": "['_AllAttributes = Tuple[List[AnyAssign], List[ast.Attribute]]\\n', 'def get_attributes(node: ast.ClassDef) -> _AllAttributes:\\n']",
  "context": "r the attributes we return from class inspection.\n_AllAttributes = Tuple[List[AnyAssign], List[ast.Attribute]]\n\n\ndef is_forbidden_super_class(class_name: Optiona"
 },
 "1992": {
  "name": "class_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/classes.py",
  "lineno": "14",
  "column": "29",
  "slicing": "['def is_forbidden_super_class(class_name: Optional[str]) -> bool:\\n']",
  "context": "st[ast.Attribute]]\n\n\ndef is_forbidden_super_class(class_name: Optional[str]) -> bool:\n    \"\"\"\n    Tells whether or not the base class is"
 },
 "1993": {
  "name": "class_attributes",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/classes.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['    class_attributes = []\\n', '            class_attributes.append(class_attr)\\n', '    return class_attributes, instance_attributes\\n']",
  "context": " class and instance level variables.\n\n    \"\"\"\n    class_attributes = []\n    instance_attributes = []\n\n    for subnode in a"
 },
 "1994": {
  "name": "instance_attributes",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/classes.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['    instance_attributes = []\\n', '            instance_attributes.append(instance_attr)\\n', '    return class_attributes, instance_attributes\\n']",
  "context": "variables.\n\n    \"\"\"\n    class_attributes = []\n    instance_attributes = []\n\n    for subnode in ast.walk(node):\n        instan"
 },
 "1995": {
  "name": "instance_attr",
  "type": "_get_instance_attribute",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/classes.py",
  "lineno": "64",
  "column": "8",
  "slicing": "['    instance_attributes = []\\n', '    for subnode in ast.walk(node):\\n', '        instance_attr = _get_instance_attribute(subnode)\\n', '        if instance_attr is not None:\\n', '            instance_attributes.append(instance_attr)\\n', '        class_attr = _get_class_attribute(node, subnode)\\n', '        if class_attr is not None:\\n', '            class_attributes.append(class_attr)\\n', '    return class_attributes, instance_attributes\\n', '    return subnode if (\\n', '        isinstance(subnode, AssignNodes) and\\n', '        nodes.get_context(subnode) == node and\\n', \"        getattr(subnode, 'value', None)\\n\"]",
  "context": " = []\n\n    for subnode in ast.walk(node):\n        instance_attr = _get_instance_attribute(subnode)\n        if instance_attr is not None:\n            "
 },
 "1996": {
  "name": "class_attr",
  "type": "_get_class_attribute",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/tree/classes.py",
  "lineno": "69",
  "column": "8",
  "slicing": "['    instance_attributes = []\\n', '    for subnode in ast.walk(node):\\n', '        instance_attr = _get_instance_attribute(subnode)\\n', '        if instance_attr is not None:\\n', '            instance_attributes.append(instance_attr)\\n', '        class_attr = _get_class_attribute(node, subnode)\\n', '        if class_attr is not None:\\n', '            class_attributes.append(class_attr)\\n', '    return class_attributes, instance_attributes\\n', '    return subnode if (\\n', '        isinstance(subnode, AssignNodes) and\\n', '        nodes.get_context(subnode) == node and\\n', \"        getattr(subnode, 'value', None)\\n\"]",
  "context": "pend(instance_attr)\n            continue\n\n        class_attr = _get_class_attribute(node, subnode)\n        if class_attr is not None:\n            cla"
 },
 "1997": {
  "name": "_BUILTINS_WHITELIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/builtins.py",
  "lineno": "10",
  "column": "0",
  "slicing": "['_BUILTINS_WHITELIST: Final = frozenset((\\n', '    if builtin[0] not in _BUILTINS_WHITELIST\\n']",
  "context": "e.logic.naming.access import is_magic, is_unused\n\n_BUILTINS_WHITELIST: Final = frozenset((\n    UNUSED_PLACEHOLDER,\n))\n\n_BUILTINS: Final = fro"
 },
 "1998": {
  "name": "_BUILTINS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/builtins.py",
  "lineno": "14",
  "column": "0",
  "slicing": "['_BUILTINS: Final = frozenset((\\n', '    *_BUILTINS,\\n']",
  "context": ": Final = frozenset((\n    UNUSED_PLACEHOLDER,\n))\n\n_BUILTINS: Final = frozenset((\n    builtin[0]\n    for builtin in inspect.getmembe"
 },
 "1999": {
  "name": "_ALL_BUILTINS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/builtins.py",
  "lineno": "20",
  "column": "0",
  "slicing": "['_ALL_BUILTINS: Final = frozenset((\\n', '    return variable_name in _ALL_BUILTINS\\n']",
  "context": "\n    if builtin[0] not in _BUILTINS_WHITELIST\n))\n\n_ALL_BUILTINS: Final = frozenset((\n    *keyword.kwlist,\n    *_BUILTINS,\n\n    # Specia"
 },
 "2000": {
  "name": "variable_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/builtins.py",
  "lineno": "31",
  "column": "20",
  "slicing": "['def is_builtin_name(variable_name: str) -> bool:\\n', '    return not is_builtin_name(variable_name[:-1])\\n']",
  "context": "   'async',\n    'await',\n))\n\n\ndef is_builtin_name(variable_name: str) -> bool:\n    \"\"\"\n    Tells whether a variable name is built"
 },
 "2001": {
  "name": "variable_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/builtins.py",
  "lineno": "54",
  "column": "19",
  "slicing": "['def is_wrong_alias(variable_name: str) -> bool:\\n']",
  "context": "riable_name in _ALL_BUILTINS\n\n\ndef is_wrong_alias(variable_name: str) -> bool:\n    \"\"\"\n    Tells whether a variable is wrong buil"
 },
 "2002": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/logical.py",
  "lineno": "10",
  "column": "18",
  "slicing": "['def is_wrong_name(name: str, to_check: Iterable[str]) -> bool:\\n']",
  "context": "de.logic.naming import access\n\n\ndef is_wrong_name(name: str, to_check: Iterable[str]) -> bool:\n    \"\"\"\n    Checks that name is not prohibited by "
 },
 "2003": {
  "name": "to_check",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/logical.py",
  "lineno": "10",
  "column": "29",
  "slicing": "['def is_wrong_name(name: str, to_check: Iterable[str]) -> bool:\\n']",
  "context": "ming import access\n\n\ndef is_wrong_name(name: str, to_check: Iterable[str]) -> bool:\n    \"\"\"\n    Checks that name is not prohibited by "
 },
 "2004": {
  "name": "choices_to_check",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/logical.py",
  "lineno": "34",
  "column": "8",
  "slicing": "['        choices_to_check = {\\n', '        if name.lower() in choices_to_check:\\n']",
  "context": "   \"\"\"\n    for name_to_check in to_check:\n        choices_to_check = {\n            name_to_check,\n            '_{0}'.form"
 },
 "2005": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/logical.py",
  "lineno": "44",
  "column": "23",
  "slicing": "['def is_upper_case_name(name: str) -> bool:\\n']",
  "context": "rn True\n    return False\n\n\ndef is_upper_case_name(name: str) -> bool:\n    \"\"\"\n    Checks that attribute name has no uppe"
 },
 "2006": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/logical.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['    name: str,\\n']",
  "context": "r character in name)\n\n\ndef is_too_short_name(\n    name: str,\n    min_length: int,\n    *,\n    trim: bool = True,"
 },
 "2007": {
  "name": "min_length",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/logical.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['    min_length: int,\\n']",
  "context": "name)\n\n\ndef is_too_short_name(\n    name: str,\n    min_length: int,\n    *,\n    trim: bool = True,\n) -> bool:\n    \"\"\"\n "
 },
 "2008": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/logical.py",
  "lineno": "132",
  "column": "4",
  "slicing": "['    name: str,\\n']",
  "context": "en(name) < min_length\n\n\ndef is_too_long_name(\n    name: str,\n    max_length: int,\n) -> bool:\n    \"\"\"\n    Checks"
 },
 "2009": {
  "name": "max_length",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/logical.py",
  "lineno": "133",
  "column": "4",
  "slicing": "['    max_length: int,\\n']",
  "context": "length\n\n\ndef is_too_long_name(\n    name: str,\n    max_length: int,\n) -> bool:\n    \"\"\"\n    Checks for too long names.\n"
 },
 "2010": {
  "name": "_UNUSED_VARIABLE_REGEX",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/access.py",
  "lineno": "6",
  "column": "0",
  "slicing": "[\"_UNUSED_VARIABLE_REGEX: Final = re.compile('^_+$')\\n\", '    return _UNUSED_VARIABLE_REGEX.match(name) is not None\\n']",
  "context": "patterns for unused variables, like `_` and `__`.\n_UNUSED_VARIABLE_REGEX: Final = re.compile('^_+$')\n\n\ndef is_unused(name: str) -> bool:\n    \"\"\"\n    Ch"
 },
 "2011": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/access.py",
  "lineno": "9",
  "column": "14",
  "slicing": "['def is_unused(name: str) -> bool:\\n', '    if is_unused(name):\\n', '    return not is_private(name) and not is_magic(name)\\n', '        not is_protected(name) and\\n', '        not is_private(name) and\\n', '        not is_magic(name) and\\n', '        not is_unused(name)\\n']",
  "context": "REGEX: Final = re.compile('^_+$')\n\n\ndef is_unused(name: str) -> bool:\n    \"\"\"\n    Checks whether the given ``name`` is u"
 },
 "2012": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/access.py",
  "lineno": "29",
  "column": "13",
  "slicing": "['def is_magic(name: str) -> bool:\\n', \"    return name.startswith('__') and not is_magic(name)\\n\", \"    if not name.startswith('_'):\\n\", '    if is_unused(name):\\n', '    return not is_private(name) and not is_magic(name)\\n', '        not is_protected(name) and\\n', '        not is_private(name) and\\n', '        not is_magic(name) and\\n', '        not is_unused(name)\\n']",
  "context": "ABLE_REGEX.match(name) is not None\n\n\ndef is_magic(name: str) -> bool:\n    \"\"\"\n    Checks whether the given ``name`` is m"
 },
 "2013": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/access.py",
  "lineno": "55",
  "column": "15",
  "slicing": "['def is_private(name: str) -> bool:\\n', '    return not is_private(name) and not is_magic(name)\\n', '        not is_protected(name) and\\n', '        not is_private(name) and\\n', '        not is_magic(name) and\\n', '        not is_unused(name)\\n']",
  "context": "th('__') and name.endswith('__')\n\n\ndef is_private(name: str) -> bool:\n    \"\"\"\n    Checks if name has private name patter"
 },
 "2014": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/access.py",
  "lineno": "78",
  "column": "17",
  "slicing": "['def is_protected(name: str) -> bool:\\n', '        not is_protected(name) and\\n', '        not is_private(name) and\\n', '        not is_magic(name) and\\n', '        not is_unused(name)\\n']",
  "context": "h('__') and not is_magic(name)\n\n\ndef is_protected(name: str) -> bool:\n    \"\"\"\n    Checks if name has protected name patt"
 },
 "2015": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/access.py",
  "lineno": "110",
  "column": "14",
  "slicing": "['def is_public(name: str) -> bool:\\n']",
  "context": "vate(name) and not is_magic(name)\n\n\ndef is_public(name: str) -> bool:\n    \"\"\"\n    Tells if this name is public.\n\n    >>>"
 },
 "2016": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/constants.py",
  "lineno": "4",
  "column": "16",
  "slicing": "['def is_constant(name: str) -> bool:\\n']",
  "context": ".naming.access import is_unused\n\n\ndef is_constant(name: str) -> bool:\n    \"\"\"\n    Checks whether the given ``name`` is a"
 },
 "2017": {
  "name": "nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/name_nodes.py",
  "lineno": "34",
  "column": "24",
  "slicing": "['def flat_variable_names(nodes: Iterable[AnyAssignWithWalrus]) -> Iterable[str]:\\n']",
  "context": "e.name\n\n    return None\n\n\ndef flat_variable_names(nodes: Iterable[AnyAssignWithWalrus]) -> Iterable[str]:\n    \"\"\"\n    Returns flat variable names from sever"
 },
 "2018": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/name_nodes.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    names: List[str] = []\\n', '        names.append(naive_attempt)\\n', '                names.extend(extracted_name)\\n', '    return names\\n']",
  "context": ", ``ast.For``,\n    ``ast.With``, etc.\n    \"\"\"\n    names: List[str] = []\n    naive_attempt = extract_name(node)\n\n    if nai"
 },
 "2019": {
  "name": "naive_attempt",
  "type": "extract_name",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/name_nodes.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['        for node in nodes\\n', '        for target in get_assign_targets(node)\\n', '    names: List[str] = []\\n', '    naive_attempt = extract_name(node)\\n', '    if naive_attempt:\\n', '        names.append(naive_attempt)\\n', '    elif isinstance(node, ast.Tuple):\\n', '        for subnode in node.elts:\\n', '            extracted_name = get_variables_from_node(subnode)\\n', '            if extracted_name:\\n', '                names.extend(extracted_name)\\n', '    return names\\n', '    if isinstance(node, ast.Starred):\\n', '        node = node.value\\n', '    if isinstance(node, ast.Name):\\n', '        return node.id\\n']",
  "context": "ith``, etc.\n    \"\"\"\n    names: List[str] = []\n    naive_attempt = extract_name(node)\n\n    if naive_attempt:\n        names.append(naive_"
 },
 "2020": {
  "name": "extracted_name",
  "type": "get_variables_from_node",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/name_nodes.py",
  "lineno": "79",
  "column": "12",
  "slicing": "['        for node in nodes\\n', '        for target in get_assign_targets(node)\\n', '    names: List[str] = []\\n', '    naive_attempt = extract_name(node)\\n', '    if naive_attempt:\\n', '        names.append(naive_attempt)\\n', '    elif isinstance(node, ast.Tuple):\\n', '        for subnode in node.elts:\\n', '            extracted_name = get_variables_from_node(subnode)\\n', '            if extracted_name:\\n', '                names.extend(extracted_name)\\n', '    return names\\n', '    if isinstance(node, ast.Starred):\\n', '        node = node.value\\n', '    if isinstance(node, ast.Name):\\n', '        return node.id\\n']",
  "context": "e):\n        for subnode in node.elts:\n            extracted_name = get_variables_from_node(subnode)\n            if extracted_name:\n                nam"
 },
 "2021": {
  "name": "options",
  "type": "wemake_python_styleguide.types.ConfigurationOptions",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/blacklists.py",
  "lineno": "10",
  "column": "4",
  "slicing": "['    options: ConfigurationOptions,\\n']",
  "context": "ru_cache()\ndef variable_names_blacklist_from(\n    options: ConfigurationOptions,\n) -> FrozenSet[str]:\n    \"\"\"Creates variable names"
 },
 "2022": {
  "name": "variable_names_blacklist",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/blacklists.py",
  "lineno": "13",
  "column": "4",
  "slicing": "['    variable_names_blacklist = {\\n', '        variable_names_blacklist - set(options.allowed_domain_names),\\n']",
  "context": "ames blacklist from options and constants.\"\"\"\n    variable_names_blacklist = {\n        *VARIABLE_NAMES_BLACKLIST,\n        *option"
 },
 "2023": {
  "name": "_UNDERSCORED_NUMBER_PATTERN",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/alphabet.py",
  "lineno": "10",
  "column": "0",
  "slicing": "[\"_UNDERSCORED_NUMBER_PATTERN: Final = re.compile(r'.+\\\\D\\\\_\\\\d+(\\\\D|$)')\\n\", '    return _UNDERSCORED_NUMBER_PATTERN.match(name) is not None\\n']",
  "context": "modules for underscored\n# numbers in their names:\n_UNDERSCORED_NUMBER_PATTERN: Final = re.compile(r'.+\\D\\_\\d+(\\D|$)')\n\n\ndef does_contain_underscored_number(name: str) -"
 },
 "2024": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/alphabet.py",
  "lineno": "13",
  "column": "36",
  "slicing": "['def does_contain_underscored_number(name: str) -> bool:\\n']",
  "context": "\\d+(\\D|$)')\n\n\ndef does_contain_underscored_number(name: str) -> bool:\n    \"\"\"\n    Checks for names with underscored numb"
 },
 "2025": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/alphabet.py",
  "lineno": "48",
  "column": "41",
  "slicing": "['def does_contain_consecutive_underscores(name: str) -> bool:\\n']",
  "context": "t None\n\n\ndef does_contain_consecutive_underscores(name: str) -> bool:\n    \"\"\"\n    Checks if name contains consecutive un"
 },
 "2026": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/alphabet.py",
  "lineno": "82",
  "column": "25",
  "slicing": "['def does_contain_unicode(name: str) -> bool:\\n']",
  "context": "   return '__' in name\n\n\ndef does_contain_unicode(name: str) -> bool:\n    \"\"\"\n    Check if name contains unicode charact"
 },
 "2027": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/alphabet.py",
  "lineno": "108",
  "column": "4",
  "slicing": "['    name: str,\\n']",
  "context": "return False\n\n\ndef get_unreadable_characters(\n    name: str,\n    character_combinations: Iterable[str],\n) -> st"
 },
 "2028": {
  "name": "character_combinations",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/logic/naming/alphabet.py",
  "lineno": "109",
  "column": "4",
  "slicing": "['    character_combinations: Iterable[str],\\n']",
  "context": "def get_unreadable_characters(\n    name: str,\n    character_combinations: Iterable[str],\n) -> str:\n    \"\"\"\n    Check if name contains unrea"
 },
 "2029": {
  "name": "ConfigValuesTypes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "157",
  "column": "0",
  "slicing": "['ConfigValuesTypes = Union[str, int, bool, Sequence[str]]\\n', '    default: ConfigValuesTypes\\n', '    def asdict_no_none(self) -> Mapping[str, ConfigValuesTypes]:\\n']",
  "context": "wemake_python_styleguide.options import defaults\n\nConfigValuesTypes = Union[str, int, bool, Sequence[str]]\nstring = 'string'\n\n\n@final\n@attr.dataclass(frozen="
 },
 "2030": {
  "name": "long_option_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "166",
  "column": "4",
  "slicing": "['    long_option_name: str\\n']",
  "context": "  \"\"\"Represents ``flake8`` option object.\"\"\"\n\n    long_option_name: str\n    default: ConfigValuesTypes\n    help: str  # no"
 },
 "2031": {
  "name": "default",
  "type": "ConfigValuesTypes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "167",
  "column": "4",
  "slicing": "['    default: ConfigValuesTypes\\n']",
  "context": " option object.\"\"\"\n\n    long_option_name: str\n    default: ConfigValuesTypes\n    help: str  # noqa: WPS125\n    type: Optional[s"
 },
 "2032": {
  "name": "help",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "168",
  "column": "4",
  "slicing": "['    help: str  # noqa: WPS125\\n']",
  "context": "tion_name: str\n    default: ConfigValuesTypes\n    help: str  # noqa: WPS125\n    type: Optional[str] = 'int'  # noqa: WPS125\n  "
 },
 "2033": {
  "name": "type",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "169",
  "column": "4",
  "slicing": "[\"    type: Optional[str] = 'int'  # noqa: WPS125\\n\"]",
  "context": "nfigValuesTypes\n    help: str  # noqa: WPS125\n    type: Optional[str] = 'int'  # noqa: WPS125\n    parse_from_config: bool = True\n    action: str"
 },
 "2034": {
  "name": "parse_from_config",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "170",
  "column": "4",
  "slicing": "['    parse_from_config: bool = True\\n']",
  "context": "  type: Optional[str] = 'int'  # noqa: WPS125\n    parse_from_config: bool = True\n    action: str = 'store'\n    comma_separated_list"
 },
 "2035": {
  "name": "action",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "171",
  "column": "4",
  "slicing": "[\"    action: str = 'store'\\n\"]",
  "context": "qa: WPS125\n    parse_from_config: bool = True\n    action: str = 'store'\n    comma_separated_list: bool = False\n    dest: O"
 },
 "2036": {
  "name": "comma_separated_list",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "172",
  "column": "4",
  "slicing": "['    comma_separated_list: bool = False\\n']",
  "context": "config: bool = True\n    action: str = 'store'\n    comma_separated_list: bool = False\n    dest: Optional[str] = None\n\n    def __attrs_po"
 },
 "2037": {
  "name": "dest",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "173",
  "column": "4",
  "slicing": "['    dest: Optional[str] = None\\n']",
  "context": "store'\n    comma_separated_list: bool = False\n    dest: Optional[str] = None\n\n    def __attrs_post_init__(self):\n        \"\"\"Is "
 },
 "2038": {
  "name": "_options",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "196",
  "column": "4",
  "slicing": "['    _options: ClassVar[Sequence[_Option]] = [\\n']",
  "context": "ple configuration store with all options.\"\"\"\n\n    _options: ClassVar[Sequence[_Option]] = [\n        # General:\n\n        _Option(\n            '"
 },
 "2039": {
  "name": "parser",
  "type": "flake8.options.manager.OptionManager",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/config.py",
  "lineno": "427",
  "column": "31",
  "slicing": "['    def register_options(self, parser: OptionManager) -> None:\\n']",
  "context": "\n        ),\n    ]\n\n    def register_options(self, parser: OptionManager) -> None:\n        \"\"\"Registers options for our plugin.\"\"\"\n  "
 },
 "2040": {
  "name": "min",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "11",
  "column": "4",
  "slicing": "['    min: Optional[int] = None,  # noqa: WPS125\\n', '    min_name_length: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_name_length: int = attr.ib(validator=[_min_max(min=1)])\\n', '        validator=[_min_max(min=1, max=defaults.MAX_NOQA_COMMENTS)],\\n', '    max_arguments: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_local_variables: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_returns: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_expressions: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_module_members: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_methods: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_line_complexity: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_jones_score: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_imports: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_imported_names: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_base_classes: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_decorators: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_string_usages: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_awaits: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_try_body_length: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_module_expressions: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_function_expressions: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_asserts: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_access_level: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_attributes: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_raises: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_cognitive_score: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_cognitive_average: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_call_level: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_annotation_complexity: int = attr.ib(validator=[_min_max(min=2)])\\n', '    max_import_from_members: int = attr.ib(validator=[_min_max(min=1)])\\n', '    max_tuple_unpack_length: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s import ConfigurationOptions\n\n\ndef _min_max(\n    min: Optional[int] = None,  # noqa: WPS125\n    max: Optional[int] = None,  # noqa: WPS125\n):\n"
 },
 "2041": {
  "name": "max",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "12",
  "column": "4",
  "slicing": "['    max: Optional[int] = None,  # noqa: WPS125\\n', '        validator=[_min_max(min=1, max=defaults.MAX_NOQA_COMMENTS)],\\n']",
  "context": "   min: Optional[int] = None,  # noqa: WPS125\n    max: Optional[int] = None,  # noqa: WPS125\n):\n    \"\"\"Validator to check that value is in boun"
 },
 "2042": {
  "name": "min_contract",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "16",
  "column": "8",
  "slicing": "['        min_contract = min is not None and field_value < min\\n', '        if min_contract or max_contract:\\n']",
  "context": "actory(instance, attribute, field_value):\n        min_contract = min is not None and field_value < min\n        max_contract = max is not None and field_v"
 },
 "2043": {
  "name": "max_contract",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "17",
  "column": "8",
  "slicing": "['        max_contract = max is not None and field_value > max\\n', '        if min_contract or max_contract:\\n']",
  "context": "t = min is not None and field_value < min\n        max_contract = max is not None and field_value > max\n        if min_contract or max_contract:\n         "
 },
 "2044": {
  "name": "allowed_domain_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['        min_contract = min is not None and field_value < min\\n', '        max_contract = max is not None and field_value > max\\n', '        if min_contract or max_contract:\\n', '    allowed_domain_names: Tuple[str, ...],\\n', '    intersecting_names = set(allowed_domain_names) & set(forbidden_domain_names)\\n', '    if intersecting_names:\\n', \"                ', '.join(intersecting_names)\\n\"]",
  "context": " factory\n\n\ndef validate_domain_names_options(\n    allowed_domain_names: Tuple[str, ...],\n    forbidden_domain_names: Tuple[str, ...],\n) -> "
 },
 "2045": {
  "name": "forbidden_domain_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['        min_contract = min is not None and field_value < min\\n', '        max_contract = max is not None and field_value > max\\n', '        if min_contract or max_contract:\\n', '    forbidden_domain_names: Tuple[str, ...],\\n', '    intersecting_names = set(allowed_domain_names) & set(forbidden_domain_names)\\n', '    if intersecting_names:\\n', \"                ', '.join(intersecting_names)\\n\"]",
  "context": "s(\n    allowed_domain_names: Tuple[str, ...],\n    forbidden_domain_names: Tuple[str, ...],\n) -> None:\n    \"\"\"Validator to check that allowed "
 },
 "2046": {
  "name": "min_name_length",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['    min_name_length: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "t used anywhere else.\n    \"\"\"\n\n    # General:\n    min_name_length: int = attr.ib(validator=[_min_max(min=1)])\n    i_control_code: bool\n    max_name_length: int "
 },
 "2047": {
  "name": "i_control_code",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['    i_control_code: bool\\n']",
  "context": "h: int = attr.ib(validator=[_min_max(min=1)])\n    i_control_code: bool\n    max_name_length: int = attr.ib(validator=[_min"
 },
 "2048": {
  "name": "max_name_length",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['    max_name_length: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "r=[_min_max(min=1)])\n    i_control_code: bool\n    max_name_length: int = attr.ib(validator=[_min_max(min=1)])\n    max_noqa_comments: int = attr.ib(\n        vali"
 },
 "2049": {
  "name": "max_noqa_comments",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['    max_noqa_comments: int = attr.ib(\\n']",
  "context": "h: int = attr.ib(validator=[_min_max(min=1)])\n    max_noqa_comments: int = attr.ib(\n        validator=[_min_max(min=1, max=defaults.MA"
 },
 "2050": {
  "name": "nested_classes_whitelist",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['    nested_classes_whitelist: Tuple[str, ...] = attr.ib(converter=tuple)\\n']",
  "context": "in=1, max=defaults.MAX_NOQA_COMMENTS)],\n    )\n    nested_classes_whitelist: Tuple[str, ...] = attr.ib(converter=tuple)\n    allowed_domain_names: Tuple[str, ...] = attr.i"
 },
 "2051": {
  "name": "allowed_domain_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "66",
  "column": "4",
  "slicing": "['        min_contract = min is not None and field_value < min\\n', '        max_contract = max is not None and field_value > max\\n', '        if min_contract or max_contract:\\n', '    intersecting_names = set(allowed_domain_names) & set(forbidden_domain_names)\\n', '    if intersecting_names:\\n', \"                ', '.join(intersecting_names)\\n\", '    allowed_domain_names: Tuple[str, ...] = attr.ib(converter=tuple)\\n']",
  "context": "t: Tuple[str, ...] = attr.ib(converter=tuple)\n    allowed_domain_names: Tuple[str, ...] = attr.ib(converter=tuple)\n    forbidden_domain_names: Tuple[str, ...] = attr"
 },
 "2052": {
  "name": "forbidden_domain_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['        min_contract = min is not None and field_value < min\\n', '        max_contract = max is not None and field_value > max\\n', '        if min_contract or max_contract:\\n', '    intersecting_names = set(allowed_domain_names) & set(forbidden_domain_names)\\n', '    if intersecting_names:\\n', \"                ', '.join(intersecting_names)\\n\", '    forbidden_domain_names: Tuple[str, ...] = attr.ib(converter=tuple)\\n']",
  "context": "s: Tuple[str, ...] = attr.ib(converter=tuple)\n    forbidden_domain_names: Tuple[str, ...] = attr.ib(converter=tuple)\n    forbidden_inline_ignore: Tuple[str, ...] = att"
 },
 "2053": {
  "name": "forbidden_inline_ignore",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['    forbidden_inline_ignore: Tuple[str, ...] = attr.ib(converter=tuple)\\n']",
  "context": "s: Tuple[str, ...] = attr.ib(converter=tuple)\n    forbidden_inline_ignore: Tuple[str, ...] = attr.ib(converter=tuple)\n\n    # Complexity:\n    max_arguments: int = attr.i"
 },
 "2054": {
  "name": "max_arguments",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['    max_arguments: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "= attr.ib(converter=tuple)\n\n    # Complexity:\n    max_arguments: int = attr.ib(validator=[_min_max(min=1)])\n    max_local_variables: int = attr.ib(validator=["
 },
 "2055": {
  "name": "max_local_variables",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    max_local_variables: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_local_variables: int = attr.ib(validator=[_min_max(min=1)])\n    max_returns: int = attr.ib(validator=[_min_max"
 },
 "2056": {
  "name": "max_returns",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['    max_returns: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_returns: int = attr.ib(validator=[_min_max(min=1)])\n    max_expressions: int = attr.ib(validator=[_min"
 },
 "2057": {
  "name": "max_expressions",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['    max_expressions: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_expressions: int = attr.ib(validator=[_min_max(min=1)])\n    max_module_members: int = attr.ib(validator=[_"
 },
 "2058": {
  "name": "max_module_members",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['    max_module_members: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_module_members: int = attr.ib(validator=[_min_max(min=1)])\n    max_methods: int = attr.ib(validator=[_min_max"
 },
 "2059": {
  "name": "max_methods",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['    max_methods: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_methods: int = attr.ib(validator=[_min_max(min=1)])\n    max_line_complexity: int = attr.ib(validator=["
 },
 "2060": {
  "name": "max_line_complexity",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "77",
  "column": "4",
  "slicing": "['    max_line_complexity: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_line_complexity: int = attr.ib(validator=[_min_max(min=1)])\n    max_jones_score: int = attr.ib(validator=[_min"
 },
 "2061": {
  "name": "max_jones_score",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['    max_jones_score: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "y: int = attr.ib(validator=[_min_max(min=1)])\n    max_jones_score: int = attr.ib(validator=[_min_max(min=1)])\n    max_imports: int = attr.ib(validator=[_min_max"
 },
 "2062": {
  "name": "max_imports",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "79",
  "column": "4",
  "slicing": "['    max_imports: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "e: int = attr.ib(validator=[_min_max(min=1)])\n    max_imports: int = attr.ib(validator=[_min_max(min=1)])\n    max_imported_names: int = attr.ib(validator=[_"
 },
 "2063": {
  "name": "max_imported_names",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['    max_imported_names: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_imported_names: int = attr.ib(validator=[_min_max(min=1)])\n    max_base_classes: int = attr.ib(validator=[_mi"
 },
 "2064": {
  "name": "max_base_classes",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "81",
  "column": "4",
  "slicing": "['    max_base_classes: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_base_classes: int = attr.ib(validator=[_min_max(min=1)])\n    max_decorators: int = attr.ib(validator=[_min_"
 },
 "2065": {
  "name": "max_decorators",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['    max_decorators: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_decorators: int = attr.ib(validator=[_min_max(min=1)])\n    max_string_usages: int = attr.ib(validator=[_m"
 },
 "2066": {
  "name": "max_string_usages",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['    max_string_usages: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_string_usages: int = attr.ib(validator=[_min_max(min=1)])\n    max_awaits: int = attr.ib(validator=[_min_max("
 },
 "2067": {
  "name": "max_awaits",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "84",
  "column": "4",
  "slicing": "['    max_awaits: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_awaits: int = attr.ib(validator=[_min_max(min=1)])\n    max_try_body_length: int = attr.ib(validator=["
 },
 "2068": {
  "name": "max_try_body_length",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['    max_try_body_length: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_try_body_length: int = attr.ib(validator=[_min_max(min=1)])\n    max_module_expressions: int = attr.ib(validato"
 },
 "2069": {
  "name": "max_module_expressions",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['    max_module_expressions: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "h: int = attr.ib(validator=[_min_max(min=1)])\n    max_module_expressions: int = attr.ib(validator=[_min_max(min=1)])\n    max_function_expressions: int = attr.ib(valida"
 },
 "2070": {
  "name": "max_function_expressions",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['    max_function_expressions: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_function_expressions: int = attr.ib(validator=[_min_max(min=1)])\n    max_asserts: int = attr.ib(validator=[_min_max"
 },
 "2071": {
  "name": "max_asserts",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['    max_asserts: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_asserts: int = attr.ib(validator=[_min_max(min=1)])\n    max_access_level: int = attr.ib(validator=[_mi"
 },
 "2072": {
  "name": "max_access_level",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "89",
  "column": "4",
  "slicing": "['    max_access_level: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_access_level: int = attr.ib(validator=[_min_max(min=1)])\n    max_attributes: int = attr.ib(validator=[_min_"
 },
 "2073": {
  "name": "max_attributes",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "90",
  "column": "4",
  "slicing": "['    max_attributes: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "l: int = attr.ib(validator=[_min_max(min=1)])\n    max_attributes: int = attr.ib(validator=[_min_max(min=1)])\n    max_raises: int = attr.ib(validator=[_min_max("
 },
 "2074": {
  "name": "max_raises",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "91",
  "column": "4",
  "slicing": "['    max_raises: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_raises: int = attr.ib(validator=[_min_max(min=1)])\n    max_cognitive_score: int = attr.ib(validator=["
 },
 "2075": {
  "name": "max_cognitive_score",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "92",
  "column": "4",
  "slicing": "['    max_cognitive_score: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_cognitive_score: int = attr.ib(validator=[_min_max(min=1)])\n    max_cognitive_average: int = attr.ib(validator"
 },
 "2076": {
  "name": "max_cognitive_average",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['    max_cognitive_average: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "e: int = attr.ib(validator=[_min_max(min=1)])\n    max_cognitive_average: int = attr.ib(validator=[_min_max(min=1)])\n    max_call_level: int = attr.ib(validator=[_min_"
 },
 "2077": {
  "name": "max_call_level",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "94",
  "column": "4",
  "slicing": "['    max_call_level: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "e: int = attr.ib(validator=[_min_max(min=1)])\n    max_call_level: int = attr.ib(validator=[_min_max(min=1)])\n    max_annotation_complexity: int = attr.ib(valid"
 },
 "2078": {
  "name": "max_annotation_complexity",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "95",
  "column": "4",
  "slicing": "['    max_annotation_complexity: int = attr.ib(validator=[_min_max(min=2)])\\n']",
  "context": "l: int = attr.ib(validator=[_min_max(min=1)])\n    max_annotation_complexity: int = attr.ib(validator=[_min_max(min=2)])\n    max_import_from_members: int = attr.ib(validat"
 },
 "2079": {
  "name": "max_import_from_members",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "96",
  "column": "4",
  "slicing": "['    max_import_from_members: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "y: int = attr.ib(validator=[_min_max(min=2)])\n    max_import_from_members: int = attr.ib(validator=[_min_max(min=1)])\n    max_tuple_unpack_length: int = attr.ib(validat"
 },
 "2080": {
  "name": "max_tuple_unpack_length",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "97",
  "column": "4",
  "slicing": "['    max_tuple_unpack_length: int = attr.ib(validator=[_min_max(min=1)])\\n']",
  "context": "s: int = attr.ib(validator=[_min_max(min=1)])\n    max_tuple_unpack_length: int = attr.ib(validator=[_min_max(min=1)])\n\n\ndef validate_options(options: ConfigurationOptio"
 },
 "2081": {
  "name": "options",
  "type": "wemake_python_styleguide.types.ConfigurationOptions",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "100",
  "column": "21",
  "slicing": "['def validate_options(options: ConfigurationOptions) -> _ValidatedOptions:\\n']",
  "context": "lidator=[_min_max(min=1)])\n\n\ndef validate_options(options: ConfigurationOptions) -> _ValidatedOptions:\n    \"\"\"Validates all options from ``flake8``, uses"
 },
 "2082": {
  "name": "fields_to_validate",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "106",
  "column": "4",
  "slicing": "['    fields_to_validate = [\\n', '        for field in fields_to_validate\\n']",
  "context": "        options.forbidden_domain_names,\n    )\n    fields_to_validate = [\n        field.name\n        for field in attr.field"
 },
 "2083": {
  "name": "options_subset",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/validation.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['    options_subset = {\\n', '    return _ValidatedOptions(**options_subset)  # raises TypeError\\n']",
  "context": "field in attr.fields(_ValidatedOptions)\n    ]\n    options_subset = {\n        field: getattr(options, field, None)\n     "
 },
 "2084": {
  "name": "MIN_NAME_LENGTH",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "22",
  "column": "0",
  "slicing": "['MIN_NAME_LENGTH: Final = 2  # reasonable enough\\n']",
  "context": "l:\n# ========\n\n#: Minimum variable's name length.\nMIN_NAME_LENGTH: Final = 2  # reasonable enough\n\n#: Maximum variable and module name length:\nMAX_N"
 },
 "2085": {
  "name": "MAX_NAME_LENGTH",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "25",
  "column": "0",
  "slicing": "['MAX_NAME_LENGTH: Final = 45  # reasonable enough\\n']",
  "context": "ough\n\n#: Maximum variable and module name length:\nMAX_NAME_LENGTH: Final = 45  # reasonable enough\n\n#: Whether you control ones who use your code.\nI_"
 },
 "2086": {
  "name": "I_CONTROL_CODE",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "28",
  "column": "0",
  "slicing": "['I_CONTROL_CODE: Final = True\\n']",
  "context": "h\n\n#: Whether you control ones who use your code.\nI_CONTROL_CODE: Final = True\n\n#: Maximum amount of ``noqa`` comments per module"
 },
 "2087": {
  "name": "MAX_NOQA_COMMENTS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "31",
  "column": "0",
  "slicing": "['MAX_NOQA_COMMENTS: Final = 10  # guessed\\n']",
  "context": ": Maximum amount of ``noqa`` comments per module.\nMAX_NOQA_COMMENTS: Final = 10  # guessed\n\n#: List of nested classes' names we allow to use."
 },
 "2088": {
  "name": "NESTED_CLASSES_WHITELIST",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "34",
  "column": "0",
  "slicing": "['NESTED_CLASSES_WHITELIST: Final = (\\n']",
  "context": "#: List of nested classes' names we allow to use.\nNESTED_CLASSES_WHITELIST: Final = (\n    'Meta',  # django forms, models, drf, etc\n    "
 },
 "2089": {
  "name": "ALLOWED_DOMAIN_NAMES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "40",
  "column": "0",
  "slicing": "['ALLOWED_DOMAIN_NAMES: Final = ()\\n']",
  "context": " that are removed from variable names' blacklist.\nALLOWED_DOMAIN_NAMES: Final = ()\n\n#: Domain names that extends variable names' blac"
 },
 "2090": {
  "name": "FORBIDDEN_DOMAIN_NAMES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "43",
  "column": "0",
  "slicing": "['FORBIDDEN_DOMAIN_NAMES: Final = ()\\n']",
  "context": "ain names that extends variable names' blacklist.\nFORBIDDEN_DOMAIN_NAMES: Final = ()\n\n#: Violation codes that are forbidden to use.\nFOR"
 },
 "2091": {
  "name": "FORBIDDEN_INLINE_IGNORE",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "46",
  "column": "0",
  "slicing": "['FORBIDDEN_INLINE_IGNORE: Final = ()\\n']",
  "context": "()\n\n#: Violation codes that are forbidden to use.\nFORBIDDEN_INLINE_IGNORE: Final = ()\n\n# ===========\n# Complexity:\n# ===========\n\n#: Max"
 },
 "2092": {
  "name": "MAX_RETURNS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "53",
  "column": "0",
  "slicing": "['MAX_RETURNS: Final = 5  # 7-2\\n']",
  "context": "`return` statements allowed in a single function.\nMAX_RETURNS: Final = 5  # 7-2\n\n#: Maximum number of local variables in a functio"
 },
 "2093": {
  "name": "MAX_LOCAL_VARIABLES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "56",
  "column": "0",
  "slicing": "['MAX_LOCAL_VARIABLES: Final = 5  # 7-2\\n']",
  "context": " Maximum number of local variables in a function.\nMAX_LOCAL_VARIABLES: Final = 5  # 7-2\n\n#: Maximum number of expressions in a single func"
 },
 "2094": {
  "name": "MAX_EXPRESSIONS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "59",
  "column": "0",
  "slicing": "['MAX_EXPRESSIONS: Final = 9  # 7+2\\n']",
  "context": "ximum number of expressions in a single function.\nMAX_EXPRESSIONS: Final = 9  # 7+2\n\n#: Maximum number of arguments for functions or m"
 },
 "2095": {
  "name": "MAX_ARGUMENTS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "62",
  "column": "0",
  "slicing": "['MAX_ARGUMENTS: Final = 5  # 7-2\\n']",
  "context": "mum number of arguments for functions or methods.\nMAX_ARGUMENTS: Final = 5  # 7-2\n\n#: Maximum number of classes and functions in a s"
 },
 "2096": {
  "name": "MAX_MODULE_MEMBERS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "65",
  "column": "0",
  "slicing": "['MAX_MODULE_MEMBERS: Final = 7  # 7\\n']",
  "context": "mber of classes and functions in a single module.\nMAX_MODULE_MEMBERS: Final = 7  # 7\n\n#: Maximum number of methods in a single class.\nM"
 },
 "2097": {
  "name": "MAX_METHODS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "68",
  "column": "0",
  "slicing": "['MAX_METHODS: Final = 7  # the same as module members\\n']",
  "context": "\n\n#: Maximum number of methods in a single class.\nMAX_METHODS: Final = 7  # the same as module members\n\n#: Maximum line complexity.\nMAX_LINE_COMPLEXITY: "
 },
 "2098": {
  "name": "MAX_LINE_COMPLEXITY",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "71",
  "column": "0",
  "slicing": "['MAX_LINE_COMPLEXITY: Final = 14  # 7 * 2, also almost guessed\\n']",
  "context": "me as module members\n\n#: Maximum line complexity.\nMAX_LINE_COMPLEXITY: Final = 14  # 7 * 2, also almost guessed\n\n#: Maximum median module Jones complexity.\nMAX_JO"
 },
 "2099": {
  "name": "MAX_JONES_SCORE",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "74",
  "column": "0",
  "slicing": "['MAX_JONES_SCORE: Final = 12  # guessed\\n']",
  "context": "essed\n\n#: Maximum median module Jones complexity.\nMAX_JONES_SCORE: Final = 12  # guessed\n\n#: Maximum number of imports in a single module.\n"
 },
 "2100": {
  "name": "MAX_IMPORTS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "77",
  "column": "0",
  "slicing": "['MAX_IMPORTS: Final = 12  # guessed\\n']",
  "context": "\n#: Maximum number of imports in a single module.\nMAX_IMPORTS: Final = 12  # guessed\n\n#: Maximum number of imported names in a single m"
 },
 "2101": {
  "name": "MAX_IMPORTED_NAMES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "80",
  "column": "0",
  "slicing": "['MAX_IMPORTED_NAMES: Final = 50  # guessed\\n']",
  "context": "imum number of imported names in a single module.\nMAX_IMPORTED_NAMES: Final = 50  # guessed\n\n#: Maximum number of base classes.\nMAX_BASE_CLASS"
 },
 "2102": {
  "name": "MAX_BASE_CLASSES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "83",
  "column": "0",
  "slicing": "['MAX_BASE_CLASSES: Final = 3  # guessed\\n']",
  "context": "50  # guessed\n\n#: Maximum number of base classes.\nMAX_BASE_CLASSES: Final = 3  # guessed\n\n#: Maximum number of decorators.\nMAX_DECORATORS: "
 },
 "2103": {
  "name": "MAX_DECORATORS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "86",
  "column": "0",
  "slicing": "['MAX_DECORATORS: Final = 5  # 7-2\\n']",
  "context": " = 3  # guessed\n\n#: Maximum number of decorators.\nMAX_DECORATORS: Final = 5  # 7-2\n\n#: Maximum number of same string usage in code.\nM"
 },
 "2104": {
  "name": "MAX_STRING_USAGES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "89",
  "column": "0",
  "slicing": "['MAX_STRING_USAGES: Final = 3  # guessed\\n']",
  "context": "\n\n#: Maximum number of same string usage in code.\nMAX_STRING_USAGES: Final = 3  # guessed\n\n#: Maximum number of ``await`` expressions for fu"
 },
 "2105": {
  "name": "MAX_AWAITS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "92",
  "column": "0",
  "slicing": "['MAX_AWAITS: Final = 5  # the same as returns\\n']",
  "context": "f ``await`` expressions for functions or methods.\nMAX_AWAITS: Final = 5  # the same as returns\n\n#: Maximum amount of ``try`` node body length.\nMA"
 },
 "2106": {
  "name": "MAX_TRY_BODY_LENGTH",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "95",
  "column": "0",
  "slicing": "['MAX_TRY_BODY_LENGTH: Final = 1  # best practice\\n']",
  "context": "s\n\n#: Maximum amount of ``try`` node body length.\nMAX_TRY_BODY_LENGTH: Final = 1  # best practice\n\n#: Maximum amount of same expressions per module."
 },
 "2107": {
  "name": "MAX_MODULE_EXPRESSIONS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "98",
  "column": "0",
  "slicing": "['MAX_MODULE_EXPRESSIONS: Final = 7  # the same as module elements\\n']",
  "context": "#: Maximum amount of same expressions per module.\nMAX_MODULE_EXPRESSIONS: Final = 7  # the same as module elements\n\n#: Maximum amount of same expressions per functio"
 },
 "2108": {
  "name": "MAX_FUNCTION_EXPRESSIONS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "101",
  "column": "0",
  "slicing": "['MAX_FUNCTION_EXPRESSIONS: Final = 4  # guessed\\n']",
  "context": " Maximum amount of same expressions per function.\nMAX_FUNCTION_EXPRESSIONS: Final = 4  # guessed\n\n#: Maximum number of ``assert`` statements in a f"
 },
 "2109": {
  "name": "MAX_ASSERTS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "104",
  "column": "0",
  "slicing": "['MAX_ASSERTS: Final = 5  # 7-2\\n']",
  "context": "um number of ``assert`` statements in a function.\nMAX_ASSERTS: Final = 5  # 7-2\n\n#: Maximum number of access level in an expressio"
 },
 "2110": {
  "name": "MAX_ACCESS_LEVEL",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "107",
  "column": "0",
  "slicing": "['MAX_ACCESS_LEVEL: Final = 4  # guessed\\n']",
  "context": " Maximum number of access level in an expression.\nMAX_ACCESS_LEVEL: Final = 4  # guessed\n\n#: Maximum number of public attributes in a singl"
 },
 "2111": {
  "name": "MAX_ATTRIBUTES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "110",
  "column": "0",
  "slicing": "['MAX_ATTRIBUTES: Final = 6  # guessed\\n']",
  "context": "um number of public attributes in a single class.\nMAX_ATTRIBUTES: Final = 6  # guessed\n\n#: Maximum number of raises in a function.\nMAX_RA"
 },
 "2112": {
  "name": "MAX_RAISES",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "113",
  "column": "0",
  "slicing": "['MAX_RAISES: Final = 3  # guessed\\n']",
  "context": "essed\n\n#: Maximum number of raises in a function.\nMAX_RAISES: Final = 3  # guessed\n\n#: Maximum amount of cognitive complexity per fun"
 },
 "2113": {
  "name": "MAX_COGNITIVE_SCORE",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "116",
  "column": "0",
  "slicing": "['MAX_COGNITIVE_SCORE: Final = 12  # based on this code statistics\\n']",
  "context": "imum amount of cognitive complexity per function.\nMAX_COGNITIVE_SCORE: Final = 12  # based on this code statistics\n\n#: Maximum amount of average cognitive complexity"
 },
 "2114": {
  "name": "MAX_COGNITIVE_AVERAGE",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "119",
  "column": "0",
  "slicing": "['MAX_COGNITIVE_AVERAGE: Final = 8  # based on this code statistics\\n']",
  "context": "mount of average cognitive complexity per module.\nMAX_COGNITIVE_AVERAGE: Final = 8  # based on this code statistics\n\n#: Maximum number of call chains.\nMAX_CALL_LEVEL:"
 },
 "2115": {
  "name": "MAX_CALL_LEVEL",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "122",
  "column": "0",
  "slicing": "['MAX_CALL_LEVEL: Final = 3  # reasonable enough\\n']",
  "context": "ode statistics\n\n#: Maximum number of call chains.\nMAX_CALL_LEVEL: Final = 3  # reasonable enough\n\n#: Maximum number of nested annotations.\nMAX_ANN_"
 },
 "2116": {
  "name": "MAX_ANN_COMPLEXITY",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "125",
  "column": "0",
  "slicing": "['MAX_ANN_COMPLEXITY: Final = 3  # reasonable enough\\n']",
  "context": " enough\n\n#: Maximum number of nested annotations.\nMAX_ANN_COMPLEXITY: Final = 3  # reasonable enough\n\n#: Maximum number of names that can be imported f"
 },
 "2117": {
  "name": "MAX_IMPORT_FROM_MEMBERS",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "128",
  "column": "0",
  "slicing": "['MAX_IMPORT_FROM_MEMBERS: Final = 8  # guessed\\n']",
  "context": "number of names that can be imported from module.\nMAX_IMPORT_FROM_MEMBERS: Final = 8  # guessed\n\n#: Maximum number of variables in a ``tuple`` unp"
 },
 "2118": {
  "name": "MAX_TUPLE_UNPACK_LENGTH",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/options/defaults.py",
  "lineno": "131",
  "column": "0",
  "slicing": "['MAX_TUPLE_UNPACK_LENGTH: Final = 4  # guessed\\n']",
  "context": " of variables in a ``tuple`` unpacking statement.\nMAX_TUPLE_UNPACK_LENGTH: Final = 4  # guessed\n"
 },
 "2119": {
  "name": "transformer",
  "type": "pep8ext_naming.NamingChecker",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast_tree.py",
  "lineno": "20",
  "column": "23",
  "slicing": "['    def __init__(self, transformer: NamingChecker) -> None:\\n']",
  "context": " types inside classes.\"\"\"\n\n    def __init__(self, transformer: NamingChecker) -> None:\n        super().__init__()\n        self.transforme"
 },
 "2120": {
  "name": "transformer",
  "type": "_ClassVisitor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast_tree.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['    for statement in ast.walk(tree):\\n', '        for child in ast.iter_child_nodes(statement):\\n', \"            setattr(child, 'wps_parent', statement)  # noqa: B010\\n\", \"    transformer = _ClassVisitor(NamingChecker(tree, 'stdin'))\\n\", '    transformer.visit(tree)\\n']",
  "context": "hod`.\n\n    .. versionchanged:: 0.3.0\n\n    \"\"\"\n    transformer = _ClassVisitor(NamingChecker(tree, 'stdin'))\n    transformer.visit(tree)\n    return tree\n\n\ndef "
 },
 "2121": {
  "name": "pipeline",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast_tree.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['    for statement in ast.walk(tree):\\n', '        for child in ast.iter_child_nodes(statement):\\n', \"            setattr(child, 'wps_parent', statement)  # noqa: B010\\n\", \"    transformer = _ClassVisitor(NamingChecker(tree, 'stdin'))\\n\", '    transformer.visit(tree)\\n', '    pipeline = (\\n', '    for transformation in pipeline:\\n', '        tree = transformation(tree)\\n', '    return tree\\n']",
  "context": "es\n    - bugfixes\n    - enhancements\n\n    \"\"\"\n    pipeline = (\n        # Initial, should be the first ones, order"
 },
 "2122": {
  "name": "tree",
  "type": "transformation",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast_tree.py",
  "lineno": "91",
  "column": "8",
  "slicing": "['    for statement in ast.walk(tree):\\n', '        for child in ast.iter_child_nodes(statement):\\n', \"            setattr(child, 'wps_parent', statement)  # noqa: B010\\n\", \"    transformer = _ClassVisitor(NamingChecker(tree, 'stdin'))\\n\", '    transformer.visit(tree)\\n', '    pipeline = (\\n', '    for transformation in pipeline:\\n', '        tree = transformation(tree)\\n', '    return tree\\n']",
  "context": "   )\n\n    for transformation in pipeline:\n        tree = transformation(tree)\n    return tree\n"
 },
 "2123": {
  "name": "nodes_to_fix",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast/bugfixes.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    nodes_to_fix = (\\n', '        if isinstance(node, nodes_to_fix):\\n']",
  "context": "/wemake-python-styleguide/issues/282\n\n    \"\"\"\n    nodes_to_fix = (\n        ast.AsyncFor,\n        ast.AsyncWith,\n     "
 },
 "2124": {
  "name": "affected",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast/bugfixes.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['    nodes_to_fix = (\\n', '    for node in ast.walk(tree):\\n', '        if isinstance(node, nodes_to_fix):\\n', '            error = 6 if node.col_offset % 4 else 0\\n', '            node.col_offset = node.col_offset - error\\n', '    affected = (ast.Tuple,)\\n', '    for node in ast.walk(tree):\\n', '        if isinstance(node, affected):\\n', \"            parent_lineno = getattr(get_parent(node), 'lineno', None)\\n\", '            if parent_lineno and parent_lineno < node.lineno:\\n', '                node.lineno = node.lineno - 1\\n']",
  "context": "actually starts from here\n        ))\n\n    \"\"\"\n    affected = (ast.Tuple,)\n    for node in ast.walk(tree):\n        if isinsta"
 },
 "2125": {
  "name": "parent_lineno",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast/bugfixes.py",
  "lineno": "56",
  "column": "12",
  "slicing": "['    nodes_to_fix = (\\n', '    for node in ast.walk(tree):\\n', '        if isinstance(node, nodes_to_fix):\\n', '            error = 6 if node.col_offset % 4 else 0\\n', '            node.col_offset = node.col_offset - error\\n', '    affected = (ast.Tuple,)\\n', '    for node in ast.walk(tree):\\n', '        if isinstance(node, affected):\\n', \"            parent_lineno = getattr(get_parent(node), 'lineno', None)\\n\", '            if parent_lineno and parent_lineno < node.lineno:\\n', '                node.lineno = node.lineno - 1\\n']",
  "context": "       if isinstance(node, affected):\n            parent_lineno = getattr(get_parent(node), 'lineno', None)\n            if parent_lineno and parent_lineno < n"
 },
 "2126": {
  "name": "_CONTEXTS",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast/enhancements.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['_CONTEXTS: Tuple[Type[ContextNodes], ...] = (\\n', '    for statement in ast.walk(tree):\\n', '        if isinstance(statement, ast.If):\\n', '            _apply_if_statement(statement)\\n', '    for statement in ast.walk(tree):\\n', '        current_context = _find_context(statement, _CONTEXTS)\\n', \"        setattr(statement, 'wps_context', current_context)  # noqa: B010\\n\", '    for child in ast.iter_child_nodes(statement):\\n', '        if isinstance(child, ast.If):\\n', '            if child in statement.orelse:\\n', \"                setattr(statement, 'wps_if_chained', True)  # noqa: B010\\n\", \"                setattr(child, 'wps_if_chain', statement)  # noqa: B010\\n\"]",
  "context": "make_python_styleguide.types import ContextNodes\n\n_CONTEXTS: Tuple[Type[ContextNodes], ...] = (\n    ast.Module,\n    ast.ClassDef,\n    *FunctionNod"
 },
 "2127": {
  "name": "current_context",
  "type": "_find_context",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast/enhancements.py",
  "lineno": "69",
  "column": "8",
  "slicing": "['_CONTEXTS: Tuple[Type[ContextNodes], ...] = (\\n', '    for statement in ast.walk(tree):\\n', '        if isinstance(statement, ast.If):\\n', '            _apply_if_statement(statement)\\n', '    for statement in ast.walk(tree):\\n', '        current_context = _find_context(statement, _CONTEXTS)\\n', \"        setattr(statement, 'wps_context', current_context)  # noqa: B010\\n\", '    for child in ast.iter_child_nodes(statement):\\n', '        if isinstance(child, ast.If):\\n', '            if child in statement.orelse:\\n', \"                setattr(statement, 'wps_if_chained', True)  # noqa: B010\\n\", \"                setattr(child, 'wps_if_chain', statement)  # noqa: B010\\n\"]",
  "context": " \"\"\"\n    for statement in ast.walk(tree):\n        current_context = _find_context(statement, _CONTEXTS)\n        setattr(statement, 'wps_context', current_"
 },
 "2128": {
  "name": "contexts",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast/enhancements.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['    contexts: Tuple[Type[ast.AST], ...],\\n']",
  "context": " tree\n\n\ndef _find_context(\n    node: ast.AST,\n    contexts: Tuple[Type[ast.AST], ...],\n) -> Optional[ast.AST]:\n    \"\"\"\n    We changed how"
 },
 "2129": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/transformations/ast/enhancements.py",
  "lineno": "84",
  "column": "4",
  "slicing": "['_CONTEXTS: Tuple[Type[ContextNodes], ...] = (\\n', '    for statement in ast.walk(tree):\\n', '        if isinstance(statement, ast.If):\\n', '            _apply_if_statement(statement)\\n', '    for statement in ast.walk(tree):\\n', '        current_context = _find_context(statement, _CONTEXTS)\\n', \"        setattr(statement, 'wps_context', current_context)  # noqa: B010\\n\", '    parent = get_parent(node)\\n', '    if parent is None:\\n', '    elif isinstance(parent, contexts):\\n', '        return parent\\n', '    return _find_context(parent, contexts)\\n', '    for child in ast.iter_child_nodes(statement):\\n', '        if isinstance(child, ast.If):\\n', '            if child in statement.orelse:\\n', \"                setattr(statement, 'wps_if_chained', True)  # noqa: B010\\n\", \"                setattr(child, 'wps_if_chain', statement)  # noqa: B010\\n\"]",
  "context": "s/wemake-python-styleguide/issues/520\n    \"\"\"\n    parent = get_parent(node)\n    if parent is None:\n        return None\n    eli"
 },
 "2130": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['    previous_codes = {426}\\n']",
  "context": "nd subclassing a builtin: {0}'\n    code = 600\n    previous_codes = {426}\n\n\n@final\nclass ShadowedClassAttributeViolation(AST"
 },
 "2131": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "147",
  "column": "4",
  "slicing": "['    previous_codes = {427}\\n']",
  "context": "shadowed class attribute: {0}'\n    code = 601\n    previous_codes = {427}\n\n\n@final\nclass StaticMethodViolation(ASTViolation)"
 },
 "2132": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "169",
  "column": "4",
  "slicing": "['    previous_codes = {433}\\n']",
  "context": " 'Found using `@staticmethod`'\n    code = 602\n    previous_codes = {433}\n\n\n@final\nclass BadMagicMethodViolation(ASTViolatio"
 },
 "2133": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "200",
  "column": "4",
  "slicing": "['    previous_codes = {434}\\n']",
  "context": " restricted magic method: {0}'\n    code = 603\n    previous_codes = {434}\n\n\n@final\nclass WrongClassBodyContentViolation(ASTV"
 },
 "2134": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "237",
  "column": "4",
  "slicing": "['    previous_codes = {452}\\n']",
  "context": "rect node inside `class` body'\n    code = 604\n    previous_codes = {452}\n\n\n@final\nclass MethodWithoutArgumentsViolation(AST"
 },
 "2135": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "273",
  "column": "4",
  "slicing": "['    previous_codes = {453}\\n']",
  "context": "method without arguments: {0}'\n    code = 605\n    previous_codes = {453}\n\n\n@final\nclass WrongBaseClassViolation(ASTViolatio"
 },
 "2136": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "311",
  "column": "4",
  "slicing": "['    previous_codes = {454}\\n']",
  "context": "= 'Found incorrect base class'\n    code = 606\n    previous_codes = {454}\n\n\n@final\nclass WrongSlotsViolation(ASTViolation):\n"
 },
 "2137": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "359",
  "column": "4",
  "slicing": "['    previous_codes = {455}\\n']",
  "context": " incorrect `__slots__` syntax'\n    code = 607\n    previous_codes = {455}\n\n\n@final\nclass WrongSuperCallViolation(ASTViolatio"
 },
 "2138": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "391",
  "column": "4",
  "slicing": "['    previous_codes = {456}\\n']",
  "context": "incorrect `super()` call: {0}'\n    code = 608\n    previous_codes = {456}\n\n\n@final\nclass DirectMagicAttributeAccessViolation"
 },
 "2139": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "427",
  "column": "4",
  "slicing": "['    previous_codes = {462}\\n']",
  "context": "ct magic attribute usage: {0}'\n    code = 609\n    previous_codes = {462}\n\n\n@final\nclass AsyncMagicMethodViolation(ASTViolat"
 },
 "2140": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/oop.py",
  "lineno": "512",
  "column": "4",
  "slicing": "['    previous_codes = {439, 435}\\n']",
  "context": "en `yield` magic method usage'\n    code = 611\n    previous_codes = {439, 435}\n\n\n@final\nclass UselessOverwrittenMethodViolation(A"
 },
 "2141": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "138",
  "column": "4",
  "slicing": "['    previous_codes = {436}\\n']",
  "context": "se` in a loop without `break`'\n    code = 500\n    previous_codes = {436}\n\n\n@final\nclass UselessFinallyViolation(ASTViolatio"
 },
 "2142": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "179",
  "column": "4",
  "slicing": "['    previous_codes = {437}\\n']",
  "context": " `try` block without `except`'\n    code = 501\n    previous_codes = {437}\n\n\n@final\nclass SimplifiableIfViolation(ASTViolatio"
 },
 "2143": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "215",
  "column": "4",
  "slicing": "['    previous_codes = {451}\\n']",
  "context": "d simplifiable `if` condition'\n    code = 502\n    previous_codes = {451}\n\n\n@final\nclass UselessReturningElseViolation(ASTVi"
 },
 "2144": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "258",
  "column": "4",
  "slicing": "['    previous_codes = {457}\\n']",
  "context": "ss returning `else` statement'\n    code = 503\n    previous_codes = {457}\n\n\n@final\nclass NegatedConditionsViolation(ASTViola"
 },
 "2145": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "302",
  "column": "4",
  "slicing": "['    previous_codes = {463}\\n']",
  "context": "te = 'Found negated condition'\n    code = 504\n    previous_codes = {463}\n\n\n@final\nclass NestedTryViolation(ASTViolation):\n "
 },
 "2146": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "352",
  "column": "4",
  "slicing": "['    previous_codes = {464}\\n']",
  "context": "e = 'Found nested `try` block'\n    code = 505\n    previous_codes = {464}\n\n\n@final\nclass UselessLambdaViolation(ASTViolation"
 },
 "2147": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "384",
  "column": "4",
  "slicing": "['    previous_codes = {467}\\n']",
  "context": "nd useless lambda declaration'\n    code = 506\n    previous_codes = {467}\n\n\n@final\nclass UselessLenCompareViolation(ASTViola"
 },
 "2148": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "420",
  "column": "4",
  "slicing": "['    previous_codes = {468}\\n']",
  "context": "Found useless `len()` compare'\n    code = 507\n    previous_codes = {468}\n\n\n@final\nclass NotOperatorWithCompareViolation(AST"
 },
 "2149": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "452",
  "column": "4",
  "slicing": "['    previous_codes = {470}\\n']",
  "context": "rect `not` with compare usage'\n    code = 508\n    previous_codes = {470}\n\n\n@final\nclass NestedTernaryViolation(ASTViolation"
 },
 "2150": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "490",
  "column": "4",
  "slicing": "['    previous_codes = {472}\\n']",
  "context": "nd incorrectly nested ternary'\n    code = 509\n    previous_codes = {472}\n\n\n@final\nclass WrongInCompareTypeViolation(ASTViol"
 },
 "2151": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "529",
  "column": "4",
  "slicing": "['    previous_codes = {473}\\n']",
  "context": "used with a non-set container'\n    code = 510\n    previous_codes = {473}\n\n\n@final\nclass UnmergedIsinstanceCallsViolation(AS"
 },
 "2152": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "565",
  "column": "4",
  "slicing": "['    previous_codes = {474}\\n']",
  "context": " can be merged for: {0}'\n    )\n    code = 511\n    previous_codes = {474}\n\n\n@final\nclass WrongIsinstanceWithTupleViolation(A"
 },
 "2153": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "598",
  "column": "4",
  "slicing": "['    previous_codes = {475}\\n']",
  "context": "l with a single element tuple'\n    code = 512\n    previous_codes = {475}\n\n\n@final\nclass ImplicitElifViolation(TokenizeViola"
 },
 "2154": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/refactoring.py",
  "lineno": "668",
  "column": "4",
  "slicing": "['    previous_codes = {336}\\n']",
  "context": "or_template = 'Found implicit `in` condition'\n    previous_codes = {336}\n\n\n@final\nclass OpenWithoutContextManagerViolation("
 },
 "2155": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/consistency.py",
  "lineno": "1545",
  "column": "4",
  "slicing": "['    previous_codes = {465}\\n']",
  "context": "= 'Found multiline conditions'\n    code = 337\n    previous_codes = {465}\n\n\n@final\nclass WrongMethodOrderViolation(ASTViolat"
 },
 "2156": {
  "name": "ErrorNode",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "61",
  "column": "0",
  "slicing": "['ErrorNode = Union[\\n', '        node: ErrorNode,\\n']",
  "context": " type for all possible nodes where error happens.\nErrorNode = Union[\n    ast.AST,\n    tokenize.TokenInfo,\n    None,\n]\n\n"
 },
 "2157": {
  "name": "ErrorCallback",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "68",
  "column": "0",
  "slicing": "[\"ErrorCallback = Callable[['BaseViolation'], None]\\n\"]",
  "context": " helper classes with callbacks to add violations.\nErrorCallback = Callable[['BaseViolation'], None]\n\n\n@enum.unique\nclass ViolationPostfixes(enum.Enum)"
 },
 "2158": {
  "name": "error_template",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "97",
  "column": "4",
  "slicing": "['    error_template: ClassVar[str]\\n']",
  "context": "ssage that we show at the very end.\n\n    \"\"\"\n\n    error_template: ClassVar[str]\n    code: ClassVar[int]\n    previous_codes: ClassV"
 },
 "2159": {
  "name": "code",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "98",
  "column": "4",
  "slicing": "['    code: ClassVar[int]\\n']",
  "context": ".\n\n    \"\"\"\n\n    error_template: ClassVar[str]\n    code: ClassVar[int]\n    previous_codes: ClassVar[Set[int]]\n    depreca"
 },
 "2160": {
  "name": "previous_codes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "99",
  "column": "4",
  "slicing": "['    previous_codes: ClassVar[Set[int]]\\n']",
  "context": "mplate: ClassVar[str]\n    code: ClassVar[int]\n    previous_codes: ClassVar[Set[int]]\n    deprecated: ClassVar[bool] = False\n\n    # We u"
 },
 "2161": {
  "name": "deprecated",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "100",
  "column": "4",
  "slicing": "['    deprecated: ClassVar[bool] = False\\n']",
  "context": "r[int]\n    previous_codes: ClassVar[Set[int]]\n    deprecated: ClassVar[bool] = False\n\n    # We use this code to show base metrics and t"
 },
 "2162": {
  "name": "postfix_template",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "103",
  "column": "4",
  "slicing": "['    postfix_template: ClassVar[ViolationPostfixes] = (\\n']",
  "context": "e to show base metrics and thresholds mostly:\n    postfix_template: ClassVar[ViolationPostfixes] = (\n        ViolationPostfixes.bigger_than\n    )\n\n    "
 },
 "2163": {
  "name": "node",
  "type": "ErrorNode",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "109",
  "column": "8",
  "slicing": "['        node: ErrorNode,\\n']",
  "context": "an\n    )\n\n    def __init__(\n        self,\n        node: ErrorNode,\n        text: Optional[str] = None,\n        baseli"
 },
 "2164": {
  "name": "text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "110",
  "column": "8",
  "slicing": "['        text: Optional[str] = None,\\n']",
  "context": "_(\n        self,\n        node: ErrorNode,\n        text: Optional[str] = None,\n        baseline: Optional[int] = None,\n    ) -> N"
 },
 "2165": {
  "name": "baseline",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "111",
  "column": "8",
  "slicing": "['        baseline: Optional[int] = None,\\n']",
  "context": "Node,\n        text: Optional[str] = None,\n        baseline: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        Creates a new i"
 },
 "2166": {
  "name": "_node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "173",
  "column": "4",
  "slicing": "['    _node: Optional[ast.AST]\\n']",
  "context": " a based type for all ``ast`` violations.\"\"\"\n\n    _node: Optional[ast.AST]\n\n    @final\n    def _location(self) -> Tuple[int, "
 },
 "2167": {
  "name": "line_number",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "177",
  "column": "8",
  "slicing": "['ErrorNode = Union[\\n', '        node: ErrorNode,\\n', \"        line_number = getattr(self._node, 'lineno', 0)\\n\", '        return line_number, column_offset\\n']",
  "context": "  def _location(self) -> Tuple[int, int]:\n        line_number = getattr(self._node, 'lineno', 0)\n        column_offset = getattr(self._node, 'col_o"
 },
 "2168": {
  "name": "column_offset",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "178",
  "column": "8",
  "slicing": "['ErrorNode = Union[\\n', '        node: ErrorNode,\\n', \"        column_offset = getattr(self._node, 'col_offset', 0)\\n\", '        return line_number, column_offset\\n']",
  "context": "number = getattr(self._node, 'lineno', 0)\n        column_offset = getattr(self._node, 'col_offset', 0)\n        return line_number, column_offset\n\n\nclass "
 },
 "2169": {
  "name": "_node",
  "type": "UnDefined",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "185",
  "column": "4",
  "slicing": "['    _node: ast.AST\\n']",
  "context": "olation for ``ast`` based style visitors.\"\"\"\n\n    _node: ast.AST\n\n\nclass MaybeASTViolation(_BaseASTViolation, metac"
 },
 "2170": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "198",
  "column": "8",
  "slicing": "['        node: Optional[ast.AST] = None,\\n']",
  "context": "\n    \"\"\"\n\n    def __init__(\n        self,\n        node: Optional[ast.AST] = None,\n        text: Optional[str] = None,\n        baseli"
 },
 "2171": {
  "name": "text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "199",
  "column": "8",
  "slicing": "['        text: Optional[str] = None,\\n']",
  "context": ",\n        node: Optional[ast.AST] = None,\n        text: Optional[str] = None,\n        baseline: Optional[int] = None,\n    ) -> N"
 },
 "2172": {
  "name": "baseline",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "200",
  "column": "8",
  "slicing": "['        baseline: Optional[int] = None,\\n']",
  "context": "None,\n        text: Optional[str] = None,\n        baseline: Optional[int] = None,\n    ) -> None:\n        \"\"\"Creates new instance of "
 },
 "2173": {
  "name": "_node",
  "type": "UnDefined",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "209",
  "column": "4",
  "slicing": "['    _node: tokenize.TokenInfo\\n']",
  "context": "iolation for ``tokenize`` based visitors.\"\"\"\n\n    _node: tokenize.TokenInfo\n\n    @final\n    def _location(self) -> Tuple[int, "
 },
 "2174": {
  "name": "_node",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "219",
  "column": "4",
  "slicing": "['    _node: None\\n']",
  "context": " cases where there's no associated nodes.\"\"\"\n\n    _node: None\n\n    def __init__(\n        self,\n        node=None"
 },
 "2175": {
  "name": "text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "224",
  "column": "8",
  "slicing": "['        text: Optional[str] = None,\\n']",
  "context": "_init__(\n        self,\n        node=None,\n        text: Optional[str] = None,\n        baseline: Optional[int] = None,\n    ) -> N"
 },
 "2176": {
  "name": "baseline",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/base.py",
  "lineno": "225",
  "column": "8",
  "slicing": "['        baseline: Optional[int] = None,\\n']",
  "context": "None,\n        text: Optional[str] = None,\n        baseline: Optional[int] = None,\n    ) -> None:\n        \"\"\"Creates new instance of "
 },
 "2177": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "336",
  "column": "4",
  "slicing": "['    previous_codes = {459}\\n']",
  "context": " 'Found complex default value'\n    code = 404\n    previous_codes = {459}\n\n\n@final\nclass LoopVariableDefinitionViolation(AST"
 },
 "2178": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "370",
  "column": "4",
  "slicing": "['    previous_codes = {460}\\n']",
  "context": "for` loop variable definition'\n    code = 405\n    previous_codes = {460}\n\n\n@final\nclass ContextManagerVariableDefinitionVio"
 },
 "2179": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "404",
  "column": "4",
  "slicing": "['    previous_codes = {461}\\n']",
  "context": "t manager variable definition'\n    code = 406\n    previous_codes = {461}\n\n\n@final\nclass MutableModuleConstantViolation(ASTV"
 },
 "2180": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "441",
  "column": "4",
  "slicing": "['    previous_codes = {466}\\n']",
  "context": "Found mutable module constant'\n    code = 407\n    previous_codes = {466}\n\n\n@final\nclass SameElementsInConditionViolation(AS"
 },
 "2181": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "475",
  "column": "4",
  "slicing": "['    previous_codes = {469}\\n']",
  "context": "d duplicate logical condition'\n    code = 408\n    previous_codes = {469}\n\n\n@final\nclass HeterogeneousCompareViolation(ASTVi"
 },
 "2182": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "516",
  "column": "4",
  "slicing": "['    previous_codes = {471}\\n']",
  "context": " 'Found heterogeneous compare'\n    code = 409\n    previous_codes = {471}\n\n\n@final\nclass WrongModuleMetadataViolation(ASTVio"
 },
 "2183": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "680",
  "column": "4",
  "slicing": "['    previous_codes = {446}\\n']",
  "context": "nd incorrect unpacking target'\n    code = 414\n    previous_codes = {446}\n\n\n@final\nclass DuplicateExceptionViolation(ASTViol"
 },
 "2184": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "719",
  "column": "4",
  "slicing": "['    previous_codes = {447}\\n']",
  "context": "ound duplicate exception: {0}'\n    code = 415\n    previous_codes = {447}\n\n\n@final\nclass YieldInComprehensionViolation(ASTVi"
 },
 "2185": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "757",
  "column": "4",
  "slicing": "['    previous_codes = {448}\\n']",
  "context": " `yield` inside comprehension'\n    code = 416\n    previous_codes = {448}\n\n\n@final\nclass NonUniqueItemsInHashViolation(ASTVi"
 },
 "2186": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "799",
  "column": "4",
  "slicing": "['    previous_codes = {449}\\n']",
  "context": " non-unique item in hash: {0}'\n    code = 417\n    previous_codes = {449}\n\n\n@final\nclass BaseExceptionSubclassViolation(ASTV"
 },
 "2187": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "836",
  "column": "4",
  "slicing": "['    previous_codes = {450}\\n']",
  "context": "nherited from `BaseException`'\n    code = 418\n    previous_codes = {450}\n\n\n@final\nclass TryExceptMultipleReturnPathViolatio"
 },
 "2188": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "892",
  "column": "4",
  "slicing": "['    previous_codes = {458}\\n']",
  "context": "y` with multiple return paths'\n    code = 419\n    previous_codes = {458}\n\n\n@final\nclass WrongKeywordViolation(ASTViolation)"
 },
 "2189": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "1131",
  "column": "4",
  "slicing": "['    previous_codes = {442}\\n']",
  "context": "Found `lambda` in loop's body\"\n    code = 426\n    previous_codes = {442}\n\n\n@final\nclass UnreachableCodeViolation(ASTViolati"
 },
 "2190": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "1177",
  "column": "4",
  "slicing": "['    previous_codes = {443}\\n']",
  "context": "ate = 'Found unreachable code'\n    code = 427\n    previous_codes = {443}\n\n\n@final\nclass StatementHasNoEffectViolation(ASTVi"
 },
 "2191": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "1213",
  "column": "4",
  "slicing": "['    previous_codes = {444}\\n']",
  "context": " statement that has no effect'\n    code = 428\n    previous_codes = {444}\n\n\n@final\nclass MultipleAssignmentsViolation(ASTVio"
 },
 "2192": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "1245",
  "column": "4",
  "slicing": "['    previous_codes = {445}\\n']",
  "context": "Found multiple assign targets'\n    code = 429\n    previous_codes = {445}\n\n\n@final\nclass NestedFunctionViolation(ASTViolatio"
 },
 "2193": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "1408",
  "column": "4",
  "slicing": "['    previous_codes = {435}\\n']",
  "context": "mplate = 'Found nested import'\n    code = 433\n    previous_codes = {435}\n\n\n@final\nclass ReassigningVariableToItselfViolatio"
 },
 "2194": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "1437",
  "column": "4",
  "slicing": "['    previous_codes = {438}\\n']",
  "context": "gning variable to itself: {0}'\n    code = 434\n    previous_codes = {438}\n\n\n@final\nclass ListMultiplyViolation(ASTViolation)"
 },
 "2195": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "1504",
  "column": "4",
  "slicing": "['    previous_codes = {440}\\n']",
  "context": " protected module import: {0}'\n    code = 436\n    previous_codes = {440}\n\n\n@final\nclass ProtectedAttributeViolation(ASTViol"
 },
 "2196": {
  "name": "previous_codes",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/violations/best_practices.py",
  "lineno": "1548",
  "column": "4",
  "slicing": "['    previous_codes = {441}\\n']",
  "context": "rotected attribute usage: {0}'\n    code = 437\n    previous_codes = {441}\n\n\n@final\nclass StopIterationInsideGeneratorViolati"
 },
 "2197": {
  "name": "_DefinedType",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/decorators.py",
  "lineno": "3",
  "column": "0",
  "slicing": "[\"_DefinedType = TypeVar('_DefinedType')\\n\", '    cls: Type[_DefinedType],\\n', ') -> Type[_DefinedType]:\\n', ') -> Callable[[Type[_DefinedType]], Type[_DefinedType]]:\\n', '    def decorator(cls: Type[_DefinedType]) -> Type[_DefinedType]:\\n']",
  "context": "rom typing import Callable, Tuple, Type, TypeVar\n\n_DefinedType = TypeVar('_DefinedType')\n\n\ndef _modify_class(\n    cls: Type[_DefinedType],\n"
 },
 "2198": {
  "name": "cls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/decorators.py",
  "lineno": "7",
  "column": "4",
  "slicing": "['    cls: Type[_DefinedType],\\n', '        return _modify_class(cls, original, aliases)\\n']",
  "context": " TypeVar('_DefinedType')\n\n\ndef _modify_class(\n    cls: Type[_DefinedType],\n    original: str,\n    aliases: Tuple[str, ...],\n)"
 },
 "2199": {
  "name": "original",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/decorators.py",
  "lineno": "8",
  "column": "4",
  "slicing": "['    original: str,\\n', '        return _modify_class(cls, original, aliases)\\n']",
  "context": "f _modify_class(\n    cls: Type[_DefinedType],\n    original: str,\n    aliases: Tuple[str, ...],\n) -> Type[_DefinedTy"
 },
 "2200": {
  "name": "aliases",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/decorators.py",
  "lineno": "9",
  "column": "4",
  "slicing": "['    aliases: Tuple[str, ...],\\n', '        return _modify_class(cls, original, aliases)\\n']",
  "context": "  cls: Type[_DefinedType],\n    original: str,\n    aliases: Tuple[str, ...],\n) -> Type[_DefinedType]:\n    original_handler = ge"
 },
 "2201": {
  "name": "original_handler",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/decorators.py",
  "lineno": "11",
  "column": "4",
  "slicing": "[\"_DefinedType = TypeVar('_DefinedType')\\n\", '    cls: Type[_DefinedType],\\n', ') -> Type[_DefinedType]:\\n', '    original_handler = getattr(cls, original, None)\\n', '    if original_handler is None:\\n', '        setattr(cls, method_alias, original_handler)\\n', ') -> Callable[[Type[_DefinedType]], Type[_DefinedType]]:\\n', '    def decorator(cls: Type[_DefinedType]) -> Type[_DefinedType]:\\n']",
  "context": "es: Tuple[str, ...],\n) -> Type[_DefinedType]:\n    original_handler = getattr(cls, original, None)\n    if original_handler is None:\n        raise Att"
 },
 "2202": {
  "name": "original",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/decorators.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    original: str,\\n']",
  "context": "original_handler)\n    return cls\n\n\ndef alias(\n    original: str,\n    aliases: Tuple[str, ...],\n) -> Callable[[Type["
 },
 "2203": {
  "name": "aliases",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/decorators.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    aliases: Tuple[str, ...],\\n']",
  "context": "   return cls\n\n\ndef alias(\n    original: str,\n    aliases: Tuple[str, ...],\n) -> Callable[[Type[_DefinedType]], Type[_DefinedT"
 },
 "2204": {
  "name": "cls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/decorators.py",
  "lineno": "44",
  "column": "18",
  "slicing": "['    def decorator(cls: Type[_DefinedType]) -> Type[_DefinedType]:\\n']",
  "context": "ror('Found duplicate aliases')\n\n    def decorator(cls: Type[_DefinedType]) -> Type[_DefinedType]:\n        return _modify_class(cls, original, aliase"
 },
 "2205": {
  "name": "options",
  "type": "wemake_python_styleguide.types.ConfigurationOptions",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "91",
  "column": "8",
  "slicing": "['        options: ConfigurationOptions,\\n']",
  "context": "\n    \"\"\"\n\n    def __init__(\n        self,\n        options: ConfigurationOptions,\n        filename: str = constants.STDIN,\n    ) -> "
 },
 "2206": {
  "name": "filename",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "92",
  "column": "8",
  "slicing": "['        filename: str = constants.STDIN,\\n']",
  "context": "f,\n        options: ConfigurationOptions,\n        filename: str = constants.STDIN,\n    ) -> None:\n        \"\"\"Creates base visitor ins"
 },
 "2207": {
  "name": "cls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "101",
  "column": "8",
  "slicing": "[\"        cls: Type['BaseVisitor'],\\n\"]",
  "context": "]\n\n    @classmethod\n    def from_checker(\n        cls: Type['BaseVisitor'],\n        checker,\n    ) -> 'BaseVisitor':\n        \""
 },
 "2208": {
  "name": "violation",
  "type": "wemake_python_styleguide.violations.base.BaseViolation",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "117",
  "column": "28",
  "slicing": "['    def add_violation(self, violation: BaseViolation) -> None:\\n']",
  "context": "filename)\n\n    @final\n    def add_violation(self, violation: BaseViolation) -> None:\n        \"\"\"Adds violation to the visitor.\"\"\"\n     "
 },
 "2209": {
  "name": "options",
  "type": "wemake_python_styleguide.types.ConfigurationOptions",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "153",
  "column": "8",
  "slicing": "['        options: ConfigurationOptions,\\n']",
  "context": "\n    \"\"\"\n\n    def __init__(\n        self,\n        options: ConfigurationOptions,\n        tree: ast.AST,\n        **kwargs,\n    ) -> "
 },
 "2210": {
  "name": "cls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "164",
  "column": "8",
  "slicing": "[\"        cls: Type['BaseNodeVisitor'],\\n\"]",
  "context": "al\n    @classmethod\n    def from_checker(\n        cls: Type['BaseNodeVisitor'],\n        checker,\n    ) -> 'BaseNodeVisitor':\n     "
 },
 "2211": {
  "name": "stem",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "206",
  "column": "4",
  "slicing": "['    stem: str\\n']",
  "context": "lename. Does not contain extension.\n\n    \"\"\"\n\n    stem: str\n\n    @abc.abstractmethod\n    def visit_filename(se"
 },
 "2212": {
  "name": "options",
  "type": "wemake_python_styleguide.types.ConfigurationOptions",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "238",
  "column": "8",
  "slicing": "['        options: ConfigurationOptions,\\n']",
  "context": "\n    \"\"\"\n\n    def __init__(\n        self,\n        options: ConfigurationOptions,\n        file_tokens: Sequence[tokenize.TokenInfo],"
 },
 "2213": {
  "name": "file_tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "239",
  "column": "8",
  "slicing": "['        file_tokens: Sequence[tokenize.TokenInfo],\\n']",
  "context": "f,\n        options: ConfigurationOptions,\n        file_tokens: Sequence[tokenize.TokenInfo],\n        **kwargs,\n    ) -> None:\n        \"\"\"Create"
 },
 "2214": {
  "name": "cls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "249",
  "column": "8",
  "slicing": "[\"        cls: Type['BaseTokenVisitor'],\\n\"]",
  "context": "al\n    @classmethod\n    def from_checker(\n        cls: Type['BaseTokenVisitor'],\n        checker,\n    ) -> 'BaseTokenVisitor':\n    "
 },
 "2215": {
  "name": "method",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/base.py",
  "lineno": "277",
  "column": "8",
  "slicing": "['        token_type = tokenize.tok_name[token.exact_type].lower()\\n', \"        method = getattr(self, 'visit_{0}'.format(token_type), None)\\n\", '        if method is not None:\\n', '            method(token)\\n']",
  "context": "kenize.tok_name[token.exact_type].lower()\n        method = getattr(self, 'visit_{0}'.format(token_type), None)\n        if method is not None:\n            method("
 },
 "2216": {
  "name": "_MeaninglessOperators",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "21",
  "column": "0",
  "slicing": "['_MeaninglessOperators = Mapping[complex, Tuple[Type[ast.operator], ...]]\\n', '    _meaningless_operations: ClassVar[_MeaninglessOperators] = {\\n', '    _left_special_cases: ClassVar[_MeaninglessOperators] = {\\n']",
  "context": "thon_styleguide.visitors import base, decorators\n\n_MeaninglessOperators = Mapping[complex, Tuple[Type[ast.operator], ...]]\n_OperatorLimits = Mapping[Type[ast.unaryop], int]\n"
 },
 "2217": {
  "name": "_OperatorLimits",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "22",
  "column": "0",
  "slicing": "['_OperatorLimits = Mapping[Type[ast.unaryop], int]\\n', '    _unary_limits: ClassVar[_OperatorLimits] = {\\n']",
  "context": " Mapping[complex, Tuple[Type[ast.operator], ...]]\n_OperatorLimits = Mapping[Type[ast.unaryop], int]\n_NumbersAndConstants = Union[ast.Num, ast.NameCons"
 },
 "2218": {
  "name": "_NumbersAndConstants",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "23",
  "column": "0",
  "slicing": "['_NumbersAndConstants = Union[ast.Num, ast.NameConstant]\\n', '    def visit_numbers_and_constants(self, node: _NumbersAndConstants) -> None:\\n', '    def _check_operator_count(self, node: _NumbersAndConstants) -> None:\\n']",
  "context": "_OperatorLimits = Mapping[Type[ast.unaryop], int]\n_NumbersAndConstants = Union[ast.Num, ast.NameConstant]\n\n\n@final\n@decorators.alias('visit_numbers_and_cons"
 },
 "2219": {
  "name": "_unary_limits",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    _unary_limits: ClassVar[_OperatorLimits] = {\\n']",
  "context": "    \"\"\"Checks operators used in the code.\"\"\"\n\n    _unary_limits: ClassVar[_OperatorLimits] = {\n        ast.UAdd: 0,\n        ast.Invert: 1,\n      "
 },
 "2220": {
  "name": "_meaningless_operations",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    _meaningless_operations: ClassVar[_MeaninglessOperators] = {\\n']",
  "context": "      ast.Not: 1,\n        ast.USub: 1,\n    }\n\n    _meaningless_operations: ClassVar[_MeaninglessOperators] = {\n        # ast.Div and ast.Mod is not in the list,\n"
 },
 "2221": {
  "name": "_left_special_cases",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['    _left_special_cases: ClassVar[_MeaninglessOperators] = {\\n']",
  "context": "ed to ignore some special cases like `1 / x`:\n    _left_special_cases: ClassVar[_MeaninglessOperators] = {\n        1: (ast.Div, ast.FloorDiv),\n    }\n\n    _ze"
 },
 "2222": {
  "name": "_zero_divisors",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['    _zero_divisors: ClassVar[AnyNodes] = (\\n']",
  "context": " {\n        1: (ast.Div, ast.FloorDiv),\n    }\n\n    _zero_divisors: ClassVar[AnyNodes] = (\n        ast.Div,\n        ast.FloorDiv,\n        ast"
 },
 "2223": {
  "name": "node",
  "type": "_NumbersAndConstants",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "77",
  "column": "42",
  "slicing": "['    def visit_numbers_and_constants(self, node: _NumbersAndConstants) -> None:\\n']",
  "context": "\n    )\n\n    def visit_numbers_and_constants(self, node: _NumbersAndConstants) -> None:\n        \"\"\"\n        Checks numbers unnecessary ope"
 },
 "2224": {
  "name": "node",
  "type": "_NumbersAndConstants",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "112",
  "column": "36",
  "slicing": "['    def _check_operator_count(self, node: _NumbersAndConstants) -> None:\\n']",
  "context": "_visit(node)\n\n    def _check_operator_count(self, node: _NumbersAndConstants) -> None:\n        for node_type, limit in self._unary_limits"
 },
 "2225": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "115",
  "column": "16",
  "slicing": "['_MeaninglessOperators = Mapping[complex, Tuple[Type[ast.operator], ...]]\\n', '_OperatorLimits = Mapping[Type[ast.unaryop], int]\\n', '_NumbersAndConstants = Union[ast.Num, ast.NameConstant]\\n', '    _unary_limits: ClassVar[_OperatorLimits] = {\\n', '    _meaningless_operations: ClassVar[_MeaninglessOperators] = {\\n', '    _left_special_cases: ClassVar[_MeaninglessOperators] = {\\n', '    def visit_numbers_and_constants(self, node: _NumbersAndConstants) -> None:\\n', '    def _check_operator_count(self, node: _NumbersAndConstants) -> None:\\n', '        for node_type, limit in self._unary_limits.items():\\n', '            if count_unary_operator(node, node_type) > limit:\\n', '                text = str(node.n) if isinstance(node, ast.Num) else node.value\\n', '                    consistency.UselessOperatorsViolation(node, text=text),\\n']",
  "context": "perator(node, node_type) > limit:\n                text = str(node.n) if isinstance(node, ast.Num) else node.value\n                self.add_violation(\n              "
 },
 "2226": {
  "name": "number",
  "type": "wemake_python_styleguide.logic.tree.operators.unwrap_unary_node",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "121",
  "column": "8",
  "slicing": "['_MeaninglessOperators = Mapping[complex, Tuple[Type[ast.operator], ...]]\\n', '_OperatorLimits = Mapping[Type[ast.unaryop], int]\\n', '_NumbersAndConstants = Union[ast.Num, ast.NameConstant]\\n', '    _unary_limits: ClassVar[_OperatorLimits] = {\\n', '    _meaningless_operations: ClassVar[_MeaninglessOperators] = {\\n', '    _left_special_cases: ClassVar[_MeaninglessOperators] = {\\n', '    def visit_numbers_and_constants(self, node: _NumbersAndConstants) -> None:\\n', '    def _check_operator_count(self, node: _NumbersAndConstants) -> None:\\n', '        for node_type, limit in self._unary_limits.items():\\n', '            if count_unary_operator(node, node_type) > limit:\\n', '                text = str(node.n) if isinstance(node, ast.Num) else node.value\\n', '                    consistency.UselessOperatorsViolation(node, text=text),\\n', '        number = unwrap_unary_node(number)\\n', '        is_zero_division = (\\n', '            isinstance(number, ast.Num) and\\n', '            number.n == 0\\n', '        if is_zero_division:\\n', '            self.add_violation(consistency.ZeroDivisionViolation(number))\\n', '                left = None\\n', '        non_negative_numbers = self._get_non_negative_nodes(left, right)\\n', '        for number in non_negative_numbers:\\n', '            forbidden = self._meaningless_operations.get(number.n, None)\\n', '            if forbidden and isinstance(op, forbidden):\\n', '                    consistency.MeaninglessNumberOperationViolation(number),\\n', '        non_negative_numbers = []\\n', '        for node in filter(None, (left, right)):\\n', '            real_node = unwrap_unary_node(node)\\n', '            correct_node = (\\n', '                isinstance(real_node, ast.Num) and\\n', '                real_node.n in self._meaningless_operations and\\n', '                not (real_node.n == 1 and walk.is_contained(node, ast.USub))\\n', '            if correct_node:\\n', '                non_negative_numbers.append(real_node)\\n', '        return non_negative_numbers\\n', '        self._check_negation(node.op, node.right)\\n', '        self._check_list_multiply(node)\\n', '        self._check_string_concat(node.left, node.op, node.right)\\n', '        self.generic_visit(node)\\n', '        self._check_negation(node.op, node.value)\\n', '        self._check_string_concat(node.value, node.op)\\n', '        self.generic_visit(node)\\n', '        is_double_minus = (\\n', '        if is_double_minus:\\n', '        is_list_multiply = (\\n', '            isinstance(node.op, ast.Mult) and\\n', '            isinstance(node.left, self._list_nodes)\\n', '        if is_list_multiply:\\n', '            self.add_violation(ListMultiplyViolation(node.left))\\n', \"        left_line = getattr(left, 'lineno', 0)\\n\", \"        if left_line != getattr(right, 'lineno', left_line):\\n\", '        for node in (left, right):\\n', '            if isinstance(node, self._string_nodes):\\n', '                    consistency.ExplicitStringConcatViolation(node),\\n', '        self.add_violation(consistency.WalrusViolation(node))\\n', '        self.generic_visit(node)\\n', '        self._check_logical_bitwise_operator(node)\\n', '        self.generic_visit(node)\\n', '        if not isinstance(node.op, (ast.BitOr, ast.BitAnd)):\\n', '        if self._is_bool_like(node.left) or self._is_bool_like(node.right):\\n', '            self.add_violation(BitwiseAndBooleanMixupViolation(node))\\n', '        return isinstance(node, self._invalid_nodes)\\n']",
  "context": ": ast.operator, number: ast.AST) -> None:\n        number = unwrap_unary_node(number)\n\n        is_zero_division = (\n            isinstan"
 },
 "2227": {
  "name": "is_zero_division",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "123",
  "column": "8",
  "slicing": "['        is_zero_division = (\\n', '        if is_zero_division:\\n']",
  "context": "      number = unwrap_unary_node(number)\n\n        is_zero_division = (\n            isinstance(op, self._zero_divisors) an"
 },
 "2228": {
  "name": "left",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "134",
  "column": "8",
  "slicing": "['        left: Optional[ast.AST],\\n']",
  "context": "(\n        self,\n        op: ast.operator,\n        left: Optional[ast.AST],\n        right: Optional[ast.AST] = None,\n    ) -> "
 },
 "2229": {
  "name": "right",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "135",
  "column": "8",
  "slicing": "['        right: Optional[ast.AST] = None,\\n']",
  "context": "perator,\n        left: Optional[ast.AST],\n        right: Optional[ast.AST] = None,\n    ) -> None:\n        if isinstance(left, ast.Num"
 },
 "2230": {
  "name": "left",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "139",
  "column": "16",
  "slicing": "['_MeaninglessOperators = Mapping[complex, Tuple[Type[ast.operator], ...]]\\n', '_OperatorLimits = Mapping[Type[ast.unaryop], int]\\n', '_NumbersAndConstants = Union[ast.Num, ast.NameConstant]\\n', '    _unary_limits: ClassVar[_OperatorLimits] = {\\n', '    _meaningless_operations: ClassVar[_MeaninglessOperators] = {\\n', '    _left_special_cases: ClassVar[_MeaninglessOperators] = {\\n', '    def visit_numbers_and_constants(self, node: _NumbersAndConstants) -> None:\\n', '    def _check_operator_count(self, node: _NumbersAndConstants) -> None:\\n', '        for node_type, limit in self._unary_limits.items():\\n', '            if count_unary_operator(node, node_type) > limit:\\n', '                text = str(node.n) if isinstance(node, ast.Num) else node.value\\n', '                    consistency.UselessOperatorsViolation(node, text=text),\\n', '        number = unwrap_unary_node(number)\\n', '        is_zero_division = (\\n', '            isinstance(number, ast.Num) and\\n', '            number.n == 0\\n', '        if is_zero_division:\\n', '            self.add_violation(consistency.ZeroDivisionViolation(number))\\n', '                left = None\\n', '        non_negative_numbers = self._get_non_negative_nodes(left, right)\\n', '        for number in non_negative_numbers:\\n', '            forbidden = self._meaningless_operations.get(number.n, None)\\n', '            if forbidden and isinstance(op, forbidden):\\n', '                    consistency.MeaninglessNumberOperationViolation(number),\\n', '        non_negative_numbers = []\\n', '        for node in filter(None, (left, right)):\\n', '            real_node = unwrap_unary_node(node)\\n', '            correct_node = (\\n', '                isinstance(real_node, ast.Num) and\\n', '                real_node.n in self._meaningless_operations and\\n', '                not (real_node.n == 1 and walk.is_contained(node, ast.USub))\\n', '            if correct_node:\\n', '                non_negative_numbers.append(real_node)\\n', '        return non_negative_numbers\\n', '        self._check_negation(node.op, node.right)\\n', '        self._check_list_multiply(node)\\n', '        self._check_string_concat(node.left, node.op, node.right)\\n', '        self.generic_visit(node)\\n', '        self._check_negation(node.op, node.value)\\n', '        self._check_string_concat(node.value, node.op)\\n', '        self.generic_visit(node)\\n', '        is_double_minus = (\\n', '        if is_double_minus:\\n', '        is_list_multiply = (\\n', '            isinstance(node.op, ast.Mult) and\\n', '            isinstance(node.left, self._list_nodes)\\n', '        if is_list_multiply:\\n', '            self.add_violation(ListMultiplyViolation(node.left))\\n', \"        left_line = getattr(left, 'lineno', 0)\\n\", \"        if left_line != getattr(right, 'lineno', left_line):\\n\", '        for node in (left, right):\\n', '            if isinstance(node, self._string_nodes):\\n', '                    consistency.ExplicitStringConcatViolation(node),\\n', '        self.add_violation(consistency.WalrusViolation(node))\\n', '        self.generic_visit(node)\\n', '        self._check_logical_bitwise_operator(node)\\n', '        self.generic_visit(node)\\n', '        if not isinstance(node.op, (ast.BitOr, ast.BitAnd)):\\n', '        if self._is_bool_like(node.left) or self._is_bool_like(node.right):\\n', '            self.add_violation(BitwiseAndBooleanMixupViolation(node))\\n', '        return isinstance(node, self._invalid_nodes)\\n']",
  "context": "elf._left_special_cases[left.n]):\n                left = None\n\n        non_negative_numbers = self._get_non_nega"
 },
 "2231": {
  "name": "non_negative_numbers",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "141",
  "column": "8",
  "slicing": "['_MeaninglessOperators = Mapping[complex, Tuple[Type[ast.operator], ...]]\\n', '_OperatorLimits = Mapping[Type[ast.unaryop], int]\\n', '_NumbersAndConstants = Union[ast.Num, ast.NameConstant]\\n', '    _unary_limits: ClassVar[_OperatorLimits] = {\\n', '    _meaningless_operations: ClassVar[_MeaninglessOperators] = {\\n', '    _left_special_cases: ClassVar[_MeaninglessOperators] = {\\n', '    def visit_numbers_and_constants(self, node: _NumbersAndConstants) -> None:\\n', '    def _check_operator_count(self, node: _NumbersAndConstants) -> None:\\n', '        for node_type, limit in self._unary_limits.items():\\n', '            if count_unary_operator(node, node_type) > limit:\\n', '                text = str(node.n) if isinstance(node, ast.Num) else node.value\\n', '                    consistency.UselessOperatorsViolation(node, text=text),\\n', '        number = unwrap_unary_node(number)\\n', '        is_zero_division = (\\n', '            isinstance(number, ast.Num) and\\n', '            number.n == 0\\n', '        if is_zero_division:\\n', '            self.add_violation(consistency.ZeroDivisionViolation(number))\\n', '                left = None\\n', '        non_negative_numbers = self._get_non_negative_nodes(left, right)\\n', '        for number in non_negative_numbers:\\n', '            forbidden = self._meaningless_operations.get(number.n, None)\\n', '            if forbidden and isinstance(op, forbidden):\\n', '                    consistency.MeaninglessNumberOperationViolation(number),\\n', '        non_negative_numbers = []\\n', '        for node in filter(None, (left, right)):\\n', '            real_node = unwrap_unary_node(node)\\n', '            correct_node = (\\n', '                isinstance(real_node, ast.Num) and\\n', '                real_node.n in self._meaningless_operations and\\n', '                not (real_node.n == 1 and walk.is_contained(node, ast.USub))\\n', '            if correct_node:\\n', '                non_negative_numbers.append(real_node)\\n', '        return non_negative_numbers\\n', '        self._check_negation(node.op, node.right)\\n', '        self._check_list_multiply(node)\\n', '        self._check_string_concat(node.left, node.op, node.right)\\n', '        self.generic_visit(node)\\n', '        self._check_negation(node.op, node.value)\\n', '        self._check_string_concat(node.value, node.op)\\n', '        self.generic_visit(node)\\n', '        is_double_minus = (\\n', '        if is_double_minus:\\n', '        is_list_multiply = (\\n', '            isinstance(node.op, ast.Mult) and\\n', '            isinstance(node.left, self._list_nodes)\\n', '        if is_list_multiply:\\n', '            self.add_violation(ListMultiplyViolation(node.left))\\n', \"        left_line = getattr(left, 'lineno', 0)\\n\", \"        if left_line != getattr(right, 'lineno', left_line):\\n\", '        for node in (left, right):\\n', '            if isinstance(node, self._string_nodes):\\n', '                    consistency.ExplicitStringConcatViolation(node),\\n', '        self.add_violation(consistency.WalrusViolation(node))\\n', '        self.generic_visit(node)\\n', '        self._check_logical_bitwise_operator(node)\\n', '        self.generic_visit(node)\\n', '        if not isinstance(node.op, (ast.BitOr, ast.BitAnd)):\\n', '        if self._is_bool_like(node.left) or self._is_bool_like(node.right):\\n', '            self.add_violation(BitwiseAndBooleanMixupViolation(node))\\n', '        return isinstance(node, self._invalid_nodes)\\n']",
  "context": "es[left.n]):\n                left = None\n\n        non_negative_numbers = self._get_non_negative_nodes(left, right)\n\n        for number in non_negative_numbers:\n     "
 },
 "2232": {
  "name": "left",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "152",
  "column": "8",
  "slicing": "['        left: Optional[ast.AST],\\n']",
  "context": "ef _get_non_negative_nodes(\n        self,\n        left: Optional[ast.AST],\n        right: Optional[ast.AST] = None,\n    ):\n  "
 },
 "2233": {
  "name": "right",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "153",
  "column": "8",
  "slicing": "['        right: Optional[ast.AST] = None,\\n']",
  "context": "   self,\n        left: Optional[ast.AST],\n        right: Optional[ast.AST] = None,\n    ):\n        non_negative_numbers = []\n        f"
 },
 "2234": {
  "name": "non_negative_numbers",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "155",
  "column": "8",
  "slicing": "['        non_negative_numbers = []\\n', '                non_negative_numbers.append(real_node)\\n', '        return non_negative_numbers\\n']",
  "context": "  right: Optional[ast.AST] = None,\n    ):\n        non_negative_numbers = []\n        for node in filter(None, (left, right)):\n "
 },
 "2235": {
  "name": "real_node",
  "type": "wemake_python_styleguide.logic.tree.operators.unwrap_unary_node",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "157",
  "column": "12",
  "slicing": "['_MeaninglessOperators = Mapping[complex, Tuple[Type[ast.operator], ...]]\\n', '_OperatorLimits = Mapping[Type[ast.unaryop], int]\\n', '_NumbersAndConstants = Union[ast.Num, ast.NameConstant]\\n', '    _unary_limits: ClassVar[_OperatorLimits] = {\\n', '    _meaningless_operations: ClassVar[_MeaninglessOperators] = {\\n', '    _left_special_cases: ClassVar[_MeaninglessOperators] = {\\n', '    def visit_numbers_and_constants(self, node: _NumbersAndConstants) -> None:\\n', '    def _check_operator_count(self, node: _NumbersAndConstants) -> None:\\n', '        for node_type, limit in self._unary_limits.items():\\n', '            if count_unary_operator(node, node_type) > limit:\\n', '                text = str(node.n) if isinstance(node, ast.Num) else node.value\\n', '                    consistency.UselessOperatorsViolation(node, text=text),\\n', '        number = unwrap_unary_node(number)\\n', '        is_zero_division = (\\n', '            isinstance(number, ast.Num) and\\n', '            number.n == 0\\n', '        if is_zero_division:\\n', '            self.add_violation(consistency.ZeroDivisionViolation(number))\\n', '                left = None\\n', '        non_negative_numbers = self._get_non_negative_nodes(left, right)\\n', '        for number in non_negative_numbers:\\n', '            forbidden = self._meaningless_operations.get(number.n, None)\\n', '            if forbidden and isinstance(op, forbidden):\\n', '                    consistency.MeaninglessNumberOperationViolation(number),\\n', '        non_negative_numbers = []\\n', '        for node in filter(None, (left, right)):\\n', '            real_node = unwrap_unary_node(node)\\n', '            correct_node = (\\n', '                isinstance(real_node, ast.Num) and\\n', '                real_node.n in self._meaningless_operations and\\n', '                not (real_node.n == 1 and walk.is_contained(node, ast.USub))\\n', '            if correct_node:\\n', '                non_negative_numbers.append(real_node)\\n', '        return non_negative_numbers\\n', '        self._check_negation(node.op, node.right)\\n', '        self._check_list_multiply(node)\\n', '        self._check_string_concat(node.left, node.op, node.right)\\n', '        self.generic_visit(node)\\n', '        self._check_negation(node.op, node.value)\\n', '        self._check_string_concat(node.value, node.op)\\n', '        self.generic_visit(node)\\n', '        is_double_minus = (\\n', '        if is_double_minus:\\n', '        is_list_multiply = (\\n', '            isinstance(node.op, ast.Mult) and\\n', '            isinstance(node.left, self._list_nodes)\\n', '        if is_list_multiply:\\n', '            self.add_violation(ListMultiplyViolation(node.left))\\n', \"        left_line = getattr(left, 'lineno', 0)\\n\", \"        if left_line != getattr(right, 'lineno', left_line):\\n\", '        for node in (left, right):\\n', '            if isinstance(node, self._string_nodes):\\n', '                    consistency.ExplicitStringConcatViolation(node),\\n', '        self.add_violation(consistency.WalrusViolation(node))\\n', '        self.generic_visit(node)\\n', '        self._check_logical_bitwise_operator(node)\\n', '        self.generic_visit(node)\\n', '        if not isinstance(node.op, (ast.BitOr, ast.BitAnd)):\\n', '        if self._is_bool_like(node.left) or self._is_bool_like(node.right):\\n', '            self.add_violation(BitwiseAndBooleanMixupViolation(node))\\n', '        return isinstance(node, self._invalid_nodes)\\n']",
  "context": " node in filter(None, (left, right)):\n            real_node = unwrap_unary_node(node)\n            correct_node = (\n                isins"
 },
 "2236": {
  "name": "correct_node",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "158",
  "column": "12",
  "slicing": "['            correct_node = (\\n', '            if correct_node:\\n']",
  "context": "  real_node = unwrap_unary_node(node)\n            correct_node = (\n                isinstance(real_node, ast.Num) and"
 },
 "2237": {
  "name": "_string_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "172",
  "column": "4",
  "slicing": "['    _string_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "that there are not wrong math operations.\"\"\"\n\n    _string_nodes: ClassVar[AnyNodes] = (\n        *TextNodes,\n        ast.JoinedStr,\n    )\n\n"
 },
 "2238": {
  "name": "_list_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "177",
  "column": "4",
  "slicing": "['    _list_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "    *TextNodes,\n        ast.JoinedStr,\n    )\n\n    _list_nodes: ClassVar[AnyNodes] = (\n        ast.List,\n        ast.ListComp,\n    )\n\n   "
 },
 "2239": {
  "name": "is_double_minus",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "208",
  "column": "8",
  "slicing": "['        is_double_minus = (\\n', '        if is_double_minus:\\n']",
  "context": "p: ast.operator, right: ast.AST) -> None:\n        is_double_minus = (\n            isinstance(op, (ast.Add, ast.Sub)) and"
 },
 "2240": {
  "name": "is_list_multiply",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "219",
  "column": "8",
  "slicing": "['        is_list_multiply = (\\n', '        if is_list_multiply:\\n']",
  "context": "_multiply(self, node: ast.BinOp) -> None:\n        is_list_multiply = (\n            isinstance(node.op, ast.Mult) and\n    "
 },
 "2241": {
  "name": "right",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "230",
  "column": "8",
  "slicing": "['        right: Optional[ast.AST] = None,\\n']",
  "context": " left: ast.AST,\n        op: ast.operator,\n        right: Optional[ast.AST] = None,\n    ) -> None:\n        if not isinstance(op, ast.A"
 },
 "2242": {
  "name": "left_line",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "235",
  "column": "8",
  "slicing": "['_MeaninglessOperators = Mapping[complex, Tuple[Type[ast.operator], ...]]\\n', '_OperatorLimits = Mapping[Type[ast.unaryop], int]\\n', '_NumbersAndConstants = Union[ast.Num, ast.NameConstant]\\n', '    _unary_limits: ClassVar[_OperatorLimits] = {\\n', '    _meaningless_operations: ClassVar[_MeaninglessOperators] = {\\n', '    _left_special_cases: ClassVar[_MeaninglessOperators] = {\\n', '    def visit_numbers_and_constants(self, node: _NumbersAndConstants) -> None:\\n', '    def _check_operator_count(self, node: _NumbersAndConstants) -> None:\\n', '        for node_type, limit in self._unary_limits.items():\\n', '            if count_unary_operator(node, node_type) > limit:\\n', '                text = str(node.n) if isinstance(node, ast.Num) else node.value\\n', '                    consistency.UselessOperatorsViolation(node, text=text),\\n', '        number = unwrap_unary_node(number)\\n', '        is_zero_division = (\\n', '            isinstance(number, ast.Num) and\\n', '            number.n == 0\\n', '        if is_zero_division:\\n', '            self.add_violation(consistency.ZeroDivisionViolation(number))\\n', '                left = None\\n', '        non_negative_numbers = self._get_non_negative_nodes(left, right)\\n', '        for number in non_negative_numbers:\\n', '            forbidden = self._meaningless_operations.get(number.n, None)\\n', '            if forbidden and isinstance(op, forbidden):\\n', '                    consistency.MeaninglessNumberOperationViolation(number),\\n', '        non_negative_numbers = []\\n', '        for node in filter(None, (left, right)):\\n', '            real_node = unwrap_unary_node(node)\\n', '            correct_node = (\\n', '                isinstance(real_node, ast.Num) and\\n', '                real_node.n in self._meaningless_operations and\\n', '                not (real_node.n == 1 and walk.is_contained(node, ast.USub))\\n', '            if correct_node:\\n', '                non_negative_numbers.append(real_node)\\n', '        return non_negative_numbers\\n', '        self._check_negation(node.op, node.right)\\n', '        self._check_list_multiply(node)\\n', '        self._check_string_concat(node.left, node.op, node.right)\\n', '        self.generic_visit(node)\\n', '        self._check_negation(node.op, node.value)\\n', '        self._check_string_concat(node.value, node.op)\\n', '        self.generic_visit(node)\\n', '        is_double_minus = (\\n', '        if is_double_minus:\\n', '        is_list_multiply = (\\n', '            isinstance(node.op, ast.Mult) and\\n', '            isinstance(node.left, self._list_nodes)\\n', '        if is_list_multiply:\\n', '            self.add_violation(ListMultiplyViolation(node.left))\\n', \"        left_line = getattr(left, 'lineno', 0)\\n\", \"        if left_line != getattr(right, 'lineno', left_line):\\n\", '        for node in (left, right):\\n', '            if isinstance(node, self._string_nodes):\\n', '                    consistency.ExplicitStringConcatViolation(node),\\n', '        self.add_violation(consistency.WalrusViolation(node))\\n', '        self.generic_visit(node)\\n', '        self._check_logical_bitwise_operator(node)\\n', '        self.generic_visit(node)\\n', '        if not isinstance(node.op, (ast.BitOr, ast.BitAnd)):\\n', '        if self._is_bool_like(node.left) or self._is_bool_like(node.right):\\n', '            self.add_violation(BitwiseAndBooleanMixupViolation(node))\\n', '        return isinstance(node, self._invalid_nodes)\\n']",
  "context": "nstance(op, ast.Add):\n            return\n\n        left_line = getattr(left, 'lineno', 0)\n        if left_line != getattr(right, 'lineno', l"
 },
 "2243": {
  "name": "node",
  "type": "wemake_python_styleguide.compat.nodes.NamedExpr",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "261",
  "column": "8",
  "slicing": "['        node: NamedExpr,\\n']",
  "context": "\"\n\n    def visit_NamedExpr(\n        self,\n        node: NamedExpr,\n    ) -> None:  # pragma: py-lt-38\n        \"\"\"\n   "
 },
 "2244": {
  "name": "_invalid_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/operators.py",
  "lineno": "278",
  "column": "4",
  "slicing": "['    _invalid_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "ks bitwise operations are used correctly.\"\"\"\n\n    _invalid_nodes: ClassVar[AnyNodes] = (\n        ast.BoolOp,\n        ast.UnaryOp,\n        a"
 },
 "2245": {
  "name": "_HashItems",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "50",
  "column": "0",
  "slicing": "['_HashItems = Sequence[Optional[ast.AST]]\\n', '    def _check_float_keys(self, keys: _HashItems) -> None:\\n', '        keys_or_elts: _HashItems,\\n', '        keys_or_elts: _HashItems,\\n']",
  "context": ", decorators\n\n#: Items that can be inside a hash.\n_HashItems = Sequence[Optional[ast.AST]]\n\n\n@final\n@decorators.alias('visit_any_string', (\n "
 },
 "2246": {
  "name": "_string_constants",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['    _string_constants: ClassVar[FrozenSet[str]] = frozenset((\\n']",
  "context": ":\n    \"\"\"Restricts several string usages.\"\"\"\n\n    _string_constants: ClassVar[FrozenSet[str]] = frozenset((\n        string.ascii_letters,\n        string.ascii"
 },
 "2247": {
  "name": "_modulo_string_pattern",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['    _modulo_string_pattern: ClassVar[Pattern] = re.compile(\\n']",
  "context": " https://stackoverflow.com/a/30018957/4842742\n    _modulo_string_pattern: ClassVar[Pattern] = re.compile(\n        r\"\"\"                             # noqa: W"
 },
 "2248": {
  "name": "_modulo_pattern_exceptions",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "95",
  "column": "4",
  "slicing": "['    _modulo_pattern_exceptions: ClassVar[FrozenSet[str]] = frozenset((\\n']",
  "context": " which we allow strings with modulo patterns.\n    _modulo_pattern_exceptions: ClassVar[FrozenSet[str]] = frozenset((\n        'strftime',  # For date, time, and datetim"
 },
 "2249": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyText",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "101",
  "column": "31",
  "slicing": "['    def visit_any_string(self, node: AnyText) -> None:\\n']",
  "context": ".execute()\n    ))\n\n    def visit_any_string(self, node: AnyText) -> None:\n        \"\"\"\n        Forbids incorrect usage of str"
 },
 "2250": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyText",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "117",
  "column": "8",
  "slicing": "['        node: AnyText,\\n']",
  "context": "    def _check_is_alphabet(\n        self,\n        node: AnyText,\n        text_data: Optional[str],\n    ) -> None:\n "
 },
 "2251": {
  "name": "text_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "118",
  "column": "8",
  "slicing": "['        text_data: Optional[str],\\n']",
  "context": "bet(\n        self,\n        node: AnyText,\n        text_data: Optional[str],\n    ) -> None:\n        if text_data in self._strin"
 },
 "2252": {
  "name": "parent",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "127",
  "column": "43",
  "slicing": "['    def _is_modulo_pattern_exception(self, parent: Optional[ast.AST]) -> bool:\\n']",
  "context": "    )\n\n    def _is_modulo_pattern_exception(self, parent: Optional[ast.AST]) -> bool:\n        \"\"\"\n        Check if string with modulo pa"
 },
 "2253": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyText",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "145",
  "column": "8",
  "slicing": "['        node: AnyText,\\n']",
  "context": "def _check_modulo_patterns(\n        self,\n        node: AnyText,\n        text_data: Optional[str],\n    ) -> None:\n "
 },
 "2254": {
  "name": "text_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "146",
  "column": "8",
  "slicing": "['        text_data: Optional[str],\\n']",
  "context": "rns(\n        self,\n        node: AnyText,\n        text_data: Optional[str],\n    ) -> None:\n        parent = nodes.get_parent(n"
 },
 "2255": {
  "name": "_valid_format_index",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "163",
  "column": "4",
  "slicing": "['    _valid_format_index: ClassVar[AnyNodes] = (\\n']",
  "context": "\n    \"\"\"Restricts usage of ``f`` strings.\"\"\"\n\n    _valid_format_index: ClassVar[AnyNodes] = (\n        *TextNodes,\n        ast.Num,\n        ast.N"
 },
 "2256": {
  "name": "_single_use_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "169",
  "column": "4",
  "slicing": "['    _single_use_types: ClassVar[AnyNodes] = (\\n']",
  "context": "    ast.Name,\n        ast.NameConstant,\n    )\n    _single_use_types: ClassVar[AnyNodes] = (\n        ast.Call,\n        ast.Subscript,\n    )\n   "
 },
 "2257": {
  "name": "_chainable_types",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "173",
  "column": "4",
  "slicing": "['    _chainable_types: Final = (\\n']",
  "context": "       ast.Call,\n        ast.Subscript,\n    )\n    _chainable_types: Final = (\n        ast.Call,\n        ast.Subscript,\n        a"
 },
 "2258": {
  "name": "has_formatted_components",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "201",
  "column": "8",
  "slicing": "['        text_data = source.render_string(node.s)\\n', '        self._check_is_alphabet(node, text_data)\\n', '        self._check_modulo_patterns(node, text_data)\\n', '        if text_data in self._string_constants:\\n', '                    node, text=text_data,\\n', '        parent = nodes.get_parent(node)\\n', '        if parent and strings.is_doc_string(parent):\\n', '        if self._modulo_string_pattern.search(text_data):\\n', '            if not self._is_modulo_pattern_exception(parent):\\n', '        has_formatted_components = any(\\n', '            for comp in node.values\\n', '        if not has_formatted_components:\\n', '        if isinstance(parent, self._allowed_parents):\\n']",
  "context": "th no parameters or variable.\n        \"\"\"\n        has_formatted_components = any(\n            isinstance(comp, ast.FormattedValue)\n "
 },
 "2259": {
  "name": "format_value",
  "type": "(?,?,?)",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "228",
  "column": "36",
  "slicing": "['    def _is_valid_final_value(self, format_value: ast.AST) -> bool:\\n']",
  "context": "ormat_value)\n\n    def _is_valid_final_value(self, format_value: ast.AST) -> bool:\n        # Variable lookup is okay and a single att"
 },
 "2260": {
  "name": "format_value",
  "type": "wemake_python_styleguide.types.AnyChainable",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "243",
  "column": "33",
  "slicing": "['    def _is_valid_chaining(self, format_value: AnyChainable) -> bool:\\n']",
  "context": "   return False\n\n    def _is_valid_chaining(self, format_value: AnyChainable) -> bool:\n        chained_parts: List[ast.AST] = list(attrib"
 },
 "2261": {
  "name": "chained_parts",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "244",
  "column": "8",
  "slicing": "['        chained_parts: List[ast.AST] = list(attributes.parts(format_value))\\n', '        if len(chained_parts) <= self._max_chained_items:\\n', '            return self._is_valid_chain_structure(chained_parts)\\n', '            for part in chained_parts\\n', '        if len(chained_parts) == self._max_chained_items:\\n', '                isinstance(part, self._single_use_types)\\n', '                for part in chained_parts\\n']",
  "context": "elf, format_value: AnyChainable) -> bool:\n        chained_parts: List[ast.AST] = list(attributes.parts(format_value))\n        if len(chained_parts) <= self._max_chained"
 },
 "2262": {
  "name": "chained_parts",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "249",
  "column": "40",
  "slicing": "['    def _is_valid_chain_structure(self, chained_parts: List[ast.AST]) -> bool:\\n']",
  "context": "rn False\n\n    def _is_valid_chain_structure(self, chained_parts: List[ast.AST]) -> bool:\n        \"\"\"Helper method for ``_is_valid_chaining`"
 },
 "2263": {
  "name": "has_invalid_parts",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "251",
  "column": "8",
  "slicing": "['        text_data = source.render_string(node.s)\\n', '        self._check_is_alphabet(node, text_data)\\n', '        self._check_modulo_patterns(node, text_data)\\n', '        if text_data in self._string_constants:\\n', '                    node, text=text_data,\\n', '        parent = nodes.get_parent(node)\\n', '        if parent and strings.is_doc_string(parent):\\n', '        if self._modulo_string_pattern.search(text_data):\\n', '            if not self._is_modulo_pattern_exception(parent):\\n', '        has_formatted_components = any(\\n', '            for comp in node.values\\n', '        if not has_formatted_components:\\n', '        for string_component in node.values:\\n', '            if isinstance(string_component, ast.FormattedValue):\\n', '                format_value = string_component.value\\n', '                if self._is_valid_formatted_value(format_value):\\n', '        if isinstance(format_value, self._chainable_types):\\n', '            if not self._is_valid_chaining(format_value):\\n', '        return self._is_valid_final_value(format_value)\\n', '        if isinstance(format_value, (ast.Name, ast.Attribute)):\\n', '        elif isinstance(format_value, ast.Call) and not format_value.args:\\n', '        elif isinstance(format_value, ast.Subscript):\\n', '                get_slice_expr(format_value),\\n', '        chained_parts: List[ast.AST] = list(attributes.parts(format_value))\\n', '        if len(chained_parts) <= self._max_chained_items:\\n', '            return self._is_valid_chain_structure(chained_parts)\\n', '        has_invalid_parts = any(\\n', '            for part in chained_parts\\n', '        if has_invalid_parts:\\n', '        if len(chained_parts) == self._max_chained_items:\\n', '                isinstance(part, self._single_use_types)\\n', '                for part in chained_parts\\n', '        if isinstance(parent, self._allowed_parents):\\n']",
  "context": "per method for ``_is_valid_chaining``.\"\"\"\n        has_invalid_parts = any(\n            not self._is_valid_final_value(part)\n "
 },
 "2264": {
  "name": "_allowed_parents",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "272",
  "column": "4",
  "slicing": "['    _allowed_parents: ClassVar[AnyNodes] = (\\n']",
  "context": "\"\"\"Checks wrong numbers used in the code.\"\"\"\n\n    _allowed_parents: ClassVar[AnyNodes] = (\n        *AssignNodesWithWalrus,\n\n        # Constru"
 },
 "2265": {
  "name": "_non_magic_modulo",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "286",
  "column": "4",
  "slicing": "['    _non_magic_modulo: ClassVar[int] = 10\\n']",
  "context": "t,\n        ast.Set,\n        ast.Tuple,\n    )\n\n    _non_magic_modulo: ClassVar[int] = 10\n\n    def visit_Num(self, node: ast.Num) -> None:\n "
 },
 "2266": {
  "name": "precision",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "318",
  "column": "12",
  "slicing": "['        text_data = source.render_string(node.s)\\n', '        self._check_is_alphabet(node, text_data)\\n', '        self._check_modulo_patterns(node, text_data)\\n', '        if text_data in self._string_constants:\\n', '                    node, text=text_data,\\n', '        parent = nodes.get_parent(node)\\n', '        if parent and strings.is_doc_string(parent):\\n', '        if self._modulo_string_pattern.search(text_data):\\n', '            if not self._is_modulo_pattern_exception(parent):\\n', '        has_formatted_components = any(\\n', '            for comp in node.values\\n', '        if not has_formatted_components:\\n', '        for string_component in node.values:\\n', '            if isinstance(string_component, ast.FormattedValue):\\n', '                format_value = string_component.value\\n', '                if self._is_valid_formatted_value(format_value):\\n', '        if isinstance(format_value, self._chainable_types):\\n', '            if not self._is_valid_chaining(format_value):\\n', '        return self._is_valid_final_value(format_value)\\n', '        if isinstance(format_value, (ast.Name, ast.Attribute)):\\n', '        elif isinstance(format_value, ast.Call) and not format_value.args:\\n', '        elif isinstance(format_value, ast.Subscript):\\n', '                get_slice_expr(format_value),\\n', '        chained_parts: List[ast.AST] = list(attributes.parts(format_value))\\n', '        if len(chained_parts) <= self._max_chained_items:\\n', '            return self._is_valid_chain_structure(chained_parts)\\n', '        has_invalid_parts = any(\\n', '            for part in chained_parts\\n', '        if has_invalid_parts:\\n', '        if len(chained_parts) == self._max_chained_items:\\n', '                isinstance(part, self._single_use_types)\\n', '                for part in chained_parts\\n', '        parent = operators.get_parent_ignoring_unary(node)\\n', '        if isinstance(parent, self._allowed_parents):\\n', \"            precision = len(str(node.n).split('.')[1])\\n\", '        if precision < 2:\\n']",
  "context": " node: ast.Num) -> None:\n        try:\n            precision = len(str(node.n).split('.')[1])\n        except IndexError:\n            precision ="
 },
 "2267": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyWith",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "346",
  "column": "29",
  "slicing": "['    def visit_any_with(self, node: AnyWith) -> None:\\n']",
  "context": "ll assign nodes.\"\"\"\n\n    def visit_any_with(self, node: AnyWith) -> None:\n        \"\"\"\n        Checks assignments inside cont"
 },
 "2268": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFor",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "377",
  "column": "28",
  "slicing": "['    def visit_any_for(self, node: AnyFor) -> None:\\n']",
  "context": ".generic_visit(node)\n\n    def visit_any_for(self, node: AnyFor) -> None:\n        \"\"\"\n        Checks assignments inside ``fo"
 },
 "2269": {
  "name": "targets",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "423",
  "column": "8",
  "slicing": "['        targets: Iterable[ast.AST],\\n']",
  "context": "ets(\n        self,\n        node: ast.AST,\n        targets: Iterable[ast.AST],\n    ) -> None:\n        targets = tuple(targets)\n\n "
 },
 "2270": {
  "name": "targets",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "425",
  "column": "8",
  "slicing": "['        text_data = source.render_string(node.s)\\n', '        self._check_is_alphabet(node, text_data)\\n', '        self._check_modulo_patterns(node, text_data)\\n', '        if text_data in self._string_constants:\\n', '                    node, text=text_data,\\n', '        parent = nodes.get_parent(node)\\n', '        if parent and strings.is_doc_string(parent):\\n', '        if self._modulo_string_pattern.search(text_data):\\n', '            if not self._is_modulo_pattern_exception(parent):\\n', '        has_formatted_components = any(\\n', '            for comp in node.values\\n', '        if not has_formatted_components:\\n', '        for string_component in node.values:\\n', '            if isinstance(string_component, ast.FormattedValue):\\n', '                format_value = string_component.value\\n', '                if self._is_valid_formatted_value(format_value):\\n', '        if isinstance(format_value, self._chainable_types):\\n', '            if not self._is_valid_chaining(format_value):\\n', '        return self._is_valid_final_value(format_value)\\n', '        if isinstance(format_value, (ast.Name, ast.Attribute)):\\n', '        elif isinstance(format_value, ast.Call) and not format_value.args:\\n', '        elif isinstance(format_value, ast.Subscript):\\n', '                get_slice_expr(format_value),\\n', '        chained_parts: List[ast.AST] = list(attributes.parts(format_value))\\n', '        if len(chained_parts) <= self._max_chained_items:\\n', '            return self._is_valid_chain_structure(chained_parts)\\n', '        has_invalid_parts = any(\\n', '            for part in chained_parts\\n', '        if has_invalid_parts:\\n', '        if len(chained_parts) == self._max_chained_items:\\n', '                isinstance(part, self._single_use_types)\\n', '                for part in chained_parts\\n', '        parent = operators.get_parent_ignoring_unary(node)\\n', '        if isinstance(parent, self._allowed_parents):\\n', \"            precision = len(str(node.n).split('.')[1])\\n\", '            precision = 0\\n', '        if precision < 2:\\n', '        for constant in constants.MATH_APPROXIMATE_CONSTANTS:\\n', '            if str(constant).startswith(str(node.n)):\\n', '        for withitem in node.items:\\n', '            self._check_unpacking_target_types(withitem.optional_vars)\\n', '            if isinstance(withitem.optional_vars, ast.Tuple):\\n', '                    node, withitem.optional_vars.elts,\\n', '        for target in node.targets:\\n', '            self._check_unpacking_target_types(target)\\n', '        targets = tuple(targets)\\n', '        if len(targets) == 1:\\n', '        for target in targets:\\n', '            target_name = extract_name(target)\\n', '            if target_name is None:  # it means, that non name node was used\\n']",
  "context": "argets: Iterable[ast.AST],\n    ) -> None:\n        targets = tuple(targets)\n\n        if len(targets) == 1:\n            self.ad"
 },
 "2271": {
  "name": "target_name",
  "type": "wemake_python_styleguide.logic.naming.name_nodes.extract_name",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "433",
  "column": "12",
  "slicing": "['        text_data = source.render_string(node.s)\\n', '        self._check_is_alphabet(node, text_data)\\n', '        self._check_modulo_patterns(node, text_data)\\n', '        if text_data in self._string_constants:\\n', '                    node, text=text_data,\\n', '        parent = nodes.get_parent(node)\\n', '        if parent and strings.is_doc_string(parent):\\n', '        if self._modulo_string_pattern.search(text_data):\\n', '            if not self._is_modulo_pattern_exception(parent):\\n', '        has_formatted_components = any(\\n', '            for comp in node.values\\n', '        if not has_formatted_components:\\n', '        for string_component in node.values:\\n', '            if isinstance(string_component, ast.FormattedValue):\\n', '                format_value = string_component.value\\n', '                if self._is_valid_formatted_value(format_value):\\n', '        if isinstance(format_value, self._chainable_types):\\n', '            if not self._is_valid_chaining(format_value):\\n', '        return self._is_valid_final_value(format_value)\\n', '        if isinstance(format_value, (ast.Name, ast.Attribute)):\\n', '        elif isinstance(format_value, ast.Call) and not format_value.args:\\n', '        elif isinstance(format_value, ast.Subscript):\\n', '                get_slice_expr(format_value),\\n', '        chained_parts: List[ast.AST] = list(attributes.parts(format_value))\\n', '        if len(chained_parts) <= self._max_chained_items:\\n', '            return self._is_valid_chain_structure(chained_parts)\\n', '        has_invalid_parts = any(\\n', '            for part in chained_parts\\n', '        if has_invalid_parts:\\n', '        if len(chained_parts) == self._max_chained_items:\\n', '                isinstance(part, self._single_use_types)\\n', '                for part in chained_parts\\n', '        parent = operators.get_parent_ignoring_unary(node)\\n', '        if isinstance(parent, self._allowed_parents):\\n', \"            precision = len(str(node.n).split('.')[1])\\n\", '            precision = 0\\n', '        if precision < 2:\\n', '        for constant in constants.MATH_APPROXIMATE_CONSTANTS:\\n', '            if str(constant).startswith(str(node.n)):\\n', '        for withitem in node.items:\\n', '            self._check_unpacking_target_types(withitem.optional_vars)\\n', '            if isinstance(withitem.optional_vars, ast.Tuple):\\n', '                    node, withitem.optional_vars.elts,\\n', '        for target in node.targets:\\n', '            self._check_unpacking_target_types(target)\\n', '        targets = tuple(targets)\\n', '        if len(targets) == 1:\\n', '        for target in targets:\\n', '            target_name = extract_name(target)\\n', '            if target_name is None:  # it means, that non name node was used\\n']",
  "context": "    )\n\n        for target in targets:\n            target_name = extract_name(target)\n            if target_name is None:  # it means, t"
 },
 "2272": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "439",
  "column": "44",
  "slicing": "['    def _check_unpacking_target_types(self, node: Optional[ast.AST]) -> None:\\n']",
  "context": "   )\n\n    def _check_unpacking_target_types(self, node: Optional[ast.AST]) -> None:\n        if not node:\n            return\n        fo"
 },
 "2273": {
  "name": "_elements_in_sets",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "452",
  "column": "4",
  "slicing": "['    _elements_in_sets: ClassVar[AnyNodes] = (\\n']",
  "context": " that collection definitions are correct.\"\"\"\n\n    _elements_in_sets: ClassVar[AnyNodes] = (\n        *TextNodes,\n        ast.Num,\n        ast.N"
 },
 "2274": {
  "name": "_unhashable_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "459",
  "column": "4",
  "slicing": "['    _unhashable_types: ClassVar[AnyNodes] = (\\n']",
  "context": "   ast.NameConstant,\n        ast.Name,\n    )\n\n    _unhashable_types: ClassVar[AnyNodes] = (\n        ast.List,\n        ast.ListComp,\n        as"
 },
 "2275": {
  "name": "_elements_to_eval",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "469",
  "column": "4",
  "slicing": "['    _elements_to_eval: ClassVar[AnyNodes] = (\\n']",
  "context": "st.DictComp,\n        ast.GeneratorExp,\n    )\n\n    _elements_to_eval: ClassVar[AnyNodes] = (\n        *TextNodes,\n        ast.Num,\n        ast.N"
 },
 "2276": {
  "name": "keys",
  "type": "_HashItems",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "513",
  "column": "32",
  "slicing": "['    def _check_float_keys(self, keys: _HashItems) -> None:\\n']",
  "context": "eric_visit(node)\n\n    def _check_float_keys(self, keys: _HashItems) -> None:\n        for dict_key in keys:\n            if dict_"
 },
 "2277": {
  "name": "is_float_key",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "519",
  "column": "12",
  "slicing": "['            is_float_key = (\\n', '            if is_float_key:\\n']",
  "context": "operators.unwrap_unary_node(dict_key)\n            is_float_key = (\n                isinstance(real_key, ast.Num) and\n"
 },
 "2278": {
  "name": "keys_or_elts",
  "type": "_HashItems",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "528",
  "column": "8",
  "slicing": "['        keys_or_elts: _HashItems,\\n']",
  "context": "_check_unhashable_elements(\n        self,\n        keys_or_elts: _HashItems,\n    ) -> None:\n        for set_item in keys_or_elt"
 },
 "2279": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "538",
  "column": "8",
  "slicing": "['        node: Union[ast.Set, ast.Dict],\\n']",
  "context": "   def _check_set_elements(\n        self,\n        node: Union[ast.Set, ast.Dict],\n        keys_or_elts: _HashItems,\n    ) -> None:\n "
 },
 "2280": {
  "name": "keys_or_elts",
  "type": "_HashItems",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "539",
  "column": "8",
  "slicing": "['        keys_or_elts: _HashItems,\\n']",
  "context": ",\n        node: Union[ast.Set, ast.Dict],\n        keys_or_elts: _HashItems,\n    ) -> None:\n        elements: List[str] = []\n  "
 },
 "2281": {
  "name": "elements",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "541",
  "column": "8",
  "slicing": "['        elements: List[str] = []\\n', \"                elements.append(node_repr.strip().strip('(').strip(')'))\\n\", '        self._report_set_elements(node, elements, element_values)\\n', '        for look_element, look_count in Counter(elements).items():\\n', '            if look_count > 1:\\n', '                        node, text=look_element,\\n']",
  "context": " keys_or_elts: _HashItems,\n    ) -> None:\n        elements: List[str] = []\n        element_values = []\n\n        for set_item "
 },
 "2282": {
  "name": "element_values",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "542",
  "column": "8",
  "slicing": "['_HashItems = Sequence[Optional[ast.AST]]\\n', '        text_data = source.render_string(node.s)\\n', '        self._check_is_alphabet(node, text_data)\\n', '        self._check_modulo_patterns(node, text_data)\\n', '        if text_data in self._string_constants:\\n', '                    node, text=text_data,\\n', '        parent = nodes.get_parent(node)\\n', '        if parent and strings.is_doc_string(parent):\\n', '        if self._modulo_string_pattern.search(text_data):\\n', '            if not self._is_modulo_pattern_exception(parent):\\n', '        has_formatted_components = any(\\n', '            for comp in node.values\\n', '        if not has_formatted_components:\\n', '        for string_component in node.values:\\n', '            if isinstance(string_component, ast.FormattedValue):\\n', '                format_value = string_component.value\\n', '                if self._is_valid_formatted_value(format_value):\\n', '        if isinstance(format_value, self._chainable_types):\\n', '            if not self._is_valid_chaining(format_value):\\n', '        return self._is_valid_final_value(format_value)\\n', '        if isinstance(format_value, (ast.Name, ast.Attribute)):\\n', '        elif isinstance(format_value, ast.Call) and not format_value.args:\\n', '        elif isinstance(format_value, ast.Subscript):\\n', '                get_slice_expr(format_value),\\n', '        chained_parts: List[ast.AST] = list(attributes.parts(format_value))\\n', '        if len(chained_parts) <= self._max_chained_items:\\n', '            return self._is_valid_chain_structure(chained_parts)\\n', '        has_invalid_parts = any(\\n', '            for part in chained_parts\\n', '        if has_invalid_parts:\\n', '        if len(chained_parts) == self._max_chained_items:\\n', '                isinstance(part, self._single_use_types)\\n', '                for part in chained_parts\\n', '        parent = operators.get_parent_ignoring_unary(node)\\n', '        if isinstance(parent, self._allowed_parents):\\n', \"            precision = len(str(node.n).split('.')[1])\\n\", '            precision = 0\\n', '        if precision < 2:\\n', '        for constant in constants.MATH_APPROXIMATE_CONSTANTS:\\n', '            if str(constant).startswith(str(node.n)):\\n', '        for withitem in node.items:\\n', '            self._check_unpacking_target_types(withitem.optional_vars)\\n', '            if isinstance(withitem.optional_vars, ast.Tuple):\\n', '                    node, withitem.optional_vars.elts,\\n', '        for target in node.targets:\\n', '            self._check_unpacking_target_types(target)\\n', '        targets = tuple(targets)\\n', '        if len(targets) == 1:\\n', '        for target in targets:\\n', '            target_name = extract_name(target)\\n', '            if target_name is None:  # it means, that non name node was used\\n', '        for subnode in walk.get_subnodes_by_type(node, ast.List):\\n', '                consistency.UnpackingIterableToListViolation(subnode),\\n', '    def _check_float_keys(self, keys: _HashItems) -> None:\\n', '        for dict_key in keys:\\n', '            if dict_key is None:\\n', '            real_key = operators.unwrap_unary_node(dict_key)\\n', '            is_float_key = (\\n', '                isinstance(real_key, ast.Num) and\\n', '                isinstance(real_key.n, float)\\n', '            if is_float_key:\\n', '                self.add_violation(best_practices.FloatKeyViolation(dict_key))\\n', '        keys_or_elts: _HashItems,\\n', '        for set_item in keys_or_elts:\\n', '            if isinstance(set_item, self._unhashable_types):\\n', '                    best_practices.UnhashableTypeInHashViolation(set_item),\\n', '        keys_or_elts: _HashItems,\\n', '        elements: List[str] = []\\n', '        element_values = []\\n', '        for set_item in keys_or_elts:\\n', '            if set_item is None:\\n', '            real_item = operators.unwrap_unary_node(set_item)\\n', '            if isinstance(real_item, self._elements_in_sets):\\n', '                node_repr = source.node_to_string(set_item)\\n', \"                elements.append(node_repr.strip().strip('(').strip(')'))\\n\", '            real_item = operators.unwrap_starred_node(real_item)\\n', '                element_values.append(\\n', '                        real_item,\\n', '                        real_item, self._elements_to_eval,\\n', '                    ) else set_item,\\n', '        self._report_set_elements(node, elements, element_values)\\n', '        for look_element, look_count in Counter(elements).items():\\n', '            if look_count > 1:\\n', '                        node, text=look_element,\\n', '        for value_element in element_values:\\n', '            real_value = value_element if isinstance(\\n', '                value_element, Hashable,\\n', '            ) else str(value_element)\\n', '            value_counts[real_value] += 1\\n', '            if value_counts[real_value] > 1:\\n', '                        node, text=value_element,\\n']",
  "context": "-> None:\n        elements: List[str] = []\n        element_values = []\n\n        for set_item in keys_or_elts:\n           "
 },
 "2283": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "571",
  "column": "8",
  "slicing": "['        node: Union[ast.Set, ast.Dict],\\n']",
  "context": "  def _report_set_elements(\n        self,\n        node: Union[ast.Set, ast.Dict],\n        elements: List[str],\n        element_value"
 },
 "2284": {
  "name": "elements",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "572",
  "column": "8",
  "slicing": "['        elements: List[str],\\n']",
  "context": ",\n        node: Union[ast.Set, ast.Dict],\n        elements: List[str],\n        element_values,\n    ) -> None:\n        for"
 },
 "2285": {
  "name": "value_counts",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "584",
  "column": "8",
  "slicing": "['        value_counts: DefaultDict[Hashable, int] = defaultdict(int)\\n', '            value_counts[real_value] += 1\\n', '            if value_counts[real_value] > 1:\\n']",
  "context": "                )\n                return\n\n        value_counts: DefaultDict[Hashable, int] = defaultdict(int)\n        for value_element in element_values:\n     "
 },
 "2286": {
  "name": "real_value",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/builtins.py",
  "lineno": "586",
  "column": "12",
  "slicing": "['_HashItems = Sequence[Optional[ast.AST]]\\n', '        text_data = source.render_string(node.s)\\n', '        self._check_is_alphabet(node, text_data)\\n', '        self._check_modulo_patterns(node, text_data)\\n', '        if text_data in self._string_constants:\\n', '                    node, text=text_data,\\n', '        parent = nodes.get_parent(node)\\n', '        if parent and strings.is_doc_string(parent):\\n', '        if self._modulo_string_pattern.search(text_data):\\n', '            if not self._is_modulo_pattern_exception(parent):\\n', '        has_formatted_components = any(\\n', '            for comp in node.values\\n', '        if not has_formatted_components:\\n', '        for string_component in node.values:\\n', '            if isinstance(string_component, ast.FormattedValue):\\n', '                format_value = string_component.value\\n', '                if self._is_valid_formatted_value(format_value):\\n', '        if isinstance(format_value, self._chainable_types):\\n', '            if not self._is_valid_chaining(format_value):\\n', '        return self._is_valid_final_value(format_value)\\n', '        if isinstance(format_value, (ast.Name, ast.Attribute)):\\n', '        elif isinstance(format_value, ast.Call) and not format_value.args:\\n', '        elif isinstance(format_value, ast.Subscript):\\n', '                get_slice_expr(format_value),\\n', '        chained_parts: List[ast.AST] = list(attributes.parts(format_value))\\n', '        if len(chained_parts) <= self._max_chained_items:\\n', '            return self._is_valid_chain_structure(chained_parts)\\n', '        has_invalid_parts = any(\\n', '            for part in chained_parts\\n', '        if has_invalid_parts:\\n', '        if len(chained_parts) == self._max_chained_items:\\n', '                isinstance(part, self._single_use_types)\\n', '                for part in chained_parts\\n', '        parent = operators.get_parent_ignoring_unary(node)\\n', '        if isinstance(parent, self._allowed_parents):\\n', \"            precision = len(str(node.n).split('.')[1])\\n\", '            precision = 0\\n', '        if precision < 2:\\n', '        for constant in constants.MATH_APPROXIMATE_CONSTANTS:\\n', '            if str(constant).startswith(str(node.n)):\\n', '        for withitem in node.items:\\n', '            self._check_unpacking_target_types(withitem.optional_vars)\\n', '            if isinstance(withitem.optional_vars, ast.Tuple):\\n', '                    node, withitem.optional_vars.elts,\\n', '        for target in node.targets:\\n', '            self._check_unpacking_target_types(target)\\n', '        targets = tuple(targets)\\n', '        if len(targets) == 1:\\n', '        for target in targets:\\n', '            target_name = extract_name(target)\\n', '            if target_name is None:  # it means, that non name node was used\\n', '        for subnode in walk.get_subnodes_by_type(node, ast.List):\\n', '                consistency.UnpackingIterableToListViolation(subnode),\\n', '    def _check_float_keys(self, keys: _HashItems) -> None:\\n', '        for dict_key in keys:\\n', '            if dict_key is None:\\n', '            real_key = operators.unwrap_unary_node(dict_key)\\n', '            is_float_key = (\\n', '                isinstance(real_key, ast.Num) and\\n', '                isinstance(real_key.n, float)\\n', '            if is_float_key:\\n', '                self.add_violation(best_practices.FloatKeyViolation(dict_key))\\n', '        keys_or_elts: _HashItems,\\n', '        for set_item in keys_or_elts:\\n', '            if isinstance(set_item, self._unhashable_types):\\n', '                    best_practices.UnhashableTypeInHashViolation(set_item),\\n', '        keys_or_elts: _HashItems,\\n', '        elements: List[str] = []\\n', '        element_values = []\\n', '        for set_item in keys_or_elts:\\n', '            if set_item is None:\\n', '            real_item = operators.unwrap_unary_node(set_item)\\n', '            if isinstance(real_item, self._elements_in_sets):\\n', '                node_repr = source.node_to_string(set_item)\\n', \"                elements.append(node_repr.strip().strip('(').strip(')'))\\n\", '            real_item = operators.unwrap_starred_node(real_item)\\n', '                element_values.append(\\n', '                        real_item,\\n', '                        real_item, self._elements_to_eval,\\n', '                    ) else set_item,\\n', '        self._report_set_elements(node, elements, element_values)\\n', '        for look_element, look_count in Counter(elements).items():\\n', '            if look_count > 1:\\n', '                        node, text=look_element,\\n', '        for value_element in element_values:\\n', '            real_value = value_element if isinstance(\\n', '                value_element, Hashable,\\n', '            ) else str(value_element)\\n', '            value_counts[real_value] += 1\\n', '            if value_counts[real_value] > 1:\\n', '                        node, text=value_element,\\n']",
  "context": " for value_element in element_values:\n            real_value = value_element if isinstance(\n                # Lists, sets, and dicts are not h"
 },
 "2287": {
  "name": "_bad_returning_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    _bad_returning_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "nsible for examining ``try`` and friends.\"\"\"\n\n    _bad_returning_nodes: ClassVar[AnyNodes] = (\n        ast.Return,\n        ast.Raise,\n        ast"
 },
 "2288": {
  "name": "try_has",
  "type": "find_returning",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "82",
  "column": "8",
  "slicing": "['        try_has, except_has, else_has, finally_has = find_returning(\\n', '        if finally_has and (try_has or except_has or else_has):\\n', '        elif else_has and try_has:\\n']",
  "context": "turning = exceptions.find_returning_nodes\n        try_has, except_has, else_has, finally_has = find_returning(\n            node, self._bad_returning_nodes,\n     "
 },
 "2289": {
  "name": "except_has",
  "type": "find_returning",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "82",
  "column": "17",
  "slicing": "['        try_has, except_has, else_has, finally_has = find_returning(\\n', '        if finally_has and (try_has or except_has or else_has):\\n']",
  "context": " exceptions.find_returning_nodes\n        try_has, except_has, else_has, finally_has = find_returning(\n            node, self._bad_returning_nodes,\n     "
 },
 "2290": {
  "name": "else_has",
  "type": "find_returning",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "82",
  "column": "29",
  "slicing": "['        try_has, except_has, else_has, finally_has = find_returning(\\n', '        if finally_has and (try_has or except_has or else_has):\\n', '        elif else_has and try_has:\\n']",
  "context": "find_returning_nodes\n        try_has, except_has, else_has, finally_has = find_returning(\n            node, self._bad_returning_nodes,\n     "
 },
 "2291": {
  "name": "finally_has",
  "type": "find_returning",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "82",
  "column": "39",
  "slicing": "['        try_has, except_has, else_has, finally_has = find_returning(\\n', '        if finally_has and (try_has or except_has or else_has):\\n']",
  "context": "ning_nodes\n        try_has, except_has, else_has, finally_has = find_returning(\n            node, self._bad_returning_nodes,\n     "
 },
 "2292": {
  "name": "seen",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "94",
  "column": "8",
  "slicing": "['        seen: Set[str] = set()\\n', '                if any(base in seen for base in bases):\\n', '                    seen.add(exception)\\n']",
  "context": " exceptions.get_all_exception_names(node)\n        seen: Set[str] = set()\n\n        for exception in exceptions_list:\n       "
 },
 "2293": {
  "name": "has_wrong_nodes",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "106",
  "column": "8",
  "slicing": "['        context = nodes.get_context(node)\\n', '        if isinstance(context, FunctionNodes) and context.decorator_list:\\n', '        exceptions_list = exceptions.get_all_exception_names(node)\\n', '        for exc_name, count in Counter(exceptions_list).items():\\n', '            if count > 1:\\n', '                    DuplicateExceptionViolation(node, text=exc_name),\\n', '        find_returning = exceptions.find_returning_nodes\\n', '        try_has, except_has, else_has, finally_has = find_returning(\\n', '        if finally_has and (try_has or except_has or else_has):\\n', '        elif else_has and try_has:\\n', '        built_in_exceptions = exceptions.traverse_exception(BaseException)\\n', '        exceptions_list = exceptions.get_all_exception_names(node)\\n', '        seen: Set[str] = set()\\n', '        for exception in exceptions_list:\\n', '            bases = built_in_exceptions.get(exception)\\n', '            if bases is not None:\\n', '                if any(base in seen for base in bases):\\n', '                    seen.add(exception)\\n', '        has_wrong_nodes = any(\\n', '            for line in node.finalbody\\n', '        if has_wrong_nodes:\\n']",
  "context": "_in_finally(self, node: ast.Try) -> None:\n        has_wrong_nodes = any(\n            is_contained(line, (ast.Break, ast.Con"
 },
 "2294": {
  "name": "_base_exception",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "140",
  "column": "4",
  "slicing": "[\"    _base_exception: ClassVar[str] = 'BaseException'\\n\"]",
  "context": "sible for examining ``ExceptionHandler``.\"\"\"\n\n    _base_exception: ClassVar[str] = 'BaseException'\n\n    _trivial_except_arg_nodes: ClassVar[AnyNodes]"
 },
 "2295": {
  "name": "_trivial_except_arg_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "142",
  "column": "4",
  "slicing": "['    _trivial_except_arg_nodes: ClassVar[AnyNodes] = (ast.Name, ast.Attribute)\\n']",
  "context": "e_exception: ClassVar[str] = 'BaseException'\n\n    _trivial_except_arg_nodes: ClassVar[AnyNodes] = (ast.Name, ast.Attribute)\n\n    def visit_ExceptHandler(self, node: ast.Excep"
 },
 "2296": {
  "name": "body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "162",
  "column": "8",
  "slicing": "['        context = nodes.get_context(node)\\n', '        if isinstance(context, FunctionNodes) and context.decorator_list:\\n', '        exceptions_list = exceptions.get_all_exception_names(node)\\n', '        for exc_name, count in Counter(exceptions_list).items():\\n', '            if count > 1:\\n', '                    DuplicateExceptionViolation(node, text=exc_name),\\n', '        find_returning = exceptions.find_returning_nodes\\n', '        try_has, except_has, else_has, finally_has = find_returning(\\n', '        if finally_has and (try_has or except_has or else_has):\\n', '        elif else_has and try_has:\\n', '        built_in_exceptions = exceptions.traverse_exception(BaseException)\\n', '        exceptions_list = exceptions.get_all_exception_names(node)\\n', '        seen: Set[str] = set()\\n', '        for exception in exceptions_list:\\n', '            bases = built_in_exceptions.get(exception)\\n', '            if bases is not None:\\n', '                if any(base in seen for base in bases):\\n', '                    seen.add(exception)\\n', '        has_wrong_nodes = any(\\n', '            for line in node.finalbody\\n', '        if has_wrong_nodes:\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Try) and sub_node is not node:\\n', '                self.add_violation(NestedTryViolation(sub_node))\\n', '        body = node.body[0]\\n', '        if not isinstance(body, ast.Raise):\\n', '        if isinstance(body.exc, ast.Call):\\n', '        if isinstance(body.exc, ast.Name) and node.name:\\n', '            if body.exc.id != node.name:\\n']",
  "context": " len(node.body) != 1:\n            return\n\n        body = node.body[0]\n        if not isinstance(body, ast.Raise):\n      "
 },
 "2297": {
  "name": "exception_id",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "180",
  "column": "8",
  "slicing": "['        context = nodes.get_context(node)\\n', '        if isinstance(context, FunctionNodes) and context.decorator_list:\\n', '        exceptions_list = exceptions.get_all_exception_names(node)\\n', '        for exc_name, count in Counter(exceptions_list).items():\\n', '            if count > 1:\\n', '                    DuplicateExceptionViolation(node, text=exc_name),\\n', '        find_returning = exceptions.find_returning_nodes\\n', '        try_has, except_has, else_has, finally_has = find_returning(\\n', '        if finally_has and (try_has or except_has or else_has):\\n', '        elif else_has and try_has:\\n', '        built_in_exceptions = exceptions.traverse_exception(BaseException)\\n', '        exceptions_list = exceptions.get_all_exception_names(node)\\n', '        seen: Set[str] = set()\\n', '        for exception in exceptions_list:\\n', '            bases = built_in_exceptions.get(exception)\\n', '            if bases is not None:\\n', '                if any(base in seen for base in bases):\\n', '                    seen.add(exception)\\n', '        has_wrong_nodes = any(\\n', '            for line in node.finalbody\\n', '        if has_wrong_nodes:\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Try) and sub_node is not node:\\n', '                self.add_violation(NestedTryViolation(sub_node))\\n', '        body = node.body[0]\\n', '        if not isinstance(body, ast.Raise):\\n', '        if isinstance(body.exc, ast.Call):\\n', '        if isinstance(body.exc, ast.Name) and node.name:\\n', '            if body.exc.id != node.name:\\n', '        exception_name = node.type\\n', '        if exception_name is None:\\n', \"        exception_id = getattr(exception_name, 'id', None)\\n\", '        if exception_id == self._base_exception:\\n']",
  "context": "ception_name is None:\n            return\n\n        exception_id = getattr(exception_name, 'id', None)\n        if exception_id == self._base_exception:\n "
 },
 "2298": {
  "name": "all_elements_are_trivial",
  "type": "all",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/exceptions.py",
  "lineno": "193",
  "column": "12",
  "slicing": "['        context = nodes.get_context(node)\\n', '        if isinstance(context, FunctionNodes) and context.decorator_list:\\n', '        exceptions_list = exceptions.get_all_exception_names(node)\\n', '        for exc_name, count in Counter(exceptions_list).items():\\n', '            if count > 1:\\n', '                    DuplicateExceptionViolation(node, text=exc_name),\\n', '        find_returning = exceptions.find_returning_nodes\\n', '        try_has, except_has, else_has, finally_has = find_returning(\\n', '        if finally_has and (try_has or except_has or else_has):\\n', '        elif else_has and try_has:\\n', '        built_in_exceptions = exceptions.traverse_exception(BaseException)\\n', '        exceptions_list = exceptions.get_all_exception_names(node)\\n', '        seen: Set[str] = set()\\n', '        for exception in exceptions_list:\\n', '            bases = built_in_exceptions.get(exception)\\n', '            if bases is not None:\\n', '                if any(base in seen for base in bases):\\n', '                    seen.add(exception)\\n', '        has_wrong_nodes = any(\\n', '            for line in node.finalbody\\n', '        if has_wrong_nodes:\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Try) and sub_node is not node:\\n', '                self.add_violation(NestedTryViolation(sub_node))\\n', '        body = node.body[0]\\n', '        if not isinstance(body, ast.Raise):\\n', '        if isinstance(body.exc, ast.Call):\\n', '        if isinstance(body.exc, ast.Name) and node.name:\\n', '            if body.exc.id != node.name:\\n', '        exception_name = node.type\\n', '        if exception_name is None:\\n', \"        exception_id = getattr(exception_name, 'id', None)\\n\", '        if exception_id == self._base_exception:\\n', '            all_elements_are_trivial = all((\\n', '                for element in node.type.elts\\n', '            if all_elements_are_trivial:\\n']",
  "context": " if isinstance(node.type, ast.Tuple):\n            all_elements_are_trivial = all((\n                isinstance(element, self._trivial_"
 },
 "2299": {
  "name": "_MODULE_MEMBERS_SEPARATOR",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "29",
  "column": "0",
  "slicing": "[\"_MODULE_MEMBERS_SEPARATOR: Final = '.'\\n\", '            if _MODULE_MEMBERS_SEPARATOR in alias.name:\\n', '            alias.name.split(_MODULE_MEMBERS_SEPARATOR)\\n', '                    _MODULE_MEMBERS_SEPARATOR.join(\\n']",
  "context": "eVisitor\n\n#: We use `.` to separate module names.\n_MODULE_MEMBERS_SEPARATOR: Final = '.'\n\n\nclass _BaseImportValidator(object):\n    \"\"\"Base "
 },
 "2300": {
  "name": "error_callback",
  "type": "wemake_python_styleguide.violations.base.ErrorCallback",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "37",
  "column": "8",
  "slicing": "['        error_callback: ErrorCallback,\\n']",
  "context": "itor.\"\"\"\n\n    def __init__(\n        self,\n        error_callback: ErrorCallback,\n        options: ConfigurationOptions,\n    ) -> No"
 },
 "2301": {
  "name": "options",
  "type": "wemake_python_styleguide.types.ConfigurationOptions",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "38",
  "column": "8",
  "slicing": "['        options: ConfigurationOptions,\\n']",
  "context": "f,\n        error_callback: ErrorCallback,\n        options: ConfigurationOptions,\n    ) -> None:\n        self._error_callback = erro"
 },
 "2302": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyImport",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "43",
  "column": "35",
  "slicing": "['    def _validate_any_import(self, node: AnyImport) -> None:\\n']",
  "context": "ons = options\n\n    def _validate_any_import(self, node: AnyImport) -> None:\n        self._check_nested_import(node)\n        se"
 },
 "2303": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyImport",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "47",
  "column": "35",
  "slicing": "['    def _check_nested_import(self, node: AnyImport) -> None:\\n']",
  "context": "e_alias(node)\n\n    def _check_nested_import(self, node: AnyImport) -> None:\n        parent = nodes.get_parent(node)\n        if"
 },
 "2304": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyImport",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "53",
  "column": "32",
  "slicing": "['    def _check_same_alias(self, node: AnyImport) -> None:\\n']",
  "context": "Violation(node))\n\n    def _check_same_alias(self, node: AnyImport) -> None:\n        for alias in node.names:\n            if al"
 },
 "2305": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "78",
  "column": "8",
  "slicing": "['        names: Iterable[str] = chain.from_iterable([\\n', '        for name in names:\\n', '            if access.is_protected(name):\\n', '                self._error_callback(ProtectedModuleViolation(node, text=name))\\n', '            if access.is_protected(name):\\n', '                self._error_callback(ProtectedModuleViolation(node, text=name))\\n', '                    (alias.asname and name != alias.asname) or\\n', '                    not imports.is_vague_import(name)\\n', '                    self._error_callback(VagueImportViolation(node, text=name))\\n']",
  "context": "d_import(self, node: ast.Import) -> None:\n        names: Iterable[str] = chain.from_iterable([\n            alias.name.split(_MODULE_MEMBERS_SEPAR"
 },
 "2306": {
  "name": "is_regular_import",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "127",
  "column": "16",
  "slicing": "['                is_regular_import = (\\n', '                if not is_regular_import:\\n']",
  "context": "one, (alias.name, alias.asname)):\n                is_regular_import = (\n                    (alias.asname and name != alia"
 },
 "2307": {
  "name": "error_callback",
  "type": "wemake_python_styleguide.violations.base.ErrorCallback",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "145",
  "column": "23",
  "slicing": "['    def __init__(self, error_callback: ErrorCallback) -> None:\\n']",
  "context": "considered valid.\n    \"\"\"\n\n    def __init__(self, error_callback: ErrorCallback) -> None:\n        self._error_callback = error_callback\n    "
 },
 "2308": {
  "name": "first_path",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/imports.py",
  "lineno": "190",
  "column": "8",
  "slicing": "[\"_MODULE_MEMBERS_SEPARATOR: Final = '.'\\n\", '        parent = nodes.get_parent(node)\\n', '        if parent is not None and not isinstance(parent, ast.Module):\\n', '            if not imports.is_nested_typing_import(parent):\\n', '        for alias in node.names:\\n', '            if alias.asname == alias.name and self._options.i_control_code:\\n', '                    SameAliasImportViolation(node, text=alias.name),\\n', '        for alias in node.names:\\n', '            if _MODULE_MEMBERS_SEPARATOR in alias.name:\\n', '                    DottedRawImportViolation(node, text=alias.name),\\n', '        names: Iterable[str] = chain.from_iterable([\\n', '            alias.name.split(_MODULE_MEMBERS_SEPARATOR)\\n', '            for alias in node.names\\n', '        for name in names:\\n', '            if access.is_protected(name):\\n', '                self._error_callback(ProtectedModuleViolation(node, text=name))\\n', '            for alias in node.names:\\n', '                if alias.name not in FUTURE_IMPORTS_WHITELIST:\\n', '                        FutureImportViolation(node, text=alias.name),\\n', '        for name in imports.get_import_parts(node):\\n', '            if access.is_protected(name):\\n', '                self._error_callback(ProtectedModuleViolation(node, text=name))\\n', '        for alias in node.names:\\n', '            if access.is_protected(alias.name):\\n', '                    ProtectedModuleMemberViolation(node, text=alias.name),\\n', '        for alias in node.names:\\n', '            for name in filter(None, (alias.name, alias.asname)):\\n', '                is_regular_import = (\\n', '                    (alias.asname and name != alias.asname) or\\n', '                    not imports.is_vague_import(name)\\n', '                if not is_regular_import:\\n', '                    self._error_callback(VagueImportViolation(node, text=name))\\n', '        for first, second in product(self._imported_names, repeat=2):\\n', '            if first.module == second.module:\\n', '            if len(first.module) < len(second.module):\\n', '            if self._does_collide(first, second):\\n', '                    first.node,\\n', '                    second.module,\\n', '        for alias in node.names:\\n', '            if not alias.asname:\\n', '                    alias.name,\\n', '        for alias in node.names:\\n', '            if not alias.asname:\\n', '                    _MODULE_MEMBERS_SEPARATOR.join(\\n', '                        filter(None, (node.module, alias.name)),\\n', \"        first_path = first.module.split('.')[:-1]\\n\", \"        second_path = second.module.split('.')\\n\", '        return first_path == second_path\\n']",
  "context": "mports.ImportedObjectInfo,\n    ) -> bool:\n        first_path = first.module.split('.')[:-1]\n        second_path = second.module.split('.')\n   "
 },
 "2309": {
  "name": "_LocalVariable",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "50",
  "column": "0",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '                for part in parts\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": "ecorators\n\n#: Things we treat as local variables.\n_LocalVariable = Union[ast.Name, ast.ExceptHandler]\n\n#: Function definitions with name and arity:\n_Def"
 },
 "2310": {
  "name": "_Defs",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "53",
  "column": "0",
  "slicing": "['_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n']",
  "context": "er]\n\n#: Function definitions with name and arity:\n_Defs = Mapping[str, int]\n\n\n@final\nclass WrongFunctionCallVisitor(base.BaseN"
 },
 "2311": {
  "name": "_functions",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['    _functions: ClassVar[_Defs] = {\\n']",
  "context": " defined in ``FUNCTIONS_BLACKLIST``.\n    \"\"\"\n\n    _functions: ClassVar[_Defs] = {\n        'getattr': 3,\n        'setattr': 3,\n    }\n"
 },
 "2312": {
  "name": "_postfixes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['    _postfixes: ClassVar[_Defs] = {\\n']",
  "context": "   'getattr': 3,\n        'setattr': 3,\n    }\n\n    _postfixes: ClassVar[_Defs] = {\n        # dict methods:\n        '.get': 2,\n       "
 },
 "2313": {
  "name": "attr",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "141",
  "column": "8",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '                for part in parts\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": "    parent_node = nodes.get_parent(node)\n\n        attr = getattr(parent_node, 'attr', None)\n        parent_name = getattr(parent_context, 'nam"
 },
 "2314": {
  "name": "parent_name",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "142",
  "column": "8",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '                for part in parts\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": "attr = getattr(parent_node, 'attr', None)\n        parent_name = getattr(parent_context, 'name', None)\n\n        if attr and parent_name and attr != paren"
 },
 "2315": {
  "name": "_nan_variants",
  "type": "frozenset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "183",
  "column": "4",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"    _nan_variants = frozenset(('nan', b'nan'))\\n\", \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '                for part in parts\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": "  \"\"\"Ensure that NaN explicitly acquired.\"\"\"\n\n    _nan_variants = frozenset(('nan', b'nan'))\n\n    def visit_Call(self, node: ast.Call) -> None:"
 },
 "2316": {
  "name": "args_len",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "246",
  "column": "8",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '                for part in parts\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": "led(node, {'range'}):\n            return\n\n        args_len = len(node.args)\n\n        is_one_arg_range = (\n            args_len"
 },
 "2317": {
  "name": "is_one_arg_range",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "248",
  "column": "8",
  "slicing": "['        is_one_arg_range = (\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n']",
  "context": "eturn\n\n        args_len = len(node.args)\n\n        is_one_arg_range = (\n            args_len == 1 and\n            isinstan"
 },
 "2318": {
  "name": "is_two_args_range",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "253",
  "column": "8",
  "slicing": "['        is_two_args_range = (\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n']",
  "context": "n_called(node.args[0], {'len'})\n        )\n        is_two_args_range = (\n            self._is_multiple_args_range_with_len("
 },
 "2319": {
  "name": "step_arg",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "259",
  "column": "8",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '                for part in parts\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": " only if `step` arg do not equals 1 or -1\n        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\n        is_three_args_range = (\n            self._"
 },
 "2320": {
  "name": "is_three_args_range",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "260",
  "column": "8",
  "slicing": "['        is_three_args_range = (\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n']",
  "context": "operators.unwrap_unary_node(node.args[2])\n        is_three_args_range = (\n            self._is_multiple_args_range_with_len("
 },
 "2321": {
  "name": "_descriptor_decorators",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "285",
  "column": "4",
  "slicing": "['    _descriptor_decorators: ClassVar[\\n']",
  "context": "ponsible for checking function internals.\"\"\"\n\n    _descriptor_decorators: ClassVar[\n        FrozenSet[str]\n    ] = frozenset((\n       "
 },
 "2322": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "293",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "operty',\n    ))\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        Checks regular and ``async`` f"
 },
 "2323": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "308",
  "column": "38",
  "slicing": "['    def _check_unused_variables(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "isit(node)\n\n    def _check_unused_variables(self, node: AnyFunctionDef) -> None:\n        local_variables: Dict[str, List[_LocalVari"
 },
 "2324": {
  "name": "local_variables",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "309",
  "column": "8",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '                for part in parts\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": "bles(self, node: AnyFunctionDef) -> None:\n        local_variables: Dict[str, List[_LocalVariable]] = {}\n\n        for body_item in node.body:\n            f"
 },
 "2325": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "321",
  "column": "31",
  "slicing": "['    def _check_generator(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "(local_variables)\n\n    def _check_generator(self, node: AnyFunctionDef) -> None:\n        if not functions.is_generator(node):\n     "
 },
 "2326": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "331",
  "column": "43",
  "slicing": "['    def _check_descriptor_decorators(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "    )\n\n    def _check_descriptor_decorators(self, node: AnyFunctionDef) -> None:\n        if isinstance(nodes.get_parent(node), ast."
 },
 "2327": {
  "name": "descriptor_decorators",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "335",
  "column": "8",
  "slicing": "['        descriptor_decorators = [\\n', '        if any(descriptor_decorators):\\n']",
  "context": "eturn  # classes can contain descriptors\n\n        descriptor_decorators = [\n            decorator.id in self._descriptor_decor"
 },
 "2328": {
  "name": "sub_node",
  "type": "_LocalVariable",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "348",
  "column": "8",
  "slicing": "['        sub_node: _LocalVariable,\\n']",
  "context": "def _maybe_update_variable(\n        self,\n        sub_node: _LocalVariable,\n        var_name: str,\n        local_variables: Di"
 },
 "2329": {
  "name": "var_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "349",
  "column": "8",
  "slicing": "['        var_name: str,\\n']",
  "context": "  self,\n        sub_node: _LocalVariable,\n        var_name: str,\n        local_variables: Dict[str, List[_LocalVari"
 },
 "2330": {
  "name": "local_variables",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "350",
  "column": "8",
  "slicing": "['        local_variables: Dict[str, List[_LocalVariable]],\\n']",
  "context": "e: _LocalVariable,\n        var_name: str,\n        local_variables: Dict[str, List[_LocalVariable]],\n    ) -> None:\n        defs = local_variables.get("
 },
 "2331": {
  "name": "is_name_def",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "361",
  "column": "8",
  "slicing": "['        is_name_def = (\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n']",
  "context": "defs.append(sub_node)\n            return\n\n        is_name_def = (\n            isinstance(sub_node, ast.Name) and\n   "
 },
 "2332": {
  "name": "local_variables",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "371",
  "column": "8",
  "slicing": "['        local_variables: Mapping[str, List[_LocalVariable]],\\n']",
  "context": "def _ensure_used_variables(\n        self,\n        local_variables: Mapping[str, List[_LocalVariable]],\n    ) -> None:\n        for varname, usages in loca"
 },
 "2333": {
  "name": "_allowed_default_value_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "446",
  "column": "4",
  "slicing": "['    _allowed_default_value_types: ClassVar[AnyNodes] = (\\n']",
  "context": "to use getters with no output value.\n    \"\"\"\n\n    _allowed_default_value_types: ClassVar[AnyNodes] = (\n        *TextNodes,\n        ast.Name,\n        ast."
 },
 "2334": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDefAndLambda",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "458",
  "column": "8",
  "slicing": "['        node: AnyFunctionDefAndLambda,\\n']",
  "context": "it_any_function_and_lambda(\n        self,\n        node: AnyFunctionDefAndLambda,\n    ) -> None:\n        \"\"\"\n        Checks function"
 },
 "2335": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "475",
  "column": "43",
  "slicing": "['    def _check_getter_without_return(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "node)\n\n    def _check_getter_without_return(self, node: AnyFunctionDef) -> None:\n        if not self._is_concrete_getter(node):\n   "
 },
 "2336": {
  "name": "has_explicit_function_exit",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "479",
  "column": "8",
  "slicing": "['        has_explicit_function_exit = False\\n', '        if not has_explicit_function_exit:\\n']",
  "context": "oncrete_getter(node):\n            return\n\n        has_explicit_function_exit = False\n        for function_exit_node in functions.get_fu"
 },
 "2337": {
  "name": "has_explicit_function_exit",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "481",
  "column": "12",
  "slicing": "['            has_explicit_function_exit = True\\n', '        if not has_explicit_function_exit:\\n']",
  "context": "ctions.get_function_exit_nodes(node):\n            has_explicit_function_exit = True\n\n            if function_exit_node.value is None:\n"
 },
 "2338": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "492",
  "column": "34",
  "slicing": "['    def _is_concrete_getter(self, node: AnyFunctionDef) -> bool:\\n']",
  "context": "olation(node))\n\n    def _is_concrete_getter(self, node: AnyFunctionDef) -> bool:\n        return (\n            node.name.startswith("
 },
 "2339": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDefAndLambda",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "500",
  "column": "8",
  "slicing": "['        node: AnyFunctionDefAndLambda,\\n']",
  "context": "check_positional_arguments(\n        self,\n        node: AnyFunctionDefAndLambda,\n    ) -> None:\n        if get_posonlyargs(node):  "
 },
 "2340": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDefAndLambda",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "507",
  "column": "8",
  "slicing": "['        node: AnyFunctionDefAndLambda,\\n']",
  "context": "_complex_argument_defaults(\n        self,\n        node: AnyFunctionDefAndLambda,\n    ) -> None:\n        all_defaults = filter(None,"
 },
 "2341": {
  "name": "all_defaults",
  "type": "filter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "509",
  "column": "8",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '                for part in parts\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": ": AnyFunctionDefAndLambda,\n    ) -> None:\n        all_defaults = filter(None, (\n            *node.args.defaults,\n            *node"
 },
 "2342": {
  "name": "parts",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "516",
  "column": "12",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '                for part in parts\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": "rg = operators.unwrap_unary_node(arg)\n            parts = attributes.parts(real_arg) if isinstance(\n                real_arg, ast.Attribute,\n         "
 },
 "2343": {
  "name": "has_incorrect_part",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/functions.py",
  "lineno": "520",
  "column": "12",
  "slicing": "['_LocalVariable = Union[ast.Name, ast.ExceptHandler]\\n', '_Defs = Mapping[str, int]\\n', '    _functions: ClassVar[_Defs] = {\\n', '    _postfixes: ClassVar[_Defs] = {\\n', '        function_name = functions.given_function_called(\\n', '        if function_name:\\n', '                WrongFunctionCallViolation(node, text=function_name),\\n', '        for arg in node.args:\\n', '            if not isinstance(arg, ast.NameConstant):\\n', '            is_ignored = self._is_call_ignored(node)\\n', '            if not is_ignored and arg.value in {True, False}:\\n', '                        arg, text=str(arg.value),\\n', \"        function_name = functions.given_function_called(node, {'isinstance'})\\n\", '        if not function_name or len(node.args) != 2:\\n', '        parent_context = nodes.get_context(node)\\n', '        parent_node = nodes.get_parent(node)\\n', \"        attr = getattr(parent_node, 'attr', None)\\n\", \"        parent_name = getattr(parent_context, 'name', None)\\n\", '        if attr and parent_name and attr != parent_name:\\n', '        if isinstance(parent_context, FunctionNodes):\\n', '            grand_context = nodes.get_context(parent_context)\\n', '            if isinstance(grand_context, ast.ClassDef):\\n', '        call = source.node_to_string(node.func)\\n', '        func_called = functions.given_function_called(\\n', '            func_called and len(node.args) == self._functions[func_called],\\n', '            call.endswith(post)\\n', '            for post in self._postfixes\\n', '            if len(node.args) == self._postfixes[post]\\n', \"        function_name = functions.given_function_called(node, {'open'})\\n\", '        if not function_name:\\n', \"        function_name = functions.given_function_called(node, {'type'})\\n\", '        if not function_name:\\n', '        args_len = len(node.args)\\n', '        is_one_arg_range = (\\n', '            args_len == 1 and\\n', '        is_two_args_range = (\\n', '            args_len == 2\\n', '        step_arg = args_len == 3 and operators.unwrap_unary_node(node.args[2])\\n', '        is_three_args_range = (\\n', '            args_len == 3 and\\n', '            isinstance(step_arg, ast.Num) and\\n', '            abs(step_arg.n) == 1\\n', '        if any([is_one_arg_range, is_two_args_range, is_three_args_range]):\\n', '        local_variables: Dict[str, List[_LocalVariable]] = {}\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                if isinstance(sub_node, (ast.Name, ast.ExceptHandler)):\\n', '                    var_name = variables.get_variable_name(sub_node)\\n', '                        sub_node, var_name, local_variables,\\n', '        self._ensure_used_variables(local_variables)\\n', '        for sub_node in walk.get_subnodes_by_type(node, ast.Raise):\\n', \"            if exceptions.get_exception_name(sub_node) == 'StopIteration':\\n\", '                    StopIterationInsideGeneratorViolation(sub_node),\\n', '        descriptor_decorators = [\\n', '            for decorator in node.decorator_list\\n', '            if isinstance(decorator, ast.Name)\\n', '        if any(descriptor_decorators):\\n', '        sub_node: _LocalVariable,\\n', '        local_variables: Dict[str, List[_LocalVariable]],\\n', '        defs = local_variables.get(var_name)\\n', '        if defs is not None:\\n', '            if not var_name or access.is_unused(var_name):\\n', '            defs.append(sub_node)\\n', '        is_name_def = (\\n', '            isinstance(sub_node, ast.Name) and\\n', '            isinstance(sub_node.ctx, ast.Store)\\n', '        if is_name_def or isinstance(sub_node, ast.ExceptHandler):\\n', '            local_variables[var_name] = []\\n', '        local_variables: Mapping[str, List[_LocalVariable]],\\n', '        for varname, usages in local_variables.items():\\n', '            for node in usages:\\n', '                if access.is_protected(varname):\\n', '                            node, text=varname,\\n', '        self._check_useless_lambda(node)\\n', '        self._check_implicit_primitive(node)\\n', '        self.generic_visit(node)\\n', '        arguments = functions.get_all_arguments(node)\\n', '        if arguments:\\n', '            return_value = ast.literal_eval(node.body)\\n', '            if return_value is not None and not return_value:\\n', '                self.add_violation(ImplicitPrimitiveViolation(node))\\n', '        if not isinstance(node.body, ast.Call):\\n', '        if not isinstance(node.body.func, ast.Name):\\n', '        if node.args.defaults or list(filter(None, node.args.kw_defaults)):\\n', '        if not function_args.is_call_matched_by_arguments(node, node.body):\\n', '        self.add_violation(UselessLambdaViolation(node))\\n', '        self._check_positional_arguments(node)\\n', '        self._check_complex_argument_defaults(node)\\n', '        if not isinstance(node, ast.Lambda):\\n', '            self._check_getter_without_return(node)\\n', '        self.generic_visit(node)\\n', '        if not self._is_concrete_getter(node):\\n', '        has_explicit_function_exit = False\\n', '        for function_exit_node in functions.get_function_exit_nodes(node):\\n', '            has_explicit_function_exit = True\\n', '            if function_exit_node.value is None:\\n', '                if isinstance(function_exit_node, ast.Yield):\\n', '                self.add_violation(GetterWithoutReturnViolation(node))\\n', '        if not has_explicit_function_exit:\\n', '            self.add_violation(GetterWithoutReturnViolation(node))\\n', \"            node.name.startswith('get_') and\\n\", '            not stubs.is_stub(node)\\n', '        if get_posonlyargs(node):  # pragma: py-lt-38\\n', '            self.add_violation(PositionalOnlyArgumentsViolation(node))\\n', '        all_defaults = filter(None, (\\n', '            *node.args.defaults,\\n', '            *node.args.kw_defaults,\\n', '        for arg in all_defaults:\\n', '            real_arg = operators.unwrap_unary_node(arg)\\n', '            parts = attributes.parts(real_arg) if isinstance(\\n', '                real_arg, ast.Attribute,\\n', '            ) else [real_arg]\\n', '            has_incorrect_part = any(\\n', '                for part in parts\\n', '            if has_incorrect_part:\\n', '                self.add_violation(ComplexDefaultValueViolation(arg))\\n', '        self._check_unnecessary_literals(node)\\n', '        self.generic_visit(node)\\n', '            node, LITERALS_BLACKLIST,\\n', '        if function_name and not node.args:\\n', '            self.add_violation(consistency.UnnecessaryLiteralsViolation(node))\\n']",
  "context": "ibute,\n            ) else [real_arg]\n\n            has_incorrect_part = any(\n                not isinstance(part, self._allowed"
 },
 "2344": {
  "name": "_unpackable_iterable_parent_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/iterables.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    _unpackable_iterable_parent_types: ClassVar[AnyNodes] = (\\n']",
  "context": "itor):\n    \"\"\"Checks iterables unpacking.\"\"\"\n\n    _unpackable_iterable_parent_types: ClassVar[AnyNodes] = (\n        ast.List,\n        ast.Set,\n        ast.Tup"
 },
 "2345": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/iterables.py",
  "lineno": "36",
  "column": "8",
  "slicing": "['        parent = get_parent(node)\\n', '        if isinstance(parent, self._unpackable_iterable_parent_types):\\n', \"            if len(getattr(parent, 'elts', [])) == 1:\\n\"]",
  "context": "packing(self, node: ast.Starred) -> None:\n        parent = get_parent(node)\n        if isinstance(parent, self._unpackable_ite"
 },
 "2346": {
  "name": "_ContainerSpec",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "44",
  "column": "0",
  "slicing": "['_ContainerSpec = Mapping[Type[ast.AST], Sequence[str]]\\n', '    _containers: ClassVar[_ContainerSpec] = {\\n']",
  "context": "ecify how we check different containers in loops.\n_ContainerSpec = Mapping[Type[ast.AST], Sequence[str]]\n\n\n@final\n@decorators.alias('visit_any_comprehensio"
 },
 "2347": {
  "name": "_max_ifs",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    _max_ifs: ClassVar[int] = 1\\n']",
  "context": "\"\"\"Checks comprehensions for correctness.\"\"\"\n\n    _max_ifs: ClassVar[int] = 1\n    _max_fors: ClassVar[int] = 2\n\n    def __init__"
 },
 "2348": {
  "name": "_max_fors",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['    _max_fors: ClassVar[int] = 2\\n']",
  "context": "rectness.\"\"\"\n\n    _max_ifs: ClassVar[int] = 1\n    _max_fors: ClassVar[int] = 2\n\n    def __init__(self, *args, **kwargs) -> None:\n"
 },
 "2349": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyComprehension",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "78",
  "column": "38",
  "slicing": "['    def visit_any_comprehension(self, node: AnyComprehension) -> None:\\n']",
  "context": "isit(node)\n\n    def visit_any_comprehension(self, node: AnyComprehension) -> None:\n        \"\"\"\n        Finds incorrect patterns insid"
 },
 "2350": {
  "name": "parent",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "93",
  "column": "12",
  "slicing": "['            parent = nodes.get_parent(node) or node\\n', '            self.add_violation(MultipleIfsInComprehensionViolation(parent))\\n', '        self._fors[parent] = len(parent.generators)  # type: ignore\\n', '        if not isinstance(parent, (*AssignNodes, ast.AugAssign)):\\n', '        return any(node == target for target in get_assign_targets(parent))\\n']",
  "context": "hension` does not have this property.\n            parent = nodes.get_parent(node) or node\n            self.add_violation(MultipleIfsInCompre"
 },
 "2351": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyComprehension",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "100",
  "column": "36",
  "slicing": "['    def _check_contains_yield(self, node: AnyComprehension) -> None:\\n']",
  "context": "type: ignore\n\n    def _check_contains_yield(self, node: AnyComprehension) -> None:\n        for sub_node in ast.walk(node):\n          "
 },
 "2352": {
  "name": "_breaks",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "126",
  "column": "4",
  "slicing": "['    _breaks: ClassVar[AnyNodes] = (\\n']",
  "context": ":\n    \"\"\"Responsible for examining loops.\"\"\"\n\n    _breaks: ClassVar[AnyNodes] = (\n        ast.Break,\n        ast.Return,\n        ast"
 },
 "2353": {
  "name": "_containers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "132",
  "column": "4",
  "slicing": "['    _containers: ClassVar[_ContainerSpec] = {\\n']",
  "context": "        ast.Return,\n        ast.Raise,\n    )\n\n    _containers: ClassVar[_ContainerSpec] = {\n        ast.ListComp: ['elt'],\n        ast.SetComp"
 },
 "2354": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyComprehension",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "143",
  "column": "29",
  "slicing": "['    def visit_any_comp(self, node: AnyComprehension) -> None:\\n']",
  "context": "le: ['body'],\n    }\n\n    def visit_any_comp(self, node: AnyComprehension) -> None:\n        \"\"\"\n        Checks all kinds of comprehens"
 },
 "2355": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyLoop",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "154",
  "column": "29",
  "slicing": "['    def visit_any_loop(self, node: AnyLoop) -> None:\\n']",
  "context": "generic_visit(node)\n\n    def visit_any_loop(self, node: AnyLoop) -> None:\n        \"\"\"\n        Checks ``for`` and ``while`` l"
 },
 "2356": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyLoop",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "172",
  "column": "37",
  "slicing": "['    def _check_loop_needs_else(self, node: AnyLoop) -> None:\\n']",
  "context": "visit(node)\n\n    def _check_loop_needs_else(self, node: AnyLoop) -> None:\n        if node.orelse and not loops.has_break(nod"
 },
 "2357": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "178",
  "column": "8",
  "slicing": "['        node: Union[AnyLoop, AnyComprehension],\\n']",
  "context": " _check_lambda_inside_loop(\n        self,\n        node: Union[AnyLoop, AnyComprehension],\n    ) -> None:\n        for lambda_node in walk.get"
 },
 "2358": {
  "name": "arguments",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "181",
  "column": "12",
  "slicing": "['            arguments = (\\n', '            if not all(symbol in arguments for symbol in body):\\n']",
  "context": "t_subnodes_by_type(node, ast.Lambda):\n            arguments = (\n                arg.arg for arg\n                in"
 },
 "2359": {
  "name": "body",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "185",
  "column": "12",
  "slicing": "['            body = (\\n', '            if not all(symbol in arguments for symbol in body):\\n']",
  "context": "e(lambda_node, ast.arg)\n            )\n            body = (\n                subnode.id for subnode\n           "
 },
 "2360": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyLoop",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "192",
  "column": "38",
  "slicing": "['    def _check_useless_continue(self, node: AnyLoop) -> None:\\n']",
  "context": "ion(node))\n\n    def _check_useless_continue(self, node: AnyLoop) -> None:\n        nodes_at_line: DefaultDict[int, List[ast.A"
 },
 "2361": {
  "name": "nodes_at_line",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "193",
  "column": "8",
  "slicing": "['_ContainerSpec = Mapping[Type[ast.AST], Sequence[str]]\\n', '            parent = nodes.get_parent(node) or node\\n', '            self.add_violation(MultipleIfsInComprehensionViolation(parent))\\n', '        parent = nodes.get_parent(node)\\n', '        self._fors[parent] = len(parent.generators)  # type: ignore\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Yield):  # pragma: py-gte-38\\n', '        for node, for_count in self._fors.items():\\n', '            if for_count > self._max_fors:\\n', '                self.add_violation(TooManyForsInComprehensionViolation(node))\\n', '    _containers: ClassVar[_ContainerSpec] = {\\n', '        self._check_lambda_inside_loop(node)\\n', '        self.generic_visit(node)\\n', '        self._check_loop_needs_else(node)\\n', '        self._check_lambda_inside_loop(node)\\n', '        self._check_useless_continue(node)\\n', '        self._check_multiline_loop(node)\\n', '        self._check_infinite_while_loop(node)\\n', '        self.generic_visit(node)\\n', '        if node.orelse and not loops.has_break(node, break_nodes=(ast.Break,)):\\n', '            self.add_violation(UselessLoopElseViolation(node))\\n', '        for lambda_node in walk.get_subnodes_by_type(node, ast.Lambda):\\n', '            arguments = (\\n', '                arg.arg for arg\\n', '                in walk.get_subnodes_by_type(lambda_node, ast.arg)\\n', '            body = (\\n', '                subnode.id for subnode\\n', '                in walk.get_subnodes_by_type(lambda_node.body, ast.Name)\\n', '            if not all(symbol in arguments for symbol in body):\\n', '                self.add_violation(LambdaInsideLoopViolation(node))\\n', '        nodes_at_line: DefaultDict[int, List[ast.AST]] = defaultdict(list)\\n', '        for sub_node in ast.walk(node):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno is not None:\\n', '                nodes_at_line[lineno].append(sub_node)\\n', '        last_line = nodes_at_line[sorted(nodes_at_line.keys())[-1]]\\n', '        if any(isinstance(last, ast.Continue) for last in last_line):\\n', '            self.add_violation(UselessContinueViolation(node))\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '        if isinstance(node, ast.While):\\n', '            node_to_check = node.test\\n', '            node_to_check = node.iter\\n', '        for sub_node in ast.walk(node_to_check):\\n', \"            sub_lineno = getattr(sub_node, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n', '                self.add_violation(MultilineLoopViolation(node))\\n', '        if not isinstance(node, ast.While):\\n', '        real_node = operators.unwrap_unary_node(node.test)\\n', '        if isinstance(real_node, ast.NameConstant) and real_node.value is True:\\n', '            if not loops.has_break(node, break_nodes=self._breaks):\\n', '                self.add_violation(InfiniteWhileLoopViolation(node))\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self._check_implicit_sum(node)\\n', '        self._check_implicit_yield_from(node)\\n', '        self.generic_visit(node)\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self.generic_visit(node)\\n', '        if not is_valid_block_variable_definition(node):\\n', '            self.add_violation(LoopVariableDefinitionViolation(node))\\n', '        node_iter = operators.unwrap_unary_node(node.iter)\\n', '        is_wrong = isinstance(node_iter, self._forbidden_for_iters)\\n', '        is_empty = isinstance(node_iter, ast.Tuple) and not node_iter.elts\\n', '        if is_wrong or is_empty:\\n', '            self.add_violation(WrongLoopIterTypeViolation(node_iter))\\n', '        is_implicit_sum = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.AugAssign) and\\n', '            isinstance(node.body[0].op, ast.Add) and\\n', '            isinstance(node.body[0].target, ast.Name)\\n', '        if is_implicit_sum:\\n', '            self.add_violation(ImplicitSumViolation(node))\\n', '        if isinstance(nodes.get_context(node), ast.AsyncFunctionDef):\\n', '        is_implicit_yield_from = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.Expr) and\\n', '            isinstance(node.body[0].value, ast.Yield)\\n', '        if is_implicit_yield_from:\\n', '            self.add_violation(ImplicitYieldFromViolation(node))\\n', '        self._check_implicit_items(node)\\n', '        self.generic_visit(node)\\n', '        iterable = source.node_to_string(node.iter)\\n', '        target = source.node_to_string(node.target)\\n', '        for sub in ast.walk(node):\\n', '            has_violation = (\\n', '                isinstance(sub, ast.Subscript) and\\n', '                not self._is_assigned_target(sub) and\\n', '                slices.is_same_slice(iterable, target, sub)\\n', '            if has_violation:\\n', '                self.add_violation(ImplicitItemsIteratorViolation(node))\\n', '        parent = nodes.get_parent(node)\\n', '        if not isinstance(parent, (*AssignNodes, ast.AugAssign)):\\n', '        return any(node == target for target in get_assign_targets(parent))\\n']",
  "context": "ss_continue(self, node: AnyLoop) -> None:\n        nodes_at_line: DefaultDict[int, List[ast.AST]] = defaultdict(list)\n        for sub_node in ast.walk(node):\n          "
 },
 "2362": {
  "name": "lineno",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "195",
  "column": "12",
  "slicing": "['_ContainerSpec = Mapping[Type[ast.AST], Sequence[str]]\\n', '            parent = nodes.get_parent(node) or node\\n', '            self.add_violation(MultipleIfsInComprehensionViolation(parent))\\n', '        parent = nodes.get_parent(node)\\n', '        self._fors[parent] = len(parent.generators)  # type: ignore\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Yield):  # pragma: py-gte-38\\n', '        for node, for_count in self._fors.items():\\n', '            if for_count > self._max_fors:\\n', '                self.add_violation(TooManyForsInComprehensionViolation(node))\\n', '    _containers: ClassVar[_ContainerSpec] = {\\n', '        self._check_lambda_inside_loop(node)\\n', '        self.generic_visit(node)\\n', '        self._check_loop_needs_else(node)\\n', '        self._check_lambda_inside_loop(node)\\n', '        self._check_useless_continue(node)\\n', '        self._check_multiline_loop(node)\\n', '        self._check_infinite_while_loop(node)\\n', '        self.generic_visit(node)\\n', '        if node.orelse and not loops.has_break(node, break_nodes=(ast.Break,)):\\n', '            self.add_violation(UselessLoopElseViolation(node))\\n', '        for lambda_node in walk.get_subnodes_by_type(node, ast.Lambda):\\n', '            arguments = (\\n', '                arg.arg for arg\\n', '                in walk.get_subnodes_by_type(lambda_node, ast.arg)\\n', '            body = (\\n', '                subnode.id for subnode\\n', '                in walk.get_subnodes_by_type(lambda_node.body, ast.Name)\\n', '            if not all(symbol in arguments for symbol in body):\\n', '                self.add_violation(LambdaInsideLoopViolation(node))\\n', '        nodes_at_line: DefaultDict[int, List[ast.AST]] = defaultdict(list)\\n', '        for sub_node in ast.walk(node):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno is not None:\\n', '                nodes_at_line[lineno].append(sub_node)\\n', '        last_line = nodes_at_line[sorted(nodes_at_line.keys())[-1]]\\n', '        if any(isinstance(last, ast.Continue) for last in last_line):\\n', '            self.add_violation(UselessContinueViolation(node))\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '        if isinstance(node, ast.While):\\n', '            node_to_check = node.test\\n', '            node_to_check = node.iter\\n', '        for sub_node in ast.walk(node_to_check):\\n', \"            sub_lineno = getattr(sub_node, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n', '                self.add_violation(MultilineLoopViolation(node))\\n', '        if not isinstance(node, ast.While):\\n', '        real_node = operators.unwrap_unary_node(node.test)\\n', '        if isinstance(real_node, ast.NameConstant) and real_node.value is True:\\n', '            if not loops.has_break(node, break_nodes=self._breaks):\\n', '                self.add_violation(InfiniteWhileLoopViolation(node))\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self._check_implicit_sum(node)\\n', '        self._check_implicit_yield_from(node)\\n', '        self.generic_visit(node)\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self.generic_visit(node)\\n', '        if not is_valid_block_variable_definition(node):\\n', '            self.add_violation(LoopVariableDefinitionViolation(node))\\n', '        node_iter = operators.unwrap_unary_node(node.iter)\\n', '        is_wrong = isinstance(node_iter, self._forbidden_for_iters)\\n', '        is_empty = isinstance(node_iter, ast.Tuple) and not node_iter.elts\\n', '        if is_wrong or is_empty:\\n', '            self.add_violation(WrongLoopIterTypeViolation(node_iter))\\n', '        is_implicit_sum = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.AugAssign) and\\n', '            isinstance(node.body[0].op, ast.Add) and\\n', '            isinstance(node.body[0].target, ast.Name)\\n', '        if is_implicit_sum:\\n', '            self.add_violation(ImplicitSumViolation(node))\\n', '        if isinstance(nodes.get_context(node), ast.AsyncFunctionDef):\\n', '        is_implicit_yield_from = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.Expr) and\\n', '            isinstance(node.body[0].value, ast.Yield)\\n', '        if is_implicit_yield_from:\\n', '            self.add_violation(ImplicitYieldFromViolation(node))\\n', '        self._check_implicit_items(node)\\n', '        self.generic_visit(node)\\n', '        iterable = source.node_to_string(node.iter)\\n', '        target = source.node_to_string(node.target)\\n', '        for sub in ast.walk(node):\\n', '            has_violation = (\\n', '                isinstance(sub, ast.Subscript) and\\n', '                not self._is_assigned_target(sub) and\\n', '                slices.is_same_slice(iterable, target, sub)\\n', '            if has_violation:\\n', '                self.add_violation(ImplicitItemsIteratorViolation(node))\\n', '        parent = nodes.get_parent(node)\\n', '        if not isinstance(parent, (*AssignNodes, ast.AugAssign)):\\n', '        return any(node == target for target in get_assign_targets(parent))\\n']",
  "context": "      for sub_node in ast.walk(node):\n            lineno = getattr(sub_node, 'lineno', None)\n            if lineno is not None:\n               "
 },
 "2363": {
  "name": "last_line",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "199",
  "column": "8",
  "slicing": "['_ContainerSpec = Mapping[Type[ast.AST], Sequence[str]]\\n', '            parent = nodes.get_parent(node) or node\\n', '            self.add_violation(MultipleIfsInComprehensionViolation(parent))\\n', '        parent = nodes.get_parent(node)\\n', '        self._fors[parent] = len(parent.generators)  # type: ignore\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Yield):  # pragma: py-gte-38\\n', '        for node, for_count in self._fors.items():\\n', '            if for_count > self._max_fors:\\n', '                self.add_violation(TooManyForsInComprehensionViolation(node))\\n', '    _containers: ClassVar[_ContainerSpec] = {\\n', '        self._check_lambda_inside_loop(node)\\n', '        self.generic_visit(node)\\n', '        self._check_loop_needs_else(node)\\n', '        self._check_lambda_inside_loop(node)\\n', '        self._check_useless_continue(node)\\n', '        self._check_multiline_loop(node)\\n', '        self._check_infinite_while_loop(node)\\n', '        self.generic_visit(node)\\n', '        if node.orelse and not loops.has_break(node, break_nodes=(ast.Break,)):\\n', '            self.add_violation(UselessLoopElseViolation(node))\\n', '        for lambda_node in walk.get_subnodes_by_type(node, ast.Lambda):\\n', '            arguments = (\\n', '                arg.arg for arg\\n', '                in walk.get_subnodes_by_type(lambda_node, ast.arg)\\n', '            body = (\\n', '                subnode.id for subnode\\n', '                in walk.get_subnodes_by_type(lambda_node.body, ast.Name)\\n', '            if not all(symbol in arguments for symbol in body):\\n', '                self.add_violation(LambdaInsideLoopViolation(node))\\n', '        nodes_at_line: DefaultDict[int, List[ast.AST]] = defaultdict(list)\\n', '        for sub_node in ast.walk(node):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno is not None:\\n', '                nodes_at_line[lineno].append(sub_node)\\n', '        last_line = nodes_at_line[sorted(nodes_at_line.keys())[-1]]\\n', '        if any(isinstance(last, ast.Continue) for last in last_line):\\n', '            self.add_violation(UselessContinueViolation(node))\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '        if isinstance(node, ast.While):\\n', '            node_to_check = node.test\\n', '            node_to_check = node.iter\\n', '        for sub_node in ast.walk(node_to_check):\\n', \"            sub_lineno = getattr(sub_node, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n', '                self.add_violation(MultilineLoopViolation(node))\\n', '        if not isinstance(node, ast.While):\\n', '        real_node = operators.unwrap_unary_node(node.test)\\n', '        if isinstance(real_node, ast.NameConstant) and real_node.value is True:\\n', '            if not loops.has_break(node, break_nodes=self._breaks):\\n', '                self.add_violation(InfiniteWhileLoopViolation(node))\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self._check_implicit_sum(node)\\n', '        self._check_implicit_yield_from(node)\\n', '        self.generic_visit(node)\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self.generic_visit(node)\\n', '        if not is_valid_block_variable_definition(node):\\n', '            self.add_violation(LoopVariableDefinitionViolation(node))\\n', '        node_iter = operators.unwrap_unary_node(node.iter)\\n', '        is_wrong = isinstance(node_iter, self._forbidden_for_iters)\\n', '        is_empty = isinstance(node_iter, ast.Tuple) and not node_iter.elts\\n', '        if is_wrong or is_empty:\\n', '            self.add_violation(WrongLoopIterTypeViolation(node_iter))\\n', '        is_implicit_sum = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.AugAssign) and\\n', '            isinstance(node.body[0].op, ast.Add) and\\n', '            isinstance(node.body[0].target, ast.Name)\\n', '        if is_implicit_sum:\\n', '            self.add_violation(ImplicitSumViolation(node))\\n', '        if isinstance(nodes.get_context(node), ast.AsyncFunctionDef):\\n', '        is_implicit_yield_from = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.Expr) and\\n', '            isinstance(node.body[0].value, ast.Yield)\\n', '        if is_implicit_yield_from:\\n', '            self.add_violation(ImplicitYieldFromViolation(node))\\n', '        self._check_implicit_items(node)\\n', '        self.generic_visit(node)\\n', '        iterable = source.node_to_string(node.iter)\\n', '        target = source.node_to_string(node.target)\\n', '        for sub in ast.walk(node):\\n', '            has_violation = (\\n', '                isinstance(sub, ast.Subscript) and\\n', '                not self._is_assigned_target(sub) and\\n', '                slices.is_same_slice(iterable, target, sub)\\n', '            if has_violation:\\n', '                self.add_violation(ImplicitItemsIteratorViolation(node))\\n', '        parent = nodes.get_parent(node)\\n', '        if not isinstance(parent, (*AssignNodes, ast.AugAssign)):\\n', '        return any(node == target for target in get_assign_targets(parent))\\n']",
  "context": "  nodes_at_line[lineno].append(sub_node)\n\n        last_line = nodes_at_line[sorted(nodes_at_line.keys())[-1]]\n        if any(isinstance(last, ast.Continue) for "
 },
 "2364": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyLoop",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "203",
  "column": "36",
  "slicing": "['    def _check_multiline_loop(self, node: AnyLoop) -> None:\\n']",
  "context": "ation(node))\n\n    def _check_multiline_loop(self, node: AnyLoop) -> None:\n        start_lineno = getattr(node, 'lineno', Non"
 },
 "2365": {
  "name": "start_lineno",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "204",
  "column": "8",
  "slicing": "['_ContainerSpec = Mapping[Type[ast.AST], Sequence[str]]\\n', '            parent = nodes.get_parent(node) or node\\n', '            self.add_violation(MultipleIfsInComprehensionViolation(parent))\\n', '        parent = nodes.get_parent(node)\\n', '        self._fors[parent] = len(parent.generators)  # type: ignore\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Yield):  # pragma: py-gte-38\\n', '        for node, for_count in self._fors.items():\\n', '            if for_count > self._max_fors:\\n', '                self.add_violation(TooManyForsInComprehensionViolation(node))\\n', '    _containers: ClassVar[_ContainerSpec] = {\\n', '        self._check_lambda_inside_loop(node)\\n', '        self.generic_visit(node)\\n', '        self._check_loop_needs_else(node)\\n', '        self._check_lambda_inside_loop(node)\\n', '        self._check_useless_continue(node)\\n', '        self._check_multiline_loop(node)\\n', '        self._check_infinite_while_loop(node)\\n', '        self.generic_visit(node)\\n', '        if node.orelse and not loops.has_break(node, break_nodes=(ast.Break,)):\\n', '            self.add_violation(UselessLoopElseViolation(node))\\n', '        for lambda_node in walk.get_subnodes_by_type(node, ast.Lambda):\\n', '            arguments = (\\n', '                arg.arg for arg\\n', '                in walk.get_subnodes_by_type(lambda_node, ast.arg)\\n', '            body = (\\n', '                subnode.id for subnode\\n', '                in walk.get_subnodes_by_type(lambda_node.body, ast.Name)\\n', '            if not all(symbol in arguments for symbol in body):\\n', '                self.add_violation(LambdaInsideLoopViolation(node))\\n', '        nodes_at_line: DefaultDict[int, List[ast.AST]] = defaultdict(list)\\n', '        for sub_node in ast.walk(node):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno is not None:\\n', '                nodes_at_line[lineno].append(sub_node)\\n', '        last_line = nodes_at_line[sorted(nodes_at_line.keys())[-1]]\\n', '        if any(isinstance(last, ast.Continue) for last in last_line):\\n', '            self.add_violation(UselessContinueViolation(node))\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '        if isinstance(node, ast.While):\\n', '            node_to_check = node.test\\n', '            node_to_check = node.iter\\n', '        for sub_node in ast.walk(node_to_check):\\n', \"            sub_lineno = getattr(sub_node, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n', '                self.add_violation(MultilineLoopViolation(node))\\n', '        if not isinstance(node, ast.While):\\n', '        real_node = operators.unwrap_unary_node(node.test)\\n', '        if isinstance(real_node, ast.NameConstant) and real_node.value is True:\\n', '            if not loops.has_break(node, break_nodes=self._breaks):\\n', '                self.add_violation(InfiniteWhileLoopViolation(node))\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self._check_implicit_sum(node)\\n', '        self._check_implicit_yield_from(node)\\n', '        self.generic_visit(node)\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self.generic_visit(node)\\n', '        if not is_valid_block_variable_definition(node):\\n', '            self.add_violation(LoopVariableDefinitionViolation(node))\\n', '        node_iter = operators.unwrap_unary_node(node.iter)\\n', '        is_wrong = isinstance(node_iter, self._forbidden_for_iters)\\n', '        is_empty = isinstance(node_iter, ast.Tuple) and not node_iter.elts\\n', '        if is_wrong or is_empty:\\n', '            self.add_violation(WrongLoopIterTypeViolation(node_iter))\\n', '        is_implicit_sum = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.AugAssign) and\\n', '            isinstance(node.body[0].op, ast.Add) and\\n', '            isinstance(node.body[0].target, ast.Name)\\n', '        if is_implicit_sum:\\n', '            self.add_violation(ImplicitSumViolation(node))\\n', '        if isinstance(nodes.get_context(node), ast.AsyncFunctionDef):\\n', '        is_implicit_yield_from = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.Expr) and\\n', '            isinstance(node.body[0].value, ast.Yield)\\n', '        if is_implicit_yield_from:\\n', '            self.add_violation(ImplicitYieldFromViolation(node))\\n', '        self._check_implicit_items(node)\\n', '        self.generic_visit(node)\\n', '        iterable = source.node_to_string(node.iter)\\n', '        target = source.node_to_string(node.target)\\n', '        for sub in ast.walk(node):\\n', '            has_violation = (\\n', '                isinstance(sub, ast.Subscript) and\\n', '                not self._is_assigned_target(sub) and\\n', '                slices.is_same_slice(iterable, target, sub)\\n', '            if has_violation:\\n', '                self.add_violation(ImplicitItemsIteratorViolation(node))\\n', '        parent = nodes.get_parent(node)\\n', '        if not isinstance(parent, (*AssignNodes, ast.AugAssign)):\\n', '        return any(node == target for target in get_assign_targets(parent))\\n']",
  "context": "tiline_loop(self, node: AnyLoop) -> None:\n        start_lineno = getattr(node, 'lineno', None)\n\n        if isinstance(node, ast.While):\n         "
 },
 "2366": {
  "name": "sub_lineno",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "212",
  "column": "12",
  "slicing": "['_ContainerSpec = Mapping[Type[ast.AST], Sequence[str]]\\n', '            parent = nodes.get_parent(node) or node\\n', '            self.add_violation(MultipleIfsInComprehensionViolation(parent))\\n', '        parent = nodes.get_parent(node)\\n', '        self._fors[parent] = len(parent.generators)  # type: ignore\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Yield):  # pragma: py-gte-38\\n', '        for node, for_count in self._fors.items():\\n', '            if for_count > self._max_fors:\\n', '                self.add_violation(TooManyForsInComprehensionViolation(node))\\n', '    _containers: ClassVar[_ContainerSpec] = {\\n', '        self._check_lambda_inside_loop(node)\\n', '        self.generic_visit(node)\\n', '        self._check_loop_needs_else(node)\\n', '        self._check_lambda_inside_loop(node)\\n', '        self._check_useless_continue(node)\\n', '        self._check_multiline_loop(node)\\n', '        self._check_infinite_while_loop(node)\\n', '        self.generic_visit(node)\\n', '        if node.orelse and not loops.has_break(node, break_nodes=(ast.Break,)):\\n', '            self.add_violation(UselessLoopElseViolation(node))\\n', '        for lambda_node in walk.get_subnodes_by_type(node, ast.Lambda):\\n', '            arguments = (\\n', '                arg.arg for arg\\n', '                in walk.get_subnodes_by_type(lambda_node, ast.arg)\\n', '            body = (\\n', '                subnode.id for subnode\\n', '                in walk.get_subnodes_by_type(lambda_node.body, ast.Name)\\n', '            if not all(symbol in arguments for symbol in body):\\n', '                self.add_violation(LambdaInsideLoopViolation(node))\\n', '        nodes_at_line: DefaultDict[int, List[ast.AST]] = defaultdict(list)\\n', '        for sub_node in ast.walk(node):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno is not None:\\n', '                nodes_at_line[lineno].append(sub_node)\\n', '        last_line = nodes_at_line[sorted(nodes_at_line.keys())[-1]]\\n', '        if any(isinstance(last, ast.Continue) for last in last_line):\\n', '            self.add_violation(UselessContinueViolation(node))\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '        if isinstance(node, ast.While):\\n', '            node_to_check = node.test\\n', '            node_to_check = node.iter\\n', '        for sub_node in ast.walk(node_to_check):\\n', \"            sub_lineno = getattr(sub_node, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n', '                self.add_violation(MultilineLoopViolation(node))\\n', '        if not isinstance(node, ast.While):\\n', '        real_node = operators.unwrap_unary_node(node.test)\\n', '        if isinstance(real_node, ast.NameConstant) and real_node.value is True:\\n', '            if not loops.has_break(node, break_nodes=self._breaks):\\n', '                self.add_violation(InfiniteWhileLoopViolation(node))\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self._check_implicit_sum(node)\\n', '        self._check_implicit_yield_from(node)\\n', '        self.generic_visit(node)\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self.generic_visit(node)\\n', '        if not is_valid_block_variable_definition(node):\\n', '            self.add_violation(LoopVariableDefinitionViolation(node))\\n', '        node_iter = operators.unwrap_unary_node(node.iter)\\n', '        is_wrong = isinstance(node_iter, self._forbidden_for_iters)\\n', '        is_empty = isinstance(node_iter, ast.Tuple) and not node_iter.elts\\n', '        if is_wrong or is_empty:\\n', '            self.add_violation(WrongLoopIterTypeViolation(node_iter))\\n', '        is_implicit_sum = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.AugAssign) and\\n', '            isinstance(node.body[0].op, ast.Add) and\\n', '            isinstance(node.body[0].target, ast.Name)\\n', '        if is_implicit_sum:\\n', '            self.add_violation(ImplicitSumViolation(node))\\n', '        if isinstance(nodes.get_context(node), ast.AsyncFunctionDef):\\n', '        is_implicit_yield_from = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.Expr) and\\n', '            isinstance(node.body[0].value, ast.Yield)\\n', '        if is_implicit_yield_from:\\n', '            self.add_violation(ImplicitYieldFromViolation(node))\\n', '        self._check_implicit_items(node)\\n', '        self.generic_visit(node)\\n', '        iterable = source.node_to_string(node.iter)\\n', '        target = source.node_to_string(node.target)\\n', '        for sub in ast.walk(node):\\n', '            has_violation = (\\n', '                isinstance(sub, ast.Subscript) and\\n', '                not self._is_assigned_target(sub) and\\n', '                slices.is_same_slice(iterable, target, sub)\\n', '            if has_violation:\\n', '                self.add_violation(ImplicitItemsIteratorViolation(node))\\n', '        parent = nodes.get_parent(node)\\n', '        if not isinstance(parent, (*AssignNodes, ast.AugAssign)):\\n', '        return any(node == target for target in get_assign_targets(parent))\\n']",
  "context": " sub_node in ast.walk(node_to_check):\n            sub_lineno = getattr(sub_node, 'lineno', None)\n            if sub_lineno is not None and sub_line"
 },
 "2367": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyLoop",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "217",
  "column": "41",
  "slicing": "['    def _check_infinite_while_loop(self, node: AnyLoop) -> None:\\n']",
  "context": "  break\n\n    def _check_infinite_while_loop(self, node: AnyLoop) -> None:\n        if not isinstance(node, ast.While):\n      "
 },
 "2368": {
  "name": "_forbidden_for_iters",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "235",
  "column": "4",
  "slicing": "['    _forbidden_for_iters: ClassVar[AnyNodes] = (\\n']",
  "context": "r`` loops and comprehensions definitions.\"\"\"\n\n    _forbidden_for_iters: ClassVar[AnyNodes] = (\n        ast.List,\n        ast.ListComp,\n        as"
 },
 "2369": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFor",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "247",
  "column": "28",
  "slicing": "['    def visit_any_for(self, node: AnyFor) -> None:\\n']",
  "context": ".NameConstant,\n    )\n\n    def visit_any_for(self, node: AnyFor) -> None:\n        \"\"\"\n        Ensures that ``for`` loop defi"
 },
 "2370": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "281",
  "column": "8",
  "slicing": "['        node: Union[AnyFor, ast.comprehension],\\n']",
  "context": " _check_explicit_iter_type(\n        self,\n        node: Union[AnyFor, ast.comprehension],\n    ) -> None:\n        node_iter = operators.unwra"
 },
 "2371": {
  "name": "is_wrong",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "284",
  "column": "8",
  "slicing": "['_ContainerSpec = Mapping[Type[ast.AST], Sequence[str]]\\n', '            parent = nodes.get_parent(node) or node\\n', '            self.add_violation(MultipleIfsInComprehensionViolation(parent))\\n', '        parent = nodes.get_parent(node)\\n', '        self._fors[parent] = len(parent.generators)  # type: ignore\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Yield):  # pragma: py-gte-38\\n', '        for node, for_count in self._fors.items():\\n', '            if for_count > self._max_fors:\\n', '                self.add_violation(TooManyForsInComprehensionViolation(node))\\n', '    _containers: ClassVar[_ContainerSpec] = {\\n', '        self._check_lambda_inside_loop(node)\\n', '        self.generic_visit(node)\\n', '        self._check_loop_needs_else(node)\\n', '        self._check_lambda_inside_loop(node)\\n', '        self._check_useless_continue(node)\\n', '        self._check_multiline_loop(node)\\n', '        self._check_infinite_while_loop(node)\\n', '        self.generic_visit(node)\\n', '        if node.orelse and not loops.has_break(node, break_nodes=(ast.Break,)):\\n', '            self.add_violation(UselessLoopElseViolation(node))\\n', '        for lambda_node in walk.get_subnodes_by_type(node, ast.Lambda):\\n', '            arguments = (\\n', '                arg.arg for arg\\n', '                in walk.get_subnodes_by_type(lambda_node, ast.arg)\\n', '            body = (\\n', '                subnode.id for subnode\\n', '                in walk.get_subnodes_by_type(lambda_node.body, ast.Name)\\n', '            if not all(symbol in arguments for symbol in body):\\n', '                self.add_violation(LambdaInsideLoopViolation(node))\\n', '        nodes_at_line: DefaultDict[int, List[ast.AST]] = defaultdict(list)\\n', '        for sub_node in ast.walk(node):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno is not None:\\n', '                nodes_at_line[lineno].append(sub_node)\\n', '        last_line = nodes_at_line[sorted(nodes_at_line.keys())[-1]]\\n', '        if any(isinstance(last, ast.Continue) for last in last_line):\\n', '            self.add_violation(UselessContinueViolation(node))\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '        if isinstance(node, ast.While):\\n', '            node_to_check = node.test\\n', '            node_to_check = node.iter\\n', '        for sub_node in ast.walk(node_to_check):\\n', \"            sub_lineno = getattr(sub_node, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n', '                self.add_violation(MultilineLoopViolation(node))\\n', '        if not isinstance(node, ast.While):\\n', '        real_node = operators.unwrap_unary_node(node.test)\\n', '        if isinstance(real_node, ast.NameConstant) and real_node.value is True:\\n', '            if not loops.has_break(node, break_nodes=self._breaks):\\n', '                self.add_violation(InfiniteWhileLoopViolation(node))\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self._check_implicit_sum(node)\\n', '        self._check_implicit_yield_from(node)\\n', '        self.generic_visit(node)\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self.generic_visit(node)\\n', '        if not is_valid_block_variable_definition(node):\\n', '            self.add_violation(LoopVariableDefinitionViolation(node))\\n', '        node_iter = operators.unwrap_unary_node(node.iter)\\n', '        is_wrong = isinstance(node_iter, self._forbidden_for_iters)\\n', '        is_empty = isinstance(node_iter, ast.Tuple) and not node_iter.elts\\n', '        if is_wrong or is_empty:\\n', '            self.add_violation(WrongLoopIterTypeViolation(node_iter))\\n', '        is_implicit_sum = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.AugAssign) and\\n', '            isinstance(node.body[0].op, ast.Add) and\\n', '            isinstance(node.body[0].target, ast.Name)\\n', '        if is_implicit_sum:\\n', '            self.add_violation(ImplicitSumViolation(node))\\n', '        if isinstance(nodes.get_context(node), ast.AsyncFunctionDef):\\n', '        is_implicit_yield_from = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.Expr) and\\n', '            isinstance(node.body[0].value, ast.Yield)\\n', '        if is_implicit_yield_from:\\n', '            self.add_violation(ImplicitYieldFromViolation(node))\\n', '        self._check_implicit_items(node)\\n', '        self.generic_visit(node)\\n', '        iterable = source.node_to_string(node.iter)\\n', '        target = source.node_to_string(node.target)\\n', '        for sub in ast.walk(node):\\n', '            has_violation = (\\n', '                isinstance(sub, ast.Subscript) and\\n', '                not self._is_assigned_target(sub) and\\n', '                slices.is_same_slice(iterable, target, sub)\\n', '            if has_violation:\\n', '                self.add_violation(ImplicitItemsIteratorViolation(node))\\n', '        parent = nodes.get_parent(node)\\n', '        if not isinstance(parent, (*AssignNodes, ast.AugAssign)):\\n', '        return any(node == target for target in get_assign_targets(parent))\\n']",
  "context": " = operators.unwrap_unary_node(node.iter)\n        is_wrong = isinstance(node_iter, self._forbidden_for_iters)\n        is_empty = isinstance(node_iter, ast.Tuple"
 },
 "2372": {
  "name": "is_empty",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "285",
  "column": "8",
  "slicing": "['_ContainerSpec = Mapping[Type[ast.AST], Sequence[str]]\\n', '            parent = nodes.get_parent(node) or node\\n', '            self.add_violation(MultipleIfsInComprehensionViolation(parent))\\n', '        parent = nodes.get_parent(node)\\n', '        self._fors[parent] = len(parent.generators)  # type: ignore\\n', '        for sub_node in ast.walk(node):\\n', '            if isinstance(sub_node, ast.Yield):  # pragma: py-gte-38\\n', '        for node, for_count in self._fors.items():\\n', '            if for_count > self._max_fors:\\n', '                self.add_violation(TooManyForsInComprehensionViolation(node))\\n', '    _containers: ClassVar[_ContainerSpec] = {\\n', '        self._check_lambda_inside_loop(node)\\n', '        self.generic_visit(node)\\n', '        self._check_loop_needs_else(node)\\n', '        self._check_lambda_inside_loop(node)\\n', '        self._check_useless_continue(node)\\n', '        self._check_multiline_loop(node)\\n', '        self._check_infinite_while_loop(node)\\n', '        self.generic_visit(node)\\n', '        if node.orelse and not loops.has_break(node, break_nodes=(ast.Break,)):\\n', '            self.add_violation(UselessLoopElseViolation(node))\\n', '        for lambda_node in walk.get_subnodes_by_type(node, ast.Lambda):\\n', '            arguments = (\\n', '                arg.arg for arg\\n', '                in walk.get_subnodes_by_type(lambda_node, ast.arg)\\n', '            body = (\\n', '                subnode.id for subnode\\n', '                in walk.get_subnodes_by_type(lambda_node.body, ast.Name)\\n', '            if not all(symbol in arguments for symbol in body):\\n', '                self.add_violation(LambdaInsideLoopViolation(node))\\n', '        nodes_at_line: DefaultDict[int, List[ast.AST]] = defaultdict(list)\\n', '        for sub_node in ast.walk(node):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno is not None:\\n', '                nodes_at_line[lineno].append(sub_node)\\n', '        last_line = nodes_at_line[sorted(nodes_at_line.keys())[-1]]\\n', '        if any(isinstance(last, ast.Continue) for last in last_line):\\n', '            self.add_violation(UselessContinueViolation(node))\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '        if isinstance(node, ast.While):\\n', '            node_to_check = node.test\\n', '            node_to_check = node.iter\\n', '        for sub_node in ast.walk(node_to_check):\\n', \"            sub_lineno = getattr(sub_node, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n', '                self.add_violation(MultilineLoopViolation(node))\\n', '        if not isinstance(node, ast.While):\\n', '        real_node = operators.unwrap_unary_node(node.test)\\n', '        if isinstance(real_node, ast.NameConstant) and real_node.value is True:\\n', '            if not loops.has_break(node, break_nodes=self._breaks):\\n', '                self.add_violation(InfiniteWhileLoopViolation(node))\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self._check_implicit_sum(node)\\n', '        self._check_implicit_yield_from(node)\\n', '        self.generic_visit(node)\\n', '        self._check_variable_definitions(node.target)\\n', '        self._check_explicit_iter_type(node)\\n', '        self.generic_visit(node)\\n', '        if not is_valid_block_variable_definition(node):\\n', '            self.add_violation(LoopVariableDefinitionViolation(node))\\n', '        node_iter = operators.unwrap_unary_node(node.iter)\\n', '        is_wrong = isinstance(node_iter, self._forbidden_for_iters)\\n', '        is_empty = isinstance(node_iter, ast.Tuple) and not node_iter.elts\\n', '        if is_wrong or is_empty:\\n', '            self.add_violation(WrongLoopIterTypeViolation(node_iter))\\n', '        is_implicit_sum = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.AugAssign) and\\n', '            isinstance(node.body[0].op, ast.Add) and\\n', '            isinstance(node.body[0].target, ast.Name)\\n', '        if is_implicit_sum:\\n', '            self.add_violation(ImplicitSumViolation(node))\\n', '        if isinstance(nodes.get_context(node), ast.AsyncFunctionDef):\\n', '        is_implicit_yield_from = (\\n', '            len(node.body) == 1 and\\n', '            isinstance(node.body[0], ast.Expr) and\\n', '            isinstance(node.body[0].value, ast.Yield)\\n', '        if is_implicit_yield_from:\\n', '            self.add_violation(ImplicitYieldFromViolation(node))\\n', '        self._check_implicit_items(node)\\n', '        self.generic_visit(node)\\n', '        iterable = source.node_to_string(node.iter)\\n', '        target = source.node_to_string(node.target)\\n', '        for sub in ast.walk(node):\\n', '            has_violation = (\\n', '                isinstance(sub, ast.Subscript) and\\n', '                not self._is_assigned_target(sub) and\\n', '                slices.is_same_slice(iterable, target, sub)\\n', '            if has_violation:\\n', '                self.add_violation(ImplicitItemsIteratorViolation(node))\\n', '        parent = nodes.get_parent(node)\\n', '        if not isinstance(parent, (*AssignNodes, ast.AugAssign)):\\n', '        return any(node == target for target in get_assign_targets(parent))\\n']",
  "context": "nce(node_iter, self._forbidden_for_iters)\n        is_empty = isinstance(node_iter, ast.Tuple) and not node_iter.elts\n        if is_wrong or is_empty:\n            self."
 },
 "2373": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFor",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "289",
  "column": "34",
  "slicing": "['    def _check_implicit_sum(self, node: AnyFor) -> None:\\n']",
  "context": "on(node_iter))\n\n    def _check_implicit_sum(self, node: AnyFor) -> None:\n        is_implicit_sum = (\n            len(node.b"
 },
 "2374": {
  "name": "is_implicit_sum",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "290",
  "column": "8",
  "slicing": "['        is_implicit_sum = (\\n', '        if is_implicit_sum:\\n']",
  "context": "implicit_sum(self, node: AnyFor) -> None:\n        is_implicit_sum = (\n            len(node.body) == 1 and\n            is"
 },
 "2375": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFor",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "299",
  "column": "41",
  "slicing": "['    def _check_implicit_yield_from(self, node: AnyFor) -> None:\\n']",
  "context": "(node))\n\n    def _check_implicit_yield_from(self, node: AnyFor) -> None:\n        if isinstance(nodes.get_context(node), ast"
 },
 "2376": {
  "name": "is_implicit_yield_from",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "304",
  "column": "8",
  "slicing": "['        is_implicit_yield_from = (\\n', '        if is_implicit_yield_from:\\n']",
  "context": "nside async functions\n            return\n\n        is_implicit_yield_from = (\n            len(node.body) == 1 and\n            is"
 },
 "2377": {
  "name": "has_violation",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/loops.py",
  "lineno": "333",
  "column": "12",
  "slicing": "['            has_violation = (\\n', '            if has_violation:\\n']",
  "context": ")\n\n        for sub in ast.walk(node):\n            has_violation = (\n                isinstance(sub, ast.Subscript) and"
 },
 "2378": {
  "name": "_StatementWithBody",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "43",
  "column": "0",
  "slicing": "['_StatementWithBody = Union[\\n', '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        node: _StatementWithBody,\\n']",
  "context": "as\n\n#: Statements that do have `.body` attribute.\n_StatementWithBody = Union[\n    ast.If,\n    AnyFor,\n    ast.While,\n    AnyWith"
 },
 "2379": {
  "name": "_AnyCollection",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "56",
  "column": "0",
  "slicing": "['_AnyCollection = Union[\\n', '    def visit_collection(self, node: _AnyCollection) -> None:\\n']",
  "context": "assDef,\n    ast.Module,\n]\n\n#: Simple collections.\n_AnyCollection = Union[\n    ast.List,\n    ast.Set,\n    ast.Dict,\n    ast.T"
 },
 "2380": {
  "name": "_closing_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['    _closing_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "atements that have multiline bodies.\n    \"\"\"\n\n    _closing_nodes: ClassVar[AnyNodes] = (\n        ast.Raise,\n        ast.Return,\n        ast"
 },
 "2381": {
  "name": "_have_doc_strings",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['    _have_doc_strings: ClassVar[AnyNodes] = (\\n']",
  "context": "      ast.Break,\n        ast.Continue,\n    )\n\n    _have_doc_strings: ClassVar[AnyNodes] = (\n        *FunctionNodes,\n        ast.ClassDef,\n    "
 },
 "2382": {
  "name": "_blocked_self_assignment",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "99",
  "column": "4",
  "slicing": "['    _blocked_self_assignment: ClassVar[AnyNodes] = (\\n']",
  "context": "     ast.ClassDef,\n        ast.Module,\n    )\n\n    _blocked_self_assignment: ClassVar[AnyNodes] = (\n        ast.BinOp,\n    )\n\n    _nodes_with_orelse ="
 },
 "2383": {
  "name": "_nodes_with_orelse",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "103",
  "column": "4",
  "slicing": "['    _nodes_with_orelse = (\\n']",
  "context": "ssVar[AnyNodes] = (\n        ast.BinOp,\n    )\n\n    _nodes_with_orelse = (\n        ast.If,\n        *ForNodes,\n        ast.Whi"
 },
 "2384": {
  "name": "_have_effect",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['    _have_effect: ClassVar[AnyNodes] = (\\n']",
  "context": "s,\n        ast.While,\n        ast.Try,\n    )\n\n    _have_effect: ClassVar[AnyNodes] = (\n        ast.Return,\n        ast.YieldFrom,\n       "
 },
 "2385": {
  "name": "_generally_useless_body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "131",
  "column": "4",
  "slicing": "['    _generally_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\"]",
  "context": "      ast.Assert,\n    )\n\n    # Useless nodes:\n    _generally_useless_body: ClassVar[AnyNodes] = (\n        ast.Break,\n        ast.Continue,\n        a"
 },
 "2386": {
  "name": "_loop_useless_body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "137",
  "column": "4",
  "slicing": "['    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\"]",
  "context": "        ast.Pass,\n        ast.Ellipsis,\n    )\n    _loop_useless_body: ClassVar[AnyNodes] = (\n        ast.Return,\n        ast.Raise,\n    )\n\n    "
 },
 "2387": {
  "name": "_useless_combination",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "142",
  "column": "4",
  "slicing": "['    _useless_combination: ClassVar[Mapping[str, AnyNodes]] = {\\n']",
  "context": "        ast.Return,\n        ast.Raise,\n    )\n\n    _useless_combination: ClassVar[Mapping[str, AnyNodes]] = {\n        'For': _generally_useless_body + _loop_use"
 },
 "2388": {
  "name": "node",
  "type": "_StatementWithBody",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "151",
  "column": "40",
  "slicing": "['    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n']",
  "context": "y,\n    }\n\n    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\n        \"\"\"\n        Visits statement's body intern"
 },
 "2389": {
  "name": "body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "172",
  "column": "8",
  "slicing": "['        body: Sequence[ast.stmt],\\n']",
  "context": "f _check_swapped_variables(\n        self,\n        body: Sequence[ast.stmt],\n    ) -> None:\n        for assigns in sequence_of_"
 },
 "2390": {
  "name": "assigns",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "177",
  "column": "30",
  "slicing": "['    def _almost_swapped(self, assigns: Sequence[ast.Assign]) -> None:\\n']",
  "context": "t_swapped(assigns)\n\n    def _almost_swapped(self, assigns: Sequence[ast.Assign]) -> None:\n        previous_var: Set[Optional[str]] = set()\n\n"
 },
 "2391": {
  "name": "previous_var",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "178",
  "column": "8",
  "slicing": "['_StatementWithBody = Union[\\n', '    _generally_useless_body: ClassVar[AnyNodes] = (\\n', '    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\", '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        for assigns in sequence_of_node((ast.Assign,), body):\\n', '            self._almost_swapped(assigns)\\n', '        previous_var: Set[Optional[str]] = set()\\n', '        for assign in assigns:\\n', '            current_var = {\\n', '                first(name_nodes.flat_variable_names([assign])),\\n', '                first(name_nodes.get_variables_from_node(assign.value)),\\n', '            if not all(map(bool, current_var)):\\n', '                previous_var.clear()\\n', '            if current_var == previous_var:\\n', '                self.add_violation(AlmostSwappedViolation(assign))\\n', '            if len(previous_var & current_var) == 1:\\n', '                current_var ^= previous_var\\n', '            previous_var = current_var\\n', '        node: _StatementWithBody,\\n']",
  "context": ", assigns: Sequence[ast.Assign]) -> None:\n        previous_var: Set[Optional[str]] = set()\n\n        for assign in assigns:\n            curren"
 },
 "2392": {
  "name": "current_var",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "181",
  "column": "12",
  "slicing": "['_StatementWithBody = Union[\\n', '    _generally_useless_body: ClassVar[AnyNodes] = (\\n', '    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\", '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        for assigns in sequence_of_node((ast.Assign,), body):\\n', '            self._almost_swapped(assigns)\\n', '        previous_var: Set[Optional[str]] = set()\\n', '        for assign in assigns:\\n', '            current_var = {\\n', '                first(name_nodes.flat_variable_names([assign])),\\n', '                first(name_nodes.get_variables_from_node(assign.value)),\\n', '            if not all(map(bool, current_var)):\\n', '                previous_var.clear()\\n', '            if current_var == previous_var:\\n', '                self.add_violation(AlmostSwappedViolation(assign))\\n', '            if len(previous_var & current_var) == 1:\\n', '                current_var ^= previous_var\\n', '            previous_var = current_var\\n', '        node: _StatementWithBody,\\n']",
  "context": "set()\n\n        for assign in assigns:\n            current_var = {\n                first(name_nodes.flat_variable_nam"
 },
 "2393": {
  "name": "current_var",
  "type": "previous_var",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "194",
  "column": "16",
  "slicing": "['_StatementWithBody = Union[\\n', '    _generally_useless_body: ClassVar[AnyNodes] = (\\n', '    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\", '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        for assigns in sequence_of_node((ast.Assign,), body):\\n', '            self._almost_swapped(assigns)\\n', '        previous_var: Set[Optional[str]] = set()\\n', '        for assign in assigns:\\n', '            current_var = {\\n', '                first(name_nodes.flat_variable_names([assign])),\\n', '                first(name_nodes.get_variables_from_node(assign.value)),\\n', '            if not all(map(bool, current_var)):\\n', '                previous_var.clear()\\n', '            if current_var == previous_var:\\n', '                self.add_violation(AlmostSwappedViolation(assign))\\n', '            if len(previous_var & current_var) == 1:\\n', '                current_var ^= previous_var\\n', '            previous_var = current_var\\n', '        node: _StatementWithBody,\\n']",
  "context": "previous_var & current_var) == 1:\n                current_var ^= previous_var\n\n            previous_var = current_var\n\n    def _"
 },
 "2394": {
  "name": "previous_var",
  "type": "current_var",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "196",
  "column": "12",
  "slicing": "['_StatementWithBody = Union[\\n', '    _generally_useless_body: ClassVar[AnyNodes] = (\\n', '    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\", '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        for assigns in sequence_of_node((ast.Assign,), body):\\n', '            self._almost_swapped(assigns)\\n', '        previous_var: Set[Optional[str]] = set()\\n', '        for assign in assigns:\\n', '            current_var = {\\n', '                first(name_nodes.flat_variable_names([assign])),\\n', '                first(name_nodes.get_variables_from_node(assign.value)),\\n', '            if not all(map(bool, current_var)):\\n', '                previous_var.clear()\\n', '            if current_var == previous_var:\\n', '                self.add_violation(AlmostSwappedViolation(assign))\\n', '            if len(previous_var & current_var) == 1:\\n', '                current_var ^= previous_var\\n', '            previous_var = current_var\\n', '        node: _StatementWithBody,\\n']",
  "context": "         current_var ^= previous_var\n\n            previous_var = current_var\n\n    def _check_useless_node(\n        self,\n      "
 },
 "2395": {
  "name": "node",
  "type": "_StatementWithBody",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "200",
  "column": "8",
  "slicing": "['        node: _StatementWithBody,\\n']",
  "context": "   def _check_useless_node(\n        self,\n        node: _StatementWithBody,\n        body: Sequence[ast.stmt],\n    ) -> None:\n "
 },
 "2396": {
  "name": "body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "201",
  "column": "8",
  "slicing": "['        body: Sequence[ast.stmt],\\n']",
  "context": "  self,\n        node: _StatementWithBody,\n        body: Sequence[ast.stmt],\n    ) -> None:\n        if len(body) != 1:\n        "
 },
 "2397": {
  "name": "is_first",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "222",
  "column": "8",
  "slicing": "['        is_first: bool = False,\\n']",
  "context": "on(\n        self,\n        node: ast.Expr,\n        is_first: bool = False,\n    ) -> None:\n        if isinstance(node.value, s"
 },
 "2398": {
  "name": "node_value",
  "type": "UnDefined",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "237",
  "column": "8",
  "slicing": "['        node_value: ast.expr\\n', '            if name_nodes.is_same_variable(node.target, node_value):\\n']",
  "context": "      node: ast.AugAssign,\n    ) -> None:\n        node_value: ast.expr\n        if isinstance(node.value, ast.BinOp):\n    "
 },
 "2399": {
  "name": "body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "245",
  "column": "31",
  "slicing": "['    def _check_internals(self, body: Sequence[ast.stmt]) -> None:\\n']",
  "context": "tViolation(node))\n\n    def _check_internals(self, body: Sequence[ast.stmt]) -> None:\n        after_closing_node = False\n        for ind"
 },
 "2400": {
  "name": "after_closing_node",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "246",
  "column": "8",
  "slicing": "['        after_closing_node = False\\n', '            if after_closing_node:\\n']",
  "context": "(self, body: Sequence[ast.stmt]) -> None:\n        after_closing_node = False\n        for index, statement in enumerate(body):\n "
 },
 "2401": {
  "name": "after_closing_node",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "252",
  "column": "16",
  "slicing": "['                after_closing_node = True\\n']",
  "context": "(statement, self._closing_nodes):\n                after_closing_node = True\n            elif isinstance(statement, ast.Expr):\n"
 },
 "2402": {
  "name": "node",
  "type": "_AnyCollection",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "273",
  "column": "31",
  "slicing": "['    def visit_collection(self, node: _AnyCollection) -> None:\\n']",
  "context": "low our rules.\"\"\"\n\n    def visit_collection(self, node: _AnyCollection) -> None:\n        \"\"\"Checks how collection items indentation"
 },
 "2403": {
  "name": "elements",
  "type": "wemake_python_styleguide.logic.tree.collections.normalize_dict_elements",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "276",
  "column": "12",
  "slicing": "['_StatementWithBody = Union[\\n', '_AnyCollection = Union[\\n', '    _generally_useless_body: ClassVar[AnyNodes] = (\\n', '    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\", '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        for assigns in sequence_of_node((ast.Assign,), body):\\n', '            self._almost_swapped(assigns)\\n', '        previous_var: Set[Optional[str]] = set()\\n', '        for assign in assigns:\\n', '            current_var = {\\n', '                first(name_nodes.flat_variable_names([assign])),\\n', '                first(name_nodes.get_variables_from_node(assign.value)),\\n', '            if not all(map(bool, current_var)):\\n', '                previous_var.clear()\\n', '            if current_var == previous_var:\\n', '                self.add_violation(AlmostSwappedViolation(assign))\\n', '            if len(previous_var & current_var) == 1:\\n', '                current_var ^= previous_var\\n', '            previous_var = current_var\\n', '        node: _StatementWithBody,\\n', '        forbidden = self._useless_combination.get(\\n', '        if not forbidden or not isinstance(body[0], forbidden):\\n', '        node_value: ast.expr\\n', '            node_value = node.value.left\\n', '            if name_nodes.is_same_variable(node.target, node_value):\\n', '        after_closing_node = False\\n', '        for index, statement in enumerate(body):\\n', '            if after_closing_node:\\n', '                self.add_violation(UnreachableCodeViolation(statement))\\n', '            if isinstance(statement, self._closing_nodes):\\n', '                after_closing_node = True\\n', '            elif isinstance(statement, ast.Expr):\\n', '                self._check_expression(statement, is_first=index == 0)\\n', '            elif isinstance(statement, ast.AugAssign):\\n', '                self._check_self_misrefactored_assignment(statement)\\n', '    def visit_collection(self, node: _AnyCollection) -> None:\\n', '            elements = normalize_dict_elements(node)\\n', '            elements = node.elts\\n', '        self._check_indentation(node, elements, extra_lines=1)\\n', '        all_args = call_args.get_all_args(node)\\n', '        self._check_indentation(node, all_args)\\n', '        all_args = [*node.bases, *[kw.value for kw in node.keywords]]\\n', '        self._check_indentation(node, all_args)\\n', '        if statement.lineno == node.lineno and not extra_lines:\\n', '        previous_has_break = previous_line != statement.lineno\\n', '        if not previous_has_break and multi_line_mode:\\n', '        elif previous_has_break and multi_line_mode is False:\\n', '        return previous_has_break\\n', '        for index, statement in enumerate(elements):\\n', '            if index == 0:\\n', '                    statement,\\n', '                    statement,\\n', '                    elements[index - 1].lineno,\\n', '        for arg in all_args:\\n', '            if isinstance(arg, self._no_tuples_collections):\\n']",
  "context": "       if isinstance(node, ast.Dict):\n            elements = normalize_dict_elements(node)\n        else:\n            elements = node.elts\n   "
 },
 "2404": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "288",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "ric_visit(node)\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"Checks function parameters indentation."
 },
 "2405": {
  "name": "all_args",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "295",
  "column": "8",
  "slicing": "['_StatementWithBody = Union[\\n', '_AnyCollection = Union[\\n', '    _generally_useless_body: ClassVar[AnyNodes] = (\\n', '    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\", '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        for assigns in sequence_of_node((ast.Assign,), body):\\n', '            self._almost_swapped(assigns)\\n', '        previous_var: Set[Optional[str]] = set()\\n', '        for assign in assigns:\\n', '            current_var = {\\n', '                first(name_nodes.flat_variable_names([assign])),\\n', '                first(name_nodes.get_variables_from_node(assign.value)),\\n', '            if not all(map(bool, current_var)):\\n', '                previous_var.clear()\\n', '            if current_var == previous_var:\\n', '                self.add_violation(AlmostSwappedViolation(assign))\\n', '            if len(previous_var & current_var) == 1:\\n', '                current_var ^= previous_var\\n', '            previous_var = current_var\\n', '        node: _StatementWithBody,\\n', '        forbidden = self._useless_combination.get(\\n', '        if not forbidden or not isinstance(body[0], forbidden):\\n', '        node_value: ast.expr\\n', '            node_value = node.value.left\\n', '            if name_nodes.is_same_variable(node.target, node_value):\\n', '        after_closing_node = False\\n', '        for index, statement in enumerate(body):\\n', '            if after_closing_node:\\n', '                self.add_violation(UnreachableCodeViolation(statement))\\n', '            if isinstance(statement, self._closing_nodes):\\n', '                after_closing_node = True\\n', '            elif isinstance(statement, ast.Expr):\\n', '                self._check_expression(statement, is_first=index == 0)\\n', '            elif isinstance(statement, ast.AugAssign):\\n', '                self._check_self_misrefactored_assignment(statement)\\n', '    def visit_collection(self, node: _AnyCollection) -> None:\\n', '            elements = normalize_dict_elements(node)\\n', '            elements = node.elts\\n', '        self._check_indentation(node, elements, extra_lines=1)\\n', '        all_args = call_args.get_all_args(node)\\n', '        self._check_indentation(node, all_args)\\n', '        all_args = [*node.bases, *[kw.value for kw in node.keywords]]\\n', '        self._check_indentation(node, all_args)\\n', '        if statement.lineno == node.lineno and not extra_lines:\\n', '        previous_has_break = previous_line != statement.lineno\\n', '        if not previous_has_break and multi_line_mode:\\n', '        elif previous_has_break and multi_line_mode is False:\\n', '        return previous_has_break\\n', '        for index, statement in enumerate(elements):\\n', '            if index == 0:\\n', '                    statement,\\n', '                    statement,\\n', '                    elements[index - 1].lineno,\\n', '        for arg in all_args:\\n', '            if isinstance(arg, self._no_tuples_collections):\\n']",
  "context": "   \"\"\"Checks base classes indentation.\"\"\"\n        all_args = [*node.bases, *[kw.value for kw in node.keywords]]\n        self._check_indentation(node, all_args)\n  "
 },
 "2406": {
  "name": "extra_lines",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "303",
  "column": "8",
  "slicing": "['        extra_lines: int,\\n']",
  "context": "ode: ast.AST,\n        statement: ast.AST,\n        extra_lines: int,\n    ) -> Optional[bool]:\n        if statement.line"
 },
 "2407": {
  "name": "previous_line",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "313",
  "column": "8",
  "slicing": "['        previous_line: int,\\n']",
  "context": "ode: ast.AST,\n        statement: ast.AST,\n        previous_line: int,\n        multi_line_mode: Optional[bool],\n    ) -> "
 },
 "2408": {
  "name": "multi_line_mode",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "314",
  "column": "8",
  "slicing": "['        multi_line_mode: Optional[bool],\\n']",
  "context": "ent: ast.AST,\n        previous_line: int,\n        multi_line_mode: Optional[bool],\n    ) -> Optional[bool]:\n        previous_has_brea"
 },
 "2409": {
  "name": "previous_has_break",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "316",
  "column": "8",
  "slicing": "['_StatementWithBody = Union[\\n', '_AnyCollection = Union[\\n', '    _generally_useless_body: ClassVar[AnyNodes] = (\\n', '    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\", '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        for assigns in sequence_of_node((ast.Assign,), body):\\n', '            self._almost_swapped(assigns)\\n', '        previous_var: Set[Optional[str]] = set()\\n', '        for assign in assigns:\\n', '            current_var = {\\n', '                first(name_nodes.flat_variable_names([assign])),\\n', '                first(name_nodes.get_variables_from_node(assign.value)),\\n', '            if not all(map(bool, current_var)):\\n', '                previous_var.clear()\\n', '            if current_var == previous_var:\\n', '                self.add_violation(AlmostSwappedViolation(assign))\\n', '            if len(previous_var & current_var) == 1:\\n', '                current_var ^= previous_var\\n', '            previous_var = current_var\\n', '        node: _StatementWithBody,\\n', '        forbidden = self._useless_combination.get(\\n', '        if not forbidden or not isinstance(body[0], forbidden):\\n', '        node_value: ast.expr\\n', '            node_value = node.value.left\\n', '            if name_nodes.is_same_variable(node.target, node_value):\\n', '        after_closing_node = False\\n', '        for index, statement in enumerate(body):\\n', '            if after_closing_node:\\n', '                self.add_violation(UnreachableCodeViolation(statement))\\n', '            if isinstance(statement, self._closing_nodes):\\n', '                after_closing_node = True\\n', '            elif isinstance(statement, ast.Expr):\\n', '                self._check_expression(statement, is_first=index == 0)\\n', '            elif isinstance(statement, ast.AugAssign):\\n', '                self._check_self_misrefactored_assignment(statement)\\n', '    def visit_collection(self, node: _AnyCollection) -> None:\\n', '            elements = normalize_dict_elements(node)\\n', '            elements = node.elts\\n', '        self._check_indentation(node, elements, extra_lines=1)\\n', '        all_args = call_args.get_all_args(node)\\n', '        self._check_indentation(node, all_args)\\n', '        all_args = [*node.bases, *[kw.value for kw in node.keywords]]\\n', '        self._check_indentation(node, all_args)\\n', '        if statement.lineno == node.lineno and not extra_lines:\\n', '        previous_has_break = previous_line != statement.lineno\\n', '        if not previous_has_break and multi_line_mode:\\n', '        elif previous_has_break and multi_line_mode is False:\\n', '        return previous_has_break\\n', '        for index, statement in enumerate(elements):\\n', '            if index == 0:\\n', '                    statement,\\n', '                    statement,\\n', '                    elements[index - 1].lineno,\\n', '        for arg in all_args:\\n', '            if isinstance(arg, self._no_tuples_collections):\\n']",
  "context": " Optional[bool],\n    ) -> Optional[bool]:\n        previous_has_break = previous_line != statement.lineno\n        if not previous_has_break and multi_line_m"
 },
 "2410": {
  "name": "elements",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "328",
  "column": "8",
  "slicing": "['        elements: Sequence[ast.AST],\\n']",
  "context": "ion(\n        self,\n        node: ast.AST,\n        elements: Sequence[ast.AST],\n        extra_lines: int = 0,  # we need it due to"
 },
 "2411": {
  "name": "extra_lines",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "329",
  "column": "8",
  "slicing": "['        extra_lines: int = 0,  # we need it due to wrong lineno in collections\\n']",
  "context": "AST,\n        elements: Sequence[ast.AST],\n        extra_lines: int = 0,  # we need it due to wrong lineno in collections\n    ) -> None:\n        multi_line_mode: Optional[b"
 },
 "2412": {
  "name": "multi_line_mode",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "331",
  "column": "8",
  "slicing": "['        multi_line_mode: Optional[bool] = None\\n', '                    multi_line_mode,\\n']",
  "context": "rong lineno in collections\n    ) -> None:\n        multi_line_mode: Optional[bool] = None\n        for index, statement in enumerate(elements"
 },
 "2413": {
  "name": "multi_line_mode",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "343",
  "column": "16",
  "slicing": "['_StatementWithBody = Union[\\n', '_AnyCollection = Union[\\n', '    _generally_useless_body: ClassVar[AnyNodes] = (\\n', '    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\", '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        for assigns in sequence_of_node((ast.Assign,), body):\\n', '            self._almost_swapped(assigns)\\n', '        previous_var: Set[Optional[str]] = set()\\n', '        for assign in assigns:\\n', '            current_var = {\\n', '                first(name_nodes.flat_variable_names([assign])),\\n', '                first(name_nodes.get_variables_from_node(assign.value)),\\n', '            if not all(map(bool, current_var)):\\n', '                previous_var.clear()\\n', '            if current_var == previous_var:\\n', '                self.add_violation(AlmostSwappedViolation(assign))\\n', '            if len(previous_var & current_var) == 1:\\n', '                current_var ^= previous_var\\n', '            previous_var = current_var\\n', '        node: _StatementWithBody,\\n', '        forbidden = self._useless_combination.get(\\n', '        if not forbidden or not isinstance(body[0], forbidden):\\n', '        node_value: ast.expr\\n', '            node_value = node.value.left\\n', '            if name_nodes.is_same_variable(node.target, node_value):\\n', '        after_closing_node = False\\n', '        for index, statement in enumerate(body):\\n', '            if after_closing_node:\\n', '                self.add_violation(UnreachableCodeViolation(statement))\\n', '            if isinstance(statement, self._closing_nodes):\\n', '                after_closing_node = True\\n', '            elif isinstance(statement, ast.Expr):\\n', '                self._check_expression(statement, is_first=index == 0)\\n', '            elif isinstance(statement, ast.AugAssign):\\n', '                self._check_self_misrefactored_assignment(statement)\\n', '    def visit_collection(self, node: _AnyCollection) -> None:\\n', '            elements = normalize_dict_elements(node)\\n', '            elements = node.elts\\n', '        self._check_indentation(node, elements, extra_lines=1)\\n', '        all_args = call_args.get_all_args(node)\\n', '        self._check_indentation(node, all_args)\\n', '        all_args = [*node.bases, *[kw.value for kw in node.keywords]]\\n', '        self._check_indentation(node, all_args)\\n', '        if statement.lineno == node.lineno and not extra_lines:\\n', '        previous_has_break = previous_line != statement.lineno\\n', '        if not previous_has_break and multi_line_mode:\\n', '        elif previous_has_break and multi_line_mode is False:\\n', '        return previous_has_break\\n', '        multi_line_mode: Optional[bool] = None\\n', '        for index, statement in enumerate(elements):\\n', '            if index == 0:\\n', '                multi_line_mode = self._check_first_element(\\n', '                    statement,\\n', '                multi_line_mode = self._check_rest_elements(\\n', '                    statement,\\n', '                    elements[index - 1].lineno,\\n', '                    multi_line_mode,\\n', '        for arg in all_args:\\n', '            if isinstance(arg, self._no_tuples_collections):\\n']",
  "context": "              )\n            else:\n                multi_line_mode = self._check_rest_elements(\n                    node,\n                    stat"
 },
 "2414": {
  "name": "_pointless_star_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "355",
  "column": "4",
  "slicing": "['    _pointless_star_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "r absence of useless starred expressions.\"\"\"\n\n    _pointless_star_nodes: ClassVar[AnyNodes] = (\n        ast.Dict,\n        ast.List,\n        ast.Se"
 },
 "2415": {
  "name": "args",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "370",
  "column": "8",
  "slicing": "['        args: Sequence[ast.AST],\\n']",
  "context": "   def _check_starred_args(\n        self,\n        args: Sequence[ast.AST],\n    ) -> None:\n        for node in args:\n         "
 },
 "2416": {
  "name": "keywords",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "379",
  "column": "8",
  "slicing": "['        keywords: Sequence[ast.keyword],\\n']",
  "context": "_check_double_starred_dict(\n        self,\n        keywords: Sequence[ast.keyword],\n    ) -> None:\n        for keyword in keywords:\n  "
 },
 "2417": {
  "name": "pointless_args",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "386",
  "column": "12",
  "slicing": "['_StatementWithBody = Union[\\n', '_AnyCollection = Union[\\n', '    _generally_useless_body: ClassVar[AnyNodes] = (\\n', '    _loop_useless_body: ClassVar[AnyNodes] = (\\n', \"        'For': _generally_useless_body + _loop_useless_body,\\n\", \"        'AsyncFor': _generally_useless_body + _loop_useless_body,\\n\", \"        'While': _generally_useless_body + _loop_useless_body,\\n\", \"        'Try': _generally_useless_body + (ast.Raise,),\\n\", \"        'With': _generally_useless_body,\\n\", \"        'AsyncWith': _generally_useless_body,\\n\", '    def visit_statement_with_body(self, node: _StatementWithBody) -> None:\\n', '        for assigns in sequence_of_node((ast.Assign,), body):\\n', '            self._almost_swapped(assigns)\\n', '        previous_var: Set[Optional[str]] = set()\\n', '        for assign in assigns:\\n', '            current_var = {\\n', '                first(name_nodes.flat_variable_names([assign])),\\n', '                first(name_nodes.get_variables_from_node(assign.value)),\\n', '            if not all(map(bool, current_var)):\\n', '                previous_var.clear()\\n', '            if current_var == previous_var:\\n', '                self.add_violation(AlmostSwappedViolation(assign))\\n', '            if len(previous_var & current_var) == 1:\\n', '                current_var ^= previous_var\\n', '            previous_var = current_var\\n', '        node: _StatementWithBody,\\n', '        forbidden = self._useless_combination.get(\\n', '        if not forbidden or not isinstance(body[0], forbidden):\\n', '        node_value: ast.expr\\n', '            node_value = node.value.left\\n', '            if name_nodes.is_same_variable(node.target, node_value):\\n', '        after_closing_node = False\\n', '        for index, statement in enumerate(body):\\n', '            if after_closing_node:\\n', '                self.add_violation(UnreachableCodeViolation(statement))\\n', '            if isinstance(statement, self._closing_nodes):\\n', '                after_closing_node = True\\n', '            elif isinstance(statement, ast.Expr):\\n', '                self._check_expression(statement, is_first=index == 0)\\n', '            elif isinstance(statement, ast.AugAssign):\\n', '                self._check_self_misrefactored_assignment(statement)\\n', '    def visit_collection(self, node: _AnyCollection) -> None:\\n', '            elements = normalize_dict_elements(node)\\n', '            elements = node.elts\\n', '        self._check_indentation(node, elements, extra_lines=1)\\n', '        all_args = call_args.get_all_args(node)\\n', '        self._check_indentation(node, all_args)\\n', '        all_args = [*node.bases, *[kw.value for kw in node.keywords]]\\n', '        self._check_indentation(node, all_args)\\n', '        if statement.lineno == node.lineno and not extra_lines:\\n', '        previous_has_break = previous_line != statement.lineno\\n', '        if not previous_has_break and multi_line_mode:\\n', '        elif previous_has_break and multi_line_mode is False:\\n', '        return previous_has_break\\n', '        multi_line_mode: Optional[bool] = None\\n', '        for index, statement in enumerate(elements):\\n', '            if index == 0:\\n', '                multi_line_mode = self._check_first_element(\\n', '                    statement,\\n', '                multi_line_mode = self._check_rest_elements(\\n', '                    statement,\\n', '                    elements[index - 1].lineno,\\n', '                    multi_line_mode,\\n', '        for node in args:\\n', '            if isinstance(node, ast.Starred):\\n', '                if self._is_pointless_star(node.value):\\n', '                    self.add_violation(PointlessStarredViolation(node))\\n', '        for keyword in keywords:\\n', '            if keyword.arg is not None:\\n', '            complex_keys = self._has_non_string_keys(keyword)\\n', '            pointless_args = self._is_pointless_star(keyword.value)\\n', '            if not complex_keys and pointless_args:\\n', '                self.add_violation(PointlessStarredViolation(keyword.value))\\n', '        return isinstance(node, self._pointless_star_nodes)\\n', '        if not isinstance(node.value, ast.Dict):\\n', '        for key_node in node.value.keys:\\n', '            if not isinstance(key_node, ast.Str):\\n', '        self._check_double_starred_dict(node.keywords)\\n', '        self.generic_visit(node)\\n', '        for keyword in keywords:\\n', '            if keyword.arg is not None:\\n', '            if self._has_wrong_keys(keyword):\\n', '                self.add_violation(WrongNamedKeywordViolation(keyword.value))\\n', '        if not isinstance(node.value, ast.Dict):\\n', '        for key_node in node.value.keys:\\n', '            if isinstance(key_node, ast.Str):\\n', '                if not str.isidentifier(key_node.s):\\n', '        self._check_augmented_assign_pattern(node)\\n', '        self.generic_visit(node)\\n', '        if not isinstance(node.value, ast.BinOp):\\n', '        is_checkable = (\\n', '            len(node.targets) == 1 and\\n', '            isinstance(node.value.right, ast.Name) and\\n', '            isinstance(node.value.left, ast.Name)\\n', '        if not is_checkable:\\n', '        if name_nodes.is_same_variable(node.targets[0], node.value.left):\\n', '            self.add_violation(AugmentedAssignPatternViolation(node))\\n', '        self._check_tuple_arguments_types(node)\\n', '        self.generic_visit(node)\\n', '        is_checkable = (\\n', '            isinstance(node.func, ast.Name) and\\n', '            node.func.id in constants.TUPLE_ARGUMENTS_METHODS\\n', '        if not is_checkable:\\n', '        all_args = call_args.get_all_args(node)\\n', '        for arg in all_args:\\n', '            if isinstance(arg, self._no_tuples_collections):\\n', '                self.add_violation(NotATupleArgumentViolation(node))\\n']",
  "context": " = self._has_non_string_keys(keyword)\n            pointless_args = self._is_pointless_star(keyword.value)\n            if not complex_keys and pointless_args"
 },
 "2418": {
  "name": "keywords",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "414",
  "column": "8",
  "slicing": "['        keywords: Sequence[ast.keyword],\\n']",
  "context": "_check_double_starred_dict(\n        self,\n        keywords: Sequence[ast.keyword],\n    ) -> None:\n        for keyword in keywords:\n  "
 },
 "2419": {
  "name": "is_checkable",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "450",
  "column": "8",
  "slicing": "['        is_checkable = (\\n', '        if not is_checkable:\\n', '        if not is_checkable:\\n']",
  "context": "de.value, ast.BinOp):\n            return\n\n        is_checkable = (\n            len(node.targets) == 1 and\n           "
 },
 "2420": {
  "name": "_no_tuples_collections",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "467",
  "column": "4",
  "slicing": "['    _no_tuples_collections: ClassVar[AnyNodes] = (\\n']",
  "context": "ures that all arguments follow our rules.\"\"\"\n\n    _no_tuples_collections: ClassVar[AnyNodes] = (\n        ast.List,\n        ast.ListComp,\n        as"
 },
 "2421": {
  "name": "is_checkable",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/statements.py",
  "lineno": "483",
  "column": "8",
  "slicing": "['        is_checkable = (\\n', '        if not is_checkable:\\n']",
  "context": "f,\n        node: ast.Call,\n    ) -> None:\n        is_checkable = (\n            isinstance(node.func, ast.Name) and\n  "
 },
 "2422": {
  "name": "lower_ok",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/subscripts.py",
  "lineno": "35",
  "column": "8",
  "slicing": "['        lower_ok = (\\n', '        if not (lower_ok and upper_ok and step_ok):\\n']",
  "context": "de.slice, ast.Slice):\n            return\n\n        lower_ok = (\n            node.slice.lower is None or (\n        "
 },
 "2423": {
  "name": "upper_ok",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/subscripts.py",
  "lineno": "42",
  "column": "8",
  "slicing": "['        upper_ok = (\\n', '        if not (lower_ok and upper_ok and step_ok):\\n']",
  "context": "ode.slice.lower)\n            )\n        )\n\n        upper_ok = (\n            node.slice.upper is None or\n          "
 },
 "2424": {
  "name": "step_ok",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/subscripts.py",
  "lineno": "47",
  "column": "8",
  "slicing": "['        step_ok = (\\n', '        if not (lower_ok and upper_ok and step_ok):\\n']",
  "context": "elf._is_none(node.slice.upper)\n        )\n\n        step_ok = (\n            node.slice.step is None or (\n         "
 },
 "2425": {
  "name": "node_slice",
  "type": "wemake_python_styleguide.compat.functions.get_slice_expr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/subscripts.py",
  "lineno": "128",
  "column": "8",
  "slicing": "['        lower_ok = (\\n', '        upper_ok = (\\n', '        step_ok = (\\n', '        if not (lower_ok and upper_ok and step_ok):\\n', '        checked_key = source.node_to_string(node.test.left)\\n', '        checked_collection = source.node_to_string(node.test.comparators[0])\\n', '        for sub in ast.walk(node):\\n', '            if not isinstance(sub, ast.Subscript):\\n', '            if slices.is_same_slice(checked_collection, checked_key, sub):\\n', '                self.add_violation(refactoring.ImplicitDictGetViolation(sub))\\n', '        node_slice = get_slice_expr(node)\\n', '            isinstance(node_slice, ast.BinOp) and\\n', '            isinstance(node_slice.op, ast.Sub) and\\n', '                node_slice,\\n']",
  "context": "_call(self, node: ast.Subscript) -> None:\n        node_slice = get_slice_expr(node)\n        is_len_call = (\n            isinstance(nod"
 },
 "2426": {
  "name": "is_len_call",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/subscripts.py",
  "lineno": "129",
  "column": "8",
  "slicing": "['        is_len_call = (\\n', '        if is_len_call:\\n']",
  "context": "        node_slice = get_slice_expr(node)\n        is_len_call = (\n            isinstance(node_slice, ast.BinOp) and\n"
 },
 "2427": {
  "name": "element",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/subscripts.py",
  "lineno": "143",
  "column": "45",
  "slicing": "['    def _is_wrong_len(self, node: ast.BinOp, element: str) -> bool:\\n']",
  "context": "  )\n\n    def _is_wrong_len(self, node: ast.BinOp, element: str) -> bool:\n        return (\n            isinstance(node.left,"
 },
 "2428": {
  "name": "_ReturningViolations",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "39",
  "column": "0",
  "slicing": "['_ReturningViolations = Union[\\n', '        violation: _ReturningViolations,\\n']",
  "context": "\n\n#: Utility type to work with violations easier.\n_ReturningViolations = Union[\n    Type[InconsistentReturnViolation],\n    Type[In"
 },
 "2429": {
  "name": "_base_exceptions",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['    _base_exceptions: ClassVar[FrozenSet[str]] = frozenset((\\n']",
  "context": "):\n    \"\"\"Finds wrong ``raise`` keywords.\"\"\"\n\n    _base_exceptions: ClassVar[FrozenSet[str]] = frozenset((\n        'Exception',\n        'BaseException',\n    "
 },
 "2430": {
  "name": "exception_name",
  "type": "wemake_python_styleguide.logic.tree.exceptions.get_exception_name",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "66",
  "column": "8",
  "slicing": "['        exception_name = get_exception_name(node)\\n', \"        if exception_name == 'NotImplemented':\\n\", '        elif exception_name in self._base_exceptions:\\n', '                BaseExceptionRaiseViolation(node, text=exception_name),\\n']",
  "context": "tion_type(self, node: ast.Raise) -> None:\n        exception_name = get_exception_name(node)\n        if exception_name == 'NotImplemented':\n   "
 },
 "2431": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "94",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "ric_visit(node)\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        Helper to get all ``return`` a"
 },
 "2432": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "108",
  "column": "8",
  "slicing": "['_ReturningViolations = Union[\\n', '        exception_name = get_exception_name(node)\\n', \"        if exception_name == 'NotImplemented':\\n\", '        elif exception_name in self._base_exceptions:\\n', '                BaseExceptionRaiseViolation(node, text=exception_name),\\n', '        parent = get_parent(node)\\n', '        if not isinstance(parent, FunctionNodes):\\n', '        returns = len(tuple(filter(\\n', '            walk.get_subnodes_by_type(parent, ast.Return),\\n', '        last_value_return = (\\n', '            len(parent.body) > 1 and\\n', '            returns < 2 and\\n', '        one_return_with_none = (\\n', '            returns == 1 and\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n', '        violation: _ReturningViolations,\\n', '        return_nodes, has_values = keywords.returning_nodes(\\n', '        for return_node in return_nodes:\\n', '            if not return_node.value and has_values:\\n', '                self.add_violation(violation(return_node))\\n', \"                message = 'del'\\n\", '                message = node.__class__.__qualname__.lower()\\n', '            self.add_violation(WrongKeywordViolation(node, text=message))\\n', '        for sub in ast.walk(node):\\n', '            if isinstance(sub, ast.Expr) and isinstance(sub.value, ast.Yield):\\n', '                self._yield_locations[sub.value.lineno] = sub\\n', '        previous_line: Optional[int] = None\\n', '        previous_parent: Optional[ast.AST] = None\\n', '        for line, node in self._yield_locations.items():\\n', '            parent = get_parent(node)\\n', '            if previous_line is not None:\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n', '                    self.add_violation(ConsecutiveYieldsViolation(node.value))\\n', '            previous_line = line\\n', '            previous_parent = parent\\n', '        self._check_consistent_variable_return(node)\\n', '        self.generic_visit(node)\\n', '        if not node.value or not self._is_named_return(node):\\n', '        previous_node = self._get_previous_stmt(node)\\n', '        if not isinstance(previous_node, AssignNodes):\\n', '        return_names = name_nodes.get_variables_from_node(node.value)\\n', '        previous_names = list(name_nodes.flat_variable_names([previous_node]))\\n', '        self._check_for_violations(node, return_names, previous_names)\\n', '        if isinstance(node.value, ast.Name):\\n', '            isinstance(node.value, ast.Tuple) and\\n', '            all(isinstance(elem, ast.Name) for elem in node.value.elts)\\n', '        parent = cast(ast.AST, get_parent(node))\\n', \"        for part in ('body', 'orelse', 'finalbody'):\\n\", '            block = getattr(parent, part, [])\\n', '                current_index = block.index(node)\\n', '            if current_index > 0:\\n', '                return block[current_index - 1]\\n', '        if previous_names == return_names:\\n', \"                    node, text=', '.join(return_names),\\n\", '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '            if isinstance(node, ast.While):\\n']",
  "context": "function(self, node: ast.Return) -> None:\n        parent = get_parent(node)\n        if not isinstance(parent, FunctionNodes):\n"
 },
 "2433": {
  "name": "returns",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "112",
  "column": "8",
  "slicing": "['_ReturningViolations = Union[\\n', '        exception_name = get_exception_name(node)\\n', \"        if exception_name == 'NotImplemented':\\n\", '        elif exception_name in self._base_exceptions:\\n', '                BaseExceptionRaiseViolation(node, text=exception_name),\\n', '        parent = get_parent(node)\\n', '        if not isinstance(parent, FunctionNodes):\\n', '        returns = len(tuple(filter(\\n', '            walk.get_subnodes_by_type(parent, ast.Return),\\n', '        last_value_return = (\\n', '            len(parent.body) > 1 and\\n', '            returns < 2 and\\n', '        one_return_with_none = (\\n', '            returns == 1 and\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n', '        violation: _ReturningViolations,\\n', '        return_nodes, has_values = keywords.returning_nodes(\\n', '        for return_node in return_nodes:\\n', '            if not return_node.value and has_values:\\n', '                self.add_violation(violation(return_node))\\n', \"                message = 'del'\\n\", '                message = node.__class__.__qualname__.lower()\\n', '            self.add_violation(WrongKeywordViolation(node, text=message))\\n', '        for sub in ast.walk(node):\\n', '            if isinstance(sub, ast.Expr) and isinstance(sub.value, ast.Yield):\\n', '                self._yield_locations[sub.value.lineno] = sub\\n', '        previous_line: Optional[int] = None\\n', '        previous_parent: Optional[ast.AST] = None\\n', '        for line, node in self._yield_locations.items():\\n', '            parent = get_parent(node)\\n', '            if previous_line is not None:\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n', '                    self.add_violation(ConsecutiveYieldsViolation(node.value))\\n', '            previous_line = line\\n', '            previous_parent = parent\\n', '        self._check_consistent_variable_return(node)\\n', '        self.generic_visit(node)\\n', '        if not node.value or not self._is_named_return(node):\\n', '        previous_node = self._get_previous_stmt(node)\\n', '        if not isinstance(previous_node, AssignNodes):\\n', '        return_names = name_nodes.get_variables_from_node(node.value)\\n', '        previous_names = list(name_nodes.flat_variable_names([previous_node]))\\n', '        self._check_for_violations(node, return_names, previous_names)\\n', '        if isinstance(node.value, ast.Name):\\n', '            isinstance(node.value, ast.Tuple) and\\n', '            all(isinstance(elem, ast.Name) for elem in node.value.elts)\\n', '        parent = cast(ast.AST, get_parent(node))\\n', \"        for part in ('body', 'orelse', 'finalbody'):\\n\", '            block = getattr(parent, part, [])\\n', '                current_index = block.index(node)\\n', '            if current_index > 0:\\n', '                return block[current_index - 1]\\n', '        if previous_names == return_names:\\n', \"                    node, text=', '.join(return_names),\\n\", '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '            if isinstance(node, ast.While):\\n']",
  "context": "rent, FunctionNodes):\n            return\n\n        returns = len(tuple(filter(\n            lambda return_node: return_node.value "
 },
 "2434": {
  "name": "last_value_return",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "117",
  "column": "8",
  "slicing": "['        last_value_return = (\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n']",
  "context": "by_type(parent, ast.Return),\n        )))\n\n        last_value_return = (\n            len(parent.body) > 1 and\n            r"
 },
 "2435": {
  "name": "one_return_with_none",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "124",
  "column": "8",
  "slicing": "['        one_return_with_none = (\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n']",
  "context": "      node.value.value is None\n        )\n\n        one_return_with_none = (\n            returns == 1 and\n            isinstanc"
 },
 "2436": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "135",
  "column": "8",
  "slicing": "['        node: AnyFunctionDef,\\n']",
  "context": " _iterate_returning_values(\n        self,\n        node: AnyFunctionDef,\n        returning_type,  # mypy is not ok with thi"
 },
 "2437": {
  "name": "violation",
  "type": "_ReturningViolations",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "137",
  "column": "8",
  "slicing": "['        violation: _ReturningViolations,\\n']",
  "context": "mypy is not ok with this type declaration\n        violation: _ReturningViolations,\n    ):\n        return_nodes, has_values = keywords"
 },
 "2438": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "147",
  "column": "35",
  "slicing": "['    def _check_return_values(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "return_node))\n\n    def _check_return_values(self, node: AnyFunctionDef) -> None:\n        self._iterate_returning_values(\n          "
 },
 "2439": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "152",
  "column": "34",
  "slicing": "['    def _check_yield_values(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "ion,\n        )\n\n    def _check_yield_values(self, node: AnyFunctionDef) -> None:\n        self._iterate_returning_values(\n          "
 },
 "2440": {
  "name": "_forbidden_keywords",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "162",
  "column": "4",
  "slicing": "['    _forbidden_keywords: ClassVar[AnyNodes] = (\\n']",
  "context": "odeVisitor):\n    \"\"\"Finds wrong keywords.\"\"\"\n\n    _forbidden_keywords: ClassVar[AnyNodes] = (\n        ast.Pass,\n        ast.Delete,\n        ast."
 },
 "2441": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyWith",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "209",
  "column": "29",
  "slicing": "['    def visit_any_with(self, node: AnyWith) -> None:\\n']",
  "context": "generic_visit(node)\n\n    def visit_any_with(self, node: AnyWith) -> None:\n        \"\"\"\n        Checks the number of assignmen"
 },
 "2442": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyWith",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "220",
  "column": "39",
  "slicing": "['    def _check_target_assignment(self, node: AnyWith):\\n']",
  "context": "sit(node)\n\n    def _check_target_assignment(self, node: AnyWith):\n        if len(node.items) > 1:\n            self.a"
 },
 "2443": {
  "name": "_allowed_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "244",
  "column": "4",
  "slicing": "['    _allowed_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "ecks how generators are defined and used.\"\"\"\n\n    _allowed_nodes: ClassVar[AnyNodes] = (\n        ast.Name,\n        ast.Call,\n        ast.At"
 },
 "2444": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "259",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": " ast.Expr] = {}\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        We use this visitor method to "
 },
 "2445": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "282",
  "column": "40",
  "slicing": "['    def _check_consecutive_yields(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "it(node)\n\n    def _check_consecutive_yields(self, node: AnyFunctionDef) -> None:\n        for sub in ast.walk(node):\n            if "
 },
 "2446": {
  "name": "previous_line",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "297",
  "column": "8",
  "slicing": "['        previous_line: Optional[int] = None\\n', '            if previous_line is not None:\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n']",
  "context": "ode))\n\n    def _post_visit(self) -> None:\n        previous_line: Optional[int] = None\n        previous_parent: Optional[ast.AST] = None\n"
 },
 "2447": {
  "name": "previous_parent",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "298",
  "column": "8",
  "slicing": "['        previous_parent: Optional[ast.AST] = None\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n']",
  "context": "      previous_line: Optional[int] = None\n        previous_parent: Optional[ast.AST] = None\n\n        for line, node in self._yield_locations.i"
 },
 "2448": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "301",
  "column": "12",
  "slicing": "['_ReturningViolations = Union[\\n', '        exception_name = get_exception_name(node)\\n', \"        if exception_name == 'NotImplemented':\\n\", '        elif exception_name in self._base_exceptions:\\n', '                BaseExceptionRaiseViolation(node, text=exception_name),\\n', '        parent = get_parent(node)\\n', '        if not isinstance(parent, FunctionNodes):\\n', '        returns = len(tuple(filter(\\n', '            walk.get_subnodes_by_type(parent, ast.Return),\\n', '        last_value_return = (\\n', '            len(parent.body) > 1 and\\n', '            returns < 2 and\\n', '        one_return_with_none = (\\n', '            returns == 1 and\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n', '        violation: _ReturningViolations,\\n', '        return_nodes, has_values = keywords.returning_nodes(\\n', '        for return_node in return_nodes:\\n', '            if not return_node.value and has_values:\\n', '                self.add_violation(violation(return_node))\\n', \"                message = 'del'\\n\", '                message = node.__class__.__qualname__.lower()\\n', '            self.add_violation(WrongKeywordViolation(node, text=message))\\n', '        for sub in ast.walk(node):\\n', '            if isinstance(sub, ast.Expr) and isinstance(sub.value, ast.Yield):\\n', '                self._yield_locations[sub.value.lineno] = sub\\n', '        previous_line: Optional[int] = None\\n', '        previous_parent: Optional[ast.AST] = None\\n', '        for line, node in self._yield_locations.items():\\n', '            parent = get_parent(node)\\n', '            if previous_line is not None:\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n', '                    self.add_violation(ConsecutiveYieldsViolation(node.value))\\n', '            previous_line = line\\n', '            previous_parent = parent\\n', '        self._check_consistent_variable_return(node)\\n', '        self.generic_visit(node)\\n', '        if not node.value or not self._is_named_return(node):\\n', '        previous_node = self._get_previous_stmt(node)\\n', '        if not isinstance(previous_node, AssignNodes):\\n', '        return_names = name_nodes.get_variables_from_node(node.value)\\n', '        previous_names = list(name_nodes.flat_variable_names([previous_node]))\\n', '        self._check_for_violations(node, return_names, previous_names)\\n', '        if isinstance(node.value, ast.Name):\\n', '            isinstance(node.value, ast.Tuple) and\\n', '            all(isinstance(elem, ast.Name) for elem in node.value.elts)\\n', '        parent = cast(ast.AST, get_parent(node))\\n', \"        for part in ('body', 'orelse', 'finalbody'):\\n\", '            block = getattr(parent, part, [])\\n', '                current_index = block.index(node)\\n', '            if current_index > 0:\\n', '                return block[current_index - 1]\\n', '        if previous_names == return_names:\\n', \"                    node, text=', '.join(return_names),\\n\", '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '            if isinstance(node, ast.While):\\n']",
  "context": "ode in self._yield_locations.items():\n            parent = get_parent(node)\n\n            if previous_line is not None:\n       "
 },
 "2449": {
  "name": "previous_line",
  "type": "line",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "308",
  "column": "12",
  "slicing": "['_ReturningViolations = Union[\\n', '        exception_name = get_exception_name(node)\\n', \"        if exception_name == 'NotImplemented':\\n\", '        elif exception_name in self._base_exceptions:\\n', '                BaseExceptionRaiseViolation(node, text=exception_name),\\n', '        parent = get_parent(node)\\n', '        if not isinstance(parent, FunctionNodes):\\n', '        returns = len(tuple(filter(\\n', '            walk.get_subnodes_by_type(parent, ast.Return),\\n', '        last_value_return = (\\n', '            len(parent.body) > 1 and\\n', '            returns < 2 and\\n', '        one_return_with_none = (\\n', '            returns == 1 and\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n', '        violation: _ReturningViolations,\\n', '        return_nodes, has_values = keywords.returning_nodes(\\n', '        for return_node in return_nodes:\\n', '            if not return_node.value and has_values:\\n', '                self.add_violation(violation(return_node))\\n', \"                message = 'del'\\n\", '                message = node.__class__.__qualname__.lower()\\n', '            self.add_violation(WrongKeywordViolation(node, text=message))\\n', '        for sub in ast.walk(node):\\n', '            if isinstance(sub, ast.Expr) and isinstance(sub.value, ast.Yield):\\n', '                self._yield_locations[sub.value.lineno] = sub\\n', '        previous_line: Optional[int] = None\\n', '        previous_parent: Optional[ast.AST] = None\\n', '        for line, node in self._yield_locations.items():\\n', '            parent = get_parent(node)\\n', '            if previous_line is not None:\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n', '                    self.add_violation(ConsecutiveYieldsViolation(node.value))\\n', '            previous_line = line\\n', '            previous_parent = parent\\n', '        self._check_consistent_variable_return(node)\\n', '        self.generic_visit(node)\\n', '        if not node.value or not self._is_named_return(node):\\n', '        previous_node = self._get_previous_stmt(node)\\n', '        if not isinstance(previous_node, AssignNodes):\\n', '        return_names = name_nodes.get_variables_from_node(node.value)\\n', '        previous_names = list(name_nodes.flat_variable_names([previous_node]))\\n', '        self._check_for_violations(node, return_names, previous_names)\\n', '        if isinstance(node.value, ast.Name):\\n', '            isinstance(node.value, ast.Tuple) and\\n', '            all(isinstance(elem, ast.Name) for elem in node.value.elts)\\n', '        parent = cast(ast.AST, get_parent(node))\\n', \"        for part in ('body', 'orelse', 'finalbody'):\\n\", '            block = getattr(parent, part, [])\\n', '                current_index = block.index(node)\\n', '            if current_index > 0:\\n', '                return block[current_index - 1]\\n', '        if previous_names == return_names:\\n', \"                    node, text=', '.join(return_names),\\n\", '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '            if isinstance(node, ast.While):\\n']",
  "context": "de.value))\n                    break\n\n            previous_line = line\n            previous_parent = parent\n\n\n@final\nclas"
 },
 "2450": {
  "name": "previous_parent",
  "type": "parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "309",
  "column": "12",
  "slicing": "['_ReturningViolations = Union[\\n', '        exception_name = get_exception_name(node)\\n', \"        if exception_name == 'NotImplemented':\\n\", '        elif exception_name in self._base_exceptions:\\n', '                BaseExceptionRaiseViolation(node, text=exception_name),\\n', '        parent = get_parent(node)\\n', '        if not isinstance(parent, FunctionNodes):\\n', '        returns = len(tuple(filter(\\n', '            walk.get_subnodes_by_type(parent, ast.Return),\\n', '        last_value_return = (\\n', '            len(parent.body) > 1 and\\n', '            returns < 2 and\\n', '        one_return_with_none = (\\n', '            returns == 1 and\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n', '        violation: _ReturningViolations,\\n', '        return_nodes, has_values = keywords.returning_nodes(\\n', '        for return_node in return_nodes:\\n', '            if not return_node.value and has_values:\\n', '                self.add_violation(violation(return_node))\\n', \"                message = 'del'\\n\", '                message = node.__class__.__qualname__.lower()\\n', '            self.add_violation(WrongKeywordViolation(node, text=message))\\n', '        for sub in ast.walk(node):\\n', '            if isinstance(sub, ast.Expr) and isinstance(sub.value, ast.Yield):\\n', '                self._yield_locations[sub.value.lineno] = sub\\n', '        previous_line: Optional[int] = None\\n', '        previous_parent: Optional[ast.AST] = None\\n', '        for line, node in self._yield_locations.items():\\n', '            parent = get_parent(node)\\n', '            if previous_line is not None:\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n', '                    self.add_violation(ConsecutiveYieldsViolation(node.value))\\n', '            previous_line = line\\n', '            previous_parent = parent\\n', '        self._check_consistent_variable_return(node)\\n', '        self.generic_visit(node)\\n', '        if not node.value or not self._is_named_return(node):\\n', '        previous_node = self._get_previous_stmt(node)\\n', '        if not isinstance(previous_node, AssignNodes):\\n', '        return_names = name_nodes.get_variables_from_node(node.value)\\n', '        previous_names = list(name_nodes.flat_variable_names([previous_node]))\\n', '        self._check_for_violations(node, return_names, previous_names)\\n', '        if isinstance(node.value, ast.Name):\\n', '            isinstance(node.value, ast.Tuple) and\\n', '            all(isinstance(elem, ast.Name) for elem in node.value.elts)\\n', '        parent = cast(ast.AST, get_parent(node))\\n', \"        for part in ('body', 'orelse', 'finalbody'):\\n\", '            block = getattr(parent, part, [])\\n', '                current_index = block.index(node)\\n', '            if current_index > 0:\\n', '                return block[current_index - 1]\\n', '        if previous_names == return_names:\\n', \"                    node, text=', '.join(return_names),\\n\", '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '            if isinstance(node, ast.While):\\n']",
  "context": "eak\n\n            previous_line = line\n            previous_parent = parent\n\n\n@final\nclass ConsistentReturningVariableVisitor("
 },
 "2451": {
  "name": "previous_names",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "336",
  "column": "8",
  "slicing": "['_ReturningViolations = Union[\\n', '        exception_name = get_exception_name(node)\\n', \"        if exception_name == 'NotImplemented':\\n\", '        elif exception_name in self._base_exceptions:\\n', '                BaseExceptionRaiseViolation(node, text=exception_name),\\n', '        parent = get_parent(node)\\n', '        if not isinstance(parent, FunctionNodes):\\n', '        returns = len(tuple(filter(\\n', '            walk.get_subnodes_by_type(parent, ast.Return),\\n', '        last_value_return = (\\n', '            len(parent.body) > 1 and\\n', '            returns < 2 and\\n', '        one_return_with_none = (\\n', '            returns == 1 and\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n', '        violation: _ReturningViolations,\\n', '        return_nodes, has_values = keywords.returning_nodes(\\n', '        for return_node in return_nodes:\\n', '            if not return_node.value and has_values:\\n', '                self.add_violation(violation(return_node))\\n', \"                message = 'del'\\n\", '                message = node.__class__.__qualname__.lower()\\n', '            self.add_violation(WrongKeywordViolation(node, text=message))\\n', '        for sub in ast.walk(node):\\n', '            if isinstance(sub, ast.Expr) and isinstance(sub.value, ast.Yield):\\n', '                self._yield_locations[sub.value.lineno] = sub\\n', '        previous_line: Optional[int] = None\\n', '        previous_parent: Optional[ast.AST] = None\\n', '        for line, node in self._yield_locations.items():\\n', '            parent = get_parent(node)\\n', '            if previous_line is not None:\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n', '                    self.add_violation(ConsecutiveYieldsViolation(node.value))\\n', '            previous_line = line\\n', '            previous_parent = parent\\n', '        self._check_consistent_variable_return(node)\\n', '        self.generic_visit(node)\\n', '        if not node.value or not self._is_named_return(node):\\n', '        previous_node = self._get_previous_stmt(node)\\n', '        if not isinstance(previous_node, AssignNodes):\\n', '        return_names = name_nodes.get_variables_from_node(node.value)\\n', '        previous_names = list(name_nodes.flat_variable_names([previous_node]))\\n', '        self._check_for_violations(node, return_names, previous_names)\\n', '        if isinstance(node.value, ast.Name):\\n', '            isinstance(node.value, ast.Tuple) and\\n', '            all(isinstance(elem, ast.Name) for elem in node.value.elts)\\n', '        parent = cast(ast.AST, get_parent(node))\\n', \"        for part in ('body', 'orelse', 'finalbody'):\\n\", '            block = getattr(parent, part, [])\\n', '                current_index = block.index(node)\\n', '            if current_index > 0:\\n', '                return block[current_index - 1]\\n', '        if previous_names == return_names:\\n', \"                    node, text=', '.join(return_names),\\n\", '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '            if isinstance(node, ast.While):\\n']",
  "context": "nodes.get_variables_from_node(node.value)\n        previous_names = list(name_nodes.flat_variable_names([previous_node]))\n        self._check_for_violations(node, return_na"
 },
 "2452": {
  "name": "parent",
  "type": "typing.cast",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "358",
  "column": "8",
  "slicing": "['_ReturningViolations = Union[\\n', '        exception_name = get_exception_name(node)\\n', \"        if exception_name == 'NotImplemented':\\n\", '        elif exception_name in self._base_exceptions:\\n', '                BaseExceptionRaiseViolation(node, text=exception_name),\\n', '        parent = get_parent(node)\\n', '        if not isinstance(parent, FunctionNodes):\\n', '        returns = len(tuple(filter(\\n', '            walk.get_subnodes_by_type(parent, ast.Return),\\n', '        last_value_return = (\\n', '            len(parent.body) > 1 and\\n', '            returns < 2 and\\n', '        one_return_with_none = (\\n', '            returns == 1 and\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n', '        violation: _ReturningViolations,\\n', '        return_nodes, has_values = keywords.returning_nodes(\\n', '        for return_node in return_nodes:\\n', '            if not return_node.value and has_values:\\n', '                self.add_violation(violation(return_node))\\n', \"                message = 'del'\\n\", '                message = node.__class__.__qualname__.lower()\\n', '            self.add_violation(WrongKeywordViolation(node, text=message))\\n', '        for sub in ast.walk(node):\\n', '            if isinstance(sub, ast.Expr) and isinstance(sub.value, ast.Yield):\\n', '                self._yield_locations[sub.value.lineno] = sub\\n', '        previous_line: Optional[int] = None\\n', '        previous_parent: Optional[ast.AST] = None\\n', '        for line, node in self._yield_locations.items():\\n', '            parent = get_parent(node)\\n', '            if previous_line is not None:\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n', '                    self.add_violation(ConsecutiveYieldsViolation(node.value))\\n', '            previous_line = line\\n', '            previous_parent = parent\\n', '        self._check_consistent_variable_return(node)\\n', '        self.generic_visit(node)\\n', '        if not node.value or not self._is_named_return(node):\\n', '        previous_node = self._get_previous_stmt(node)\\n', '        if not isinstance(previous_node, AssignNodes):\\n', '        return_names = name_nodes.get_variables_from_node(node.value)\\n', '        previous_names = list(name_nodes.flat_variable_names([previous_node]))\\n', '        self._check_for_violations(node, return_names, previous_names)\\n', '        if isinstance(node.value, ast.Name):\\n', '            isinstance(node.value, ast.Tuple) and\\n', '            all(isinstance(elem, ast.Name) for elem in node.value.elts)\\n', '        parent = cast(ast.AST, get_parent(node))\\n', \"        for part in ('body', 'orelse', 'finalbody'):\\n\", '            block = getattr(parent, part, [])\\n', '                current_index = block.index(node)\\n', '            if current_index > 0:\\n', '                return block[current_index - 1]\\n', '        if previous_names == return_names:\\n', \"                    node, text=', '.join(return_names),\\n\", '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '            if isinstance(node, ast.While):\\n']",
  "context": "return`` always has a parent.\n        \"\"\"\n        parent = cast(ast.AST, get_parent(node))\n        for part in ('body', 'orelse', 'finalbody'"
 },
 "2453": {
  "name": "block",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "360",
  "column": "12",
  "slicing": "['_ReturningViolations = Union[\\n', '        exception_name = get_exception_name(node)\\n', \"        if exception_name == 'NotImplemented':\\n\", '        elif exception_name in self._base_exceptions:\\n', '                BaseExceptionRaiseViolation(node, text=exception_name),\\n', '        parent = get_parent(node)\\n', '        if not isinstance(parent, FunctionNodes):\\n', '        returns = len(tuple(filter(\\n', '            walk.get_subnodes_by_type(parent, ast.Return),\\n', '        last_value_return = (\\n', '            len(parent.body) > 1 and\\n', '            returns < 2 and\\n', '        one_return_with_none = (\\n', '            returns == 1 and\\n', '        if node.value is None or last_value_return or one_return_with_none:\\n', '        violation: _ReturningViolations,\\n', '        return_nodes, has_values = keywords.returning_nodes(\\n', '        for return_node in return_nodes:\\n', '            if not return_node.value and has_values:\\n', '                self.add_violation(violation(return_node))\\n', \"                message = 'del'\\n\", '                message = node.__class__.__qualname__.lower()\\n', '            self.add_violation(WrongKeywordViolation(node, text=message))\\n', '        for sub in ast.walk(node):\\n', '            if isinstance(sub, ast.Expr) and isinstance(sub.value, ast.Yield):\\n', '                self._yield_locations[sub.value.lineno] = sub\\n', '        previous_line: Optional[int] = None\\n', '        previous_parent: Optional[ast.AST] = None\\n', '        for line, node in self._yield_locations.items():\\n', '            parent = get_parent(node)\\n', '            if previous_line is not None:\\n', '                if line - 1 == previous_line and previous_parent == parent:\\n', '                    self.add_violation(ConsecutiveYieldsViolation(node.value))\\n', '            previous_line = line\\n', '            previous_parent = parent\\n', '        self._check_consistent_variable_return(node)\\n', '        self.generic_visit(node)\\n', '        if not node.value or not self._is_named_return(node):\\n', '        previous_node = self._get_previous_stmt(node)\\n', '        if not isinstance(previous_node, AssignNodes):\\n', '        return_names = name_nodes.get_variables_from_node(node.value)\\n', '        previous_names = list(name_nodes.flat_variable_names([previous_node]))\\n', '        self._check_for_violations(node, return_names, previous_names)\\n', '        if isinstance(node.value, ast.Name):\\n', '            isinstance(node.value, ast.Tuple) and\\n', '            all(isinstance(elem, ast.Name) for elem in node.value.elts)\\n', '        parent = cast(ast.AST, get_parent(node))\\n', \"        for part in ('body', 'orelse', 'finalbody'):\\n\", '            block = getattr(parent, part, [])\\n', '                current_index = block.index(node)\\n', '            if current_index > 0:\\n', '                return block[current_index - 1]\\n', '        if previous_names == return_names:\\n', \"                    node, text=', '.join(return_names),\\n\", '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '        self._check_condition(node, node.test)\\n', '        self.generic_visit(node)\\n', '            if isinstance(node, ast.While):\\n']",
  "context": "t in ('body', 'orelse', 'finalbody'):\n            block = getattr(parent, part, [])\n            try:\n                current_index = b"
 },
 "2454": {
  "name": "return_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "373",
  "column": "8",
  "slicing": "['        return_names: List[str],\\n']",
  "context": "(\n        self,\n        node: ast.Return,\n        return_names: List[str],\n        previous_names: List[str],\n    ) -> None:\n"
 },
 "2455": {
  "name": "previous_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "374",
  "column": "8",
  "slicing": "['        previous_names: List[str],\\n']",
  "context": ".Return,\n        return_names: List[str],\n        previous_names: List[str],\n    ) -> None:\n        if previous_names == return"
 },
 "2456": {
  "name": "_forbidden_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/keywords.py",
  "lineno": "388",
  "column": "4",
  "slicing": "['    _forbidden_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "efinitions to detect constant conditions.\"\"\"\n\n    _forbidden_nodes: ClassVar[AnyNodes] = (\n        ast.NameConstant,\n\n        ast.List,\n     "
 },
 "2457": {
  "name": "_BlockVariables",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "26",
  "column": "0",
  "slicing": "['_BlockVariables = DefaultDict[\\n', '        self._block_variables: _BlockVariables = defaultdict(\\n']",
  "context": " how we represent contexts for control variables.\n_BlockVariables = DefaultDict[\n    ast.AST,\n    DefaultDict[str, List[ast.AST]],\n"
 },
 "2458": {
  "name": "_ScopePredicate",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "32",
  "column": "0",
  "slicing": "['_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n']",
  "context": "we filter some overlaps that do happen in Python:\n_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\n_NamePredicate = Callable[[ast.AST], bool]\n\n\n@fina"
 },
 "2459": {
  "name": "_NamePredicate",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "33",
  "column": "0",
  "slicing": "['_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n']",
  "context": "pePredicate = Callable[[ast.AST, Set[str]], bool]\n_NamePredicate = Callable[[ast.AST], bool]\n\n\n@final\n@decorators.alias('visit_named_nodes', (\n"
 },
 "2460": {
  "name": "_naming_predicates",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n']",
  "context": "odify. This is fragile and complex.\n\n    \"\"\"\n\n    _naming_predicates: Tuple[_NamePredicate, ...] = (\n        predicates.is_property_setter,\n        pre"
 },
 "2461": {
  "name": "_scope_predicates",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "77",
  "column": "4",
  "slicing": "['    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n']",
  "context": "    predicates.is_no_value_annotation,\n    )\n\n    _scope_predicates: Tuple[_ScopePredicate, ...] = (\n        lambda node, names: predicates.is_property"
 },
 "2462": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "87",
  "column": "8",
  "slicing": "['        node: Union[AnyFunctionDef, ast.ClassDef, ast.ExceptHandler],\\n']",
  "context": "\n    def visit_named_nodes(\n        self,\n        node: Union[AnyFunctionDef, ast.ClassDef, ast.ExceptHandler],\n    ) -> None:\n        \"\"\"\n        Visits block no"
 },
 "2463": {
  "name": "names",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "96",
  "column": "8",
  "slicing": "['_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n']",
  "context": "lockAndLocalOverlapViolation\n\n        \"\"\"\n        names = {node.name} if node.name else set()\n        self._scope(node, names, is_local=False)\n "
 },
 "2464": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFor",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "101",
  "column": "28",
  "slicing": "['    def visit_any_for(self, node: AnyFor) -> None:\\n']",
  "context": ".generic_visit(node)\n\n    def visit_any_for(self, node: AnyFor) -> None:\n        \"\"\"\n        Collects block nodes from loop"
 },
 "2465": {
  "name": "parent",
  "type": "typing.cast",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "122",
  "column": "8",
  "slicing": "['_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n']",
  "context": "lockAndLocalOverlapViolation\n\n        \"\"\"\n        parent = cast(AnyImport, get_parent(node))\n        import_name = {node.asname} if node.asname"
 },
 "2466": {
  "name": "import_name",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "123",
  "column": "8",
  "slicing": "['_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n']",
  "context": "arent = cast(AnyImport, get_parent(node))\n        import_name = {node.asname} if node.asname else {node.name}\n        self._scope(parent, import_name, is_local="
 },
 "2467": {
  "name": "parent",
  "type": "typing.cast",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "137",
  "column": "12",
  "slicing": "['_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n']",
  "context": "   \"\"\"\n        if node.optional_vars:\n            parent = cast(AnyWith, get_parent(node))\n            names = defs.extract_names(node.option"
 },
 "2468": {
  "name": "node",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "145",
  "column": "27",
  "slicing": "['    def visit_locals(self, node: Union[AnyAssignWithWalrus, ast.arg]) -> None:\\n']",
  "context": "(node)\n\n    # Locals:\n\n    def visit_locals(self, node: Union[AnyAssignWithWalrus, ast.arg]) -> None:\n        \"\"\"\n        Visits local variable definiti"
 },
 "2469": {
  "name": "names",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "154",
  "column": "12",
  "slicing": "['_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n']",
  "context": "        if isinstance(node, ast.arg):\n            names = {node.arg}\n        else:\n            names = set(flat_variabl"
 },
 "2470": {
  "name": "names",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "156",
  "column": "12",
  "slicing": "['_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n']",
  "context": "     names = {node.arg}\n        else:\n            names = set(flat_variable_names([node]))\n\n        self._scope(node, names, is_local=True)\n "
 },
 "2471": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "167",
  "column": "8",
  "slicing": "['        names: Set[str],\\n']",
  "context": "ope(\n        self,\n        node: ast.AST,\n        names: Set[str],\n        *,\n        is_local: bool,\n    ) -> None:\n"
 },
 "2472": {
  "name": "ignored_scope",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "174",
  "column": "8",
  "slicing": "['_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n']",
  "context": "cope.shadowing(names, is_local=is_local)\n\n        ignored_scope = any(\n            predicate(node, names)\n            for"
 },
 "2473": {
  "name": "ignored_name",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "178",
  "column": "8",
  "slicing": "['_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n']",
  "context": "icate in self._scope_predicates\n        )\n        ignored_name = any(\n            predicate(node)\n            for predic"
 },
 "2474": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "191",
  "column": "42",
  "slicing": "['    def _outer_scope(self, node: ast.AST, names: Set[str]) -> None:\\n']",
  "context": "local)\n\n    def _outer_scope(self, node: ast.AST, names: Set[str]) -> None:\n        scope = defs.OuterScope(node)\n        shad"
 },
 "2475": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFor",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "220",
  "column": "28",
  "slicing": "['    def visit_any_for(self, node: AnyFor) -> None:\\n']",
  "context": "    )\n\n    # Blocks:\n\n    def visit_any_for(self, node: AnyFor) -> None:\n        \"\"\"Visit loops.\"\"\"\n        self._add_to_sc"
 },
 "2476": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "250",
  "column": "43",
  "slicing": "['    def _add_to_scope(self, node: ast.AST, names: Set[str]) -> None:\\n']",
  "context": "tils:\n\n    def _add_to_scope(self, node: ast.AST, names: Set[str]) -> None:\n        context = cast(ast.AST, get_context(node))"
 },
 "2477": {
  "name": "context",
  "type": "typing.cast",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "251",
  "column": "8",
  "slicing": "['_BlockVariables = DefaultDict[\\n', '_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        self._block_variables: _BlockVariables = defaultdict(\\n', '        context = cast(ast.AST, get_context(node))\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n', '        context = cast(ast.AST, get_context(node))\\n', '        blocks = self._block_variables[context][node.id]\\n', '        if all(is_contained_by(node, block) for block in blocks):\\n']",
  "context": " node: ast.AST, names: Set[str]) -> None:\n        context = cast(ast.AST, get_context(node))\n        for var_name in names:\n            self._b"
 },
 "2478": {
  "name": "context",
  "type": "typing.cast",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "256",
  "column": "8",
  "slicing": "['_BlockVariables = DefaultDict[\\n', '_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        self._block_variables: _BlockVariables = defaultdict(\\n', '        context = cast(ast.AST, get_context(node))\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n', '        context = cast(ast.AST, get_context(node))\\n', '        blocks = self._block_variables[context][node.id]\\n', '        if all(is_contained_by(node, block) for block in blocks):\\n']",
  "context": "able_usage(self, node: ast.Name) -> None:\n        context = cast(ast.AST, get_context(node))\n        blocks = self._block_variables[context][no"
 },
 "2479": {
  "name": "blocks",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/blocks.py",
  "lineno": "257",
  "column": "8",
  "slicing": "['_BlockVariables = DefaultDict[\\n', '_ScopePredicate = Callable[[ast.AST, Set[str]], bool]\\n', '_NamePredicate = Callable[[ast.AST], bool]\\n', '    _naming_predicates: Tuple[_NamePredicate, ...] = (\\n', '    _scope_predicates: Tuple[_ScopePredicate, ...] = (\\n', '        names = {node.name} if node.name else set()\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        names = defs.extract_names(node.target)\\n', '        self._scope(node, names, is_local=False)\\n', '        self._outer_scope(node, names)\\n', '        parent = cast(AnyImport, get_parent(node))\\n', '        import_name = {node.asname} if node.asname else {node.name}\\n', '        self._scope(parent, import_name, is_local=False)\\n', '        self._outer_scope(parent, import_name)\\n', '            parent = cast(AnyWith, get_parent(node))\\n', '            names = defs.extract_names(node.optional_vars)\\n', '            self._scope(parent, names, is_local=False)\\n', '            self._outer_scope(parent, names)\\n', '            names = {node.arg}\\n', '            names = set(flat_variable_names([node]))\\n', '        self._scope(node, names, is_local=True)\\n', '        self._outer_scope(node, names)\\n', '        scope = defs.BlockScope(node)\\n', '        shadow = scope.shadowing(names, is_local=is_local)\\n', '        ignored_scope = any(\\n', '            predicate(node, names)\\n', '            for predicate in self._scope_predicates\\n', '        ignored_name = any(\\n', '            predicate(node)\\n', '            for predicate in self._naming_predicates\\n', '        if shadow and not ignored_scope:\\n', \"                BlockAndLocalOverlapViolation(node, text=', '.join(shadow)),\\n\", '        if not ignored_name:\\n', '            scope.add_to_scope(names, is_local=is_local)\\n', '        scope = defs.OuterScope(node)\\n', '        shadow = scope.shadowing(names)\\n', '        if shadow:\\n', \"                OuterScopeShadowingViolation(node, text=', '.join(shadow)),\\n\", '        scope.add_to_scope(names)\\n', '        self._block_variables: _BlockVariables = defaultdict(\\n', '        context = cast(ast.AST, get_context(node))\\n', '        for var_name in names:\\n', '            self._block_variables[context][var_name].append(node)\\n', '        context = cast(ast.AST, get_context(node))\\n', '        blocks = self._block_variables[context][node.id]\\n', '        if all(is_contained_by(node, block) for block in blocks):\\n']",
  "context": "ontext = cast(ast.AST, get_context(node))\n        blocks = self._block_variables[context][node.id]\n        if all(is_contained_by(node, block) for bl"
 },
 "2480": {
  "name": "last_was_literal",
  "type": "next_is_literal",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "84",
  "column": "12",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "iolation(node))\n                break\n            last_was_literal = next_is_literal\n\n    def _check_useless_compare(self, node: ast.Co"
 },
 "2481": {
  "name": "last_variable",
  "type": "wemake_python_styleguide.logic.walrus.get_assigned_expr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "87",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "compare(self, node: ast.Compare) -> None:\n        last_variable = get_assigned_expr(node.left)\n        for next_variable in map(get_assigned_expr"
 },
 "2482": {
  "name": "last_variable",
  "type": "next_variable",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "92",
  "column": "12",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "iolation(node))\n                break\n            last_variable = next_variable\n\n    def _check_unpythonic_compare(self, node: ast"
 },
 "2483": {
  "name": "all_nodes",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "95",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "compare(self, node: ast.Compare) -> None:\n        all_nodes = list(\n            map(get_assigned_expr, (node.left, *no"
 },
 "2484": {
  "name": "ps",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "104",
  "column": "16",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "unction_called(compare, {'len'}):\n                ps = index - len(all_nodes) + 1\n                if not self._is_correct_len(node.o"
 },
 "2485": {
  "name": "is_less",
  "type": "all",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "123",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "f len(node.ops) != 2:\n            return\n\n        is_less = all(\n            isinstance(op, (ast.Gt, ast.GtE))\n    "
 },
 "2486": {
  "name": "_forbidden_for_is",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "137",
  "column": "4",
  "slicing": "['    _forbidden_for_is: ClassVar[AnyNodes] = (\\n']",
  "context": "tricts incorrect compares with constants.\"\"\"\n\n    _forbidden_for_is: ClassVar[AnyNodes] = (\n        ast.List,\n        ast.ListComp,\n        as"
 },
 "2487": {
  "name": "real",
  "type": "wemake_python_styleguide.logic.walrus.get_assigned_expr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "172",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": ", ast.Is, ast.IsNot)):\n            return\n        real = get_assigned_expr(comparator)\n        if not isinstance(real, (ast.List, ast.Dic"
 },
 "2488": {
  "name": "length",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "176",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "st.Dict, ast.Tuple)):\n            return\n\n        length = len(real.keys) if isinstance(\n            real, ast.Dict,\n        ) else len(rea"
 },
 "2489": {
  "name": "_allowed_left_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "202",
  "column": "4",
  "slicing": "['    _allowed_left_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "arison where argument doesn't come first.\"\"\"\n\n    _allowed_left_nodes: ClassVar[AnyNodes] = (\n        ast.Name,\n        ast.Call,\n        ast.At"
 },
 "2490": {
  "name": "_special_cases",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "210",
  "column": "4",
  "slicing": "['    _special_cases: ClassVar[AnyNodes] = (\\n']",
  "context": "     ast.Subscript,\n        ast.Await,\n    )\n\n    _special_cases: ClassVar[AnyNodes] = (\n        ast.In,\n        ast.NotIn,\n    )\n\n    def "
 },
 "2491": {
  "name": "comparators",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "253",
  "column": "8",
  "slicing": "['        comparators: Sequence[ast.AST],\\n']",
  "context": "s_wrong_nodes_on_the_right(\n        self,\n        comparators: Sequence[ast.AST],\n    ) -> bool:\n        for right in map(get_assign"
 },
 "2492": {
  "name": "_forbidden_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "288",
  "column": "4",
  "slicing": "['    _forbidden_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "    \"\"\"Finds wrong conditional arguments.\"\"\"\n\n    _forbidden_nodes: ClassVar[AnyNodes] = (\n        # Constants:\n        *TextNodes,\n        a"
 },
 "2493": {
  "name": "_forbidden_expression_parents",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "301",
  "column": "4",
  "slicing": "['    _forbidden_expression_parents: ClassVar[AnyNodes] = (\\n']",
  "context": ",\n        ast.Dict,\n        ast.Tuple,\n    )\n\n    _forbidden_expression_parents: ClassVar[AnyNodes] = (\n        ast.IfExp,\n        ast.BoolOp,\n        ast"
 },
 "2494": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyIf",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "309",
  "column": "27",
  "slicing": "['    def visit_any_if(self, node: AnyIf) -> None:\\n']",
  "context": "   ast.Compare,\n    )\n\n    def visit_any_if(self, node: AnyIf) -> None:\n        \"\"\"\n        Ensures that ``if`` nodes are "
 },
 "2495": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyIf",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "328",
  "column": "40",
  "slicing": "['    def _check_constant_condition(self, node: AnyIf) -> None:\\n']",
  "context": "it(node)\n\n    def _check_constant_condition(self, node: AnyIf) -> None:\n        real_node = operators.unwrap_unary_node(\n "
 },
 "2496": {
  "name": "conditions",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "344",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "le_ifexpr(self, node: ast.IfExp) -> None:\n        conditions = set()\n        if isinstance(node.body, ast.NameConstant)"
 },
 "2497": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyIf",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "353",
  "column": "35",
  "slicing": "['    def _check_nested_ifexpr(self, node: AnyIf) -> None:\\n']",
  "context": "lation(node))\n\n    def _check_nested_ifexpr(self, node: AnyIf) -> None:\n        is_nested_in_if = bool(\n            isinst"
 },
 "2498": {
  "name": "is_nested_in_if",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "354",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "nested_ifexpr(self, node: AnyIf) -> None:\n        is_nested_in_if = bool(\n            isinstance(node, ast.If) and\n         "
 },
 "2499": {
  "name": "node_body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "367",
  "column": "8",
  "slicing": "['        node_body: List[ast.stmt],\\n']",
  "context": "ef _is_simplifiable_assign(\n        self,\n        node_body: List[ast.stmt],\n    ) -> Optional[str]:\n        wrong_length = len"
 },
 "2500": {
  "name": "wrong_length",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "369",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": ": List[ast.stmt],\n    ) -> Optional[str]:\n        wrong_length = len(node_body) != 1\n        if wrong_length or not isinstance(node_bod"
 },
 "2501": {
  "name": "targets",
  "type": "wemake_python_styleguide.compat.functions.get_assign_targets",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "377",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "e.value is None:\n            return None\n\n        targets = get_assign_targets(node_body[0])\n        if len(targets) != 1:\n            return N"
 },
 "2502": {
  "name": "_in_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "411",
  "column": "4",
  "slicing": "['    _in_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "\"Restricts the incorrect ``in`` compares.\"\"\"\n\n    _in_nodes: ClassVar[AnyNodes] = (\n        ast.In,\n        ast.NotIn,\n    )\n\n    _wro"
 },
 "2503": {
  "name": "_wrong_in_comparators",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "416",
  "column": "4",
  "slicing": "['    _wrong_in_comparators: ClassVar[AnyNodes] = (\\n']",
  "context": "= (\n        ast.In,\n        ast.NotIn,\n    )\n\n    _wrong_in_comparators: ClassVar[AnyNodes] = (\n        ast.List,\n        ast.ListComp,\n        as"
 },
 "2504": {
  "name": "count",
  "type": "sum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "440",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '            if not isinstance(op, self._in_nodes):\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "ompares(self, node: ast.Compare) -> None:\n        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\n        if count > 1:\n            self.add_violati"
 },
 "2505": {
  "name": "real",
  "type": "wemake_python_styleguide.logic.walrus.get_assigned_expr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "449",
  "column": "12",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '        for op, comp in zip(node.ops, node.comparators):\\n', '            if not isinstance(op, self._in_nodes):\\n', '            real = get_assigned_expr(comp)\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "_in_nodes):\n                continue\n\n            real = get_assigned_expr(comp)\n            self._check_single_item_container(real"
 },
 "2506": {
  "name": "is_text_violated",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "454",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '        for op, comp in zip(node.ops, node.comparators):\\n', '            if not isinstance(op, self._in_nodes):\\n', '            real = get_assigned_expr(comp)\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '        is_text_violated = isinstance(node, TextNodes) and len(node.s) == 1\\n', '        if is_text_violated or is_dict_violated or is_iter_violated:\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "m_container(self, node: ast.AST) -> None:\n        is_text_violated = isinstance(node, TextNodes) and len(node.s) == 1\n        is_dict_violated = isinstance(node, ast.Di"
 },
 "2507": {
  "name": "is_dict_violated",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "455",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '        for op, comp in zip(node.ops, node.comparators):\\n', '            if not isinstance(op, self._in_nodes):\\n', '            real = get_assigned_expr(comp)\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '        is_dict_violated = isinstance(node, ast.Dict) and len(node.keys) == 1\\n', '        if is_text_violated or is_dict_violated or is_iter_violated:\\n', '            self._is_float_or_complex(comparator)\\n']",
  "context": "nce(node, TextNodes) and len(node.s) == 1\n        is_dict_violated = isinstance(node, ast.Dict) and len(node.keys) == 1\n        is_iter_violated = (\n            isinstanc"
 },
 "2508": {
  "name": "is_iter_violated",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "456",
  "column": "8",
  "slicing": "['        is_iter_violated = (\\n', '        if is_text_violated or is_dict_violated or is_iter_violated:\\n']",
  "context": "e(node, ast.Dict) and len(node.keys) == 1\n        is_iter_violated = (\n            isinstance(node, (ast.List, ast.Tuple,"
 },
 "2509": {
  "name": "any_float_or_complex",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/compares.py",
  "lineno": "492",
  "column": "8",
  "slicing": "['            numeric_value = ast.literal_eval(comparator)\\n', '            if numeric_value == 0:\\n', '            if numeric_value == 1:\\n', '        last_was_literal = nodes.is_literal(get_assigned_expr(node.left))\\n', '        for comparator in map(get_assigned_expr, node.comparators):\\n', '            next_is_literal = nodes.is_literal(comparator)\\n', '            if last_was_literal and next_is_literal:\\n', '            last_was_literal = next_is_literal\\n', '        last_variable = get_assigned_expr(node.left)\\n', '        for next_variable in map(get_assigned_expr, node.comparators):\\n', '            if is_same_variable(last_variable, next_variable):\\n', '            last_variable = next_variable\\n', '        all_nodes = list(\\n', '        for index, compare in enumerate(all_nodes):\\n', '            if not isinstance(compare, ast.Call):\\n', \"            if functions.given_function_called(compare, {'len'}):\\n\", '                ps = index - len(all_nodes) + 1\\n', '                if not self._is_correct_len(node.ops[ps], node.comparators[ps]):\\n', '        prototype = compares.get_similar_operators(node.ops[0])\\n', '        for op in node.ops:\\n', '            if not isinstance(op, prototype):\\n', '        is_less = all(\\n', '            isinstance(op, (ast.Gt, ast.GtE))\\n', '            for op in node.ops\\n', '        if not is_less:\\n', '        for op, comparator in zip(node.ops, node.comparators):\\n', '            self._check_constant(op, comparator)\\n', '            self._check_is_constant_compare(op, comparator)\\n', '        if not isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\\n', '        real = get_assigned_expr(comparator)\\n', '        if not isinstance(real, (ast.List, ast.Dict, ast.Tuple)):\\n', '        length = len(real.keys) if isinstance(\\n', '            real, ast.Dict,\\n', '        ) else len(real.elts)\\n', '        if not length:\\n', '            self.add_violation(FalsyConstantCompareViolation(comparator))\\n', '        if not isinstance(op, (ast.Is, ast.IsNot)):\\n', '        unwrapped = operators.unwrap_unary_node(\\n', '            get_assigned_expr(comparator),\\n', '        if isinstance(unwrapped, self._forbidden_for_is):\\n', '            self.add_violation(WrongIsCompareViolation(comparator))\\n', '            left_node = self._is_left_node_valid(left.left)\\n', '            right_node = self._is_left_node_valid(left.right)\\n', '            return left_node or right_node\\n', '        for right in map(get_assigned_expr, comparators):\\n', '            if isinstance(right, self._allowed_left_nodes):\\n', '            if isinstance(right, ast.BinOp):\\n', '                    right.left, right.right,\\n', '        real_node = operators.unwrap_unary_node(\\n', '        if isinstance(real_node, self._forbidden_nodes):\\n', '            body_var = self._is_simplifiable_assign(node.body)\\n', '            else_var = self._is_simplifiable_assign(node.orelse)\\n', '            if body_var and body_var == else_var:\\n', '        conditions = set()\\n', '            conditions.add(node.body.value)\\n', '            conditions.add(node.orelse.value)\\n', '        if conditions == {True, False}:\\n', '        is_nested_in_if = bool(\\n', '        is_nested_poorly = walk.get_closest_parent(\\n', '        if is_nested_in_if or is_nested_poorly:\\n', '        wrong_length = len(node_body) != 1\\n', '        if wrong_length or not isinstance(node_body[0], AssignNodes):\\n', '        targets = get_assign_targets(node_body[0])\\n', '        if len(targets) != 1:\\n', '        return source.node_to_string(targets[0])\\n', '        count = sum(1 for op in node.ops if isinstance(op, self._in_nodes))\\n', '        if count > 1:\\n', '        for op, comp in zip(node.ops, node.comparators):\\n', '            if not isinstance(op, self._in_nodes):\\n', '            real = get_assigned_expr(comp)\\n', '            self._check_single_item_container(real)\\n', '            self._check_wrong_comparators(real)\\n', '        is_text_violated = isinstance(node, TextNodes) and len(node.s) == 1\\n', '        is_dict_violated = isinstance(node, ast.Dict) and len(node.keys) == 1\\n', '        is_iter_violated = (\\n', '        if is_text_violated or is_dict_violated or is_iter_violated:\\n', '        node = operators.unwrap_unary_node(node)\\n', '            isinstance(node, ast.Num) and\\n', '            isinstance(node.n, (float, complex))\\n', '        any_float_or_complex = any(\\n', '            self._is_float_or_complex(comparator)\\n', '            for comparator in node.comparators\\n', '        ) or self._is_float_or_complex(node.left)\\n', '        if any_float_or_complex:\\n', '            self.add_violation(FloatComplexCompareViolation(node))\\n']",
  "context": "compare(self, node: ast.Compare) -> None:\n        any_float_or_complex = any(\n            self._is_float_or_complex(comparator)\n"
 },
 "2510": {
  "name": "_OperatorPairs",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "31",
  "column": "0",
  "slicing": "['_OperatorPairs = Mapping[Type[ast.boolop], Type[ast.cmpop]]\\n', '    _allowed: ClassVar[_OperatorPairs] = {\\n']",
  "context": "thon_styleguide.visitors.decorators import alias\n\n_OperatorPairs = Mapping[Type[ast.boolop], Type[ast.cmpop]]\n\n\ndef _duplicated_isinstance_call(node: ast.BoolOp"
 },
 "2511": {
  "name": "counter",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['    counter: DefaultDict[str, int] = defaultdict(int)\\n', '        counter[isinstance_object] += 1\\n', '        for node_name, count in counter.items()\\n', '        if count > 1\\n']",
  "context": "instance_call(node: ast.BoolOp) -> List[str]:\n    counter: DefaultDict[str, int] = defaultdict(int)\n\n    for call in node.values:\n        if not isins"
 },
 "2512": {
  "name": "variables",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "54",
  "column": "25",
  "slicing": "['def _get_duplicate_names(variables: List[Set[str]]):\\n', '        for duplicate in _get_duplicate_names(variables):\\n', '                ImplicitInConditionViolation(node, text=duplicate),\\n']",
  "context": "    if count > 1\n    ]\n\n\ndef _get_duplicate_names(variables: List[Set[str]]):\n    return reduce(\n        lambda acc, element: ac"
 },
 "2513": {
  "name": "_returning_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['    _returning_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "odes that break or return the execution flow.\n    _returning_nodes: ClassVar[AnyNodes] = (\n        ast.Break,\n        ast.Raise,\n        ast."
 },
 "2514": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyIf",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "102",
  "column": "40",
  "slicing": "['    def _check_negated_conditions(self, node: AnyIf) -> None:\\n']",
  "context": "it(node)\n\n    def _check_negated_conditions(self, node: AnyIf) -> None:\n        if isinstance(node, ast.If) and not ifs.ha"
 },
 "2515": {
  "name": "start_lineno",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "115",
  "column": "8",
  "slicing": "['    counter: DefaultDict[str, int] = defaultdict(int)\\n', '    for call in node.values:\\n', '        if not isinstance(call, ast.Call) or len(call.args) != 2:\\n', \"        if not given_function_called(call, {'isinstance'}):\\n\", '        isinstance_object = source.node_to_string(call.args[0])\\n', '        counter[isinstance_object] += 1\\n', '        for node_name, count in counter.items()\\n', '        if count > 1\\n', '            if any(isinstance(elem, ast.NotEq) for elem in node.test.ops):\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n']",
  "context": "ine conditions ``if`` statement nodes.\"\"\"\n        start_lineno = getattr(node, 'lineno', None)\n        for sub_nodes in ast.walk(node.test):\n    "
 },
 "2516": {
  "name": "sub_lineno",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "117",
  "column": "12",
  "slicing": "['    counter: DefaultDict[str, int] = defaultdict(int)\\n', '    for call in node.values:\\n', '        if not isinstance(call, ast.Call) or len(call.args) != 2:\\n', \"        if not given_function_called(call, {'isinstance'}):\\n\", '        isinstance_object = source.node_to_string(call.args[0])\\n', '        counter[isinstance_object] += 1\\n', '        for node_name, count in counter.items()\\n', '        if count > 1\\n', '            if any(isinstance(elem, ast.NotEq) for elem in node.test.ops):\\n', '        for sub_nodes in ast.walk(node.test):\\n', \"            sub_lineno = getattr(sub_nodes, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n']",
  "context": "for sub_nodes in ast.walk(node.test):\n            sub_lineno = getattr(sub_nodes, 'lineno', None)\n            if sub_lineno is not None and sub_line"
 },
 "2517": {
  "name": "real_ifs",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "123",
  "column": "8",
  "slicing": "['        real_ifs = []\\n', '                real_ifs.append(chained_if)\\n', '                for real_if in real_ifs\\n']",
  "context": "useless_else(self, node: ast.If) -> None:\n        real_ifs = []\n        for chained_if in ifs.chain(node):\n       "
 },
 "2518": {
  "name": "previous_has_returns",
  "type": "all",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "133",
  "column": "12",
  "slicing": "['    counter: DefaultDict[str, int] = defaultdict(int)\\n', '    for call in node.values:\\n', '        if not isinstance(call, ast.Call) or len(call.args) != 2:\\n', \"        if not given_function_called(call, {'isinstance'}):\\n\", '        isinstance_object = source.node_to_string(call.args[0])\\n', '        counter[isinstance_object] += 1\\n', '        for node_name, count in counter.items()\\n', '        if count > 1\\n', '            if any(isinstance(elem, ast.NotEq) for elem in node.test.ops):\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '        for sub_nodes in ast.walk(node.test):\\n', \"            sub_lineno = getattr(sub_nodes, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n', '        real_ifs = []\\n', '        for chained_if in ifs.chain(node):\\n', '            if isinstance(chained_if, ast.If):\\n', '                if chained_if in self._visited_ifs:\\n', '                self._visited_ifs.update({chained_if})\\n', '                real_ifs.append(chained_if)\\n', '            previous_has_returns = all(\\n', '                for real_if in real_ifs\\n', '                self._returning_nodes, chained_if,\\n', '            if previous_has_returns and current_has_returns:\\n', '                    UselessReturningElseViolation(chained_if[0]),\\n']",
  "context": "chained_if)\n                continue\n\n            previous_has_returns = all(\n                ifs.has_nodes(\n                   "
 },
 "2519": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyIf",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "149",
  "column": "33",
  "slicing": "['    def _check_useless_len(self, node: AnyIf) -> None:\\n']",
  "context": "              )\n\n    def _check_useless_len(self, node: AnyIf) -> None:\n        if isinstance(node.test, ast.Call):\n      "
 },
 "2520": {
  "name": "names",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "200",
  "column": "8",
  "slicing": "['        names = []\\n', '                names.extend(self._get_all_names(operand))\\n', '                names.append(\\n', '        return names\\n']",
  "context": "e:\n        self._same_nodes.append(node)\n\n        names = []\n        for operand in node.values:\n            if"
 },
 "2521": {
  "name": "operands",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "216",
  "column": "8",
  "slicing": "['    counter: DefaultDict[str, int] = defaultdict(int)\\n', '    for call in node.values:\\n', '        if not isinstance(call, ast.Call) or len(call.args) != 2:\\n', \"        if not given_function_called(call, {'isinstance'}):\\n\", '        isinstance_object = source.node_to_string(call.args[0])\\n', '        counter[isinstance_object] += 1\\n', '        for node_name, count in counter.items()\\n', '        if count > 1\\n', '            if any(isinstance(elem, ast.NotEq) for elem in node.test.ops):\\n', \"        start_lineno = getattr(node, 'lineno', None)\\n\", '        for sub_nodes in ast.walk(node.test):\\n', \"            sub_lineno = getattr(sub_nodes, 'lineno', None)\\n\", '            if sub_lineno is not None and sub_lineno > start_lineno:\\n', '        real_ifs = []\\n', '        for chained_if in ifs.chain(node):\\n', '            if isinstance(chained_if, ast.If):\\n', '                if chained_if in self._visited_ifs:\\n', '                self._visited_ifs.update({chained_if})\\n', '                real_ifs.append(chained_if)\\n', '            previous_has_returns = all(\\n', '                for real_if in real_ifs\\n', '            current_has_returns = ifs.has_nodes(\\n', '                self._returning_nodes, chained_if,\\n', '            if previous_has_returns and current_has_returns:\\n', '                    UselessReturningElseViolation(chained_if[0]),\\n', '        body = node.body\\n', '        simple_if_and_root = not (ifs.has_elif(node) or ifs.is_elif(node))\\n', '        if keywords.is_simple_return(body) and simple_if_and_root:\\n', '                else_body = node.orelse\\n', '                if keywords.is_simple_return(else_body):\\n', \"            body = getattr(node, 'wps_parent').body\\n\", '            next_index_in_parent = body.index(node) + 1\\n', '            if keywords.next_node_returns_bool(body, next_index_in_parent):\\n', '        names = []\\n', '        for operand in node.values:\\n', '            if isinstance(operand, ast.BoolOp):\\n', '                names.extend(self._get_all_names(operand))\\n', '                names.append(\\n', '                        operators.unwrap_unary_node(operand),\\n', '        return names\\n', '        operands = self._get_all_names(node)\\n', '        if len(set(operands)) != len(operands):\\n']",
  "context": " We do not visit nested `BoolOp`s twice.\n\n        operands = self._get_all_names(node)\n        if len(set(operands)) != len(operands):\n  "
 },
 "2522": {
  "name": "_allowed",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "234",
  "column": "4",
  "slicing": "['    _allowed: ClassVar[_OperatorPairs] = {\\n']",
  "context": "icit patterns that are formed by boolops.\"\"\"\n\n    _allowed: ClassVar[_OperatorPairs] = {\n        ast.And: ast.NotEq,\n        ast.Or: ast.Eq"
 },
 "2523": {
  "name": "variables",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/conditions.py",
  "lineno": "253",
  "column": "8",
  "slicing": "['        variables: List[Set[str]] = []\\n', '            variables.append({source.node_to_string(cmp.left)})\\n', '        for duplicate in _get_duplicate_names(variables):\\n', '                ImplicitInConditionViolation(node, text=duplicate),\\n']",
  "context": "licit_in(self, node: ast.BoolOp) -> None:\n        variables: List[Set[str]] = []\n\n        for cmp in node.values:\n            if no"
 },
 "2524": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/annotations.py",
  "lineno": "21",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "d correctly.\"\"\"\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        Checks return type annotations"
 },
 "2525": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/annotations.py",
  "lineno": "43",
  "column": "39",
  "slicing": "['    def _check_return_annotation(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "sit(node)\n\n    def _check_return_annotation(self, node: AnyFunctionDef) -> None:\n        if not node.returns:\n            return\n\n "
 },
 "2526": {
  "name": "lineno",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/annotations.py",
  "lineno": "48",
  "column": "12",
  "slicing": "['        for sub_node in ast.walk(node.returns):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno and lineno != node.returns.lineno:\\n', '        for sub_node in ast.walk(node):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno and lineno != node.lineno:\\n']",
  "context": "r sub_node in ast.walk(node.returns):\n            lineno = getattr(sub_node, 'lineno', None)\n            if lineno and lineno != node.returns.l"
 },
 "2527": {
  "name": "lineno",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/annotations.py",
  "lineno": "55",
  "column": "12",
  "slicing": "['        for sub_node in ast.walk(node.returns):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno and lineno != node.returns.lineno:\\n', '        for sub_node in ast.walk(node):\\n', \"            lineno = getattr(sub_node, 'lineno', None)\\n\", '            if lineno and lineno != node.lineno:\\n']",
  "context": "      for sub_node in ast.walk(node):\n            lineno = getattr(sub_node, 'lineno', None)\n            if lineno and lineno != node.lineno:\n "
 },
 "2528": {
  "name": "_allowed_to_use_protected",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/attributes.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    _allowed_to_use_protected: ClassVar[FrozenSet[str]] = frozenset((\\n']",
  "context": "sures that attributes are used correctly.\"\"\"\n\n    _allowed_to_use_protected: ClassVar[FrozenSet[str]] = frozenset((\n        'self',\n        'cls',\n        'mcs',\n    "
 },
 "2529": {
  "name": "_allowed_magic_attributes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/attributes.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    _allowed_magic_attributes: ClassVar[FrozenSet[str]] = frozenset((\\n']",
  "context": "'self',\n        'cls',\n        'mcs',\n    ))\n\n    _allowed_magic_attributes: ClassVar[FrozenSet[str]] = frozenset((\n        '__class__',\n        '__name__',\n        '"
 },
 "2530": {
  "name": "_VariableDef",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "48",
  "column": "0",
  "slicing": "['_VariableDef = Union[ast.Name, ast.Attribute, ast.ExceptHandler]\\n', '    def visit_variable(self, node: _VariableDef) -> None:\\n']",
  "context": "thon_styleguide.visitors.decorators import alias\n\n_VariableDef = Union[ast.Name, ast.Attribute, ast.ExceptHandler]\n_ErrorCallback = Callable[[base.BaseViolation], No"
 },
 "2531": {
  "name": "_ErrorCallback",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "49",
  "column": "0",
  "slicing": "['_ErrorCallback = Callable[[base.BaseViolation], None]\\n', '        error_callback: _ErrorCallback,\\n']",
  "context": "Union[ast.Name, ast.Attribute, ast.ExceptHandler]\n_ErrorCallback = Callable[[base.BaseViolation], None]\n\n_PredicateCallback = Callable[[str], bool]\n_Predi"
 },
 "2532": {
  "name": "_PredicateCallback",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "51",
  "column": "0",
  "slicing": "['_PredicateCallback = Callable[[str], bool]\\n', '_Predicates = Mapping[_PredicateCallback, Type[base.BaseViolation]]\\n', '    _naming_predicates: ClassVar[_Predicates] = {\\n']",
  "context": "rCallback = Callable[[base.BaseViolation], None]\n\n_PredicateCallback = Callable[[str], bool]\n_Predicates = Mapping[_PredicateCallback, Type[bas"
 },
 "2533": {
  "name": "_Predicates",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "52",
  "column": "0",
  "slicing": "['_PredicateCallback = Callable[[str], bool]\\n', '_Predicates = Mapping[_PredicateCallback, Type[base.BaseViolation]]\\n', '    _naming_predicates: ClassVar[_Predicates] = {\\n']",
  "context": "None]\n\n_PredicateCallback = Callable[[str], bool]\n_Predicates = Mapping[_PredicateCallback, Type[base.BaseViolation]]\n\n\n@final\nclass _NameValidator(object):\n    \"\"\"Util"
 },
 "2534": {
  "name": "_naming_predicates",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['    _naming_predicates: ClassVar[_Predicates] = {\\n']",
  "context": "o separate logic from the naming visitor.\"\"\"\n\n    _naming_predicates: ClassVar[_Predicates] = {\n        builtins.is_builtin_name: naming.BuiltinSh"
 },
 "2535": {
  "name": "error_callback",
  "type": "_ErrorCallback",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "74",
  "column": "8",
  "slicing": "['        error_callback: _ErrorCallback,\\n']",
  "context": "n,\n    }\n\n    def __init__(\n        self,\n        error_callback: _ErrorCallback,\n        options: ConfigurationOptions,\n    ) -> No"
 },
 "2536": {
  "name": "options",
  "type": "wemake_python_styleguide.types.ConfigurationOptions",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "75",
  "column": "8",
  "slicing": "['        options: ConfigurationOptions,\\n']",
  "context": ",\n        error_callback: _ErrorCallback,\n        options: ConfigurationOptions,\n    ) -> None:\n        \"\"\"Creates new instance of "
 },
 "2537": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "87",
  "column": "8",
  "slicing": "['        name: str,\\n']",
  "context": "ame(\n        self,\n        node: ast.AST,\n        name: str,\n        *,\n        is_first_argument: bool = False"
 },
 "2538": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDefAndLambda",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "100",
  "column": "39",
  "slicing": "['    def check_function_signature(self, node: AnyFunctionDefAndLambda) -> None:\\n']",
  "context": "        )\n\n    def check_function_signature(self, node: AnyFunctionDefAndLambda) -> None:\n        for arg in functions.get_all_arguments(nod"
 },
 "2539": {
  "name": "should_check_argument",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "102",
  "column": "12",
  "slicing": "['            should_check_argument = (\\n', '                arg, arg.arg, is_first_argument=should_check_argument,\\n']",
  "context": "in functions.get_all_arguments(node):\n            should_check_argument = (\n                functions.is_first_argument(node, "
 },
 "2540": {
  "name": "top_level_assigns",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "112",
  "column": "8",
  "slicing": "['        top_level_assigns = [\\n', '        for assignment in top_level_assigns:\\n', '            for target in get_assign_targets(assignment):\\n', '                self._ensure_case(target)\\n']",
  "context": "e_name(self, node: ast.ClassDef) -> None:\n        top_level_assigns = [\n            sub\n            for sub in ast.walk(no"
 },
 "2541": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "122",
  "column": "44",
  "slicing": "['    def _ensure_length(self, node: ast.AST, name: str) -> None:\\n']",
  "context": "get)\n\n    def _ensure_length(self, node: ast.AST, name: str) -> None:\n        min_length = self._options.min_name_length"
 },
 "2542": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "142",
  "column": "8",
  "slicing": "['        name: str,\\n']",
  "context": "ing(\n        self,\n        node: ast.AST,\n        name: str,\n        *,\n        is_first_argument: bool,\n    ) "
 },
 "2543": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "219",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "ric_visit(node)\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        Used to find wrong function an"
 },
 "2544": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyImport",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "252",
  "column": "31",
  "slicing": "['    def visit_any_import(self, node: AnyImport) -> None:\\n']",
  "context": "neric_visit(node)\n\n    def visit_any_import(self, node: AnyImport) -> None:\n        \"\"\"\n        Used to check wrong import ali"
 },
 "2545": {
  "name": "node",
  "type": "_VariableDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "271",
  "column": "29",
  "slicing": "['    def visit_variable(self, node: _VariableDef) -> None:\\n']",
  "context": "generic_visit(node)\n\n    def visit_variable(self, node: _VariableDef) -> None:\n        \"\"\"\n        Used to check wrong names of a"
 },
 "2546": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyAssign",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "300",
  "column": "31",
  "slicing": "['    def visit_any_assign(self, node: AnyAssign) -> None:\\n']",
  "context": "n of a module.\"\"\"\n\n    def visit_any_assign(self, node: AnyAssign) -> None:\n        \"\"\"\n        Used to find the bad metadata "
 },
 "2547": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyAssign",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "311",
  "column": "30",
  "slicing": "['    def _check_metadata(self, node: AnyAssign) -> None:\\n']",
  "context": "eneric_visit(node)\n\n    def _check_metadata(self, node: AnyAssign) -> None:\n        if not isinstance(nodes.get_parent(node), "
 },
 "2548": {
  "name": "targets",
  "type": "wemake_python_styleguide.compat.functions.get_assign_targets",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "315",
  "column": "8",
  "slicing": "['_VariableDef = Union[ast.Name, ast.Attribute, ast.ExceptHandler]\\n', '_ErrorCallback = Callable[[base.BaseViolation], None]\\n', '_PredicateCallback = Callable[[str], bool]\\n', '_Predicates = Mapping[_PredicateCallback, Type[base.BaseViolation]]\\n', '    _naming_predicates: ClassVar[_Predicates] = {\\n', '        error_callback: _ErrorCallback,\\n', '        for predicate, violation in self._naming_predicates.items():\\n', '            if predicate(name):\\n', '                self._error_callback(violation(node, text=name))\\n', '        for arg in functions.get_all_arguments(node):\\n', '            should_check_argument = (\\n', '                functions.is_first_argument(node, arg.arg) and\\n', '                arg, arg.arg, is_first_argument=should_check_argument,\\n', '        top_level_assigns = [\\n', '            for sub in ast.walk(node)\\n', '            if isinstance(sub, AssignNodes) and nodes.get_context(sub) is node\\n', '        for assignment in top_level_assigns:\\n', '            for target in get_assign_targets(assignment):\\n', '                self._ensure_case(target)\\n', '        min_length = self._options.min_name_length\\n', '        if logical.is_too_short_name(name, min_length=min_length):\\n', '                    node, text=name, baseline=min_length,\\n', '        max_length = self._options.max_name_length\\n', '        if logical.is_too_long_name(name, max_length=max_length):\\n', '                    node, text=name, baseline=max_length,\\n', '        unreadable_sequence = alphabet.get_unreadable_characters(\\n', '        if unreadable_sequence:\\n', '                naming.UnreadableNameViolation(node, text=unreadable_sequence),\\n', '        for alias_node in node.names:\\n', '            if alias_node.asname:\\n', '                self._validator.check_name(node, alias_node.asname)\\n', '    def visit_variable(self, node: _VariableDef) -> None:\\n', '        variable_name = name_nodes.get_assigned_name(node)\\n', '        if variable_name is not None:\\n', '            self._validator.check_name(node, variable_name)\\n', '        targets = get_assign_targets(node)\\n', '        for target_node in targets:\\n', '            if not isinstance(target_node, ast.Name):\\n', '            if target_node.id not in MODULE_METADATA_VARIABLES_BLACKLIST:\\n', '                    node, text=target_node.id,\\n']",
  "context": "t(node), ast.Module):\n            return\n\n        targets = get_assign_targets(node)\n        for target_node in targets:\n            if"
 },
 "2549": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyAssign",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "338",
  "column": "31",
  "slicing": "['    def visit_any_assign(self, node: AnyAssign) -> None:\\n']",
  "context": "s assignments.\"\"\"\n\n    def visit_any_assign(self, node: AnyAssign) -> None:\n        \"\"\"\n        Used to check assignment varia"
 },
 "2550": {
  "name": "names",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "346",
  "column": "8",
  "slicing": "['_VariableDef = Union[ast.Name, ast.Attribute, ast.ExceptHandler]\\n', '_ErrorCallback = Callable[[base.BaseViolation], None]\\n', '_PredicateCallback = Callable[[str], bool]\\n', '_Predicates = Mapping[_PredicateCallback, Type[base.BaseViolation]]\\n', '    _naming_predicates: ClassVar[_Predicates] = {\\n', '        error_callback: _ErrorCallback,\\n', '        for predicate, violation in self._naming_predicates.items():\\n', '            if predicate(name):\\n', '                self._error_callback(violation(node, text=name))\\n', '        for arg in functions.get_all_arguments(node):\\n', '            should_check_argument = (\\n', '                functions.is_first_argument(node, arg.arg) and\\n', '                arg, arg.arg, is_first_argument=should_check_argument,\\n', '        top_level_assigns = [\\n', '            for sub in ast.walk(node)\\n', '            if isinstance(sub, AssignNodes) and nodes.get_context(sub) is node\\n', '        for assignment in top_level_assigns:\\n', '            for target in get_assign_targets(assignment):\\n', '                self._ensure_case(target)\\n', '        min_length = self._options.min_name_length\\n', '        if logical.is_too_short_name(name, min_length=min_length):\\n', '                    node, text=name, baseline=min_length,\\n', '        max_length = self._options.max_name_length\\n', '        if logical.is_too_long_name(name, max_length=max_length):\\n', '                    node, text=name, baseline=max_length,\\n', '        unreadable_sequence = alphabet.get_unreadable_characters(\\n', '        if unreadable_sequence:\\n', '                naming.UnreadableNameViolation(node, text=unreadable_sequence),\\n', '        for alias_node in node.names:\\n', '            if alias_node.asname:\\n', '                self._validator.check_name(node, alias_node.asname)\\n', '    def visit_variable(self, node: _VariableDef) -> None:\\n', '        variable_name = name_nodes.get_assigned_name(node)\\n', '        if variable_name is not None:\\n', '            self._validator.check_name(node, variable_name)\\n', '        targets = get_assign_targets(node)\\n', '        for target_node in targets:\\n', '            if not isinstance(target_node, ast.Name):\\n', '            if target_node.id not in MODULE_METADATA_VARIABLES_BLACKLIST:\\n', '                    node, text=target_node.id,\\n', '        names = list(name_nodes.flat_variable_names([node]))\\n', '        self._check_reassignment(node, names)\\n', '        self._check_unique_assignment(node, names)\\n', '        for var_name, var_value in itertools.zip_longest(names, var_values):\\n', '            if var_name == var_value:\\n', '                        node, text=var_name,\\n', '        for used_name, count in Counter(names).items():\\n', '            if count > 1:\\n', '                        node, text=used_name,\\n']",
  "context": "ingVariableToItselfViolation\n\n        \"\"\"\n        names = list(name_nodes.flat_variable_names([node]))\n\n        self._check_reassignment(node, names)\n   "
 },
 "2551": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyAssign",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "354",
  "column": "8",
  "slicing": "['        node: AnyAssign,\\n']",
  "context": "   def _check_reassignment(\n        self,\n        node: AnyAssign,\n        names: List[str],\n    ) -> None:\n        i"
 },
 "2552": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "355",
  "column": "8",
  "slicing": "['        names: List[str],\\n']",
  "context": "t(\n        self,\n        node: AnyAssign,\n        names: List[str],\n    ) -> None:\n        if not node.value:\n        "
 },
 "2553": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyAssign",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "371",
  "column": "8",
  "slicing": "['        node: AnyAssign,\\n']",
  "context": "f _check_unique_assignment(\n        self,\n        node: AnyAssign,\n        names: List[str],\n    ) -> None:\n        f"
 },
 "2554": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "372",
  "column": "8",
  "slicing": "['        names: List[str],\\n']",
  "context": "t(\n        self,\n        node: AnyAssign,\n        names: List[str],\n    ) -> None:\n        for used_name, count in Cou"
 },
 "2555": {
  "name": "node",
  "type": "wemake_python_styleguide.compat.types.AnyAssignWithWalrus",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "396",
  "column": "31",
  "slicing": "['    def visit_any_assign(self, node: AnyAssignWithWalrus) -> None:\\n']",
  "context": "bles are used.\"\"\"\n\n    def visit_any_assign(self, node: AnyAssignWithWalrus) -> None:\n        \"\"\"\n        Checks that we cannot assign e"
 },
 "2556": {
  "name": "is_inside_class_or_module",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "408",
  "column": "8",
  "slicing": "['_VariableDef = Union[ast.Name, ast.Attribute, ast.ExceptHandler]\\n', '_ErrorCallback = Callable[[base.BaseViolation], None]\\n', '_PredicateCallback = Callable[[str], bool]\\n', '_Predicates = Mapping[_PredicateCallback, Type[base.BaseViolation]]\\n', '    _naming_predicates: ClassVar[_Predicates] = {\\n', '        error_callback: _ErrorCallback,\\n', '        for predicate, violation in self._naming_predicates.items():\\n', '            if predicate(name):\\n', '                self._error_callback(violation(node, text=name))\\n', '        for arg in functions.get_all_arguments(node):\\n', '            should_check_argument = (\\n', '                functions.is_first_argument(node, arg.arg) and\\n', '                arg, arg.arg, is_first_argument=should_check_argument,\\n', '        top_level_assigns = [\\n', '            for sub in ast.walk(node)\\n', '            if isinstance(sub, AssignNodes) and nodes.get_context(sub) is node\\n', '        for assignment in top_level_assigns:\\n', '            for target in get_assign_targets(assignment):\\n', '                self._ensure_case(target)\\n', '        min_length = self._options.min_name_length\\n', '        if logical.is_too_short_name(name, min_length=min_length):\\n', '                    node, text=name, baseline=min_length,\\n', '        max_length = self._options.max_name_length\\n', '        if logical.is_too_long_name(name, max_length=max_length):\\n', '                    node, text=name, baseline=max_length,\\n', '        unreadable_sequence = alphabet.get_unreadable_characters(\\n', '        if unreadable_sequence:\\n', '                naming.UnreadableNameViolation(node, text=unreadable_sequence),\\n', '        for alias_node in node.names:\\n', '            if alias_node.asname:\\n', '                self._validator.check_name(node, alias_node.asname)\\n', '    def visit_variable(self, node: _VariableDef) -> None:\\n', '        variable_name = name_nodes.get_assigned_name(node)\\n', '        if variable_name is not None:\\n', '            self._validator.check_name(node, variable_name)\\n', '        targets = get_assign_targets(node)\\n', '        for target_node in targets:\\n', '            if not isinstance(target_node, ast.Name):\\n', '            if target_node.id not in MODULE_METADATA_VARIABLES_BLACKLIST:\\n', '                    node, text=target_node.id,\\n', '        names = list(name_nodes.flat_variable_names([node]))\\n', '        self._check_reassignment(node, names)\\n', '        self._check_unique_assignment(node, names)\\n', '        var_values = name_nodes.get_variables_from_node(node.value)\\n', '        for var_name, var_value in itertools.zip_longest(names, var_values):\\n', '            if var_name == var_value:\\n', '                        node, text=var_name,\\n', '        for used_name, count in Counter(names).items():\\n', '            if count > 1:\\n', '                        node, text=used_name,\\n', '        is_inside_class_or_module = isinstance(\\n', '            is_local=not is_inside_class_or_module,\\n']",
  "context": "edVariableIsDefinedViolation\n\n        \"\"\"\n        is_inside_class_or_module = isinstance(\n            nodes.get_context(node),\n            ("
 },
 "2557": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFor",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "419",
  "column": "28",
  "slicing": "['    def visit_any_for(self, node: AnyFor) -> None:\\n']",
  "context": ".generic_visit(node)\n\n    def visit_any_for(self, node: AnyFor) -> None:\n        \"\"\"\n        Checks that we cannot create e"
 },
 "2558": {
  "name": "is_target_no_op_variable",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "428",
  "column": "8",
  "slicing": "['        is_target_no_op_variable = (\\n', '        if not is_target_no_op_variable:  # see issue 1406\\n']",
  "context": "odes.get_variables_from_node(node.target)\n        is_target_no_op_variable = (\n            len(target_names) == 1 and access.is_u"
 },
 "2559": {
  "name": "all_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "470",
  "column": "8",
  "slicing": "['        all_names: Iterable[str],\\n']",
  "context": "sed(\n        self,\n        node: ast.AST,\n        all_names: Iterable[str],\n        *,\n        is_local: bool,\n    ) -> None:\n"
 },
 "2560": {
  "name": "all_names",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "474",
  "column": "8",
  "slicing": "['_VariableDef = Union[ast.Name, ast.Attribute, ast.ExceptHandler]\\n', '_ErrorCallback = Callable[[base.BaseViolation], None]\\n', '_PredicateCallback = Callable[[str], bool]\\n', '_Predicates = Mapping[_PredicateCallback, Type[base.BaseViolation]]\\n', '    _naming_predicates: ClassVar[_Predicates] = {\\n', '        error_callback: _ErrorCallback,\\n', '        for predicate, violation in self._naming_predicates.items():\\n', '            if predicate(name):\\n', '                self._error_callback(violation(node, text=name))\\n', '        for arg in functions.get_all_arguments(node):\\n', '            should_check_argument = (\\n', '                functions.is_first_argument(node, arg.arg) and\\n', '                arg, arg.arg, is_first_argument=should_check_argument,\\n', '        top_level_assigns = [\\n', '            for sub in ast.walk(node)\\n', '            if isinstance(sub, AssignNodes) and nodes.get_context(sub) is node\\n', '        for assignment in top_level_assigns:\\n', '            for target in get_assign_targets(assignment):\\n', '                self._ensure_case(target)\\n', '        min_length = self._options.min_name_length\\n', '        if logical.is_too_short_name(name, min_length=min_length):\\n', '                    node, text=name, baseline=min_length,\\n', '        max_length = self._options.max_name_length\\n', '        if logical.is_too_long_name(name, max_length=max_length):\\n', '                    node, text=name, baseline=max_length,\\n', '        unreadable_sequence = alphabet.get_unreadable_characters(\\n', '        if unreadable_sequence:\\n', '                naming.UnreadableNameViolation(node, text=unreadable_sequence),\\n', '        for alias_node in node.names:\\n', '            if alias_node.asname:\\n', '                self._validator.check_name(node, alias_node.asname)\\n', '    def visit_variable(self, node: _VariableDef) -> None:\\n', '        variable_name = name_nodes.get_assigned_name(node)\\n', '        if variable_name is not None:\\n', '            self._validator.check_name(node, variable_name)\\n', '        targets = get_assign_targets(node)\\n', '        for target_node in targets:\\n', '            if not isinstance(target_node, ast.Name):\\n', '            if target_node.id not in MODULE_METADATA_VARIABLES_BLACKLIST:\\n', '                    node, text=target_node.id,\\n', '        names = list(name_nodes.flat_variable_names([node]))\\n', '        self._check_reassignment(node, names)\\n', '        self._check_unique_assignment(node, names)\\n', '        var_values = name_nodes.get_variables_from_node(node.value)\\n', '        for var_name, var_value in itertools.zip_longest(names, var_values):\\n', '            if var_name == var_value:\\n', '                        node, text=var_name,\\n', '        for used_name, count in Counter(names).items():\\n', '            if count > 1:\\n', '                        node, text=used_name,\\n', '        is_inside_class_or_module = isinstance(\\n', '            is_local=not is_inside_class_or_module,\\n', '        target_names = name_nodes.get_variables_from_node(node.target)\\n', '        is_target_no_op_variable = (\\n', '            len(target_names) == 1 and access.is_unused(target_names[0])\\n', '        if not is_target_no_op_variable:  # see issue 1406\\n', '                target_names,\\n', '        all_names = list(all_names)  # we are using it twice\\n', '            for vn in all_names\\n', '        if all_names and all_unused:\\n', \"                    node, text=', '.join(all_names),\\n\"]",
  "context": "*,\n        is_local: bool,\n    ) -> None:\n        all_names = list(all_names)  # we are using it twice\n        all_unused = all(\n            is_local if "
 },
 "2561": {
  "name": "all_unused",
  "type": "all",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "475",
  "column": "8",
  "slicing": "['_VariableDef = Union[ast.Name, ast.Attribute, ast.ExceptHandler]\\n', '_ErrorCallback = Callable[[base.BaseViolation], None]\\n', '_PredicateCallback = Callable[[str], bool]\\n', '_Predicates = Mapping[_PredicateCallback, Type[base.BaseViolation]]\\n', '    _naming_predicates: ClassVar[_Predicates] = {\\n', '        error_callback: _ErrorCallback,\\n', '        for predicate, violation in self._naming_predicates.items():\\n', '            if predicate(name):\\n', '                self._error_callback(violation(node, text=name))\\n', '        for arg in functions.get_all_arguments(node):\\n', '            should_check_argument = (\\n', '                functions.is_first_argument(node, arg.arg) and\\n', '                arg, arg.arg, is_first_argument=should_check_argument,\\n', '        top_level_assigns = [\\n', '            for sub in ast.walk(node)\\n', '            if isinstance(sub, AssignNodes) and nodes.get_context(sub) is node\\n', '        for assignment in top_level_assigns:\\n', '            for target in get_assign_targets(assignment):\\n', '                self._ensure_case(target)\\n', '        min_length = self._options.min_name_length\\n', '        if logical.is_too_short_name(name, min_length=min_length):\\n', '                    node, text=name, baseline=min_length,\\n', '        max_length = self._options.max_name_length\\n', '        if logical.is_too_long_name(name, max_length=max_length):\\n', '                    node, text=name, baseline=max_length,\\n', '        unreadable_sequence = alphabet.get_unreadable_characters(\\n', '        if unreadable_sequence:\\n', '                naming.UnreadableNameViolation(node, text=unreadable_sequence),\\n', '        for alias_node in node.names:\\n', '            if alias_node.asname:\\n', '                self._validator.check_name(node, alias_node.asname)\\n', '    def visit_variable(self, node: _VariableDef) -> None:\\n', '        variable_name = name_nodes.get_assigned_name(node)\\n', '        if variable_name is not None:\\n', '            self._validator.check_name(node, variable_name)\\n', '        targets = get_assign_targets(node)\\n', '        for target_node in targets:\\n', '            if not isinstance(target_node, ast.Name):\\n', '            if target_node.id not in MODULE_METADATA_VARIABLES_BLACKLIST:\\n', '                    node, text=target_node.id,\\n', '        names = list(name_nodes.flat_variable_names([node]))\\n', '        self._check_reassignment(node, names)\\n', '        self._check_unique_assignment(node, names)\\n', '        var_values = name_nodes.get_variables_from_node(node.value)\\n', '        for var_name, var_value in itertools.zip_longest(names, var_values):\\n', '            if var_name == var_value:\\n', '                        node, text=var_name,\\n', '        for used_name, count in Counter(names).items():\\n', '            if count > 1:\\n', '                        node, text=used_name,\\n', '        is_inside_class_or_module = isinstance(\\n', '            is_local=not is_inside_class_or_module,\\n', '        target_names = name_nodes.get_variables_from_node(node.target)\\n', '        is_target_no_op_variable = (\\n', '            len(target_names) == 1 and access.is_unused(target_names[0])\\n', '        if not is_target_no_op_variable:  # see issue 1406\\n', '                target_names,\\n', '        all_names = list(all_names)  # we are using it twice\\n', '        all_unused = all(\\n', '            for vn in all_names\\n', '        if all_names and all_unused:\\n', \"                    node, text=', '.join(all_names),\\n\"]",
  "context": " list(all_names)  # we are using it twice\n        all_unused = all(\n            is_local if access.is_protected(vn) el"
 },
 "2562": {
  "name": "assigned_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/naming.py",
  "lineno": "508",
  "column": "8",
  "slicing": "['        assigned_name: str,\\n']",
  "context": "sed(\n        self,\n        node: ast.AST,\n        assigned_name: str,\n        *,\n        is_created: bool,\n    ) -> None"
 },
 "2563": {
  "name": "_mutable_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/modules.py",
  "lineno": "104",
  "column": "4",
  "slicing": "['    _mutable_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": "\n    \"\"\"Finds incorrect module constants.\"\"\"\n\n    _mutable_nodes: ClassVar[AnyNodes] = (\n        ast.Dict,\n        ast.List,\n        ast.Se"
 },
 "2564": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyAssign",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/modules.py",
  "lineno": "113",
  "column": "31",
  "slicing": "['    def visit_any_assign(self, node: AnyAssign) -> None:\\n']",
  "context": "st.SetComp,\n    )\n\n    def visit_any_assign(self, node: AnyAssign) -> None:\n        \"\"\"\n        Checks that module's cannot ha"
 },
 "2565": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyAssign",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/modules.py",
  "lineno": "124",
  "column": "38",
  "slicing": "['    def _check_mutable_constant(self, node: AnyAssign) -> None:\\n']",
  "context": "isit(node)\n\n    def _check_mutable_constant(self, node: AnyAssign) -> None:\n        if not isinstance(get_context(node), ast.M"
 },
 "2566": {
  "name": "targets",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/modules.py",
  "lineno": "129",
  "column": "12",
  "slicing": "['            targets = [node.target]\\n', '        for target in targets:\\n', '            if not isinstance(target, ast.Name) or not is_constant(target.id):\\n', '                self.add_violation(MutableModuleConstantViolation(target))\\n']",
  "context": "  if isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n        else:\n            targets = node.targets\n\n"
 },
 "2567": {
  "name": "_allowed_body_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    _allowed_body_nodes: ClassVar[types.AnyNodes] = (\\n']",
  "context": "tylistic issues and design patterns.\n    \"\"\"\n\n    _allowed_body_nodes: ClassVar[types.AnyNodes] = (\n        *FunctionNodes,\n        ast.ClassDef,  # w"
 },
 "2568": {
  "name": "id_attr",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "74",
  "column": "8",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n']",
  "context": "      base_name: ast.expr,\n    ) -> None:\n        id_attr = getattr(base_name, 'id', None)\n\n        if id_attr == 'BaseException':\n          "
 },
 "2569": {
  "name": "parts",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "106",
  "column": "12",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n']",
  "context": "sinstance(base_class, ast.Subscript):\n            parts = list(attributes.parts(base_class))\n            subscripts = list(filter(\n            "
 },
 "2570": {
  "name": "subscripts",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "107",
  "column": "12",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '            subscripts = list(filter(\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n', '            return len(subscripts) == 1 and correct_items\\n']",
  "context": " = list(attributes.parts(base_class))\n            subscripts = list(filter(\n                lambda part: isinstance(part, ast."
 },
 "2571": {
  "name": "correct_items",
  "type": "all",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "110",
  "column": "12",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '            correct_items = all(\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n', '            return len(subscripts) == 1 and correct_items\\n']",
  "context": "ast.Subscript), parts,\n            ))\n            correct_items = all(\n                isinstance(sub_node, (ast.Name, as"
 },
 "2572": {
  "name": "_staticmethod_names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "127",
  "column": "4",
  "slicing": "['    _staticmethod_names: ClassVar[FrozenSet[str]] = frozenset((\\n']",
  "context": "ts functions, but treats them as methods.\"\"\"\n\n    _staticmethod_names: ClassVar[FrozenSet[str]] = frozenset((\n        'staticmethod',\n    ))\n\n    def visit_any_"
 },
 "2573": {
  "name": "decorator_name",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "151",
  "column": "12",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '            subscripts = list(filter(\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '            correct_items = all(\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n', '            return len(subscripts) == 1 and correct_items\\n', '        for decorator in node.decorator_list:\\n', \"            decorator_name = getattr(decorator, 'id', None)\\n\", '            if decorator_name in self._staticmethod_names:\\n']",
  "context": "for decorator in node.decorator_list:\n            decorator_name = getattr(decorator, 'id', None)\n            if decorator_name in self._staticmetho"
 },
 "2574": {
  "name": "is_async",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "170",
  "column": "8",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '            subscripts = list(filter(\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '            correct_items = all(\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n', '            return len(subscripts) == 1 and correct_items\\n', '        for decorator in node.decorator_list:\\n', \"            decorator_name = getattr(decorator, 'id', None)\\n\", '            if decorator_name in self._staticmethod_names:\\n', '        node_context = nodes.get_context(node)\\n', '        if not isinstance(node_context, ast.ClassDef):\\n', '        is_async = isinstance(node, ast.AsyncFunctionDef)\\n', '        if is_async and access.is_magic(node.name):\\n', '            class_name=node_context.name,\\n']",
  "context": "ion(node, text=node.name),\n            )\n\n        is_async = isinstance(node, ast.AsyncFunctionDef)\n        if is_async and access.is_magic(node.name)"
 },
 "2575": {
  "name": "statements_number",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "204",
  "column": "8",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '            subscripts = list(filter(\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '            correct_items = all(\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n', '            return len(subscripts) == 1 and correct_items\\n', '        for decorator in node.decorator_list:\\n', \"            decorator_name = getattr(decorator, 'id', None)\\n\", '            if decorator_name in self._staticmethod_names:\\n', '        node_context = nodes.get_context(node)\\n', '        if not isinstance(node_context, ast.ClassDef):\\n', '        is_async = isinstance(node, ast.AsyncFunctionDef)\\n', '        if is_async and access.is_magic(node.name):\\n', '            class_name=node_context.name,\\n', '        statements_number = len(node.body)\\n', '        if statements_number > 2 or statements_number == 0:\\n', '        if statements_number == 2:\\n']",
  "context": "ython-styleguide/issues/1168\n\n        \"\"\"\n        statements_number = len(node.body)\n        if statements_number > 2 or statements_num"
 },
 "2576": {
  "name": "stmt",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "212",
  "column": "8",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '            subscripts = list(filter(\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '            correct_items = all(\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n', '            return len(subscripts) == 1 and correct_items\\n', '        for decorator in node.decorator_list:\\n', \"            decorator_name = getattr(decorator, 'id', None)\\n\", '            if decorator_name in self._staticmethod_names:\\n', '        node_context = nodes.get_context(node)\\n', '        if not isinstance(node_context, ast.ClassDef):\\n', '        is_async = isinstance(node, ast.AsyncFunctionDef)\\n', '        if is_async and access.is_magic(node.name):\\n', '            class_name=node_context.name,\\n', '        statements_number = len(node.body)\\n', '        if statements_number > 2 or statements_number == 0:\\n', '        if statements_number == 2:\\n', '        stmt = node.body[-1]\\n', '        if isinstance(stmt, ast.Return):\\n', '            call_stmt = stmt.value\\n', '            return call_stmt if isinstance(call_stmt, ast.Call) else None\\n', '        elif isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Call):\\n', '            return stmt.value\\n', '        call_stmt = self._get_call_stmt_of_useless_method(node)\\n', '        if call_stmt is None or not isinstance(call_stmt.func, ast.Attribute):\\n', '        attribute = call_stmt.func\\n', '        if defined_method_name != attribute.attr:\\n', '        if not super_args.is_ordinary_super_call(attribute.value, class_name):\\n', '        if not function_args.is_call_matched_by_arguments(node, call_stmt):\\n']",
  "context": "de.body[0]):\n                return None\n\n        stmt = node.body[-1]\n        if isinstance(stmt, ast.Return):\n         "
 },
 "2577": {
  "name": "class_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "223",
  "column": "8",
  "slicing": "['        class_name: str,\\n']",
  "context": "self,\n        node: types.AnyFunctionDef,\n        class_name: str,\n    ) -> None:\n        if node.decorator_list:\n   "
 },
 "2578": {
  "name": "_whitelisted_slots_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "259",
  "column": "4",
  "slicing": "['    _whitelisted_slots_nodes: ClassVar[types.AnyNodes] = (\\n']",
  "context": "Visitor):\n    \"\"\"Visits class attributes.\"\"\"\n\n    _whitelisted_slots_nodes: ClassVar[types.AnyNodes] = (\n        ast.Tuple,\n        ast.Attribute,\n        "
 },
 "2579": {
  "name": "fields",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "289",
  "column": "8",
  "slicing": "['        fields: DefaultDict[str, List[ast.AST]] = defaultdict(list)\\n', '            fields[slot_name].append(tuple_item)\\n', '        for slots in fields.values():\\n', '            if not self._are_correct_slots(slots) or len(slots) > 1:\\n', '            for slot in slots\\n', '            if isinstance(slot, ast.Str)\\n']",
  "context": "      elements: ast.Tuple,\n    ) -> None:\n        fields: DefaultDict[str, List[ast.AST]] = defaultdict(list)\n\n        for tuple_item in elements.elts:\n        "
 },
 "2580": {
  "name": "slots",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "324",
  "column": "33",
  "slicing": "['    def _are_correct_slots(self, slots: List[ast.AST]) -> bool:\\n']",
  "context": "    return None\n\n    def _are_correct_slots(self, slots: List[ast.AST]) -> bool:\n        return all(\n            slot.s.isidentifie"
 },
 "2581": {
  "name": "class_attribute_names",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "349",
  "column": "8",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '            subscripts = list(filter(\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '            correct_items = all(\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n', '            return len(subscripts) == 1 and correct_items\\n', '        for decorator in node.decorator_list:\\n', \"            decorator_name = getattr(decorator, 'id', None)\\n\", '            if decorator_name in self._staticmethod_names:\\n', '        node_context = nodes.get_context(node)\\n', '        if not isinstance(node_context, ast.ClassDef):\\n', '        is_async = isinstance(node, ast.AsyncFunctionDef)\\n', '        if is_async and access.is_magic(node.name):\\n', '            class_name=node_context.name,\\n', '        statements_number = len(node.body)\\n', '        if statements_number > 2 or statements_number == 0:\\n', '        if statements_number == 2:\\n', '        stmt = node.body[-1]\\n', '        if isinstance(stmt, ast.Return):\\n', '            call_stmt = stmt.value\\n', '            return call_stmt if isinstance(call_stmt, ast.Call) else None\\n', '        elif isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Call):\\n', '            return stmt.value\\n', '        call_stmt = self._get_call_stmt_of_useless_method(node)\\n', '        if call_stmt is None or not isinstance(call_stmt.func, ast.Attribute):\\n', '        attribute = call_stmt.func\\n', '        defined_method_name = node.name\\n', '        if defined_method_name != attribute.attr:\\n', '        if not super_args.is_ordinary_super_call(attribute.value, class_name):\\n', '        if not function_args.is_call_matched_by_arguments(node, call_stmt):\\n', '                node, text=defined_method_name,\\n', '        for target in get_assign_targets(node):\\n', \"            if isinstance(target, ast.Name) and target.id == '__slots__':\\n\", '        fields: DefaultDict[str, List[ast.AST]] = defaultdict(list)\\n', '        for tuple_item in elements.elts:\\n', '            slot_name = self._slot_item_name(tuple_item)\\n', '            if not slot_name:\\n', '                self.add_violation(oop.WrongSlotsViolation(tuple_item))\\n', '            fields[slot_name].append(tuple_item)\\n', '        for slots in fields.values():\\n', '            if not self._are_correct_slots(slots) or len(slots) > 1:\\n', '            for slot in slots\\n', '            if isinstance(slot, ast.Str)\\n', '        class_attributes, instance_attributes = classes.get_attributes(node)\\n', '        class_attribute_names = set(\\n', '            name_nodes.flat_variable_names(class_attributes),\\n', '            if instance_attr.attr in class_attribute_names:\\n']",
  "context": "attributes = classes.get_attributes(node)\n        class_attribute_names = set(\n            name_nodes.flat_variable_names(class_a"
 },
 "2582": {
  "name": "method_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "379",
  "column": "8",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '            subscripts = list(filter(\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '            correct_items = all(\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n', '            return len(subscripts) == 1 and correct_items\\n', '        for decorator in node.decorator_list:\\n', \"            decorator_name = getattr(decorator, 'id', None)\\n\", '            if decorator_name in self._staticmethod_names:\\n', '        node_context = nodes.get_context(node)\\n', '        if not isinstance(node_context, ast.ClassDef):\\n', '        is_async = isinstance(node, ast.AsyncFunctionDef)\\n', '        if is_async and access.is_magic(node.name):\\n', '            class_name=node_context.name,\\n', '        statements_number = len(node.body)\\n', '        if statements_number > 2 or statements_number == 0:\\n', '        if statements_number == 2:\\n', '        stmt = node.body[-1]\\n', '        if isinstance(stmt, ast.Return):\\n', '            call_stmt = stmt.value\\n', '            return call_stmt if isinstance(call_stmt, ast.Call) else None\\n', '        elif isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Call):\\n', '            return stmt.value\\n', '        call_stmt = self._get_call_stmt_of_useless_method(node)\\n', '        if call_stmt is None or not isinstance(call_stmt.func, ast.Attribute):\\n', '        attribute = call_stmt.func\\n', '        defined_method_name = node.name\\n', '        if defined_method_name != attribute.attr:\\n', '        if not super_args.is_ordinary_super_call(attribute.value, class_name):\\n', '        if not function_args.is_call_matched_by_arguments(node, call_stmt):\\n', '                node, text=defined_method_name,\\n', '        for target in get_assign_targets(node):\\n', \"            if isinstance(target, ast.Name) and target.id == '__slots__':\\n\", '        fields: DefaultDict[str, List[ast.AST]] = defaultdict(list)\\n', '        for tuple_item in elements.elts:\\n', '            slot_name = self._slot_item_name(tuple_item)\\n', '            if not slot_name:\\n', '                self.add_violation(oop.WrongSlotsViolation(tuple_item))\\n', '            fields[slot_name].append(tuple_item)\\n', '        for slots in fields.values():\\n', '            if not self._are_correct_slots(slots) or len(slots) > 1:\\n', '            for slot in slots\\n', '            if isinstance(slot, ast.Str)\\n', '        class_attributes, instance_attributes = classes.get_attributes(node)\\n', '        class_attribute_names = set(\\n', '            name_nodes.flat_variable_names(class_attributes),\\n', '        for instance_attr in instance_attributes:\\n', '            if instance_attr.attr in class_attribute_names:\\n', '                        instance_attr,\\n', '                        text=instance_attr.attr,\\n', '        method_nodes: List[str] = []\\n', '        for subnode in ast.walk(node):\\n', '            if isinstance(subnode, FunctionNodes):\\n', '                if nodes.get_context(subnode) == node:\\n', '                    method_nodes.append(subnode.name)\\n', '        ideal = sorted(method_nodes, key=self._ideal_order, reverse=True)\\n', '        for existing_order, ideal_order in zip(method_nodes, ideal):\\n', '            if existing_order != ideal_order:\\n']",
  "context": "_order(self, node: ast.ClassDef) -> None:\n        method_nodes: List[str] = []\n\n        for subnode in ast.walk(node):\n          "
 },
 "2583": {
  "name": "ideal",
  "type": "sorted",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "386",
  "column": "8",
  "slicing": "['        for base_name in node.bases:\\n', '            if not self._is_correct_base_class(base_name):\\n', '                self.add_violation(oop.WrongBaseClassViolation(base_name))\\n', '            self._check_base_classes_rules(node, base_name)\\n', \"        id_attr = getattr(base_name, 'id', None)\\n\", \"        if id_attr == 'BaseException':\\n\", \"        elif id_attr == 'object' and len(node.bases) >= 2:\\n\", '                    node, text=id_attr,\\n', '        elif classes.is_forbidden_super_class(id_attr):\\n', '                oop.BuiltinSubclassViolation(node, text=id_attr),\\n', '        for sub_node in node.body:\\n', '            if isinstance(sub_node, self._allowed_body_nodes):\\n', '            if strings.is_doc_string(sub_node):\\n', '            self.add_violation(oop.WrongClassBodyContentViolation(sub_node))\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute))\\n', '                for sub_node in attributes.parts(base_class)\\n', '            parts = list(attributes.parts(base_class))\\n', '            subscripts = list(filter(\\n', '                lambda part: isinstance(part, ast.Subscript), parts,\\n', '            correct_items = all(\\n', '                isinstance(sub_node, (ast.Name, ast.Attribute, ast.Subscript))\\n', '                for sub_node in parts\\n', '            return len(subscripts) == 1 and correct_items\\n', '        for decorator in node.decorator_list:\\n', \"            decorator_name = getattr(decorator, 'id', None)\\n\", '            if decorator_name in self._staticmethod_names:\\n', '        node_context = nodes.get_context(node)\\n', '        if not isinstance(node_context, ast.ClassDef):\\n', '        is_async = isinstance(node, ast.AsyncFunctionDef)\\n', '        if is_async and access.is_magic(node.name):\\n', '            class_name=node_context.name,\\n', '        statements_number = len(node.body)\\n', '        if statements_number > 2 or statements_number == 0:\\n', '        if statements_number == 2:\\n', '        stmt = node.body[-1]\\n', '        if isinstance(stmt, ast.Return):\\n', '            call_stmt = stmt.value\\n', '            return call_stmt if isinstance(call_stmt, ast.Call) else None\\n', '        elif isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Call):\\n', '            return stmt.value\\n', '        call_stmt = self._get_call_stmt_of_useless_method(node)\\n', '        if call_stmt is None or not isinstance(call_stmt.func, ast.Attribute):\\n', '        attribute = call_stmt.func\\n', '        defined_method_name = node.name\\n', '        if defined_method_name != attribute.attr:\\n', '        if not super_args.is_ordinary_super_call(attribute.value, class_name):\\n', '        if not function_args.is_call_matched_by_arguments(node, call_stmt):\\n', '                node, text=defined_method_name,\\n', '        for target in get_assign_targets(node):\\n', \"            if isinstance(target, ast.Name) and target.id == '__slots__':\\n\", '        fields: DefaultDict[str, List[ast.AST]] = defaultdict(list)\\n', '        for tuple_item in elements.elts:\\n', '            slot_name = self._slot_item_name(tuple_item)\\n', '            if not slot_name:\\n', '                self.add_violation(oop.WrongSlotsViolation(tuple_item))\\n', '            fields[slot_name].append(tuple_item)\\n', '        for slots in fields.values():\\n', '            if not self._are_correct_slots(slots) or len(slots) > 1:\\n', '            for slot in slots\\n', '            if isinstance(slot, ast.Str)\\n', '        class_attributes, instance_attributes = classes.get_attributes(node)\\n', '        class_attribute_names = set(\\n', '            name_nodes.flat_variable_names(class_attributes),\\n', '        for instance_attr in instance_attributes:\\n', '            if instance_attr.attr in class_attribute_names:\\n', '                        instance_attr,\\n', '                        text=instance_attr.attr,\\n', '        method_nodes: List[str] = []\\n', '        for subnode in ast.walk(node):\\n', '            if isinstance(subnode, FunctionNodes):\\n', '                if nodes.get_context(subnode) == node:\\n', '                    method_nodes.append(subnode.name)\\n', '        ideal = sorted(method_nodes, key=self._ideal_order, reverse=True)\\n', '        for existing_order, ideal_order in zip(method_nodes, ideal):\\n', '            if existing_order != ideal_order:\\n']",
  "context": "       method_nodes.append(subnode.name)\n\n        ideal = sorted(method_nodes, key=self._ideal_order, reverse=True)\n        for existing_order, ideal_order in zip(met"
 },
 "2584": {
  "name": "first",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "392",
  "column": "27",
  "slicing": "['    def _ideal_order(self, first: str) -> int:\\n']",
  "context": "               return\n\n    def _ideal_order(self, first: str) -> int:\n        base_methods_order = {\n            '__new_"
 },
 "2585": {
  "name": "base_methods_order",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/classes.py",
  "lineno": "393",
  "column": "8",
  "slicing": "['        base_methods_order = {\\n', '        return base_methods_order.get(first, public_and_magic_methods_priority)\\n']",
  "context": "ef _ideal_order(self, first: str) -> int:\n        base_methods_order = {\n            '__new__': 6,  # highest priority\n    "
 },
 "2586": {
  "name": "_AnyFunctionCounter",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "28",
  "column": "0",
  "slicing": "['_AnyFunctionCounter = Union[FunctionCounter, FunctionCounterWithLambda]\\n', '_CheckRule = Tuple[_AnyFunctionCounter, int, Type[BaseViolation]]\\n', '    def _function_checks(self) -> List[_CheckRule]:\\n']",
  "context": "isitors.decorators import alias\n\n# Type aliases:\n\n_AnyFunctionCounter = Union[FunctionCounter, FunctionCounterWithLambda]\n_CheckRule = Tuple[_AnyFunctionCounter, int, Type["
 },
 "2587": {
  "name": "_CheckRule",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "29",
  "column": "0",
  "slicing": "['_AnyFunctionCounter = Union[FunctionCounter, FunctionCounterWithLambda]\\n', '_CheckRule = Tuple[_AnyFunctionCounter, int, Type[BaseViolation]]\\n', '    def _function_checks(self) -> List[_CheckRule]:\\n']",
  "context": "Union[FunctionCounter, FunctionCounterWithLambda]\n_CheckRule = Tuple[_AnyFunctionCounter, int, Type[BaseViolation]]\n_NodeTypeHandler = Mapping[\n    Union[type, Tuple["
 },
 "2588": {
  "name": "_NodeTypeHandler",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "30",
  "column": "0",
  "slicing": "['_AnyFunctionCounter = Union[FunctionCounter, FunctionCounterWithLambda]\\n', '_CheckRule = Tuple[_AnyFunctionCounter, int, Type[BaseViolation]]\\n', '_NodeTypeHandler = Mapping[\\n', '        error_counters: _NodeTypeHandler = {\\n', '        for types, counter in error_counters.items():\\n', '            if isinstance(sub_node, types):\\n', '                counter[node] += 1\\n', '            for node, count in counter.items():\\n', '                if count > limit:\\n', '                        violation(node, text=str(count), baseline=limit),\\n', '    def _function_checks(self) -> List[_CheckRule]:\\n', '        self._functions[node] = cognitive.cognitive_score(node)\\n', '        self.generic_visit(node)\\n']",
  "context": "le[_AnyFunctionCounter, int, Type[BaseViolation]]\n_NodeTypeHandler = Mapping[\n    Union[type, Tuple[type, ...]],\n    FunctionCou"
 },
 "2589": {
  "name": "_not_contain_locals",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['    _not_contain_locals: ClassVar[AnyNodes] = (\\n']",
  "context": "ss to encapsulate logic from the visitor.\"\"\"\n\n    _not_contain_locals: ClassVar[AnyNodes] = (\n        ast.comprehension,\n    )\n\n    def __init__"
 },
 "2590": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDefAndLambda",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "47",
  "column": "36",
  "slicing": "['    def check_arguments_count(self, node: AnyFunctionDefAndLambda) -> None:\\n']",
  "context": "ityMetrics()\n\n    def check_arguments_count(self, node: AnyFunctionDefAndLambda) -> None:\n        \"\"\"Checks the number of the arguments in a"
 },
 "2591": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "51",
  "column": "40",
  "slicing": "['    def check_function_complexity(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "s(node))\n\n    def check_function_complexity(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        In this function we iterate al"
 },
 "2592": {
  "name": "function",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "63",
  "column": "8",
  "slicing": "['        function: AnyFunctionDef,\\n']",
  "context": "\n    def _update_variables(\n        self,\n        function: AnyFunctionDef,\n        variable_def: ast.Name,\n    ) -> None:\n   "
 },
 "2593": {
  "name": "function_variables",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "72",
  "column": "8",
  "slicing": "['_AnyFunctionCounter = Union[FunctionCounter, FunctionCounterWithLambda]\\n', '_CheckRule = Tuple[_AnyFunctionCounter, int, Type[BaseViolation]]\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                self._check_sub_node(node, sub_node)\\n', '        function_variables = self.metrics.variables[function]\\n', '        if variable_def.id not in function_variables:\\n', '            function_variables.append(variable_def.id)\\n', '        if isinstance(sub_node, ast.Name):\\n', '            if isinstance(sub_node.ctx, ast.Store):\\n', '                self._update_variables(node, sub_node)\\n', '            if isinstance(sub_node, types):\\n', '    def _function_checks(self) -> List[_CheckRule]:\\n']",
  "context": "alsViolation`` documentation.\n        \"\"\"\n        function_variables = self.metrics.variables[function]\n        if variable_def.id not in function_variabl"
 },
 "2594": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "77",
  "column": "12",
  "slicing": "['_AnyFunctionCounter = Union[FunctionCounter, FunctionCounterWithLambda]\\n', '_CheckRule = Tuple[_AnyFunctionCounter, int, Type[BaseViolation]]\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                self._check_sub_node(node, sub_node)\\n', '        function_variables = self.metrics.variables[function]\\n', '        if variable_def.id not in function_variables:\\n', '            parent = get_parent(variable_def)\\n', '            if isinstance(parent, no_locals):\\n', '            function_variables.append(variable_def.id)\\n', '        if isinstance(sub_node, ast.Name):\\n', '            if isinstance(sub_node.ctx, ast.Store):\\n', '                self._update_variables(node, sub_node)\\n', '            if isinstance(sub_node, types):\\n', '    def _function_checks(self) -> List[_CheckRule]:\\n']",
  "context": "able_def.id):\n                return\n\n            parent = get_parent(variable_def)\n            no_locals = self._not_contain_locals\n "
 },
 "2595": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "86",
  "column": "8",
  "slicing": "['        node: AnyFunctionDef,\\n']",
  "context": ")\n\n    def _check_sub_node(\n        self,\n        node: AnyFunctionDef,\n        sub_node: ast.AST,\n    ) -> None:\n        "
 },
 "2596": {
  "name": "error_counters",
  "type": "_NodeTypeHandler",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "93",
  "column": "8",
  "slicing": "['        error_counters: _NodeTypeHandler = {\\n', '        for types, counter in error_counters.items():\\n', '            if isinstance(sub_node, types):\\n', '                counter[node] += 1\\n', '            for node, count in counter.items():\\n', '                if count > limit:\\n', '                        violation(node, text=str(count), baseline=limit),\\n', '        self._functions[node] = cognitive.cognitive_score(node)\\n', '        self.generic_visit(node)\\n']",
  "context": "  self._update_variables(node, sub_node)\n\n        error_counters: _NodeTypeHandler = {\n            ast.Return: self.metrics.returns,\n    "
 },
 "2597": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "129",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "lexityCounter()\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        Checks function's internal com"
 },
 "2598": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "233",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "efaultdict(int)\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        Counts cognitive complexity.\n\n"
 },
 "2599": {
  "name": "total",
  "type": "score",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/function.py",
  "lineno": "251",
  "column": "12",
  "slicing": "['_AnyFunctionCounter = Union[FunctionCounter, FunctionCounterWithLambda]\\n', '_CheckRule = Tuple[_AnyFunctionCounter, int, Type[BaseViolation]]\\n', '_NodeTypeHandler = Mapping[\\n', '        for body_item in node.body:\\n', '            for sub_node in ast.walk(body_item):\\n', '                self._check_sub_node(node, sub_node)\\n', '        function_variables = self.metrics.variables[function]\\n', '        if variable_def.id not in function_variables:\\n', '            parent = get_parent(variable_def)\\n', '            no_locals = self._not_contain_locals\\n', '            if isinstance(parent, no_locals):\\n', '            function_variables.append(variable_def.id)\\n', '        if isinstance(sub_node, ast.Name):\\n', '            if isinstance(sub_node.ctx, ast.Store):\\n', '                self._update_variables(node, sub_node)\\n', '        error_counters: _NodeTypeHandler = {\\n', '        for types, counter in error_counters.items():\\n', '            if isinstance(sub_node, types):\\n', '                counter[node] += 1\\n', '        for var_node, variables in self._counter.metrics.variables.items():\\n', '            if len(variables) > self.options.max_local_variables:\\n', '                        var_node,\\n', '                        text=str(len(variables)),\\n', '        for exp_node, expressions in self._counter.metrics.expressions.items():\\n', '            if expressions > self.options.max_expressions:\\n', '                        exp_node,\\n', '                        text=str(expressions),\\n', '        for counter, limit, violation in self._function_checks():\\n', '            for node, count in counter.items():\\n', '                if count > limit:\\n', '                        violation(node, text=str(count), baseline=limit),\\n', '    def _function_checks(self) -> List[_CheckRule]:\\n', '        self._functions[node] = cognitive.cognitive_score(node)\\n', '        self.generic_visit(node)\\n', '        total = 0\\n', '        for function, score in self._functions.items():\\n', '            total += score\\n', '            if score > self.options.max_cognitive_score:\\n', '                        function,\\n', '                        text=str(score),\\n', '        average = total / len(self._functions)\\n', '        if average > self.options.max_cognitive_average:\\n', '                    text=str(round(average, 1)),\\n']",
  "context": "on, score in self._functions.items():\n            total += score\n\n            if score > self.options.max_cognitive"
 },
 "2600": {
  "name": "_ConditionNodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "16",
  "column": "0",
  "slicing": "['_ConditionNodes = Union[ast.If, ast.While, ast.IfExp]\\n']",
  "context": "visitors.decorators import alias\n\n# Type aliases:\n_ConditionNodes = Union[ast.If, ast.While, ast.IfExp]\n_ModuleMembers = Union[AnyFunctionDef, ast.ClassDe"
 },
 "2601": {
  "name": "_ModuleMembers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "17",
  "column": "0",
  "slicing": "['_ModuleMembers = Union[AnyFunctionDef, ast.ClassDef]\\n', '    def visit_module_members(self, node: _ModuleMembers) -> None:\\n', '    def _check_members_count(self, node: _ModuleMembers) -> None:\\n', '    def _check_decorators_count(self, node: _ModuleMembers) -> None:\\n']",
  "context": "ditionNodes = Union[ast.If, ast.While, ast.IfExp]\n_ModuleMembers = Union[AnyFunctionDef, ast.ClassDef]\n\n\n@final\n@alias('visit_module_members', (\n    'vis"
 },
 "2602": {
  "name": "node",
  "type": "_ModuleMembers",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "34",
  "column": "35",
  "slicing": "['    def visit_module_members(self, node: _ModuleMembers) -> None:\\n']",
  "context": "ems_count = 0\n\n    def visit_module_members(self, node: _ModuleMembers) -> None:\n        \"\"\"\n        Counts the number of _ModuleMe"
 },
 "2603": {
  "name": "node",
  "type": "_ModuleMembers",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "46",
  "column": "35",
  "slicing": "['    def _check_members_count(self, node: _ModuleMembers) -> None:\\n']",
  "context": "c_visit(node)\n\n    def _check_members_count(self, node: _ModuleMembers) -> None:\n        \"\"\"This method increases the number of mod"
 },
 "2604": {
  "name": "is_real_method",
  "type": "wemake_python_styleguide.logic.tree.functions.is_method",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "48",
  "column": "8",
  "slicing": "['_ModuleMembers = Union[AnyFunctionDef, ast.ClassDef]\\n', '    def visit_module_members(self, node: _ModuleMembers) -> None:\\n', '    def _check_members_count(self, node: _ModuleMembers) -> None:\\n', \"        is_real_method = is_method(getattr(node, 'function_type', None))\\n\", '        if isinstance(get_parent(node), ast.Module) and not is_real_method:\\n', '    def _check_decorators_count(self, node: _ModuleMembers) -> None:\\n']",
  "context": "ncreases the number of module members.\"\"\"\n        is_real_method = is_method(getattr(node, 'function_type', None))\n\n        if isinstance(get_parent(node), ast.Modul"
 },
 "2605": {
  "name": "node",
  "type": "_ModuleMembers",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "53",
  "column": "38",
  "slicing": "['    def _check_decorators_count(self, node: _ModuleMembers) -> None:\\n']",
  "context": "count += 1\n\n    def _check_decorators_count(self, node: _ModuleMembers) -> None:\n        number_of_decorators = len(node.decorator_"
 },
 "2606": {
  "name": "number_of_decorators",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "54",
  "column": "8",
  "slicing": "['_ModuleMembers = Union[AnyFunctionDef, ast.ClassDef]\\n', '    def visit_module_members(self, node: _ModuleMembers) -> None:\\n', '    def _check_members_count(self, node: _ModuleMembers) -> None:\\n', \"        is_real_method = is_method(getattr(node, 'function_type', None))\\n\", '        if isinstance(get_parent(node), ast.Module) and not is_real_method:\\n', '    def _check_decorators_count(self, node: _ModuleMembers) -> None:\\n', '        number_of_decorators = len(node.decorator_list)\\n', '        if number_of_decorators > self.options.max_decorators:\\n', '                    text=str(number_of_decorators),\\n']",
  "context": "ount(self, node: _ModuleMembers) -> None:\n        number_of_decorators = len(node.decorator_list)\n        if number_of_decorators > self.options.max"
 },
 "2607": {
  "name": "is_all_equals",
  "type": "all",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "121",
  "column": "8",
  "slicing": "['_ModuleMembers = Union[AnyFunctionDef, ast.ClassDef]\\n', '    def visit_module_members(self, node: _ModuleMembers) -> None:\\n', '    def _check_members_count(self, node: _ModuleMembers) -> None:\\n', \"        is_real_method = is_method(getattr(node, 'function_type', None))\\n\", '        if isinstance(get_parent(node), ast.Module) and not is_real_method:\\n', '    def _check_decorators_count(self, node: _ModuleMembers) -> None:\\n', '        number_of_decorators = len(node.decorator_list)\\n', '        if number_of_decorators > self.options.max_decorators:\\n', '                    text=str(number_of_decorators),\\n', '        counter = 0\\n', '        for condition in node.values:\\n', '            if isinstance(condition, ast.BoolOp):\\n', '                counter += self._count_conditions(condition)\\n', '                counter += 1\\n', '        return counter\\n', '        conditions_count = self._count_conditions(node)\\n', '        if conditions_count > constants.MAX_CONDITIONS:\\n', '                    text=str(conditions_count),\\n', '        is_all_equals = all(isinstance(op, ast.Eq) for op in node.ops)\\n', '        is_all_notequals = all(isinstance(op, ast.NotEq) for op in node.ops)\\n', '        can_be_longer = is_all_notequals or is_all_equals\\n', '        if can_be_longer:\\n']",
  "context": "ompares(self, node: ast.Compare) -> None:\n        is_all_equals = all(isinstance(op, ast.Eq) for op in node.ops)\n        is_all_notequals = all(isinstance(op, ast."
 },
 "2608": {
  "name": "is_all_notequals",
  "type": "all",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "122",
  "column": "8",
  "slicing": "['_ModuleMembers = Union[AnyFunctionDef, ast.ClassDef]\\n', '    def visit_module_members(self, node: _ModuleMembers) -> None:\\n', '    def _check_members_count(self, node: _ModuleMembers) -> None:\\n', \"        is_real_method = is_method(getattr(node, 'function_type', None))\\n\", '        if isinstance(get_parent(node), ast.Module) and not is_real_method:\\n', '    def _check_decorators_count(self, node: _ModuleMembers) -> None:\\n', '        number_of_decorators = len(node.decorator_list)\\n', '        if number_of_decorators > self.options.max_decorators:\\n', '                    text=str(number_of_decorators),\\n', '        counter = 0\\n', '        for condition in node.values:\\n', '            if isinstance(condition, ast.BoolOp):\\n', '                counter += self._count_conditions(condition)\\n', '                counter += 1\\n', '        return counter\\n', '        conditions_count = self._count_conditions(node)\\n', '        if conditions_count > constants.MAX_CONDITIONS:\\n', '                    text=str(conditions_count),\\n', '        is_all_equals = all(isinstance(op, ast.Eq) for op in node.ops)\\n', '        is_all_notequals = all(isinstance(op, ast.NotEq) for op in node.ops)\\n', '        can_be_longer = is_all_notequals or is_all_equals\\n', '        if can_be_longer:\\n']",
  "context": "sinstance(op, ast.Eq) for op in node.ops)\n        is_all_notequals = all(isinstance(op, ast.NotEq) for op in node.ops)\n        can_be_longer = is_all_notequals or is_all"
 },
 "2609": {
  "name": "can_be_longer",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "123",
  "column": "8",
  "slicing": "['_ModuleMembers = Union[AnyFunctionDef, ast.ClassDef]\\n', '    def visit_module_members(self, node: _ModuleMembers) -> None:\\n', '    def _check_members_count(self, node: _ModuleMembers) -> None:\\n', \"        is_real_method = is_method(getattr(node, 'function_type', None))\\n\", '        if isinstance(get_parent(node), ast.Module) and not is_real_method:\\n', '    def _check_decorators_count(self, node: _ModuleMembers) -> None:\\n', '        number_of_decorators = len(node.decorator_list)\\n', '        if number_of_decorators > self.options.max_decorators:\\n', '                    text=str(number_of_decorators),\\n', '        counter = 0\\n', '        for condition in node.values:\\n', '            if isinstance(condition, ast.BoolOp):\\n', '                counter += self._count_conditions(condition)\\n', '                counter += 1\\n', '        return counter\\n', '        conditions_count = self._count_conditions(node)\\n', '        if conditions_count > constants.MAX_CONDITIONS:\\n', '                    text=str(conditions_count),\\n', '        is_all_equals = all(isinstance(op, ast.Eq) for op in node.ops)\\n', '        is_all_notequals = all(isinstance(op, ast.NotEq) for op in node.ops)\\n', '        can_be_longer = is_all_notequals or is_all_equals\\n', '        if can_be_longer:\\n']",
  "context": "stance(op, ast.NotEq) for op in node.ops)\n        can_be_longer = is_all_notequals or is_all_equals\n\n        threshold = constants.MAX_COMPARES\n      "
 },
 "2610": {
  "name": "has_elif",
  "type": "all",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "173",
  "column": "8",
  "slicing": "['_ModuleMembers = Union[AnyFunctionDef, ast.ClassDef]\\n', '    def visit_module_members(self, node: _ModuleMembers) -> None:\\n', '    def _check_members_count(self, node: _ModuleMembers) -> None:\\n', \"        is_real_method = is_method(getattr(node, 'function_type', None))\\n\", '        if isinstance(get_parent(node), ast.Module) and not is_real_method:\\n', '    def _check_decorators_count(self, node: _ModuleMembers) -> None:\\n', '        number_of_decorators = len(node.decorator_list)\\n', '        if number_of_decorators > self.options.max_decorators:\\n', '                    text=str(number_of_decorators),\\n', '        counter = 0\\n', '        for condition in node.values:\\n', '            if isinstance(condition, ast.BoolOp):\\n', '                counter += self._count_conditions(condition)\\n', '                counter += 1\\n', '        return counter\\n', '        conditions_count = self._count_conditions(node)\\n', '        if conditions_count > constants.MAX_CONDITIONS:\\n', '                    text=str(conditions_count),\\n', '        is_all_equals = all(isinstance(op, ast.Eq) for op in node.ops)\\n', '        is_all_notequals = all(isinstance(op, ast.NotEq) for op in node.ops)\\n', '        can_be_longer = is_all_notequals or is_all_equals\\n', '        threshold = constants.MAX_COMPARES\\n', '        if can_be_longer:\\n', '            threshold += 1\\n', '        if len(node.ops) > threshold:\\n', '                    baseline=threshold,\\n', '        for root, children in self._if_children.items():\\n', '            if node in children:\\n', '                return root\\n', '        if node is not root:\\n', '            self._if_children[root].append(node)\\n', '        self._if_children[root].extend(node.orelse)  # type: ignore\\n', '        has_elif = all(\\n', '            isinstance(if_node, ast.If) for if_node in node.orelse\\n', '        if has_elif:\\n', '            root = self._get_root_if_node(node)\\n', '            self._update_if_child(root, node)\\n', '        for root, children in self._if_children.items():\\n', '            real_children_length = len(set(children))\\n', '            if real_children_length > constants.MAX_ELIFS:\\n', '                        root,\\n', '                        text=str(real_children_length),\\n']",
  "context": "_check_elifs(self, node: ast.If) -> None:\n        has_elif = all(\n            isinstance(if_node, ast.If) for if_nod"
 },
 "2611": {
  "name": "real_children_length",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/counts.py",
  "lineno": "183",
  "column": "12",
  "slicing": "['_ModuleMembers = Union[AnyFunctionDef, ast.ClassDef]\\n', '    def visit_module_members(self, node: _ModuleMembers) -> None:\\n', '    def _check_members_count(self, node: _ModuleMembers) -> None:\\n', \"        is_real_method = is_method(getattr(node, 'function_type', None))\\n\", '        if isinstance(get_parent(node), ast.Module) and not is_real_method:\\n', '    def _check_decorators_count(self, node: _ModuleMembers) -> None:\\n', '        number_of_decorators = len(node.decorator_list)\\n', '        if number_of_decorators > self.options.max_decorators:\\n', '                    text=str(number_of_decorators),\\n', '        counter = 0\\n', '        for condition in node.values:\\n', '            if isinstance(condition, ast.BoolOp):\\n', '                counter += self._count_conditions(condition)\\n', '                counter += 1\\n', '        return counter\\n', '        conditions_count = self._count_conditions(node)\\n', '        if conditions_count > constants.MAX_CONDITIONS:\\n', '                    text=str(conditions_count),\\n', '        is_all_equals = all(isinstance(op, ast.Eq) for op in node.ops)\\n', '        is_all_notequals = all(isinstance(op, ast.NotEq) for op in node.ops)\\n', '        can_be_longer = is_all_notequals or is_all_equals\\n', '        threshold = constants.MAX_COMPARES\\n', '        if can_be_longer:\\n', '            threshold += 1\\n', '        if len(node.ops) > threshold:\\n', '                    baseline=threshold,\\n', '        for root, children in self._if_children.items():\\n', '            if node in children:\\n', '                return root\\n', '        if node is not root:\\n', '            self._if_children[root].append(node)\\n', '        self._if_children[root].extend(node.orelse)  # type: ignore\\n', '        has_elif = all(\\n', '            isinstance(if_node, ast.If) for if_node in node.orelse\\n', '        if has_elif:\\n', '            root = self._get_root_if_node(node)\\n', '            self._update_if_child(root, node)\\n', '        for root, children in self._if_children.items():\\n', '            real_children_length = len(set(children))\\n', '            if real_children_length > constants.MAX_ELIFS:\\n', '                        root,\\n', '                        text=str(real_children_length),\\n']",
  "context": "hildren in self._if_children.items():\n            real_children_length = len(set(children))\n            if real_children_length > constants.MA"
 },
 "2612": {
  "name": "consecutive_calls",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/calls.py",
  "lineno": "41",
  "column": "8",
  "slicing": "['        consecutive_calls = set(takewhile(\\n', '        self._visited_calls.update(consecutive_calls)\\n', '        num_of_calls = len(consecutive_calls)\\n', '        if num_of_calls > self.options.max_call_level:\\n', '                    text=str(num_of_calls),\\n']",
  "context": " self._visited_calls:\n            return\n\n        consecutive_calls = set(takewhile(\n            self._is_call, parts(node),\n        ))"
 },
 "2613": {
  "name": "num_of_calls",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/calls.py",
  "lineno": "46",
  "column": "8",
  "slicing": "['        consecutive_calls = set(takewhile(\\n', '        self._visited_calls.update(consecutive_calls)\\n', '        num_of_calls = len(consecutive_calls)\\n', '        if num_of_calls > self.options.max_call_level:\\n', '                    text=str(num_of_calls),\\n']",
  "context": "._visited_calls.update(consecutive_calls)\n        num_of_calls = len(consecutive_calls)\n\n        if num_of_calls > self.options.max_call_l"
 },
 "2614": {
  "name": "_ignored_nodes",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/jones.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['    _ignored_nodes = (\\n']",
  "context": "lexity,\n    so we do not count them.\n    \"\"\"\n\n    _ignored_nodes = (\n        ast.ClassDef,\n        *FunctionNodes,\n    "
 },
 "2615": {
  "name": "line_number",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/jones.py",
  "lineno": "62",
  "column": "8",
  "slicing": "[\"        line_number = getattr(node, 'lineno', None)\\n\", '        if line_number is not None and not is_ignored:\\n', '                self._lines[line_number].append(node)\\n']",
  "context": "     LineComplexityViolation\n\n        \"\"\"\n        line_number = getattr(node, 'lineno', None)\n        is_ignored = isinstance(node, self._ignore"
 },
 "2616": {
  "name": "is_ignored",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/jones.py",
  "lineno": "63",
  "column": "8",
  "slicing": "['        is_ignored = isinstance(node, self._ignored_nodes)\\n', '        if line_number is not None and not is_ignored:\\n']",
  "context": "ne_number = getattr(node, 'lineno', None)\n        is_ignored = isinstance(node, self._ignored_nodes)\n\n        if line_number is not None and not is_ign"
 },
 "2617": {
  "name": "complexity",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/jones.py",
  "lineno": "79",
  "column": "12",
  "slicing": "[\"        line_number = getattr(node, 'lineno', None)\\n\", '        is_ignored = isinstance(node, self._ignored_nodes)\\n', '        if line_number is not None and not is_ignored:\\n', '                self._lines[line_number].append(node)\\n', '        for line_nodes in self._lines.values():\\n', '            complexity = len(line_nodes)\\n', '            if complexity > self.options.max_line_complexity:\\n', '                        line_nodes[0],\\n', '                        text=str(complexity),\\n']",
  "context": "r line_nodes in self._lines.values():\n            complexity = len(line_nodes)\n            if complexity > self.options.max_line_"
 },
 "2618": {
  "name": "node_counts",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/jones.py",
  "lineno": "89",
  "column": "8",
  "slicing": "[\"        line_number = getattr(node, 'lineno', None)\\n\", '        is_ignored = isinstance(node, self._ignored_nodes)\\n', '        if line_number is not None and not is_ignored:\\n', '                self._lines[line_number].append(node)\\n', '        for line_nodes in self._lines.values():\\n', '            complexity = len(line_nodes)\\n', '            if complexity > self.options.max_line_complexity:\\n', '                        line_nodes[0],\\n', '                        text=str(complexity),\\n', '        node_counts = [len(nodes) for nodes in self._lines.values()]\\n', '        total_count = median(node_counts) if node_counts else 0\\n', '        if total_count > self.options.max_jones_score:\\n', '                    text=str(total_count),\\n']",
  "context": "                    ),\n                )\n\n        node_counts = [len(nodes) for nodes in self._lines.values()]\n        total_count = median(node_counts) if node_"
 },
 "2619": {
  "name": "error_callback",
  "type": "wemake_python_styleguide.violations.base.ErrorCallback",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/imports.py",
  "lineno": "17",
  "column": "8",
  "slicing": "['        error_callback: ErrorCallback,\\n']",
  "context": "ames.\"\"\"\n\n    def __init__(\n        self,\n        error_callback: ErrorCallback,\n        options: ConfigurationOptions,\n    ) -> No"
 },
 "2620": {
  "name": "options",
  "type": "wemake_python_styleguide.types.ConfigurationOptions",
  "class": "customized",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/imports.py",
  "lineno": "18",
  "column": "8",
  "slicing": "['        options: ConfigurationOptions,\\n']",
  "context": "f,\n        error_callback: ErrorCallback,\n        options: ConfigurationOptions,\n    ) -> None:\n        self._error_callback = erro"
 },
 "2621": {
  "name": "imported_names_number",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/imports.py",
  "lineno": "27",
  "column": "8",
  "slicing": "['        imported_names_number = len(node.names)\\n', '        if imported_names_number > self._options.max_import_from_members:\\n', '                    text=str(imported_names_number),\\n']",
  "context": "ount(self, node: ast.ImportFrom) -> None:\n        imported_names_number = len(node.names)\n        if imported_names_number > self._options.m"
 },
 "2622": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyImport",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/imports.py",
  "lineno": "78",
  "column": "32",
  "slicing": "['    def _visit_any_import(self, node: AnyImport) -> None:\\n']",
  "context": "eric_visit(node)\n\n    def _visit_any_import(self, node: AnyImport) -> None:\n        self._imports_count += 1\n        self._imp"
 },
 "2623": {
  "name": "_Expressions",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/overuses.py",
  "lineno": "23",
  "column": "0",
  "slicing": "['_Expressions = DefaultDict[str, List[ast.AST]]\\n', '_FunctionExpressions = DefaultDict[ast.AST, _Expressions]\\n', '        self._module_expressions: _Expressions = defaultdict(list)\\n', '        self._function_expressions: _FunctionExpressions = defaultdict(\\n']",
  "context": " the number of nodes usage in different contexts.\n_Expressions = DefaultDict[str, List[ast.AST]]\n_FunctionExpressions = DefaultDict[ast.AST, _Expre"
 },
 "2624": {
  "name": "_FunctionExpressions",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/overuses.py",
  "lineno": "24",
  "column": "0",
  "slicing": "['_Expressions = DefaultDict[str, List[ast.AST]]\\n', '_FunctionExpressions = DefaultDict[ast.AST, _Expressions]\\n', '        self._module_expressions: _Expressions = defaultdict(list)\\n', '        self._function_expressions: _FunctionExpressions = defaultdict(\\n']",
  "context": "s.\n_Expressions = DefaultDict[str, List[ast.AST]]\n_FunctionExpressions = DefaultDict[ast.AST, _Expressions]\n_StringConstants = FrozenSet[Union[str, bytes]]\n\n\n"
 },
 "2625": {
  "name": "_StringConstants",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/overuses.py",
  "lineno": "25",
  "column": "0",
  "slicing": "['_Expressions = DefaultDict[str, List[ast.AST]]\\n', '_FunctionExpressions = DefaultDict[ast.AST, _Expressions]\\n', '_StringConstants = FrozenSet[Union[str, bytes]]\\n', '    _ignored_string_constants: ClassVar[_StringConstants] = frozenset((\\n', '        self._module_expressions: _Expressions = defaultdict(list)\\n', '        self._function_expressions: _FunctionExpressions = defaultdict(\\n']",
  "context": "nExpressions = DefaultDict[ast.AST, _Expressions]\n_StringConstants = FrozenSet[Union[str, bytes]]\n\n\n@final\n@decorators.alias('visit_any_string', (\n "
 },
 "2626": {
  "name": "_ignored_string_constants",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/overuses.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    _ignored_string_constants: ClassVar[_StringConstants] = frozenset((\\n']",
  "context": "ke much sense (i.e. newlines or \"\").\n    \"\"\"\n\n    _ignored_string_constants: ClassVar[_StringConstants] = frozenset((\n        ' ',\n        '',\n        '\\n',\n        '\\r"
 },
 "2627": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyText",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/overuses.py",
  "lineno": "61",
  "column": "31",
  "slicing": "['    def visit_any_string(self, node: AnyText) -> None:\\n']",
  "context": " defaultdict(int)\n\n    def visit_any_string(self, node: AnyText) -> None:\n        \"\"\"\n        Restricts to over-use string c"
 },
 "2628": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyText",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/overuses.py",
  "lineno": "72",
  "column": "37",
  "slicing": "['    def _check_string_constant(self, node: AnyText) -> None:\\n']",
  "context": "visit(node)\n\n    def _check_string_constant(self, node: AnyText) -> None:\n        if overuses.is_annotation(node):\n         "
 },
 "2629": {
  "name": "_expressions",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/overuses.py",
  "lineno": "98",
  "column": "4",
  "slicing": "['    _expressions: ClassVar[AnyNodes] = (\\n']",
  "context": "itor):\n    \"\"\"Finds overused expressions.\"\"\"\n\n    _expressions: ClassVar[AnyNodes] = (\n        # We do not treat `ast.Attribute`s as expr"
 },
 "2630": {
  "name": "_ignore_predicates",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/overuses.py",
  "lineno": "120",
  "column": "4",
  "slicing": "['    _ignore_predicates: Tuple[Callable[[ast.AST], bool], ...] = (\\n']",
  "context": "\n        ast.Set,\n        ast.SetComp,\n    )\n\n    _ignore_predicates: Tuple[Callable[[ast.AST], bool], ...] = (\n        overuses.is_decorator,\n        overuses.is"
 },
 "2631": {
  "name": "_msg",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/overuses.py",
  "lineno": "129",
  "column": "4",
  "slicing": "[\"    _msg: ClassVar[str] = '{0}; used {1}'\\n\"]",
  "context": "r_call,\n        overuses.is_primitive,\n    )\n\n    _msg: ClassVar[str] = '{0}; used {1}'\n\n    def __init__(self, *args, **kwargs) -> None:\n"
 },
 "2632": {
  "name": "_access_nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/access.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    _access_nodes: ClassVar[AnyNodes] = (\\n']",
  "context": " \"\"\"Counts access number for expressions.\"\"\"\n\n    _access_nodes: ClassVar[AnyNodes] = (\n        ast.Attribute,\n        ast.Subscript,\n    "
 },
 "2633": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyAccess",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/access.py",
  "lineno": "54",
  "column": "47",
  "slicing": "['    def _check_consecutive_access_number(self, node: AnyAccess) -> None:\\n']",
  "context": ")\n\n    def _check_consecutive_access_number(self, node: AnyAccess) -> None:\n        if node in self._visited_accesses:\n       "
 },
 "2634": {
  "name": "consecutive_access",
  "type": "typing.cast",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/access.py",
  "lineno": "58",
  "column": "8",
  "slicing": "['        consecutive_access = cast(Set[AnyAccess], set(takewhile(\\n', '        self._visited_accesses.update(consecutive_access)\\n', '        access_number = len(consecutive_access)\\n', '        if access_number > self.options.max_access_level:\\n', '                    text=str(access_number),\\n']",
  "context": "lf._visited_accesses:\n            return\n\n        consecutive_access = cast(Set[AnyAccess], set(takewhile(\n            self._is_any_access,\n            attri"
 },
 "2635": {
  "name": "access_number",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/access.py",
  "lineno": "64",
  "column": "8",
  "slicing": "['        consecutive_access = cast(Set[AnyAccess], set(takewhile(\\n', '        self._visited_accesses.update(consecutive_access)\\n', '        access_number = len(consecutive_access)\\n', '        if access_number > self.options.max_access_level:\\n', '                    text=str(access_number),\\n']",
  "context": "sited_accesses.update(consecutive_access)\n        access_number = len(consecutive_access)\n\n        if access_number > self.options.max_acces"
 },
 "2636": {
  "name": "_max_offset_blocks",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/offset.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['    _max_offset_blocks: ClassVar[int] = 5\\n']",
  "context": "umber of blocks to nest different structures:\n    _max_offset_blocks: ClassVar[int] = 5\n\n    def visit_line_expression(self, node: ast.AST"
 },
 "2637": {
  "name": "offset",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/offset.py",
  "lineno": "60",
  "column": "8",
  "slicing": "[\"        offset = getattr(node, 'col_offset', 0)\\n\", '        if offset > baseline:\\n', '                    text=str(offset),\\n']",
  "context": "heck_offset(self, node: ast.AST) -> None:\n        offset = getattr(node, 'col_offset', 0)\n        baseline = self._max_offset_blocks * 4\n   "
 },
 "2638": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "46",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "ric_visit(node)\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        Used to find nested functions."
 },
 "2639": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "70",
  "column": "37",
  "slicing": "['    def _check_nested_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "visit(node)\n\n    def _check_nested_function(self, node: AnyFunctionDef) -> None:\n        is_inside_function = isinstance(get_contex"
 },
 "2640": {
  "name": "is_inside_function",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "71",
  "column": "8",
  "slicing": "['        is_inside_function = isinstance(get_context(node), FunctionNodes)\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        if is_bad or is_inside_function:\\n']",
  "context": "tion(self, node: AnyFunctionDef) -> None:\n        is_inside_function = isinstance(get_context(node), FunctionNodes)\n\n        is_direct = isinstance(get_parent(node), "
 },
 "2641": {
  "name": "is_direct",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "73",
  "column": "8",
  "slicing": "['        is_direct = isinstance(get_parent(node), FunctionNodes)\\n', '        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        if is_bad or is_inside_function:\\n', '        if is_direct or is_deep:\\n']",
  "context": "stance(get_context(node), FunctionNodes)\n\n        is_direct = isinstance(get_parent(node), FunctionNodes)\n        is_bad = is_direct and node.name not in NE"
 },
 "2642": {
  "name": "is_bad",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "74",
  "column": "8",
  "slicing": "['        is_direct = isinstance(get_parent(node), FunctionNodes)\\n', '        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        if is_bad or is_inside_function:\\n', '        if is_direct or is_deep:\\n']",
  "context": "instance(get_parent(node), FunctionNodes)\n        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\n\n        if is_bad or (is_inside_function and not "
 },
 "2643": {
  "name": "parent_context",
  "type": "wemake_python_styleguide.logic.nodes.get_context",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "80",
  "column": "8",
  "slicing": "['        is_inside_function = isinstance(get_context(node), FunctionNodes)\\n', '        is_direct = isinstance(get_parent(node), FunctionNodes)\\n', '        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        parent_context = get_context(node)\\n', '        is_inside_class = isinstance(parent_context, ast.ClassDef)\\n', '        is_whitelisted = node.name in self.options.nested_classes_whitelist\\n', '        is_bad = is_inside_class and not is_whitelisted\\n', '        is_inside_function = isinstance(parent_context, FunctionNodes)\\n', '        if is_bad or is_inside_function:\\n', '        if is_direct or is_deep:\\n']",
  "context": "lasses(self, node: ast.ClassDef) -> None:\n        parent_context = get_context(node)\n\n        is_inside_class = isinstance(parent_conte"
 },
 "2644": {
  "name": "is_inside_class",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "82",
  "column": "8",
  "slicing": "['        is_inside_function = isinstance(get_context(node), FunctionNodes)\\n', '        is_direct = isinstance(get_parent(node), FunctionNodes)\\n', '        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        parent_context = get_context(node)\\n', '        is_inside_class = isinstance(parent_context, ast.ClassDef)\\n', '        is_whitelisted = node.name in self.options.nested_classes_whitelist\\n', '        is_bad = is_inside_class and not is_whitelisted\\n', '        is_inside_function = isinstance(parent_context, FunctionNodes)\\n', '        if is_bad or is_inside_function:\\n', '        if is_direct or is_deep:\\n']",
  "context": "      parent_context = get_context(node)\n\n        is_inside_class = isinstance(parent_context, ast.ClassDef)\n        is_whitelisted = node.name in self.options"
 },
 "2645": {
  "name": "is_whitelisted",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "83",
  "column": "8",
  "slicing": "['        is_inside_function = isinstance(get_context(node), FunctionNodes)\\n', '        is_direct = isinstance(get_parent(node), FunctionNodes)\\n', '        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        parent_context = get_context(node)\\n', '        is_inside_class = isinstance(parent_context, ast.ClassDef)\\n', '        is_whitelisted = node.name in self.options.nested_classes_whitelist\\n', '        is_bad = is_inside_class and not is_whitelisted\\n', '        is_inside_function = isinstance(parent_context, FunctionNodes)\\n', '        if is_bad or is_inside_function:\\n', '        if is_direct or is_deep:\\n']",
  "context": " isinstance(parent_context, ast.ClassDef)\n        is_whitelisted = node.name in self.options.nested_classes_whitelist\n\n        is_bad = is_inside_class and not is_white"
 },
 "2646": {
  "name": "is_bad",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "85",
  "column": "8",
  "slicing": "['        is_inside_function = isinstance(get_context(node), FunctionNodes)\\n', '        is_direct = isinstance(get_parent(node), FunctionNodes)\\n', '        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        parent_context = get_context(node)\\n', '        is_inside_class = isinstance(parent_context, ast.ClassDef)\\n', '        is_whitelisted = node.name in self.options.nested_classes_whitelist\\n', '        is_bad = is_inside_class and not is_whitelisted\\n', '        is_inside_function = isinstance(parent_context, FunctionNodes)\\n', '        if is_bad or is_inside_function:\\n', '        if is_direct or is_deep:\\n']",
  "context": "in self.options.nested_classes_whitelist\n\n        is_bad = is_inside_class and not is_whitelisted\n\n        is_inside_function = isinstance(parent_co"
 },
 "2647": {
  "name": "is_inside_function",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "87",
  "column": "8",
  "slicing": "['        is_inside_function = isinstance(get_context(node), FunctionNodes)\\n', '        is_direct = isinstance(get_parent(node), FunctionNodes)\\n', '        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        parent_context = get_context(node)\\n', '        is_inside_class = isinstance(parent_context, ast.ClassDef)\\n', '        is_whitelisted = node.name in self.options.nested_classes_whitelist\\n', '        is_bad = is_inside_class and not is_whitelisted\\n', '        is_inside_function = isinstance(parent_context, FunctionNodes)\\n', '        if is_bad or is_inside_function:\\n', '        if is_direct or is_deep:\\n']",
  "context": "= is_inside_class and not is_whitelisted\n\n        is_inside_function = isinstance(parent_context, FunctionNodes)\n\n        if is_bad or is_inside_function:\n        "
 },
 "2648": {
  "name": "is_direct",
  "type": "isinstance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "93",
  "column": "8",
  "slicing": "['        is_inside_function = isinstance(get_context(node), FunctionNodes)\\n', '        is_direct = isinstance(get_parent(node), FunctionNodes)\\n', '        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        parent_context = get_context(node)\\n', '        is_inside_class = isinstance(parent_context, ast.ClassDef)\\n', '        is_whitelisted = node.name in self.options.nested_classes_whitelist\\n', '        is_bad = is_inside_class and not is_whitelisted\\n', '        is_inside_function = isinstance(parent_context, FunctionNodes)\\n', '        if is_bad or is_inside_function:\\n', '        is_direct = isinstance(get_context(node), ast.Lambda)\\n', '        if is_direct or is_deep:\\n']",
  "context": "_lambdas(self, node: ast.Lambda) -> None:\n        is_direct = isinstance(get_context(node), ast.Lambda)\n        is_deep = get_closest_parent(node, ast.Lam"
 },
 "2649": {
  "name": "is_deep",
  "type": "wemake_python_styleguide.logic.walk.get_closest_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/nested.py",
  "lineno": "94",
  "column": "8",
  "slicing": "['        is_inside_function = isinstance(get_context(node), FunctionNodes)\\n', '        is_direct = isinstance(get_parent(node), FunctionNodes)\\n', '        is_bad = is_direct and node.name not in NESTED_FUNCTIONS_WHITELIST\\n', '        if is_bad or (is_inside_function and not is_direct):\\n', '        parent_context = get_context(node)\\n', '        is_inside_class = isinstance(parent_context, ast.ClassDef)\\n', '        is_whitelisted = node.name in self.options.nested_classes_whitelist\\n', '        is_bad = is_inside_class and not is_whitelisted\\n', '        is_inside_function = isinstance(parent_context, FunctionNodes)\\n', '        if is_bad or is_inside_function:\\n', '        is_direct = isinstance(get_context(node), ast.Lambda)\\n', '        is_deep = get_closest_parent(node, ast.Lambda)\\n', '        if is_direct or is_deep:\\n']",
  "context": "isinstance(get_context(node), ast.Lambda)\n        is_deep = get_closest_parent(node, ast.Lambda)\n\n        if is_direct or is_deep:\n            self"
 },
 "2650": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/annotations.py",
  "lineno": "26",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "d correctly.\"\"\"\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        Checks return type annotations"
 },
 "2651": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/annotations.py",
  "lineno": "49",
  "column": "14",
  "slicing": "['        self, node: AnyFunctionDef,\\n']",
  "context": "ck_function_annotations_complexity(\n        self, node: AnyFunctionDef,\n    ) -> None:\n        annotations = [\n           "
 },
 "2652": {
  "name": "annotations",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/annotations.py",
  "lineno": "51",
  "column": "8",
  "slicing": "['        annotations = [\\n', '            for arg in get_all_arguments(node)\\n', '            if arg.annotation is not None\\n', '            annotations.append(node.returns)\\n', '        self._check_annotations_complexity(node, annotations)\\n', '        for annotation in annotations:\\n', '            complexity = get_annotation_complexity(annotation)\\n', '            if complexity > max_complexity:\\n', '                        text=str(complexity),\\n']",
  "context": "elf, node: AnyFunctionDef,\n    ) -> None:\n        annotations = [\n            arg.annotation\n            for arg in "
 },
 "2653": {
  "name": "annotations",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/annotations.py",
  "lineno": "63",
  "column": "8",
  "slicing": "['        annotations: List[ast.expr],\\n']",
  "context": "ity(\n        self,\n        node: ast.AST,\n        annotations: List[ast.expr],\n    ) -> None:\n        max_complexity = self.optio"
 },
 "2654": {
  "name": "complexity",
  "type": "wemake_python_styleguide.logic.complexity.annotations.get_annotation_complexity",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/annotations.py",
  "lineno": "67",
  "column": "12",
  "slicing": "['        annotations = [\\n', '            for arg in get_all_arguments(node)\\n', '            if arg.annotation is not None\\n', '            annotations.append(node.returns)\\n', '        self._check_annotations_complexity(node, annotations)\\n', '        for annotation in annotations:\\n', '            complexity = get_annotation_complexity(annotation)\\n', '            if complexity > max_complexity:\\n', '                        text=str(complexity),\\n']",
  "context": "       for annotation in annotations:\n            complexity = get_annotation_complexity(annotation)\n            if complexity > max_complexity:\n      "
 },
 "2655": {
  "name": "attrs_count",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/classes.py",
  "lineno": "62",
  "column": "8",
  "slicing": "['        _, instance_attributes = classes.get_attributes(node)\\n', '        attrs_count = len({\\n', '            for attr in instance_attributes\\n', '            if access.is_public(attr.attr)\\n', '        if attrs_count > self.options.max_attributes:\\n', '                    text=str(attrs_count),\\n']",
  "context": "attributes = classes.get_attributes(node)\n        attrs_count = len({\n            attr.attr\n            for attr in inst"
 },
 "2656": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/classes.py",
  "lineno": "91",
  "column": "33",
  "slicing": "['    def visit_any_function(self, node: AnyFunctionDef) -> None:\\n']",
  "context": "efaultdict(int)\n\n    def visit_any_function(self, node: AnyFunctionDef) -> None:\n        \"\"\"\n        Counts the number of methods i"
 },
 "2657": {
  "name": "node",
  "type": "wemake_python_styleguide.types.AnyFunctionDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/classes.py",
  "lineno": "102",
  "column": "28",
  "slicing": "['    def _check_method(self, node: AnyFunctionDef) -> None:\\n']",
  "context": ".generic_visit(node)\n\n    def _check_method(self, node: AnyFunctionDef) -> None:\n        parent = get_parent(node)\n        if isins"
 },
 "2658": {
  "name": "parent",
  "type": "wemake_python_styleguide.logic.nodes.get_parent",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/ast/complexity/classes.py",
  "lineno": "103",
  "column": "8",
  "slicing": "['        _, instance_attributes = classes.get_attributes(node)\\n', '        attrs_count = len({\\n', '            for attr in instance_attributes\\n', '            if access.is_public(attr.attr)\\n', '        if attrs_count > self.options.max_attributes:\\n', '                    text=str(attrs_count),\\n', '        parent = get_parent(node)\\n', '        if isinstance(parent, ast.ClassDef):\\n', '            self._methods[parent] += 1\\n']",
  "context": "thod(self, node: AnyFunctionDef) -> None:\n        parent = get_parent(node)\n        if isinstance(parent, ast.ClassDef):\n     "
 },
 "2659": {
  "name": "TokenLines",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "37",
  "column": "0",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines: TokenLines = defaultdict(list)\\n']",
  "context": "styleguide.visitors.base import BaseTokenVisitor\n\nTokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\n\n\n@final\nclass ExtraIndentationVisitor(BaseTokenVi"
 },
 "2660": {
  "name": "_ignored_tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "52",
  "column": "4",
  "slicing": "['    _ignored_tokens: ClassVar[Tuple[int, ...]] = (\\n']",
  "context": "lines: indentation should not be >4\n\n    \"\"\"\n\n    _ignored_tokens: ClassVar[Tuple[int, ...]] = (\n        tokenize.NEWLINE,\n    )\n\n    _ignored_prev"
 },
 "2661": {
  "name": "_ignored_previous_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    _ignored_previous_token: ClassVar[Tuple[int, ...]] = (\\n']",
  "context": "t, ...]] = (\n        tokenize.NEWLINE,\n    )\n\n    _ignored_previous_token: ClassVar[Tuple[int, ...]] = (\n        tokenize.NL,\n    )\n\n    def __init__(self,"
 },
 "2662": {
  "name": "lines",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "87",
  "column": "8",
  "slicing": "['        lines: Sequence[int],\\n']",
  "context": "def _check_individual_line(\n        self,\n        lines: Sequence[int],\n        line: int,\n        index: int,\n    ) -> No"
 },
 "2663": {
  "name": "line",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "88",
  "column": "8",
  "slicing": "['        line: int,\\n']",
  "context": "      self,\n        lines: Sequence[int],\n        line: int,\n        index: int,\n    ) -> None:\n        current"
 },
 "2664": {
  "name": "index",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "89",
  "column": "8",
  "slicing": "['        index: int,\\n']",
  "context": " lines: Sequence[int],\n        line: int,\n        index: int,\n    ) -> None:\n        current_token = self._offse"
 },
 "2665": {
  "name": "current_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "91",
  "column": "8",
  "slicing": "['        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n']",
  "context": ": int,\n        index: int,\n    ) -> None:\n        current_token = self._offsets[line]\n        if current_token.exact_type in self._ignor"
 },
 "2666": {
  "name": "previous_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "95",
  "column": "8",
  "slicing": "['        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n']",
  "context": "self._ignored_tokens:\n            return\n\n        previous_token = self._offsets[lines[index - 1]]\n        if previous_token.exact_type in self._igno"
 },
 "2667": {
  "name": "lines",
  "type": "sorted",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "106",
  "column": "8",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\"]",
  "context": "ken))\n\n    def _post_visit(self) -> None:\n        lines = sorted(self._offsets.keys())\n\n        for index, line in enumerate(lines):\n    "
 },
 "2668": {
  "name": "tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "142",
  "column": "8",
  "slicing": "['        tokens: List[tokenize.TokenInfo],\\n']",
  "context": "    def _annotate_brackets(\n        self,\n        tokens: List[tokenize.TokenInfo],\n    ) -> Mapping[int, int]:\n        \"\"\"Annotates e"
 },
 "2669": {
  "name": "brackets",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "145",
  "column": "8",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\"]",
  "context": "g bracket with the nested level index.\"\"\"\n        brackets = {bracket: 0 for bracket in MATCHING}\n        for token in tokens:\n            if token."
 },
 "2670": {
  "name": "reverse_bracket",
  "type": "wemake_python_styleguide.logic.tokens.get_reverse_bracket",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "150",
  "column": "16",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\"]",
  "context": ".exact_type in MATCHING.values():\n                reverse_bracket = get_reverse_bracket(token)\n                if brackets[reverse_bracket] > 0:\n"
 },
 "2671": {
  "name": "index",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "158",
  "column": "8",
  "slicing": "['        index: int,\\n']",
  "context": " self,\n        token: tokenize.TokenInfo,\n        index: int,\n        tokens: List[tokenize.TokenInfo],\n    ) ->"
 },
 "2672": {
  "name": "tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "159",
  "column": "8",
  "slicing": "['        tokens: List[tokenize.TokenInfo],\\n']",
  "context": ": tokenize.TokenInfo,\n        index: int,\n        tokens: List[tokenize.TokenInfo],\n    ) -> None:\n        tokens_before = tokens[:ind"
 },
 "2673": {
  "name": "tokens_before",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "161",
  "column": "8",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\"]",
  "context": " List[tokenize.TokenInfo],\n    ) -> None:\n        tokens_before = tokens[:index]\n        annotated = self._annotate_brackets(tokens"
 },
 "2674": {
  "name": "annotated",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "162",
  "column": "8",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\"]",
  "context": "e:\n        tokens_before = tokens[:index]\n        annotated = self._annotate_brackets(tokens_before)\n        if annotated[get_reverse_bracket(token)] ="
 },
 "2675": {
  "name": "tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "167",
  "column": "37",
  "slicing": "['    def _check_individual_line(self, tokens: List[tokenize.TokenInfo]) -> None:\\n']",
  "context": "ion(token))\n\n    def _check_individual_line(self, tokens: List[tokenize.TokenInfo]) -> None:\n        for index, token in enumerate(tokens):\n   "
 },
 "2676": {
  "name": "index",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "213",
  "column": "8",
  "slicing": "['        index: int,\\n']",
  "context": "ken)\n\n    def _check_token(\n        self,\n        index: int,\n        tokens: List[tokenize.TokenInfo],\n        "
 },
 "2677": {
  "name": "tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "214",
  "column": "8",
  "slicing": "['        tokens: List[tokenize.TokenInfo],\\n']",
  "context": "_token(\n        self,\n        index: int,\n        tokens: List[tokenize.TokenInfo],\n        previous_token: Optional[tokenize.TokenInf"
 },
 "2678": {
  "name": "previous_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "215",
  "column": "8",
  "slicing": "['        previous_token: Optional[tokenize.TokenInfo],\\n']",
  "context": "        tokens: List[tokenize.TokenInfo],\n        previous_token: Optional[tokenize.TokenInfo],\n        next_token: Optional[tokenize.TokenInfo],\n"
 },
 "2679": {
  "name": "next_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "216",
  "column": "8",
  "slicing": "['        next_token: Optional[tokenize.TokenInfo],\\n']",
  "context": "ious_token: Optional[tokenize.TokenInfo],\n        next_token: Optional[tokenize.TokenInfo],\n    ) -> None:\n        if index != 0:\n            "
 },
 "2680": {
  "name": "previous_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "219",
  "column": "12",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\"]",
  "context": "    ) -> None:\n        if index != 0:\n            previous_token = tokens[index - 1]\n        if previous_token and previous_token.exact"
 },
 "2681": {
  "name": "next_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "224",
  "column": "12",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\"]",
  "context": "\n\n        if index + 1 < len(tokens):\n            next_token = tokens[index + 1]\n        if next_token and next_token.exact_type =="
 },
 "2682": {
  "name": "tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "230",
  "column": "8",
  "slicing": "['        tokens: List[tokenize.TokenInfo],\\n']",
  "context": "def _check_individual_line(\n        self,\n        tokens: List[tokenize.TokenInfo],\n        previous_token: Optional[tokenize.TokenInf"
 },
 "2683": {
  "name": "previous_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "231",
  "column": "8",
  "slicing": "['        previous_token: Optional[tokenize.TokenInfo],\\n']",
  "context": "        tokens: List[tokenize.TokenInfo],\n        previous_token: Optional[tokenize.TokenInfo],\n        next_token: Optional[tokenize.TokenInfo],\n"
 },
 "2684": {
  "name": "next_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "232",
  "column": "8",
  "slicing": "['        next_token: Optional[tokenize.TokenInfo],\\n']",
  "context": "ious_token: Optional[tokenize.TokenInfo],\n        next_token: Optional[tokenize.TokenInfo],\n    ) -> None:\n        for index, token in enumera"
 },
 "2685": {
  "name": "linenos",
  "type": "sorted",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "241",
  "column": "8",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', '        linenos = sorted((self._lines.keys()))\\n', '        for index, _ in enumerate(linenos):\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\"]",
  "context": "oken)\n\n    def _post_visit(self) -> None:\n        linenos = sorted((self._lines.keys()))\n        for index, _ in enumerate(linenos):\n      "
 },
 "2686": {
  "name": "line_tokens",
  "type": "sorted",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "243",
  "column": "12",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', '        linenos = sorted((self._lines.keys()))\\n', '        for index, _ in enumerate(linenos):\\n', '            line_tokens = sorted(\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\", '                line_tokens, previous_line_token, next_line_token,\\n']",
  "context": "  for index, _ in enumerate(linenos):\n            line_tokens = sorted(\n                self._lines[linenos[index]], key=a"
 },
 "2687": {
  "name": "previous_line_token",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "246",
  "column": "12",
  "slicing": "['            previous_line_token = None\\n', '                line_tokens, previous_line_token, next_line_token,\\n']",
  "context": "ey=attrgetter('start'),\n            )\n            previous_line_token = None\n            next_line_token = None\n            if "
 },
 "2688": {
  "name": "next_line_token",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "247",
  "column": "12",
  "slicing": "['            next_line_token = None\\n', '                line_tokens, previous_line_token, next_line_token,\\n']",
  "context": "           previous_line_token = None\n            next_line_token = None\n            if index != 0:\n                previou"
 },
 "2689": {
  "name": "previous_line_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "249",
  "column": "16",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', '        linenos = sorted((self._lines.keys()))\\n', '        for index, _ in enumerate(linenos):\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', '                previous_line_token = sorted(\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\", '                line_tokens, previous_line_token, next_line_token,\\n']",
  "context": "= None\n            if index != 0:\n                previous_line_token = sorted(\n                    self._lines[linenos[index - 1]"
 },
 "2690": {
  "name": "next_line_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/statements.py",
  "lineno": "253",
  "column": "16",
  "slicing": "['TokenLines = DefaultDict[int, List[tokenize.TokenInfo]]\\n', '        lineno, _offset = token.start\\n', '        if lineno not in self._offsets:\\n', '            self._offsets[lineno] = token\\n', '        current_token = self._offsets[line]\\n', '        if current_token.exact_type in self._ignored_tokens:\\n', '        previous_token = self._offsets[lines[index - 1]]\\n', '        if previous_token.exact_type in self._ignored_previous_token:\\n', '        offset = self._get_token_offset(current_token)\\n', '        previous_offset = self._get_token_offset(previous_token)\\n', '        if offset > previous_offset + 4:\\n', '            self.add_violation(ExtraIndentationViolation(current_token))\\n', '        lines = sorted(self._offsets.keys())\\n', '        for index, line in enumerate(lines):\\n', '            if index == 0 or line != lines[index - 1] + 1:\\n', '            self._check_individual_line(lines, line, index)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        brackets = {bracket: 0 for bracket in MATCHING}\\n', '        for token in tokens:\\n', '            if token.exact_type in MATCHING.keys():\\n', '                brackets[token.exact_type] += 1\\n', '            if token.exact_type in MATCHING.values():\\n', '                reverse_bracket = get_reverse_bracket(token)\\n', '                if brackets[reverse_bracket] > 0:\\n', '                    brackets[reverse_bracket] -= 1\\n', '        return brackets\\n', '        tokens_before = tokens[:index]\\n', '        annotated = self._annotate_brackets(tokens_before)\\n', '        if annotated[get_reverse_bracket(token)] == 0:\\n', '            if not only_contains(tokens_before, ALLOWED_EMPTY_LINE_TOKENS):\\n', '                self.add_violation(WrongBracketPositionViolation(token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type in MATCHING.values():\\n', '                self._check_closing(token, index, tokens)\\n', '                if index == 0:\\n', '                    self._check_empty_line_wrap(token, delta=-1)\\n', '            elif token.exact_type in MATCHING and last_bracket(tokens, index):\\n', '                self._check_empty_line_wrap(token, delta=1)\\n', '        tokens = self._lines.get(token.start[0] + delta)\\n', '        if tokens is not None and only_contains(tokens, NEWLINES):\\n', '            self.add_violation(BracketBlankLineViolation(token))\\n', '        for tokens in self._lines.values():\\n', '            self._check_individual_line(tokens)\\n', '        self._lines: TokenLines = defaultdict(list)\\n', '        self._lines[token.start[0]].append(token)\\n', '        if index != 0:\\n', '            previous_token = tokens[index - 1]\\n', '        if previous_token and previous_token.exact_type != tokenize.EQUAL:\\n', '            self.add_violation(WrongMultilineStringUseViolation(previous_token))\\n', '        if index + 1 < len(tokens):\\n', '            next_token = tokens[index + 1]\\n', '        if next_token and next_token.exact_type == tokenize.DOT:\\n', '            self.add_violation(WrongMultilineStringUseViolation(next_token))\\n', '        for index, token in enumerate(tokens):\\n', '            if token.exact_type != tokenize.STRING or token in self._docstrings:\\n', '            if has_triple_string_quotes(token.string):\\n', '                self._check_token(index, tokens, previous_token, next_token)\\n', '        linenos = sorted((self._lines.keys()))\\n', '        for index, _ in enumerate(linenos):\\n', \"                self._lines[linenos[index]], key=attrgetter('start'),\\n\", '            if index != 0:\\n', \"                    self._lines[linenos[index - 1]], key=attrgetter('start'),\\n\", '            if index + 1 < len(linenos):\\n', '                next_line_token = sorted(\\n', \"                    self._lines[linenos[index + 1]], key=attrgetter('start'),\\n\", '                line_tokens, previous_line_token, next_line_token,\\n']",
  "context": "     if index + 1 < len(linenos):\n                next_line_token = sorted(\n                    self._lines[linenos[index + 1]"
 },
 "2691": {
  "name": "_allowed_token_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    _allowed_token_types: ClassVar[FrozenSet[int]] = frozenset((\\n']",
  "context": "    the raw tokens inside the text.\n\n    \"\"\"\n\n    _allowed_token_types: ClassVar[FrozenSet[int]] = frozenset((\n        tokenize.NEWLINE,\n        tokenize.NL,\n   "
 },
 "2692": {
  "name": "start_index",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "58",
  "column": "38",
  "slicing": "['    def _does_else_belong_to_if(self, start_index: int) -> bool:\\n']",
  "context": "lif(token)\n\n    def _does_else_belong_to_if(self, start_index: int) -> bool:\n        previous_token = self.file_tokens[start_in"
 },
 "2693": {
  "name": "previous_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "59",
  "column": "8",
  "slicing": "['        previous_token = self.file_tokens[start_index - 1]\\n', '        if previous_token.type != tokenize.DEDENT:\\n', '            if token.start[1] == previous_token.start[1]:\\n']",
  "context": "ng_to_if(self, start_index: int) -> bool:\n        previous_token = self.file_tokens[start_index - 1]\n\n        if previous_token.type != tokenize.DEDENT"
 },
 "2694": {
  "name": "remaining_tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "79",
  "column": "8",
  "slicing": "['        remaining_tokens: Sequence[tokenize.TokenInfo],\\n']",
  "context": "    def _if_has_code_below(\n        self,\n        remaining_tokens: Sequence[tokenize.TokenInfo],\n    ) -> bool:\n        \"\"\"\n        Checks code imm"
 },
 "2695": {
  "name": "next_token",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "95",
  "column": "12",
  "slicing": "['        previous_token = self.file_tokens[start_index - 1]\\n', '        if previous_token.type != tokenize.DEDENT:\\n', '        for token in reversed(self.file_tokens[:start_index - 1]):\\n', '            if token.type != tokenize.NAME:\\n', '            if token.start[1] == previous_token.start[1]:\\n', \"                return token.string in {'if', 'elif'}\\n\", '        index = 1\\n', '        while remaining_tokens[index - 1].exact_type != tokenize.INDENT:\\n', '            index += 1\\n', '        context_count = 1\\n', '        while context_count:\\n', '            next_token = remaining_tokens[index]\\n', '            if next_token.exact_type == tokenize.INDENT:\\n', '                context_count += 1\\n', '            if next_token.exact_type == tokenize.DEDENT:\\n', '                context_count -= 1\\n', '            index += 1\\n', '        return remaining_tokens[index].exact_type != tokenize.DEDENT\\n', '        complex_else = self._if_has_code_below(tokens[index + 1:])\\n', '        if not complex_else:\\n', \"        is_not_else = token.string != 'else'\\n\", '        belongs_to_if = self._does_else_belong_to_if(index)\\n', '        return is_not_else or not belongs_to_if\\n', '        token_index = self.file_tokens.index(token)\\n', '        if self._is_invalid_token(token_index, token):\\n', '        next_tokens = self.file_tokens[token_index + 1:]\\n', '        for index, next_token in enumerate(next_tokens):  # pragma: no cover\\n', '            if next_token.exact_type in self._allowed_token_types:\\n', \"            elif next_token.string == 'if':\\n\", '                self._check_complex_else(next_tokens, next_token, index)\\n']",
  "context": "unt = 1\n\n        while context_count:\n            next_token = remaining_tokens[index]\n            if next_token.exact_type == tokenize.I"
 },
 "2696": {
  "name": "tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "106",
  "column": "8",
  "slicing": "['        tokens: Sequence[tokenize.TokenInfo],\\n']",
  "context": "   def _check_complex_else(\n        self,\n        tokens: Sequence[tokenize.TokenInfo],\n        current_token: tokenize.TokenInfo,\n       "
 },
 "2697": {
  "name": "index",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "108",
  "column": "8",
  "slicing": "['        index: int,\\n']",
  "context": "       current_token: tokenize.TokenInfo,\n        index: int,\n    ) -> None:\n        complex_else = self._if_has"
 },
 "2698": {
  "name": "complex_else",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "110",
  "column": "8",
  "slicing": "['        previous_token = self.file_tokens[start_index - 1]\\n', '        if previous_token.type != tokenize.DEDENT:\\n', '        for token in reversed(self.file_tokens[:start_index - 1]):\\n', '            if token.type != tokenize.NAME:\\n', '            if token.start[1] == previous_token.start[1]:\\n', \"                return token.string in {'if', 'elif'}\\n\", '        index = 1\\n', '        while remaining_tokens[index - 1].exact_type != tokenize.INDENT:\\n', '            index += 1\\n', '        context_count = 1\\n', '        while context_count:\\n', '            next_token = remaining_tokens[index]\\n', '            if next_token.exact_type == tokenize.INDENT:\\n', '                context_count += 1\\n', '            if next_token.exact_type == tokenize.DEDENT:\\n', '                context_count -= 1\\n', '            index += 1\\n', '        return remaining_tokens[index].exact_type != tokenize.DEDENT\\n', '        complex_else = self._if_has_code_below(tokens[index + 1:])\\n', '        if not complex_else:\\n', \"        is_not_else = token.string != 'else'\\n\", '        belongs_to_if = self._does_else_belong_to_if(index)\\n', '        return is_not_else or not belongs_to_if\\n', '        token_index = self.file_tokens.index(token)\\n', '        if self._is_invalid_token(token_index, token):\\n', '        next_tokens = self.file_tokens[token_index + 1:]\\n', '        for index, next_token in enumerate(next_tokens):  # pragma: no cover\\n', '            if next_token.exact_type in self._allowed_token_types:\\n', \"            elif next_token.string == 'if':\\n\", '                self._check_complex_else(next_tokens, next_token, index)\\n']",
  "context": "nInfo,\n        index: int,\n    ) -> None:\n        complex_else = self._if_has_code_below(tokens[index + 1:])\n        if not complex_else:\n            self.add_"
 },
 "2699": {
  "name": "index",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "114",
  "column": "32",
  "slicing": "['    def _is_invalid_token(self, index: int, token: tokenize.TokenInfo) -> bool:\\n']",
  "context": "(current_token))\n\n    def _is_invalid_token(self, index: int, token: tokenize.TokenInfo) -> bool:\n        is_not_else = token.string != 'else'\n\n    "
 },
 "2700": {
  "name": "is_not_else",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "115",
  "column": "8",
  "slicing": "['        previous_token = self.file_tokens[start_index - 1]\\n', '        if previous_token.type != tokenize.DEDENT:\\n', '        for token in reversed(self.file_tokens[:start_index - 1]):\\n', '            if token.type != tokenize.NAME:\\n', '            if token.start[1] == previous_token.start[1]:\\n', \"                return token.string in {'if', 'elif'}\\n\", '        index = 1\\n', '        while remaining_tokens[index - 1].exact_type != tokenize.INDENT:\\n', '            index += 1\\n', '        context_count = 1\\n', '        while context_count:\\n', '            next_token = remaining_tokens[index]\\n', '            if next_token.exact_type == tokenize.INDENT:\\n', '                context_count += 1\\n', '            if next_token.exact_type == tokenize.DEDENT:\\n', '                context_count -= 1\\n', '            index += 1\\n', '        return remaining_tokens[index].exact_type != tokenize.DEDENT\\n', '        complex_else = self._if_has_code_below(tokens[index + 1:])\\n', '        if not complex_else:\\n', \"        is_not_else = token.string != 'else'\\n\", '        belongs_to_if = self._does_else_belong_to_if(index)\\n', '        return is_not_else or not belongs_to_if\\n', '        token_index = self.file_tokens.index(token)\\n', '        if self._is_invalid_token(token_index, token):\\n', '        next_tokens = self.file_tokens[token_index + 1:]\\n', '        for index, next_token in enumerate(next_tokens):  # pragma: no cover\\n', '            if next_token.exact_type in self._allowed_token_types:\\n', \"            elif next_token.string == 'if':\\n\", '                self._check_complex_else(next_tokens, next_token, index)\\n']",
  "context": " int, token: tokenize.TokenInfo) -> bool:\n        is_not_else = token.string != 'else'\n\n        # `else` token can belong also to `for` a"
 },
 "2701": {
  "name": "belongs_to_if",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "119",
  "column": "8",
  "slicing": "['        previous_token = self.file_tokens[start_index - 1]\\n', '        if previous_token.type != tokenize.DEDENT:\\n', '        for token in reversed(self.file_tokens[:start_index - 1]):\\n', '            if token.type != tokenize.NAME:\\n', '            if token.start[1] == previous_token.start[1]:\\n', \"                return token.string in {'if', 'elif'}\\n\", '        index = 1\\n', '        while remaining_tokens[index - 1].exact_type != tokenize.INDENT:\\n', '            index += 1\\n', '        context_count = 1\\n', '        while context_count:\\n', '            next_token = remaining_tokens[index]\\n', '            if next_token.exact_type == tokenize.INDENT:\\n', '                context_count += 1\\n', '            if next_token.exact_type == tokenize.DEDENT:\\n', '                context_count -= 1\\n', '            index += 1\\n', '        return remaining_tokens[index].exact_type != tokenize.DEDENT\\n', '        complex_else = self._if_has_code_below(tokens[index + 1:])\\n', '        if not complex_else:\\n', \"        is_not_else = token.string != 'else'\\n\", '        belongs_to_if = self._does_else_belong_to_if(index)\\n', '        return is_not_else or not belongs_to_if\\n', '        token_index = self.file_tokens.index(token)\\n', '        if self._is_invalid_token(token_index, token):\\n', '        next_tokens = self.file_tokens[token_index + 1:]\\n', '        for index, next_token in enumerate(next_tokens):  # pragma: no cover\\n', '            if next_token.exact_type in self._allowed_token_types:\\n', \"            elif next_token.string == 'if':\\n\", '                self._check_complex_else(next_tokens, next_token, index)\\n']",
  "context": "rigger false positive for that violation.\n        belongs_to_if = self._does_else_belong_to_if(index)\n\n        return is_not_else or not belongs_to_if\n\n"
 },
 "2702": {
  "name": "next_tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/conditions.py",
  "lineno": "130",
  "column": "8",
  "slicing": "['        previous_token = self.file_tokens[start_index - 1]\\n', '        if previous_token.type != tokenize.DEDENT:\\n', '        for token in reversed(self.file_tokens[:start_index - 1]):\\n', '            if token.type != tokenize.NAME:\\n', '            if token.start[1] == previous_token.start[1]:\\n', \"                return token.string in {'if', 'elif'}\\n\", '        index = 1\\n', '        while remaining_tokens[index - 1].exact_type != tokenize.INDENT:\\n', '            index += 1\\n', '        context_count = 1\\n', '        while context_count:\\n', '            next_token = remaining_tokens[index]\\n', '            if next_token.exact_type == tokenize.INDENT:\\n', '                context_count += 1\\n', '            if next_token.exact_type == tokenize.DEDENT:\\n', '                context_count -= 1\\n', '            index += 1\\n', '        return remaining_tokens[index].exact_type != tokenize.DEDENT\\n', '        complex_else = self._if_has_code_below(tokens[index + 1:])\\n', '        if not complex_else:\\n', \"        is_not_else = token.string != 'else'\\n\", '        belongs_to_if = self._does_else_belong_to_if(index)\\n', '        return is_not_else or not belongs_to_if\\n', '        token_index = self.file_tokens.index(token)\\n', '        if self._is_invalid_token(token_index, token):\\n', '        next_tokens = self.file_tokens[token_index + 1:]\\n', '        for index, next_token in enumerate(next_tokens):  # pragma: no cover\\n', '            if next_token.exact_type in self._allowed_token_types:\\n', \"            elif next_token.string == 'if':\\n\", '                self._check_complex_else(next_tokens, next_token, index)\\n']",
  "context": "erage, I am not sure how to make it work.\n        next_tokens = self.file_tokens[token_index + 1:]\n        for index, next_token in enumerate(next_to"
 },
 "2703": {
  "name": "string",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "20",
  "column": "20",
  "slicing": "['def _replace_braces(string: str) -> str:\\n', '    return string.lstrip(\"\\'\").rstrip(\"\\'\")\\n', '        if self._implicit_raw_strings.search(_replace_braces(string_def)):\\n']",
  "context": "ase import BaseTokenVisitor\n\n\ndef _replace_braces(string: str) -> str:\n    if string.startswith('\"'):\n        return stri"
 },
 "2704": {
  "name": "_bad_number_suffixes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    _bad_number_suffixes: ClassVar[Pattern] = re.compile(\\n']",
  "context": "s number tokens to find incorrect usages.\"\"\"\n\n    _bad_number_suffixes: ClassVar[Pattern] = re.compile(\n        r'^[0-9\\.]+[BOXE]',\n    )\n\n    _leading_ze"
 },
 "2705": {
  "name": "_leading_zero_pattern",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    _leading_zero_pattern: ClassVar[Pattern] = re.compile(\\n']",
  "context": "e.compile(\n        r'^[0-9\\.]+[BOXE]',\n    )\n\n    _leading_zero_pattern: ClassVar[Pattern] = re.compile(\n        r'^[0-9\\.]+([box]|e\\+?\\-?)0.+', re.IGNOREC"
 },
 "2706": {
  "name": "_leading_zero_float_pattern",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    _leading_zero_float_pattern: ClassVar[Pattern] = re.compile(\\n']",
  "context": "e\\+?\\-?)0.+', re.IGNORECASE | re.ASCII,\n    )\n    _leading_zero_float_pattern: ClassVar[Pattern] = re.compile(\n        r'^[0-9]*\\.[0-9]+0+$',\n    )\n\n    _positiv"
 },
 "2707": {
  "name": "_positive_exponent_patterns",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    _positive_exponent_patterns: ClassVar[Pattern] = re.compile(\\n']",
  "context": "ompile(\n        r'^[0-9]*\\.[0-9]+0+$',\n    )\n\n    _positive_exponent_patterns: ClassVar[Pattern] = re.compile(\n        r'^[0-9\\.]+e\\+', re.IGNORECASE | re.ASCII,"
 },
 "2708": {
  "name": "_bad_hex_numbers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['    _bad_hex_numbers: ClassVar[FrozenSet[str]] = frozenset((\\n']",
  "context": "0-9\\.]+e\\+', re.IGNORECASE | re.ASCII,\n    )\n\n    _bad_hex_numbers: ClassVar[FrozenSet[str]] = frozenset((\n        'a', 'b', 'c', 'd', 'e', 'f',\n    ))\n\n    "
 },
 "2709": {
  "name": "_bad_complex_suffix",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "49",
  "column": "4",
  "slicing": "[\"    _bad_complex_suffix: ClassVar[str] = 'J'\\n\"]",
  "context": "        'a', 'b', 'c', 'd', 'e', 'f',\n    ))\n\n    _bad_complex_suffix: ClassVar[str] = 'J'\n\n    _float_zero: ClassVar[Pattern] = re.compile(\n"
 },
 "2710": {
  "name": "_float_zero",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    _float_zero: ClassVar[Pattern] = re.compile(\\n']",
  "context": "    _bad_complex_suffix: ClassVar[str] = 'J'\n\n    _float_zero: ClassVar[Pattern] = re.compile(\n        r'^0\\.0$',\n    )\n\n    def visit_number(sel"
 },
 "2711": {
  "name": "has_wrong_hex_numbers",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "127",
  "column": "12",
  "slicing": "['        float_zeros = self._leading_zero_float_pattern.match(token.string)\\n', '        other_zeros = self._leading_zero_pattern.match(token.string)\\n', '        if float_zeros or other_zeros:\\n', '            has_wrong_hex_numbers = any(\\n', '                for char in token.string\\n', '            if has_wrong_hex_numbers:\\n']",
  "context": "x') or token.string.startswith('0X'):\n            has_wrong_hex_numbers = any(\n                char in self._bad_hex_numbers\n    "
 },
 "2712": {
  "name": "_bad_string_modifiers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "150",
  "column": "4",
  "slicing": "['    _bad_string_modifiers: ClassVar[FrozenSet[str]] = frozenset((\\n']",
  "context": "\"\"\"Checks incorrect string tokens usages.\"\"\"\n\n    _bad_string_modifiers: ClassVar[FrozenSet[str]] = frozenset((\n        'R', 'F', 'B', 'U',\n    ))\n\n    _unicode_e"
 },
 "2713": {
  "name": "_unicode_escapes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "154",
  "column": "4",
  "slicing": "['    _unicode_escapes: ClassVar[FrozenSet[str]] = frozenset((\\n']",
  "context": "ozenset((\n        'R', 'F', 'B', 'U',\n    ))\n\n    _unicode_escapes: ClassVar[FrozenSet[str]] = frozenset((\n        'u', 'U', 'N',\n    ))\n\n    _implicit_raw_s"
 },
 "2714": {
  "name": "_implicit_raw_strings",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "158",
  "column": "4",
  "slicing": "[\"    _implicit_raw_strings: ClassVar[Pattern] = re.compile(r'\\\\\\\\{2}.+')\\n\"]",
  "context": " = frozenset((\n        'u', 'U', 'N',\n    ))\n\n    _implicit_raw_strings: ClassVar[Pattern] = re.compile(r'\\\\{2}.+')\n\n    def __init__(self, *args, **kwargs) -> None:\n"
 },
 "2715": {
  "name": "_",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "188",
  "column": "8",
  "slicing": "['        _, string_def = split_prefixes(token.string)\\n']",
  "context": "self, token: tokenize.TokenInfo) -> None:\n        _, string_def = split_prefixes(token.string)\n        if has_triple_string_quotes(string_def):\n "
 },
 "2716": {
  "name": "string_def",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "188",
  "column": "11",
  "slicing": "['        _, string_def = split_prefixes(token.string)\\n', '        if has_triple_string_quotes(string_def):\\n', \"            if '\\\\n' not in string_def and token not in self._docstrings:\\n\", '        if self._implicit_raw_strings.search(_replace_braces(string_def)):\\n', \"        if 'r' in modifiers.lower() and '\\\\\\\\' not in string_def:\\n\", '                consistency.RawStringNotNeededViolation(token, text=string_def),\\n']",
  "context": "f, token: tokenize.TokenInfo) -> None:\n        _, string_def = split_prefixes(token.string)\n        if has_triple_string_quotes(string_def):\n "
 },
 "2717": {
  "name": "modifiers",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "196",
  "column": "8",
  "slicing": "['        modifiers, _ = split_prefixes(token.string)\\n', \"        if 'u' in modifiers.lower():\\n\", '        for mod in modifiers:\\n', '            if mod in self._bad_string_modifiers:\\n', '                        text=mod,\\n', \"        if 'r' in modifiers.lower():\\n\", \"            if 'b' in modifiers.lower() and next_char in self._unicode_escapes:\\n\", \"        if 'r' in modifiers.lower() and '\\\\\\\\' not in string_def:\\n\"]",
  "context": "self, token: tokenize.TokenInfo) -> None:\n        modifiers, _ = split_prefixes(token.string)\n\n        if 'u' in modifiers.lower():\n            "
 },
 "2718": {
  "name": "_",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "196",
  "column": "19",
  "slicing": "['        modifiers, _ = split_prefixes(token.string)\\n']",
  "context": ": tokenize.TokenInfo) -> None:\n        modifiers, _ = split_prefixes(token.string)\n\n        if 'u' in modifiers.lower():\n            "
 },
 "2719": {
  "name": "modifiers",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "213",
  "column": "8",
  "slicing": "['        modifiers, string_def = split_prefixes(token.string)\\n', \"        if 'r' in modifiers.lower():\\n\", \"            if 'b' in modifiers.lower() and next_char in self._unicode_escapes:\\n\", \"        if 'r' in modifiers.lower() and '\\\\\\\\' not in string_def:\\n\"]",
  "context": "self, token: tokenize.TokenInfo) -> None:\n        modifiers, string_def = split_prefixes(token.string)\n        if 'r' in modifiers.lower():\n            r"
 },
 "2720": {
  "name": "string_def",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "213",
  "column": "19",
  "slicing": "['        modifiers, string_def = split_prefixes(token.string)\\n', '        if self._implicit_raw_strings.search(_replace_braces(string_def)):\\n', \"        if 'r' in modifiers.lower() and '\\\\\\\\' not in string_def:\\n\", '                consistency.RawStringNotNeededViolation(token, text=string_def),\\n']",
  "context": ": tokenize.TokenInfo) -> None:\n        modifiers, string_def = split_prefixes(token.string)\n        if 'r' in modifiers.lower():\n            r"
 },
 "2721": {
  "name": "modifiers",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "227",
  "column": "8",
  "slicing": "['        modifiers, string_body = split_prefixes(token.string)\\n', \"            if 'b' in modifiers.lower() and next_char in self._unicode_escapes:\\n\", \"        if 'r' in modifiers.lower() and '\\\\\\\\' not in string_def:\\n\"]",
  "context": "ython.org/reference/lexical_analysis.html\n        modifiers, string_body = split_prefixes(token.string)\n\n        index = 0\n        while True:\n           "
 },
 "2722": {
  "name": "string_body",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "227",
  "column": "19",
  "slicing": "['def _replace_braces(string: str) -> str:\\n', '    return string.lstrip(\"\\'\").rstrip(\"\\'\")\\n', '        float_zeros = self._leading_zero_float_pattern.match(token.string)\\n', '        other_zeros = self._leading_zero_pattern.match(token.string)\\n', '        if float_zeros or other_zeros:\\n', '            has_wrong_hex_numbers = any(\\n', '                for char in token.string\\n', '            if has_wrong_hex_numbers:\\n', '        _, string_def = split_prefixes(token.string)\\n', '        if has_triple_string_quotes(string_def):\\n', \"            if '\\\\n' not in string_def and token not in self._docstrings:\\n\", '        modifiers, _ = split_prefixes(token.string)\\n', \"        if 'u' in modifiers.lower():\\n\", '        for mod in modifiers:\\n', '            if mod in self._bad_string_modifiers:\\n', '                        text=mod,\\n', '        modifiers, string_def = split_prefixes(token.string)\\n', \"        if 'r' in modifiers.lower():\\n\", '        if self._implicit_raw_strings.search(_replace_braces(string_def)):\\n', '        modifiers, string_body = split_prefixes(token.string)\\n', '        index = 0\\n', \"            index = string_body.find('\\\\\\\\', index)\\n\", '            if index == -1:\\n', '            next_char = string_body[index + 1]\\n', \"            if 'b' in modifiers.lower() and next_char in self._unicode_escapes:\\n\", \"        if 'r' in modifiers.lower() and '\\\\\\\\' not in string_def:\\n\", '                consistency.RawStringNotNeededViolation(token, text=string_def),\\n']",
  "context": "eference/lexical_analysis.html\n        modifiers, string_body = split_prefixes(token.string)\n\n        index = 0\n        while True:\n           "
 },
 "2723": {
  "name": "next_char",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "235",
  "column": "12",
  "slicing": "['def _replace_braces(string: str) -> str:\\n', '    return string.lstrip(\"\\'\").rstrip(\"\\'\")\\n', '        float_zeros = self._leading_zero_float_pattern.match(token.string)\\n', '        other_zeros = self._leading_zero_pattern.match(token.string)\\n', '        if float_zeros or other_zeros:\\n', '            has_wrong_hex_numbers = any(\\n', '                for char in token.string\\n', '            if has_wrong_hex_numbers:\\n', '        _, string_def = split_prefixes(token.string)\\n', '        if has_triple_string_quotes(string_def):\\n', \"            if '\\\\n' not in string_def and token not in self._docstrings:\\n\", '        modifiers, _ = split_prefixes(token.string)\\n', \"        if 'u' in modifiers.lower():\\n\", '        for mod in modifiers:\\n', '            if mod in self._bad_string_modifiers:\\n', '                        text=mod,\\n', '        modifiers, string_def = split_prefixes(token.string)\\n', \"        if 'r' in modifiers.lower():\\n\", '        if self._implicit_raw_strings.search(_replace_braces(string_def)):\\n', '        modifiers, string_body = split_prefixes(token.string)\\n', '        index = 0\\n', \"            index = string_body.find('\\\\\\\\', index)\\n\", '            if index == -1:\\n', '            next_char = string_body[index + 1]\\n', \"            if 'b' in modifiers.lower() and next_char in self._unicode_escapes:\\n\", \"        if 'r' in modifiers.lower() and '\\\\\\\\' not in string_def:\\n\", '                consistency.RawStringNotNeededViolation(token, text=string_def),\\n']",
  "context": "f index == -1:\n                break\n\n            next_char = string_body[index + 1]\n            if 'b' in modifiers.lower() and next_c"
 },
 "2724": {
  "name": "modifiers",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "247",
  "column": "8",
  "slicing": "['        modifiers, string_def = split_prefixes(token.string)\\n', \"        if 'r' in modifiers.lower() and '\\\\\\\\' not in string_def:\\n\"]",
  "context": "self, token: tokenize.TokenInfo) -> None:\n        modifiers, string_def = split_prefixes(token.string)\n\n        if 'r' in modifiers.lower() and '\\\\' not "
 },
 "2725": {
  "name": "string_def",
  "type": "wemake_python_styleguide.logic.tokens.split_prefixes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "247",
  "column": "19",
  "slicing": "['        modifiers, string_def = split_prefixes(token.string)\\n', \"        if 'r' in modifiers.lower() and '\\\\\\\\' not in string_def:\\n\", '                consistency.RawStringNotNeededViolation(token, text=string_def),\\n']",
  "context": ": tokenize.TokenInfo) -> None:\n        modifiers, string_def = split_prefixes(token.string)\n\n        if 'r' in modifiers.lower() and '\\\\' not "
 },
 "2726": {
  "name": "_ignored_tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/primitives.py",
  "lineno": "259",
  "column": "4",
  "slicing": "['    _ignored_tokens: ClassVar[FrozenSet[int]] = frozenset((\\n']",
  "context": "\"\"\"Checks incorrect string concatenation.\"\"\"\n\n    _ignored_tokens: ClassVar[FrozenSet[int]] = frozenset((\n        tokenize.NL,\n        tokenize.NEWLINE,\n   "
 },
 "2727": {
  "name": "EMPTY_STRING",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "41",
  "column": "0",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "styleguide.visitors.base import BaseTokenVisitor\n\nEMPTY_STRING: Final = ''\n\nSENTINEL_TOKEN: Final = tokenize.TokenInfo(\n    t"
 },
 "2728": {
  "name": "SENTINEL_TOKEN",
  "type": "typing_extensions.Final",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "43",
  "column": "0",
  "slicing": "['SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n']",
  "context": "mport BaseTokenVisitor\n\nEMPTY_STRING: Final = ''\n\nSENTINEL_TOKEN: Final = tokenize.TokenInfo(\n    type=ENDMARKER,\n    string=EMPTY_STRING,\n    s"
 },
 "2729": {
  "name": "_no_cover",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "56",
  "column": "4",
  "slicing": "[\"    _no_cover: ClassVar[Pattern] = re.compile(r'^pragma:\\\\s+no\\\\s+cover')\\n\"]",
  "context": "enVisitor):\n    \"\"\"Checks comment tokens.\"\"\"\n\n    _no_cover: ClassVar[Pattern] = re.compile(r'^pragma:\\s+no\\s+cover')\n    _type_check: ClassVar[Pattern] = re.compile(\n "
 },
 "2730": {
  "name": "_type_check",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    _type_check: ClassVar[Pattern] = re.compile(\\n']",
  "context": "ttern] = re.compile(r'^pragma:\\s+no\\s+cover')\n    _type_check: ClassVar[Pattern] = re.compile(\n        r'^type:\\s?([\\w\\d\\[\\]\\'\\\"\\.]+)$',\n    )\n\n "
 },
 "2731": {
  "name": "comment_text",
  "type": "wemake_python_styleguide.logic.tokens.get_comment_text",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "80",
  "column": "8",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "self, token: tokenize.TokenInfo) -> None:\n        comment_text = get_comment_text(token)\n        match = self._type_check.match(comment_tex"
 },
 "2732": {
  "name": "comment_text",
  "type": "wemake_python_styleguide.logic.tokens.get_comment_text",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "96",
  "column": "8",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "self, token: tokenize.TokenInfo) -> None:\n        comment_text = get_comment_text(token)\n        match = self._no_cover.match(comment_text)"
 },
 "2733": {
  "name": "to_reserve",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "155",
  "column": "12",
  "slicing": "['            to_reserve = (\\n', '            if to_reserve:\\n']",
  "context": "          self._in_same_block = True\n\n            to_reserve = (\n                # Empty comment right after non-em"
 },
 "2734": {
  "name": "prev_line_num",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "178",
  "column": "30",
  "slicing": "['    def _is_consecutive(self, prev_line_num: int) -> bool:\\n']",
  "context": "ck_alerted = False\n\n    def _is_consecutive(self, prev_line_num: int) -> bool:\n        return (self._line_num - prev_line_num == "
 },
 "2735": {
  "name": "_shebang",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "197",
  "column": "4",
  "slicing": "[\"    _shebang: ClassVar[Pattern] = re.compile(r'(\\\\s*)#!')\\n\"]",
  "context": "/github.com/xuhdev/flake8-executable\n    \"\"\"\n\n    _shebang: ClassVar[Pattern] = re.compile(r'(\\s*)#!')\n    _python_executable: ClassVar[str] = 'python'\n\n"
 },
 "2736": {
  "name": "_python_executable",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "198",
  "column": "4",
  "slicing": "[\"    _python_executable: ClassVar[str] = 'python'\\n\"]",
  "context": "g: ClassVar[Pattern] = re.compile(r'(\\s*)#!')\n    _python_executable: ClassVar[str] = 'python'\n\n    def visit_comment(self, token: tokenize.Token"
 },
 "2737": {
  "name": "is_shebang",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "211",
  "column": "8",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "this is a regular comment, not a shebang\n\n        is_shebang = self._is_valid_shebang_line(token)\n        self._check_executable_mismatch(token, is_"
 },
 "2738": {
  "name": "is_executable",
  "type": "wemake_python_styleguide.logic.system.is_executable_file",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "227",
  "column": "8",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "ame for STDIN inputs.\n            return\n\n        is_executable = is_executable_file(self.filename)\n        if is_executable and not is_shebang:\n     "
 },
 "2739": {
  "name": "all_tokens",
  "type": "iter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "264",
  "column": "8",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "self, token: tokenize.TokenInfo) -> bool:\n        all_tokens = iter(self.file_tokens)\n        current_token = next(all_tokens)\n\n        "
 },
 "2740": {
  "name": "current_token",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "265",
  "column": "8",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "      all_tokens = iter(self.file_tokens)\n        current_token = next(all_tokens)\n\n        while True:\n            if current_token "
 },
 "2741": {
  "name": "current_token",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "272",
  "column": "12",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "ot in NEWLINES:\n                break\n            current_token = next(all_tokens)\n        return False\n\n    def _is_valid_shebang_li"
 },
 "2742": {
  "name": "_noqa_check",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "283",
  "column": "4",
  "slicing": "[\"    _noqa_check: ClassVar[Pattern] = re.compile(r'^(noqa:?)($|[A-Z\\\\d\\\\,\\\\s]+)')\\n\"]",
  "context": "itor):\n    \"\"\"Checks noqa comment tokens.\"\"\"\n\n    _noqa_check: ClassVar[Pattern] = re.compile(r'^(noqa:?)($|[A-Z\\d\\,\\s]+)')\n\n    def __init__(self, *args, **kwargs) -> None:\n"
 },
 "2743": {
  "name": "comment_text",
  "type": "wemake_python_styleguide.logic.tokens.get_comment_text",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "302",
  "column": "8",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "self, token: tokenize.TokenInfo) -> None:\n        comment_text = get_comment_text(token)\n        match = self._noqa_check.match(comment_tex"
 },
 "2744": {
  "name": "excludes_list",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/wemake_python_styleguide/visitors/tokenize/comments.py",
  "lineno": "319",
  "column": "8",
  "slicing": "[\"EMPTY_STRING: Final = ''\\n\", 'SENTINEL_TOKEN: Final = tokenize.TokenInfo(\\n', '    string=EMPTY_STRING,\\n', '    line=EMPTY_STRING,\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._type_check.match(comment_text)\\n', '        if not match:\\n', '        declared_type = match.groups()[0].strip()\\n', \"        if not declared_type.startswith('ignore'):\\n\", '                WrongMagicCommentViolation(token, text=comment_text),\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._no_cover.match(comment_text)\\n', '        if not match:\\n', '        self._reserved_token = SENTINEL_TOKEN\\n', '            self._reserved_token = SENTINEL_TOKEN\\n', '        if get_comment_text(token) == EMPTY_STRING:\\n', '            to_reserve = (\\n', '            if to_reserve:\\n', '                self._reserved_token = SENTINEL_TOKEN\\n', '        return (self._reserved_token != SENTINEL_TOKEN)\\n', '        is_shebang = self._is_valid_shebang_line(token)\\n', '        self._check_executable_mismatch(token, is_shebang=is_shebang)\\n', '        if is_shebang:\\n', '        is_executable = is_executable_file(self.filename)\\n', '        if is_executable and not is_shebang:\\n', '        elif not is_executable and is_shebang:\\n', '        all_tokens = iter(self.file_tokens)\\n', '        current_token = next(all_tokens)\\n', '            if current_token == token:\\n', '            elif current_token.exact_type not in NEWLINES:\\n', '            current_token = next(all_tokens)\\n', '        comment_text = get_comment_text(token)\\n', '        match = self._noqa_check.match(comment_text)\\n', '        if not match:\\n', '        excludes = match.groups()[1].strip()\\n', '        prefix = match.groups()[0].strip()\\n', \"        if not excludes or prefix[-1] != ':':\\n\", '            self.add_violation(WrongMagicCommentViolation(text=comment_text))\\n', '        self._check_forbidden_noqa(excludes)\\n', \"        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\\n\", '        forbidden_noqa = EMPTY_STRING.join(self.options.forbidden_inline_ignore)\\n', \"        for noqa_code in forbidden_noqa.split(','):\\n\", '            noqa_code = noqa_code.strip()\\n', '            if noqa_code in excludes_list:\\n', '            if not noqa_code.isalpha():\\n', '            for excluded in excludes_list:\\n', \"                if re.fullmatch(r'{0}($|\\\\d+)'.format(noqa_code), excluded):\\n\"]",
  "context": "bidden_noqa(self, noqa_excludes) -> None:\n        excludes_list = [ex.strip() for ex in noqa_excludes.split(',')]\n        forbidden_noqa = EMPTY_STRING.join(self.op"
 },
 "2745": {
  "name": "my_print",
  "type": "print",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/scripts/check_generic_visit.py",
  "lineno": "20",
  "column": "0",
  "slicing": "['my_print = print\\n', \"        my_print('Please provide path to search in!')\\n\", '    my_print()\\n', '    my_print(\\'\"self.generic_visit(node)\" should be last statement here:\\')\\n', \"            my_print('\\\\t{0}:{1}\\\\n\\\\t{2}'.format(fn, line, highlighted))\\n\"]",
  "context": "needed to stop linter from spewing WPS421 errors.\nmy_print = print\n\n\nif __name__ == '__main__':\n    if len(sys.argv) "
 },
 "2746": {
  "name": "source",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/scripts/check_generic_visit.py",
  "lineno": "37",
  "column": "12",
  "slicing": "['OK_CODE = 0\\n', \"PATTERN = '''\\n\", 'my_print = print\\n', \"        my_print('Please provide path to search in!')\\n\", '    matches = astpath.search(sys.argv[1], PATTERN, print_matches=False)\\n', '    if not len(matches):\\n', '        exit(OK_CODE)  # noqa: WPS421\\n', '    my_print()\\n', '    my_print(\\'\"self.generic_visit(node)\" should be last statement here:\\')\\n', '    for fn, line in matches:\\n', \"        with open(fn, 'r') as fp:\\n\", '            source = fp.read()\\n', '            lines = source.splitlines()\\n', '                lines[line - 1],\\n', \"            my_print('\\\\t{0}:{1}\\\\n\\\\t{2}'.format(fn, line, highlighted))\\n\"]",
  "context": "es:\n        with open(fn, 'r') as fp:\n            source = fp.read()\n            lines = source.splitlines()\n          "
 },
 "2747": {
  "name": "lines",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "wemake-python-styleguide/scripts/check_generic_visit.py",
  "lineno": "38",
  "column": "12",
  "slicing": "['OK_CODE = 0\\n', \"PATTERN = '''\\n\", 'my_print = print\\n', \"        my_print('Please provide path to search in!')\\n\", '    matches = astpath.search(sys.argv[1], PATTERN, print_matches=False)\\n', '    if not len(matches):\\n', '        exit(OK_CODE)  # noqa: WPS421\\n', '    my_print()\\n', '    my_print(\\'\"self.generic_visit(node)\" should be last statement here:\\')\\n', '    for fn, line in matches:\\n', \"        with open(fn, 'r') as fp:\\n\", '            source = fp.read()\\n', '            lines = source.splitlines()\\n', '                lines[line - 1],\\n', \"            my_print('\\\\t{0}:{1}\\\\n\\\\t{2}'.format(fn, line, highlighted))\\n\"]",
  "context": "as fp:\n            source = fp.read()\n            lines = source.splitlines()\n            highlighted = highlight(\n             "
 },
 "2748": {
  "name": "highlighted",
  "type": "pygments.highlight",
  "class": "imported",
  "approach": "annotation",
  "file_path": "wemake-python-styleguide/scripts/check_generic_visit.py",
  "lineno": "39",
  "column": "12",
  "slicing": "['OK_CODE = 0\\n', \"PATTERN = '''\\n\", 'my_print = print\\n', \"        my_print('Please provide path to search in!')\\n\", '    matches = astpath.search(sys.argv[1], PATTERN, print_matches=False)\\n', '    if not len(matches):\\n', '        exit(OK_CODE)  # noqa: WPS421\\n', '    my_print()\\n', '    my_print(\\'\"self.generic_visit(node)\" should be last statement here:\\')\\n', '    for fn, line in matches:\\n', \"        with open(fn, 'r') as fp:\\n\", '            source = fp.read()\\n', '            lines = source.splitlines()\\n', '            highlighted = highlight(\\n', '                lines[line - 1],\\n', \"            my_print('\\\\t{0}:{1}\\\\n\\\\t{2}'.format(fn, line, highlighted))\\n\"]",
  "context": "          lines = source.splitlines()\n            highlighted = highlight(\n                lines[line - 1],\n                P"
 }
}