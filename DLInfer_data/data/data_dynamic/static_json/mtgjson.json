{
 "1": {
  "name": "github_url",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n']",
  "context": "ile_name = config.get(\"GitHub\", \"file_name\")\n\n    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\n\n    if github_repo_local_path.is_dir():\n        L"
 },
 "2": {
  "name": "content",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['    content: Any,\\n', '    prune_recursive(content)\\n', '    upload_prices_archive(config, github_local_path, archive_prices)\\n']",
  "context": "er,\n    github_repo_local_path: pathlib.Path,\n    content: Any,\n) -> None:\n    \"\"\"\n    Upload prices archive back "
 },
 "3": {
  "name": "push_result",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "107",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '        LOGGER.error(\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    LOGGER.info(\"Merging price data\")\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    LOGGER.info(\"Uploading price data\")\\n']",
  "context": "ed with GitHub push\")\n            return\n\n        push_result = push_results[0]\n        if push_result.flags & push_result.ERROR ="
 },
 "4": {
  "name": "content",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "120",
  "column": "25",
  "slicing": "['def prune_prices_archive(content: Dict[str, Any], months: int = 3) -> None:\\n', '    prune_recursive(content)\\n', '    prune_prices_archive(archive_prices)\\n']",
  "context": "ithub_repo_local_path)\n\n\ndef prune_prices_archive(content: Dict[str, Any], months: int = 3) -> None:\n    \"\"\"\n    Prune entries from the MTGJSON databas"
 },
 "5": {
  "name": "months",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "120",
  "column": "50",
  "slicing": "['def prune_prices_archive(content: Dict[str, Any], months: int = 3) -> None:\\n']",
  "context": "def prune_prices_archive(content: Dict[str, Any], months: int = 3) -> None:\n    \"\"\"\n    Prune entries from the MTGJSON databas"
 },
 "6": {
  "name": "prune_date_str",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "126",
  "column": "4",
  "slicing": "['    prune_date_str = (\\n', '                if date < prune_date_str:\\n']",
  "context": "ths back should we keep (default = 3)\n    \"\"\"\n    prune_date_str = (\n        datetime.date.today() + dateutil.relatived"
 },
 "7": {
  "name": "obj",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "131",
  "column": "24",
  "slicing": "['    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '                    del obj[key]\\n', '    prune_recursive(content)\\n']",
  "context": "%d\")\n    keys_pruned = 0\n\n    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\n        \"\"\"\n        Recursive pruner to pluck out "
 },
 "8": {
  "name": "depth",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "131",
  "column": "45",
  "slicing": "['    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n']",
  "context": "= 0\n\n    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\n        \"\"\"\n        Recursive pruner to pluck out "
 },
 "9": {
  "name": "keys_pruned",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "140",
  "column": "20",
  "slicing": "['                    keys_pruned += 1\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n']",
  "context": "                del obj[date]\n                    keys_pruned += 1\n        elif isinstance(obj, dict):\n            fo"
 },
 "10": {
  "name": "keys_pruned",
  "type": "num",
  "class": "imported",
  "approach": "UNKNOWN",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "146",
  "column": "20",
  "slicing": "['                    keys_pruned += 1\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n']",
  "context": "                 del obj[key]\n                    keys_pruned += 1\n\n    LOGGER.info(\"Determining keys to prune\")\n    "
 },
 "11": {
  "name": "card_hoarder",
  "type": "_generate_prices",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "162",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    card_hoarder = _generate_prices(CardHoarderProvider())\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '        LOGGER.error(\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    LOGGER.info(\"Merging price data\")\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    LOGGER.info(\"Uploading price data\")\\n']",
  "context": "t found in {OUTPUT_PATH}\")\n        return {}\n\n    card_hoarder = _generate_prices(CardHoarderProvider())\n    tcgplayer = _generate_prices(TCGPlayerProvider"
 },
 "12": {
  "name": "tcgplayer",
  "type": "_generate_prices",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "163",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    tcgplayer = _generate_prices(TCGPlayerProvider())\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '        LOGGER.error(\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    LOGGER.info(\"Merging price data\")\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    LOGGER.info(\"Uploading price data\")\\n']",
  "context": "der = _generate_prices(CardHoarderProvider())\n    tcgplayer = _generate_prices(TCGPlayerProvider())\n    card_market = _generate_prices(CardMarketProvi"
 },
 "13": {
  "name": "card_market",
  "type": "_generate_prices",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "164",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    card_market = _generate_prices(CardMarketProvider())\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '        LOGGER.error(\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    LOGGER.info(\"Merging price data\")\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    LOGGER.info(\"Uploading price data\")\\n']",
  "context": "layer = _generate_prices(TCGPlayerProvider())\n    card_market = _generate_prices(CardMarketProvider())\n    card_kingdom = _generate_prices(CardKingdomPro"
 },
 "14": {
  "name": "card_kingdom",
  "type": "_generate_prices",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "165",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    card_kingdom = _generate_prices(CardKingdomProvider())\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '        LOGGER.error(\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    LOGGER.info(\"Merging price data\")\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    LOGGER.info(\"Uploading price data\")\\n']",
  "context": "rket = _generate_prices(CardMarketProvider())\n    card_kingdom = _generate_prices(CardKingdomProvider())\n\n    final_results = deep_merge_dictionaries(\n    "
 },
 "15": {
  "name": "final_results",
  "type": "utils.deep_merge_dictionaries",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "167",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    card_hoarder = _generate_prices(CardHoarderProvider())\\n', '    tcgplayer = _generate_prices(TCGPlayerProvider())\\n', '    card_market = _generate_prices(CardMarketProvider())\\n', '    card_kingdom = _generate_prices(CardKingdomProvider())\\n', '    final_results = deep_merge_dictionaries(\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '    return final_results\\n', '        LOGGER.error(\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    LOGGER.info(\"Merging price data\")\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    LOGGER.info(\"Uploading price data\")\\n']",
  "context": "om = _generate_prices(CardKingdomProvider())\n\n    final_results = deep_merge_dictionaries(\n        card_hoarder, tcgplayer, card_market, card"
 },
 "16": {
  "name": "provider",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "174",
  "column": "21",
  "slicing": "['def _generate_prices(provider: Any) -> Dict[str, Any]:\\n']",
  "context": "\n\n    return final_results\n\n\ndef _generate_prices(provider: Any) -> Dict[str, Any]:\n    \"\"\"\n    Generate the prices for a source and p"
 },
 "17": {
  "name": "preprocess_prices",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "181",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    card_hoarder = _generate_prices(CardHoarderProvider())\\n', '    tcgplayer = _generate_prices(TCGPlayerProvider())\\n', '    card_market = _generate_prices(CardMarketProvider())\\n', '    card_kingdom = _generate_prices(CardKingdomProvider())\\n', '    final_results = deep_merge_dictionaries(\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '    return final_results\\n', '    preprocess_prices = provider.generate_today_price_dict(\\n', '            json.dumps(preprocess_prices, default=lambda o: o.to_json())\\n', '        LOGGER.error(\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    LOGGER.info(\"Merging price data\")\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    LOGGER.info(\"Uploading price data\")\\n']",
  "context": "rn Manageable data for MTGJSON prices\n    \"\"\"\n    preprocess_prices = provider.generate_today_price_dict(\n        OUTPUT_PATH.joinpath(\"AllPrintings.json\")\n"
 },
 "18": {
  "name": "final_prices",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "185",
  "column": "8",
  "slicing": "['        final_prices: Dict[str, Any] = json.loads(\\n', '        return final_prices\\n']",
  "context": "npath(\"AllPrintings.json\")\n    )\n    try:\n        final_prices: Dict[str, Any] = json.loads(\n            json.dumps(preprocess_prices, default="
 },
 "19": {
  "name": "file_bytes",
  "type": "chunk",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "224",
  "column": "12",
  "slicing": "['            file_bytes += chunk\\n', '        f.write(lzma.decompress(file_bytes).decode())\\n']",
  "context": "nk_size=1024 * 36):\n        if chunk:\n            file_bytes += chunk\n\n    OUTPUT_PATH.mkdir(parents=True, exist_ok=True"
 },
 "20": {
  "name": "today_prices",
  "type": "build_today_prices",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "246",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    config: configparser.ConfigParser,\\n', '    github_repo_local_path: pathlib.Path,\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    shutil.rmtree(github_repo_local_path)\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    card_hoarder = _generate_prices(CardHoarderProvider())\\n', '    tcgplayer = _generate_prices(TCGPlayerProvider())\\n', '    card_market = _generate_prices(CardMarketProvider())\\n', '    card_kingdom = _generate_prices(CardKingdomProvider())\\n', '    final_results = deep_merge_dictionaries(\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '    return final_results\\n', '    preprocess_prices = provider.generate_today_price_dict(\\n', '        final_prices: Dict[str, Any] = json.loads(\\n', '            json.dumps(preprocess_prices, default=lambda o: o.to_json())\\n', '        return final_prices\\n', '        LOGGER.error(\\n', '    config = TCGPlayerProvider().get_configs()\\n', '    if \"GitHub\" not in config.sections():\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    github_local_path = CACHE_PATH.joinpath(\"GitHub-PricesArchive\")\\n', '    return download_prices_archive(config, github_local_path)\\n', '    file_bytes = b\"\"\\n', '    file_data = requests.get(\\n', '    for chunk in file_data.iter_content(chunk_size=1024 * 36):\\n', '        if chunk:\\n', '            file_bytes += chunk\\n', '    with OUTPUT_PATH.joinpath(\"AllPrintings.json\").open(\"w\", encoding=\"utf8\") as f:\\n', '        f.write(lzma.decompress(file_bytes).decode())\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '    today_prices = build_today_prices()\\n', '    if not today_prices:\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    archive_prices = get_price_archive_data()\\n', '    LOGGER.info(\"Merging price data\")\\n', '    archive_prices = deep_merge_dictionaries(archive_prices, today_prices)\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    prune_prices_archive(archive_prices)\\n', '    LOGGER.info(\"Uploading price data\")\\n', '    upload_prices_archive(config, github_local_path, archive_prices)\\n', '    return archive_prices\\n']",
  "context": "se\n    LOGGER.info(\"Building new price data\")\n    today_prices = build_today_prices()\n\n    if not today_prices:\n        LOGGER.warning(\""
 },
 "21": {
  "name": "archive_prices",
  "type": "get_price_archive_data",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "252",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    config: configparser.ConfigParser,\\n', '    github_repo_local_path: pathlib.Path,\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    shutil.rmtree(github_repo_local_path)\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    card_hoarder = _generate_prices(CardHoarderProvider())\\n', '    tcgplayer = _generate_prices(TCGPlayerProvider())\\n', '    card_market = _generate_prices(CardMarketProvider())\\n', '    card_kingdom = _generate_prices(CardKingdomProvider())\\n', '    final_results = deep_merge_dictionaries(\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '    return final_results\\n', '    preprocess_prices = provider.generate_today_price_dict(\\n', '        final_prices: Dict[str, Any] = json.loads(\\n', '            json.dumps(preprocess_prices, default=lambda o: o.to_json())\\n', '        return final_prices\\n', '        LOGGER.error(\\n', '    config = TCGPlayerProvider().get_configs()\\n', '    if \"GitHub\" not in config.sections():\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    github_local_path = CACHE_PATH.joinpath(\"GitHub-PricesArchive\")\\n', '    return download_prices_archive(config, github_local_path)\\n', '    file_bytes = b\"\"\\n', '    file_data = requests.get(\\n', '    for chunk in file_data.iter_content(chunk_size=1024 * 36):\\n', '        if chunk:\\n', '            file_bytes += chunk\\n', '    with OUTPUT_PATH.joinpath(\"AllPrintings.json\").open(\"w\", encoding=\"utf8\") as f:\\n', '        f.write(lzma.decompress(file_bytes).decode())\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '    today_prices = build_today_prices()\\n', '    if not today_prices:\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    archive_prices = get_price_archive_data()\\n', '    LOGGER.info(\"Merging price data\")\\n', '    archive_prices = deep_merge_dictionaries(archive_prices, today_prices)\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    prune_prices_archive(archive_prices)\\n', '    LOGGER.info(\"Uploading price data\")\\n', '    upload_prices_archive(config, github_local_path, archive_prices)\\n', '    return archive_prices\\n']",
  "context": "ation failed to generate\")\n        return {}\n\n    archive_prices = get_price_archive_data()\n\n    # Update local copy of database\n    LOGGER.in"
 },
 "22": {
  "name": "archive_prices",
  "type": "utils.deep_merge_dictionaries",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "256",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    config: configparser.ConfigParser,\\n', '    github_repo_local_path: pathlib.Path,\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    shutil.rmtree(github_repo_local_path)\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    card_hoarder = _generate_prices(CardHoarderProvider())\\n', '    tcgplayer = _generate_prices(TCGPlayerProvider())\\n', '    card_market = _generate_prices(CardMarketProvider())\\n', '    card_kingdom = _generate_prices(CardKingdomProvider())\\n', '    final_results = deep_merge_dictionaries(\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '    return final_results\\n', '    preprocess_prices = provider.generate_today_price_dict(\\n', '        final_prices: Dict[str, Any] = json.loads(\\n', '            json.dumps(preprocess_prices, default=lambda o: o.to_json())\\n', '        return final_prices\\n', '        LOGGER.error(\\n', '    config = TCGPlayerProvider().get_configs()\\n', '    if \"GitHub\" not in config.sections():\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    github_local_path = CACHE_PATH.joinpath(\"GitHub-PricesArchive\")\\n', '    return download_prices_archive(config, github_local_path)\\n', '    file_bytes = b\"\"\\n', '    file_data = requests.get(\\n', '    for chunk in file_data.iter_content(chunk_size=1024 * 36):\\n', '        if chunk:\\n', '            file_bytes += chunk\\n', '    with OUTPUT_PATH.joinpath(\"AllPrintings.json\").open(\"w\", encoding=\"utf8\") as f:\\n', '        f.write(lzma.decompress(file_bytes).decode())\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '    today_prices = build_today_prices()\\n', '    if not today_prices:\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    archive_prices = get_price_archive_data()\\n', '    LOGGER.info(\"Merging price data\")\\n', '    archive_prices = deep_merge_dictionaries(archive_prices, today_prices)\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    prune_prices_archive(archive_prices)\\n', '    LOGGER.info(\"Uploading price data\")\\n', '    upload_prices_archive(config, github_local_path, archive_prices)\\n', '    return archive_prices\\n']",
  "context": "atabase\n    LOGGER.info(\"Merging price data\")\n    archive_prices = deep_merge_dictionaries(archive_prices, today_prices)\n\n    # Prune local copy of database\n    LOGGER.inf"
 },
 "23": {
  "name": "last_price_build_time",
  "type": "datetime",
  "class": "imported",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/price_builder.py",
  "lineno": "285",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    config: configparser.ConfigParser,\\n', '    github_repo_local_path: pathlib.Path,\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_key = config.get(\"GitHub\", \"api_key\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_url = f\"https://{github_username}:{github_api_key}@github.com/{github_username}/{github_repo_name}.git\"\\n', '        LOGGER.info(\"Deleting Old Price Data Repo\")\\n', '    LOGGER.info(\"Cloning Price Data Repo\")\\n', '    git_sh = git.cmd.Git()\\n', '    git_sh.clone(github_url, github_repo_local_path, depth=1)\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name)) as file:\\n', '        return dict(json.load(file))\\n', '    config: configparser.ConfigParser,\\n', '    github_repo_local_path: pathlib.Path,\\n', '    content: Any,\\n', '        LOGGER.warning(\"GitHub section not established. Skipping upload\")\\n', '    github_username = config.get(\"GitHub\", \"username\")\\n', '    github_api_token = config.get(\"GitHub\", \"api_key\")\\n', '    github_file_name = config.get(\"GitHub\", \"file_name\")\\n', '    github_repo_name = config.get(\"GitHub\", \"repo_name\")\\n', '        github_username and github_api_token and github_file_name and github_repo_name\\n', '        LOGGER.warning(\"GitHub key values missing. Skipping upload\")\\n', '    with lzma.open(github_repo_local_path.joinpath(github_file_name), \"w\") as file:\\n', '        file.write(json.dumps(content).encode(\"utf-8\"))\\n', '        repo = git.Repo(github_repo_local_path)\\n', '        repo.git.remote(\\n', '            f\"https://{github_username}:{github_api_token}@github.com/{github_username}/{github_repo_name}.git\",\\n', '        repo.git.commit(\"-am\", \"auto-push\")\\n', '        origin = repo.remote()\\n', '        push_results = origin.push()\\n', '        if not push_results:\\n', '            LOGGER.error(\"A critical failure happened with GitHub push\")\\n', '        push_result = push_results[0]\\n', '        if push_result.flags & push_result.ERROR == push_result.ERROR:\\n', '            LOGGER.error(f\"Push to GitHub failed: {push_result.summary}\")\\n', '        LOGGER.info(\"Pushed changes to GitHub repo\")\\n', '        LOGGER.warning(\"No changes found to GitHub repo, skipping\")\\n', '    shutil.rmtree(github_repo_local_path)\\n', 'def prune_prices_archive(content: Dict[str, Any], months: int = 3) -> None:\\n', '    prune_date_str = (\\n', '    keys_pruned = 0\\n', '    def prune_recursive(obj: Dict[str, Any], depth: int = 0) -> None:\\n', '            for date in list(obj.keys()):\\n', '                if date < prune_date_str:\\n', '                    del obj[date]\\n', '                    keys_pruned += 1\\n', '            for key, value in list(obj.items()):\\n', '                prune_recursive(value, depth + 1)\\n', '                if not value:\\n', '                    del obj[key]\\n', '                    keys_pruned += 1\\n', '    LOGGER.info(\"Determining keys to prune\")\\n', '    prune_recursive(content)\\n', '    LOGGER.info(f\"Pruned {keys_pruned} structs\")\\n', '        LOGGER.error(f\"Unable to build prices. AllPrintings not found in {OUTPUT_PATH}\")\\n', '    card_hoarder = _generate_prices(CardHoarderProvider())\\n', '    tcgplayer = _generate_prices(TCGPlayerProvider())\\n', '    card_market = _generate_prices(CardMarketProvider())\\n', '    card_kingdom = _generate_prices(CardKingdomProvider())\\n', '    final_results = deep_merge_dictionaries(\\n', '        card_hoarder, tcgplayer, card_market, card_kingdom\\n', '    return final_results\\n', '    preprocess_prices = provider.generate_today_price_dict(\\n', '        final_prices: Dict[str, Any] = json.loads(\\n', '            json.dumps(preprocess_prices, default=lambda o: o.to_json())\\n', '        return final_prices\\n', '        LOGGER.error(\\n', '    config = TCGPlayerProvider().get_configs()\\n', '    if \"GitHub\" not in config.sections():\\n', '        LOGGER.warning(\"GitHub section not established. Skipping requests\")\\n', '    LOGGER.info(\"Downloading Price Data Repo\")\\n', '    github_local_path = CACHE_PATH.joinpath(\"GitHub-PricesArchive\")\\n', '    return download_prices_archive(config, github_local_path)\\n', '    file_bytes = b\"\"\\n', '    file_data = requests.get(\\n', '    for chunk in file_data.iter_content(chunk_size=1024 * 36):\\n', '        if chunk:\\n', '            file_bytes += chunk\\n', '    with OUTPUT_PATH.joinpath(\"AllPrintings.json\").open(\"w\", encoding=\"utf8\") as f:\\n', '        f.write(lzma.decompress(file_bytes).decode())\\n', '    LOGGER.info(\"Prices Build - Building Prices\")\\n', '        LOGGER.info(\"AllPrintings not found, attempting to download\")\\n', '    LOGGER.info(\"Building new price data\")\\n', '    today_prices = build_today_prices()\\n', '    if not today_prices:\\n', '        LOGGER.warning(\"Pricing information failed to generate\")\\n', '    archive_prices = get_price_archive_data()\\n', '    LOGGER.info(\"Merging price data\")\\n', '    archive_prices = deep_merge_dictionaries(archive_prices, today_prices)\\n', '    LOGGER.info(\"Pruning price data\")\\n', '    prune_prices_archive(archive_prices)\\n', '    LOGGER.info(\"Uploading price data\")\\n', '    config = TCGPlayerProvider().get_configs()\\n', '    github_local_path = CACHE_PATH.joinpath(\"GitHub-PricesArchive\")\\n', '    upload_prices_archive(config, github_local_path, archive_prices)\\n', '    return archive_prices\\n', '    cache_file = CACHE_PATH.joinpath(\"last_price_build_time\")\\n', '    if not cache_file.is_file():\\n', '    stat_time = cache_file.stat().st_mtime\\n', '    last_price_build_time = datetime.datetime.fromtimestamp(stat_time)\\n', '    return twelve_hours_ago > last_price_build_time\\n']",
  "context": "e\n\n    stat_time = cache_file.stat().st_mtime\n    last_price_build_time = datetime.datetime.fromtimestamp(stat_time)\n    twelve_hours_ago = datetime.datetime.now() - d"
 },
 "24": {
  "name": "start_time",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n']",
  "context": " LOG_PATH.mkdir(parents=True, exist_ok=True)\n\n    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\n\n    logging.basicConfig(\n        level=logging.DE"
 },
 "25": {
  "name": "unique_seed",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "48",
  "column": "15",
  "slicing": "['def url_keygen(unique_seed: Union[int, str], with_leading: bool = True) -> str:\\n']",
  "context": "rllib3\").setLevel(logging.ERROR)\n\n\ndef url_keygen(unique_seed: Union[int, str], with_leading: bool = True) -> str:\n    \"\"\"\n    Generates a key that MTGJSON will use "
 },
 "26": {
  "name": "with_leading",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "48",
  "column": "45",
  "slicing": "['def url_keygen(unique_seed: Union[int, str], with_leading: bool = True) -> str:\\n']",
  "context": "R)\n\n\ndef url_keygen(unique_seed: Union[int, str], with_leading: bool = True) -> str:\n    \"\"\"\n    Generates a key that MTGJSON will use "
 },
 "27": {
  "name": "snake_str",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "59",
  "column": "18",
  "slicing": "['def to_camel_case(snake_str: str) -> str:\\n']",
  "context": ".encode()).hexdigest()[:16]}\"\n\n\ndef to_camel_case(snake_str: str) -> str:\n    \"\"\"\n    Convert \"snake_case\" => \"snakeCase\"\n  "
 },
 "28": {
  "name": "magic_rules",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['    magic_rules: str, start_header: str = \"\", end_header: str = \"\"\\n']",
  "context": "mponents[1:])\n\n\ndef parse_magic_rules_subset(\n    magic_rules: str, start_header: str = \"\", end_header: str = \"\"\n) -> str:\n    \"\"\"\n    Split up the magic rules to "
 },
 "29": {
  "name": "start_header",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "70",
  "column": "22",
  "slicing": "['    magic_rules: str, start_header: str = \"\", end_header: str = \"\"\\n']",
  "context": "f parse_magic_rules_subset(\n    magic_rules: str, start_header: str = \"\", end_header: str = \"\"\n) -> str:\n    \"\"\"\n    Split up the magic rules to "
 },
 "30": {
  "name": "end_header",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "70",
  "column": "46",
  "slicing": "['    magic_rules: str, start_header: str = \"\", end_header: str = \"\"\\n']",
  "context": "et(\n    magic_rules: str, start_header: str = \"\", end_header: str = \"\"\n) -> str:\n    \"\"\"\n    Split up the magic rules to "
 },
 "31": {
  "name": "magic_rules",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "81",
  "column": "8",
  "slicing": "['    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n', '    return_value = \"https://mtgjson.com/links/\" if with_leading else \"\"\\n', '    return f\"{return_value}{hashlib.sha256(str(unique_seed).encode()).hexdigest()[:16]}\"\\n', '    components = snake_str.split(\"_\")\\n', '    return components[0] + \"\".join(x.title() for x in components[1:])\\n', '        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\\n', '    valid_line_segments = \"\\\\n\".join(magic_rules.splitlines())\\n', '    return valid_line_segments\\n']",
  "context": "n XXX\n    if start_header and end_header:\n        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\n\n    # Windows line endings... yuck\n    valid_line"
 },
 "32": {
  "name": "retries",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "90",
  "column": "4",
  "slicing": "['    retries: int = 8,\\n']",
  "context": " valid_line_segments\n\n\ndef retryable_session(\n    retries: int = 8,\n) -> Union[requests.Session, requests_cache.Cached"
 },
 "33": {
  "name": "function",
  "type": "typing.Callable",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "121",
  "column": "4",
  "slicing": "['    function: Callable,\\n']",
  "context": "om\"})\n    return session\n\n\ndef parallel_call(\n    function: Callable,\n    args: Any,\n    repeatable_args: Union[Tuple[An"
 },
 "34": {
  "name": "args",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "122",
  "column": "4",
  "slicing": "['    args: Any,\\n']",
  "context": "\n\n\ndef parallel_call(\n    function: Callable,\n    args: Any,\n    repeatable_args: Union[Tuple[Any, ...], List[A"
 },
 "35": {
  "name": "repeatable_args",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "123",
  "column": "4",
  "slicing": "['    repeatable_args: Union[Tuple[Any, ...], List[Any]] = None,\\n']",
  "context": "_call(\n    function: Callable,\n    args: Any,\n    repeatable_args: Union[Tuple[Any, ...], List[Any]] = None,\n    fold_list: bool = False,\n    fold_dict: bool ="
 },
 "36": {
  "name": "fold_list",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "124",
  "column": "4",
  "slicing": "['    fold_list: bool = False,\\n']",
  "context": "gs: Union[Tuple[Any, ...], List[Any]] = None,\n    fold_list: bool = False,\n    fold_dict: bool = False,\n    force_starmap: bo"
 },
 "37": {
  "name": "fold_dict",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "125",
  "column": "4",
  "slicing": "['    fold_dict: bool = False,\\n']",
  "context": "st[Any]] = None,\n    fold_list: bool = False,\n    fold_dict: bool = False,\n    force_starmap: bool = False,\n    pool_size: in"
 },
 "38": {
  "name": "force_starmap",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "126",
  "column": "4",
  "slicing": "['    force_starmap: bool = False,\\n']",
  "context": "t: bool = False,\n    fold_dict: bool = False,\n    force_starmap: bool = False,\n    pool_size: int = 32,\n) -> Any:\n    \"\"\"\n    Exe"
 },
 "39": {
  "name": "pool_size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "127",
  "column": "4",
  "slicing": "['    pool_size: int = 32,\\n']",
  "context": "ool = False,\n    force_starmap: bool = False,\n    pool_size: int = 32,\n) -> Any:\n    \"\"\"\n    Execute a function in parall"
 },
 "40": {
  "name": "extra_args_rep",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "143",
  "column": "8",
  "slicing": "['    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n', '    return_value = \"https://mtgjson.com/links/\" if with_leading else \"\"\\n', '    return f\"{return_value}{hashlib.sha256(str(unique_seed).encode()).hexdigest()[:16]}\"\\n', '    components = snake_str.split(\"_\")\\n', '    return components[0] + \"\".join(x.title() for x in components[1:])\\n', '        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\\n', '    valid_line_segments = \"\\\\n\".join(magic_rules.splitlines())\\n', '    return valid_line_segments\\n', '        stack = inspect.stack()\\n', '        calling_class = stack[1][0].f_locals[\"self\"].__class__.__name__\\n', '        session = requests_cache.CachedSession(str(CACHE_PATH.joinpath(calling_class)))\\n', '        session = requests.Session()\\n', '    retry = urllib3.util.retry.Retry(\\n', '    adapter = requests.adapters.HTTPAdapter(max_retries=retry)\\n', '    session.mount(\"http://\", adapter)\\n', '    session.mount(\"https://\", adapter)\\n', '    session.headers.update({\"User-Agent\": \"Mozilla/5.0 Firefox/75.0 www.mtgjson.com\"})\\n', '    return session\\n', '    pool = gevent.pool.Pool(pool_size)\\n', '        extra_args_rep = [itertools.repeat(arg) for arg in repeatable_args]\\n', '        results = pool.map(lambda g_args: function(*g_args), zip(args, *extra_args_rep))\\n', '        results = pool.map(lambda g_args: function(*g_args), args)\\n', '        results = pool.map(function, args)\\n', '        return list(itertools.chain.from_iterable(results))\\n', '        return dict(collections.ChainMap(*results))\\n', '    return results\\n']",
  "context": ".Pool(pool_size)\n\n    if repeatable_args:\n        extra_args_rep = [itertools.repeat(arg) for arg in repeatable_args]\n        results = pool.map(lambda g_args: function"
 },
 "41": {
  "name": "data",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "159",
  "column": "24",
  "slicing": "['def sort_internal_lists(data: Any) -> Any:\\n']",
  "context": "s))\n\n    return results\n\n\ndef sort_internal_lists(data: Any) -> Any:\n    \"\"\"\n    Sort all lists & sets within a given d"
 },
 "42": {
  "name": "set_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "174",
  "column": "25",
  "slicing": "['def fix_windows_set_name(set_name: str) -> str:\\n']",
  "context": "ata))\n\n    return data\n\n\ndef fix_windows_set_name(set_name: str) -> str:\n    \"\"\"\n    In the Windows OS, there are certain f"
 },
 "43": {
  "name": "block_size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "188",
  "column": "46",
  "slicing": "['def get_file_hash(file_to_hash: pathlib.Path, block_size: int = 65536) -> str:\\n']",
  "context": "e\n\n\ndef get_file_hash(file_to_hash: pathlib.Path, block_size: int = 65536) -> str:\n    \"\"\"\n    Given a file, generate a hash of the c"
 },
 "44": {
  "name": "value",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "212",
  "column": "20",
  "slicing": "['def get_str_or_none(value: Any) -> Optional[str]:\\n']",
  "context": " hash_operation.hexdigest()\n\n\ndef get_str_or_none(value: Any) -> Optional[str]:\n    \"\"\"\n    Given a value, get its string represen"
 },
 "45": {
  "name": "message",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "225",
  "column": "27",
  "slicing": "['def send_push_notification(message: str) -> bool:\\n']",
  "context": "   return str(value)\n\n\ndef send_push_notification(message: str) -> bool:\n    \"\"\"\n    Send a push notification to project ma"
 },
 "46": {
  "name": "pushover_app_users",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "238",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n', '    return_value = \"https://mtgjson.com/links/\" if with_leading else \"\"\\n', '    return f\"{return_value}{hashlib.sha256(str(unique_seed).encode()).hexdigest()[:16]}\"\\n', '    components = snake_str.split(\"_\")\\n', '    return components[0] + \"\".join(x.title() for x in components[1:])\\n', '        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\\n', '    valid_line_segments = \"\\\\n\".join(magic_rules.splitlines())\\n', '    return valid_line_segments\\n', '        stack = inspect.stack()\\n', '        calling_class = stack[1][0].f_locals[\"self\"].__class__.__name__\\n', '        session = requests_cache.CachedSession(str(CACHE_PATH.joinpath(calling_class)))\\n', '        session = requests.Session()\\n', '    retry = urllib3.util.retry.Retry(\\n', '    adapter = requests.adapters.HTTPAdapter(max_retries=retry)\\n', '    session.mount(\"http://\", adapter)\\n', '    session.mount(\"https://\", adapter)\\n', '    session.headers.update({\"User-Agent\": \"Mozilla/5.0 Firefox/75.0 www.mtgjson.com\"})\\n', '    return session\\n', '    pool = gevent.pool.Pool(pool_size)\\n', '        extra_args_rep = [itertools.repeat(arg) for arg in repeatable_args]\\n', '        results = pool.map(lambda g_args: function(*g_args), zip(args, *extra_args_rep))\\n', '        results = pool.map(lambda g_args: function(*g_args), args)\\n', '        results = pool.map(function, args)\\n', '        return list(itertools.chain.from_iterable(results))\\n', '        return dict(collections.ChainMap(*results))\\n', '    return results\\n', '        for key, value in data.items():\\n', '            data[key] = sort_internal_lists(value)\\n', '        LOGGER.warning(f\"Unable to find {file_to_hash}, no hashes generated\")\\n', '    hash_operation = consts.HASH_TO_GENERATE.copy()\\n', '    with file_to_hash.open(\"rb\") as file:\\n', '            data = file.read(block_size)\\n', '            if not data:\\n', '            hash_operation.update(data)\\n', '    return hash_operation.hexdigest()\\n', '    if not value:\\n', '    return str(value)\\n', '        LOGGER.warning(\"Pushover section not established. Skipping alerts\")\\n', '    pushover_app_token = consts.CONFIG.get(\"Pushover\", \"app_token\")\\n', '    pushover_app_users = list(\\n', '    if not (pushover_app_token and pushover_app_token):\\n', '        LOGGER.warning(\"Pushover keys values missing. Skipping alerts\")\\n', '    all_succeeded = True\\n', '    for user in pushover_app_users:\\n', '        response = requests.post(\\n', '                \"token\": pushover_app_token,\\n', '                \"user\": user,\\n', '        if not response.ok:\\n', '            LOGGER.warning(f\"Error sending Pushover notification: {response.text}\")\\n', '            all_succeeded = False\\n', '    return all_succeeded\\n', '    result = first_dict.copy()\\n', '    for dictionary in other_dicts:\\n', '        for key, new in dictionary.items():\\n', '            old = result.get(key)\\n', '            if isinstance(old, dict) and isinstance(new, dict):\\n', '                new = deep_merge_dictionaries(old, new)\\n', '            result[key] = new\\n', '    return result\\n', '    all_printings_content: Dict[str, Any]\\n', '    cards_and_tokens_with_set_code = []\\n', '    for value in all_printings_content.values():\\n', '        for card in value.get(\"cards\", []) + value.get(\"tokens\", []):\\n', '            cards_and_tokens_with_set_code.append(card)\\n', '    return cards_and_tokens_with_set_code\\n', '    all_printings_path: pathlib.Path,\\n', '    all_printings_path = all_printings_path.expanduser()\\n', '    if not all_printings_path.exists():\\n', '        LOGGER.error(f\"File {all_printings_path} does not exist, cannot iterate\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as f:\\n', '        file_contents = json.load(f).get(\"data\", {})\\n', '    for card in get_all_cards_and_tokens_from_content(file_contents):\\n', '        yield card\\n', '    for card in get_all_cards_and_tokens(all_printings_path):\\n', '            key = card\\n', '            for inside_component in left_side_components:\\n', '                key = key[inside_component]\\n', '            value = card\\n', '            for inside_component in right_side_components:\\n', '                value = value[inside_component]\\n', '            dump_map[str(key)] = value\\n']",
  "context": " = consts.CONFIG.get(\"Pushover\", \"app_token\")\n    pushover_app_users = list(\n        filter(None, consts.CONFIG.get(\"Pushover\","
 },
 "47": {
  "name": "all_succeeded",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "246",
  "column": "4",
  "slicing": "['    all_succeeded = True\\n', '    return all_succeeded\\n']",
  "context": "sing. Skipping alerts\")\n        return False\n\n    all_succeeded = True\n    for user in pushover_app_users:\n        respon"
 },
 "48": {
  "name": "all_succeeded",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "259",
  "column": "12",
  "slicing": "['            all_succeeded = False\\n', '    return all_succeeded\\n']",
  "context": "hover notification: {response.text}\")\n            all_succeeded = False\n\n    return all_succeeded\n\n\ndef deep_merge_diction"
 },
 "49": {
  "name": "first_dict",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "265",
  "column": "4",
  "slicing": "['    first_dict: Dict[str, Any], *other_dicts: Dict[str, Any]\\n']",
  "context": " all_succeeded\n\n\ndef deep_merge_dictionaries(\n    first_dict: Dict[str, Any], *other_dicts: Dict[str, Any]\n) -> Dict[str, Any]:\n    \"\"\"\n    Merge N dictionar"
 },
 "50": {
  "name": "new",
  "type": "utils.deep_merge_dictionaries",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "279",
  "column": "16",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n', '    return_value = \"https://mtgjson.com/links/\" if with_leading else \"\"\\n', '    return f\"{return_value}{hashlib.sha256(str(unique_seed).encode()).hexdigest()[:16]}\"\\n', '    components = snake_str.split(\"_\")\\n', '    return components[0] + \"\".join(x.title() for x in components[1:])\\n', '        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\\n', '    valid_line_segments = \"\\\\n\".join(magic_rules.splitlines())\\n', '    return valid_line_segments\\n', '        stack = inspect.stack()\\n', '        calling_class = stack[1][0].f_locals[\"self\"].__class__.__name__\\n', '        session = requests_cache.CachedSession(str(CACHE_PATH.joinpath(calling_class)))\\n', '        session = requests.Session()\\n', '    retry = urllib3.util.retry.Retry(\\n', '    adapter = requests.adapters.HTTPAdapter(max_retries=retry)\\n', '    session.mount(\"http://\", adapter)\\n', '    session.mount(\"https://\", adapter)\\n', '    session.headers.update({\"User-Agent\": \"Mozilla/5.0 Firefox/75.0 www.mtgjson.com\"})\\n', '    return session\\n', '    pool = gevent.pool.Pool(pool_size)\\n', '        extra_args_rep = [itertools.repeat(arg) for arg in repeatable_args]\\n', '        results = pool.map(lambda g_args: function(*g_args), zip(args, *extra_args_rep))\\n', '        results = pool.map(lambda g_args: function(*g_args), args)\\n', '        results = pool.map(function, args)\\n', '        return list(itertools.chain.from_iterable(results))\\n', '        return dict(collections.ChainMap(*results))\\n', '    return results\\n', '        for key, value in data.items():\\n', '            data[key] = sort_internal_lists(value)\\n', '        LOGGER.warning(f\"Unable to find {file_to_hash}, no hashes generated\")\\n', '    hash_operation = consts.HASH_TO_GENERATE.copy()\\n', '    with file_to_hash.open(\"rb\") as file:\\n', '            data = file.read(block_size)\\n', '            if not data:\\n', '            hash_operation.update(data)\\n', '    return hash_operation.hexdigest()\\n', '    if not value:\\n', '    return str(value)\\n', '        LOGGER.warning(\"Pushover section not established. Skipping alerts\")\\n', '    pushover_app_token = consts.CONFIG.get(\"Pushover\", \"app_token\")\\n', '    pushover_app_users = list(\\n', '    if not (pushover_app_token and pushover_app_token):\\n', '        LOGGER.warning(\"Pushover keys values missing. Skipping alerts\")\\n', '    all_succeeded = True\\n', '    for user in pushover_app_users:\\n', '        response = requests.post(\\n', '                \"token\": pushover_app_token,\\n', '                \"user\": user,\\n', '        if not response.ok:\\n', '            LOGGER.warning(f\"Error sending Pushover notification: {response.text}\")\\n', '            all_succeeded = False\\n', '    return all_succeeded\\n', '    result = first_dict.copy()\\n', '    for dictionary in other_dicts:\\n', '        for key, new in dictionary.items():\\n', '            old = result.get(key)\\n', '            if isinstance(old, dict) and isinstance(new, dict):\\n', '                new = deep_merge_dictionaries(old, new)\\n', '            result[key] = new\\n', '    return result\\n', '    all_printings_content: Dict[str, Any]\\n', '    cards_and_tokens_with_set_code = []\\n', '    for value in all_printings_content.values():\\n', '        for card in value.get(\"cards\", []) + value.get(\"tokens\", []):\\n', '            cards_and_tokens_with_set_code.append(card)\\n', '    return cards_and_tokens_with_set_code\\n', '    all_printings_path: pathlib.Path,\\n', '    all_printings_path = all_printings_path.expanduser()\\n', '    if not all_printings_path.exists():\\n', '        LOGGER.error(f\"File {all_printings_path} does not exist, cannot iterate\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as f:\\n', '        file_contents = json.load(f).get(\"data\", {})\\n', '    for card in get_all_cards_and_tokens_from_content(file_contents):\\n', '        yield card\\n', '    for card in get_all_cards_and_tokens(all_printings_path):\\n', '            key = card\\n', '            for inside_component in left_side_components:\\n', '                key = key[inside_component]\\n', '            value = card\\n', '            for inside_component in right_side_components:\\n', '                value = value[inside_component]\\n', '            dump_map[str(key)] = value\\n']",
  "context": " dict) and isinstance(new, dict):\n                new = deep_merge_dictionaries(old, new)\n            result[key] = new\n\n    return result\n\n"
 },
 "51": {
  "name": "all_printings_content",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "286",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n', '    return_value = \"https://mtgjson.com/links/\" if with_leading else \"\"\\n', '    return f\"{return_value}{hashlib.sha256(str(unique_seed).encode()).hexdigest()[:16]}\"\\n', '    components = snake_str.split(\"_\")\\n', '    return components[0] + \"\".join(x.title() for x in components[1:])\\n', '        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\\n', '    valid_line_segments = \"\\\\n\".join(magic_rules.splitlines())\\n', '    return valid_line_segments\\n', '        stack = inspect.stack()\\n', '        calling_class = stack[1][0].f_locals[\"self\"].__class__.__name__\\n', '        session = requests_cache.CachedSession(str(CACHE_PATH.joinpath(calling_class)))\\n', '        session = requests.Session()\\n', '    retry = urllib3.util.retry.Retry(\\n', '    adapter = requests.adapters.HTTPAdapter(max_retries=retry)\\n', '    session.mount(\"http://\", adapter)\\n', '    session.mount(\"https://\", adapter)\\n', '    session.headers.update({\"User-Agent\": \"Mozilla/5.0 Firefox/75.0 www.mtgjson.com\"})\\n', '    return session\\n', '    pool = gevent.pool.Pool(pool_size)\\n', '        extra_args_rep = [itertools.repeat(arg) for arg in repeatable_args]\\n', '        results = pool.map(lambda g_args: function(*g_args), zip(args, *extra_args_rep))\\n', '        results = pool.map(lambda g_args: function(*g_args), args)\\n', '        results = pool.map(function, args)\\n', '        return list(itertools.chain.from_iterable(results))\\n', '        return dict(collections.ChainMap(*results))\\n', '    return results\\n', '        for key, value in data.items():\\n', '            data[key] = sort_internal_lists(value)\\n', '        LOGGER.warning(f\"Unable to find {file_to_hash}, no hashes generated\")\\n', '    hash_operation = consts.HASH_TO_GENERATE.copy()\\n', '    with file_to_hash.open(\"rb\") as file:\\n', '            data = file.read(block_size)\\n', '            if not data:\\n', '            hash_operation.update(data)\\n', '    return hash_operation.hexdigest()\\n', '    if not value:\\n', '    return str(value)\\n', '        LOGGER.warning(\"Pushover section not established. Skipping alerts\")\\n', '    pushover_app_token = consts.CONFIG.get(\"Pushover\", \"app_token\")\\n', '    pushover_app_users = list(\\n', '    if not (pushover_app_token and pushover_app_token):\\n', '        LOGGER.warning(\"Pushover keys values missing. Skipping alerts\")\\n', '    all_succeeded = True\\n', '    for user in pushover_app_users:\\n', '        response = requests.post(\\n', '                \"token\": pushover_app_token,\\n', '                \"user\": user,\\n', '        if not response.ok:\\n', '            LOGGER.warning(f\"Error sending Pushover notification: {response.text}\")\\n', '            all_succeeded = False\\n', '    return all_succeeded\\n', '    result = first_dict.copy()\\n', '    for dictionary in other_dicts:\\n', '        for key, new in dictionary.items():\\n', '            old = result.get(key)\\n', '            if isinstance(old, dict) and isinstance(new, dict):\\n', '                new = deep_merge_dictionaries(old, new)\\n', '            result[key] = new\\n', '    return result\\n', '    all_printings_content: Dict[str, Any]\\n', '    cards_and_tokens_with_set_code = []\\n', '    for value in all_printings_content.values():\\n', '        for card in value.get(\"cards\", []) + value.get(\"tokens\", []):\\n', '            cards_and_tokens_with_set_code.append(card)\\n', '    return cards_and_tokens_with_set_code\\n', '    all_printings_path: pathlib.Path,\\n', '    all_printings_path = all_printings_path.expanduser()\\n', '    if not all_printings_path.exists():\\n', '        LOGGER.error(f\"File {all_printings_path} does not exist, cannot iterate\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as f:\\n', '        file_contents = json.load(f).get(\"data\", {})\\n', '    for card in get_all_cards_and_tokens_from_content(file_contents):\\n', '        yield card\\n', '    for card in get_all_cards_and_tokens(all_printings_path):\\n', '            key = card\\n', '            for inside_component in left_side_components:\\n', '                key = key[inside_component]\\n', '            value = card\\n', '            for inside_component in right_side_components:\\n', '                value = value[inside_component]\\n', '            dump_map[str(key)] = value\\n']",
  "context": "\n\n\ndef get_all_cards_and_tokens_from_content(\n    all_printings_content: Dict[str, Any]\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Convert the"
 },
 "52": {
  "name": "cards_and_tokens_with_set_code",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "293",
  "column": "4",
  "slicing": "['    cards_and_tokens_with_set_code = []\\n', '            cards_and_tokens_with_set_code.append(card)\\n', '    return cards_and_tokens_with_set_code\\n']",
  "context": "llPrintings\n    :return List of cards\n    \"\"\"\n    cards_and_tokens_with_set_code = []\n    for value in all_printings_content.values():\n "
 },
 "53": {
  "name": "left_side_components",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "322",
  "column": "4",
  "slicing": "['    left_side_components: Tuple[str, ...],\\n']",
  "context": "apping(\n    all_printings_path: pathlib.Path,\n    left_side_components: Tuple[str, ...],\n    right_side_components: Tuple[str, ...],\n) -> D"
 },
 "54": {
  "name": "right_side_components",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "323",
  "column": "4",
  "slicing": "['    right_side_components: Tuple[str, ...],\\n']",
  "context": "h,\n    left_side_components: Tuple[str, ...],\n    right_side_components: Tuple[str, ...],\n) -> Dict[str, Any]:\n    \"\"\"\n    Construct a mappi"
 },
 "55": {
  "name": "dump_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "333",
  "column": "4",
  "slicing": "['    dump_map: Dict[str, Any] = {}\\n', '            dump_map[str(key)] = value\\n', '    return dump_map\\n']",
  "context": "m left components => right components\n    \"\"\"\n    dump_map: Dict[str, Any] = {}\n\n    for card in get_all_cards_and_tokens(all_prin"
 },
 "56": {
  "name": "key",
  "type": "card",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "337",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n', '    return_value = \"https://mtgjson.com/links/\" if with_leading else \"\"\\n', '    return f\"{return_value}{hashlib.sha256(str(unique_seed).encode()).hexdigest()[:16]}\"\\n', '    components = snake_str.split(\"_\")\\n', '    return components[0] + \"\".join(x.title() for x in components[1:])\\n', '        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\\n', '    valid_line_segments = \"\\\\n\".join(magic_rules.splitlines())\\n', '    return valid_line_segments\\n', '        stack = inspect.stack()\\n', '        calling_class = stack[1][0].f_locals[\"self\"].__class__.__name__\\n', '        session = requests_cache.CachedSession(str(CACHE_PATH.joinpath(calling_class)))\\n', '        session = requests.Session()\\n', '    retry = urllib3.util.retry.Retry(\\n', '    adapter = requests.adapters.HTTPAdapter(max_retries=retry)\\n', '    session.mount(\"http://\", adapter)\\n', '    session.mount(\"https://\", adapter)\\n', '    session.headers.update({\"User-Agent\": \"Mozilla/5.0 Firefox/75.0 www.mtgjson.com\"})\\n', '    return session\\n', '    pool = gevent.pool.Pool(pool_size)\\n', '        extra_args_rep = [itertools.repeat(arg) for arg in repeatable_args]\\n', '        results = pool.map(lambda g_args: function(*g_args), zip(args, *extra_args_rep))\\n', '        results = pool.map(lambda g_args: function(*g_args), args)\\n', '        results = pool.map(function, args)\\n', '        return list(itertools.chain.from_iterable(results))\\n', '        return dict(collections.ChainMap(*results))\\n', '    return results\\n', '        for key, value in data.items():\\n', '            data[key] = sort_internal_lists(value)\\n', '        LOGGER.warning(f\"Unable to find {file_to_hash}, no hashes generated\")\\n', '    hash_operation = consts.HASH_TO_GENERATE.copy()\\n', '    with file_to_hash.open(\"rb\") as file:\\n', '            data = file.read(block_size)\\n', '            if not data:\\n', '            hash_operation.update(data)\\n', '    return hash_operation.hexdigest()\\n', '    if not value:\\n', '    return str(value)\\n', '        LOGGER.warning(\"Pushover section not established. Skipping alerts\")\\n', '    pushover_app_token = consts.CONFIG.get(\"Pushover\", \"app_token\")\\n', '    pushover_app_users = list(\\n', '    if not (pushover_app_token and pushover_app_token):\\n', '        LOGGER.warning(\"Pushover keys values missing. Skipping alerts\")\\n', '    all_succeeded = True\\n', '    for user in pushover_app_users:\\n', '        response = requests.post(\\n', '                \"token\": pushover_app_token,\\n', '                \"user\": user,\\n', '        if not response.ok:\\n', '            LOGGER.warning(f\"Error sending Pushover notification: {response.text}\")\\n', '            all_succeeded = False\\n', '    return all_succeeded\\n', '    result = first_dict.copy()\\n', '    for dictionary in other_dicts:\\n', '        for key, new in dictionary.items():\\n', '            old = result.get(key)\\n', '            if isinstance(old, dict) and isinstance(new, dict):\\n', '                new = deep_merge_dictionaries(old, new)\\n', '            result[key] = new\\n', '    return result\\n', '    all_printings_content: Dict[str, Any]\\n', '    cards_and_tokens_with_set_code = []\\n', '    for value in all_printings_content.values():\\n', '        for card in value.get(\"cards\", []) + value.get(\"tokens\", []):\\n', '            cards_and_tokens_with_set_code.append(card)\\n', '    return cards_and_tokens_with_set_code\\n', '    all_printings_path: pathlib.Path,\\n', '    all_printings_path = all_printings_path.expanduser()\\n', '    if not all_printings_path.exists():\\n', '        LOGGER.error(f\"File {all_printings_path} does not exist, cannot iterate\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as f:\\n', '        file_contents = json.load(f).get(\"data\", {})\\n', '    for card in get_all_cards_and_tokens_from_content(file_contents):\\n', '        yield card\\n', '    for card in get_all_cards_and_tokens(all_printings_path):\\n', '            key = card\\n', '            for inside_component in left_side_components:\\n', '                key = key[inside_component]\\n', '            value = card\\n', '            for inside_component in right_side_components:\\n', '                value = value[inside_component]\\n', '            dump_map[str(key)] = value\\n']",
  "context": "ens(all_printings_path):\n        try:\n            key = card\n            for inside_component in left_side_comp"
 },
 "57": {
  "name": "key",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "339",
  "column": "16",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n', '    return_value = \"https://mtgjson.com/links/\" if with_leading else \"\"\\n', '    return f\"{return_value}{hashlib.sha256(str(unique_seed).encode()).hexdigest()[:16]}\"\\n', '    components = snake_str.split(\"_\")\\n', '    return components[0] + \"\".join(x.title() for x in components[1:])\\n', '        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\\n', '    valid_line_segments = \"\\\\n\".join(magic_rules.splitlines())\\n', '    return valid_line_segments\\n', '        stack = inspect.stack()\\n', '        calling_class = stack[1][0].f_locals[\"self\"].__class__.__name__\\n', '        session = requests_cache.CachedSession(str(CACHE_PATH.joinpath(calling_class)))\\n', '        session = requests.Session()\\n', '    retry = urllib3.util.retry.Retry(\\n', '    adapter = requests.adapters.HTTPAdapter(max_retries=retry)\\n', '    session.mount(\"http://\", adapter)\\n', '    session.mount(\"https://\", adapter)\\n', '    session.headers.update({\"User-Agent\": \"Mozilla/5.0 Firefox/75.0 www.mtgjson.com\"})\\n', '    return session\\n', '    pool = gevent.pool.Pool(pool_size)\\n', '        extra_args_rep = [itertools.repeat(arg) for arg in repeatable_args]\\n', '        results = pool.map(lambda g_args: function(*g_args), zip(args, *extra_args_rep))\\n', '        results = pool.map(lambda g_args: function(*g_args), args)\\n', '        results = pool.map(function, args)\\n', '        return list(itertools.chain.from_iterable(results))\\n', '        return dict(collections.ChainMap(*results))\\n', '    return results\\n', '        for key, value in data.items():\\n', '            data[key] = sort_internal_lists(value)\\n', '        LOGGER.warning(f\"Unable to find {file_to_hash}, no hashes generated\")\\n', '    hash_operation = consts.HASH_TO_GENERATE.copy()\\n', '    with file_to_hash.open(\"rb\") as file:\\n', '            data = file.read(block_size)\\n', '            if not data:\\n', '            hash_operation.update(data)\\n', '    return hash_operation.hexdigest()\\n', '    if not value:\\n', '    return str(value)\\n', '        LOGGER.warning(\"Pushover section not established. Skipping alerts\")\\n', '    pushover_app_token = consts.CONFIG.get(\"Pushover\", \"app_token\")\\n', '    pushover_app_users = list(\\n', '    if not (pushover_app_token and pushover_app_token):\\n', '        LOGGER.warning(\"Pushover keys values missing. Skipping alerts\")\\n', '    all_succeeded = True\\n', '    for user in pushover_app_users:\\n', '        response = requests.post(\\n', '                \"token\": pushover_app_token,\\n', '                \"user\": user,\\n', '        if not response.ok:\\n', '            LOGGER.warning(f\"Error sending Pushover notification: {response.text}\")\\n', '            all_succeeded = False\\n', '    return all_succeeded\\n', '    result = first_dict.copy()\\n', '    for dictionary in other_dicts:\\n', '        for key, new in dictionary.items():\\n', '            old = result.get(key)\\n', '            if isinstance(old, dict) and isinstance(new, dict):\\n', '                new = deep_merge_dictionaries(old, new)\\n', '            result[key] = new\\n', '    return result\\n', '    all_printings_content: Dict[str, Any]\\n', '    cards_and_tokens_with_set_code = []\\n', '    for value in all_printings_content.values():\\n', '        for card in value.get(\"cards\", []) + value.get(\"tokens\", []):\\n', '            cards_and_tokens_with_set_code.append(card)\\n', '    return cards_and_tokens_with_set_code\\n', '    all_printings_path: pathlib.Path,\\n', '    all_printings_path = all_printings_path.expanduser()\\n', '    if not all_printings_path.exists():\\n', '        LOGGER.error(f\"File {all_printings_path} does not exist, cannot iterate\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as f:\\n', '        file_contents = json.load(f).get(\"data\", {})\\n', '    for card in get_all_cards_and_tokens_from_content(file_contents):\\n', '        yield card\\n', '    for card in get_all_cards_and_tokens(all_printings_path):\\n', '            key = card\\n', '            for inside_component in left_side_components:\\n', '                key = key[inside_component]\\n', '            value = card\\n', '            for inside_component in right_side_components:\\n', '                value = value[inside_component]\\n', '            dump_map[str(key)] = value\\n']",
  "context": "omponent in left_side_components:\n                key = key[inside_component]\n\n            value = card\n            for inside_c"
 },
 "58": {
  "name": "value",
  "type": "card",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "341",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n', '    return_value = \"https://mtgjson.com/links/\" if with_leading else \"\"\\n', '    return f\"{return_value}{hashlib.sha256(str(unique_seed).encode()).hexdigest()[:16]}\"\\n', '    components = snake_str.split(\"_\")\\n', '    return components[0] + \"\".join(x.title() for x in components[1:])\\n', '        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\\n', '    valid_line_segments = \"\\\\n\".join(magic_rules.splitlines())\\n', '    return valid_line_segments\\n', '        stack = inspect.stack()\\n', '        calling_class = stack[1][0].f_locals[\"self\"].__class__.__name__\\n', '        session = requests_cache.CachedSession(str(CACHE_PATH.joinpath(calling_class)))\\n', '        session = requests.Session()\\n', '    retry = urllib3.util.retry.Retry(\\n', '    adapter = requests.adapters.HTTPAdapter(max_retries=retry)\\n', '    session.mount(\"http://\", adapter)\\n', '    session.mount(\"https://\", adapter)\\n', '    session.headers.update({\"User-Agent\": \"Mozilla/5.0 Firefox/75.0 www.mtgjson.com\"})\\n', '    return session\\n', '    pool = gevent.pool.Pool(pool_size)\\n', '        extra_args_rep = [itertools.repeat(arg) for arg in repeatable_args]\\n', '        results = pool.map(lambda g_args: function(*g_args), zip(args, *extra_args_rep))\\n', '        results = pool.map(lambda g_args: function(*g_args), args)\\n', '        results = pool.map(function, args)\\n', '        return list(itertools.chain.from_iterable(results))\\n', '        return dict(collections.ChainMap(*results))\\n', '    return results\\n', '        for key, value in data.items():\\n', '            data[key] = sort_internal_lists(value)\\n', '        LOGGER.warning(f\"Unable to find {file_to_hash}, no hashes generated\")\\n', '    hash_operation = consts.HASH_TO_GENERATE.copy()\\n', '    with file_to_hash.open(\"rb\") as file:\\n', '            data = file.read(block_size)\\n', '            if not data:\\n', '            hash_operation.update(data)\\n', '    return hash_operation.hexdigest()\\n', '    if not value:\\n', '    return str(value)\\n', '        LOGGER.warning(\"Pushover section not established. Skipping alerts\")\\n', '    pushover_app_token = consts.CONFIG.get(\"Pushover\", \"app_token\")\\n', '    pushover_app_users = list(\\n', '    if not (pushover_app_token and pushover_app_token):\\n', '        LOGGER.warning(\"Pushover keys values missing. Skipping alerts\")\\n', '    all_succeeded = True\\n', '    for user in pushover_app_users:\\n', '        response = requests.post(\\n', '                \"token\": pushover_app_token,\\n', '                \"user\": user,\\n', '        if not response.ok:\\n', '            LOGGER.warning(f\"Error sending Pushover notification: {response.text}\")\\n', '            all_succeeded = False\\n', '    return all_succeeded\\n', '    result = first_dict.copy()\\n', '    for dictionary in other_dicts:\\n', '        for key, new in dictionary.items():\\n', '            old = result.get(key)\\n', '            if isinstance(old, dict) and isinstance(new, dict):\\n', '                new = deep_merge_dictionaries(old, new)\\n', '            result[key] = new\\n', '    return result\\n', '    all_printings_content: Dict[str, Any]\\n', '    cards_and_tokens_with_set_code = []\\n', '    for value in all_printings_content.values():\\n', '        for card in value.get(\"cards\", []) + value.get(\"tokens\", []):\\n', '            cards_and_tokens_with_set_code.append(card)\\n', '    return cards_and_tokens_with_set_code\\n', '    all_printings_path: pathlib.Path,\\n', '    all_printings_path = all_printings_path.expanduser()\\n', '    if not all_printings_path.exists():\\n', '        LOGGER.error(f\"File {all_printings_path} does not exist, cannot iterate\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as f:\\n', '        file_contents = json.load(f).get(\"data\", {})\\n', '    for card in get_all_cards_and_tokens_from_content(file_contents):\\n', '        yield card\\n', '    for card in get_all_cards_and_tokens(all_printings_path):\\n', '            key = card\\n', '            for inside_component in left_side_components:\\n', '                key = key[inside_component]\\n', '            value = card\\n', '            for inside_component in right_side_components:\\n', '                value = value[inside_component]\\n', '            dump_map[str(key)] = value\\n']",
  "context": "         key = key[inside_component]\n\n            value = card\n            for inside_component in right_side_com"
 },
 "59": {
  "name": "value",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/utils.py",
  "lineno": "343",
  "column": "16",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    start_time = time.strftime(\"%Y-%m-%d_%H.%M.%S\")\\n', '            logging.FileHandler(str(LOG_PATH.joinpath(f\"mtgjson_{start_time}.log\"))),\\n', '    return_value = \"https://mtgjson.com/links/\" if with_leading else \"\"\\n', '    return f\"{return_value}{hashlib.sha256(str(unique_seed).encode()).hexdigest()[:16]}\"\\n', '    components = snake_str.split(\"_\")\\n', '    return components[0] + \"\".join(x.title() for x in components[1:])\\n', '        magic_rules = magic_rules.split(start_header)[2].split(end_header)[0]\\n', '    valid_line_segments = \"\\\\n\".join(magic_rules.splitlines())\\n', '    return valid_line_segments\\n', '        stack = inspect.stack()\\n', '        calling_class = stack[1][0].f_locals[\"self\"].__class__.__name__\\n', '        session = requests_cache.CachedSession(str(CACHE_PATH.joinpath(calling_class)))\\n', '        session = requests.Session()\\n', '    retry = urllib3.util.retry.Retry(\\n', '    adapter = requests.adapters.HTTPAdapter(max_retries=retry)\\n', '    session.mount(\"http://\", adapter)\\n', '    session.mount(\"https://\", adapter)\\n', '    session.headers.update({\"User-Agent\": \"Mozilla/5.0 Firefox/75.0 www.mtgjson.com\"})\\n', '    return session\\n', '    pool = gevent.pool.Pool(pool_size)\\n', '        extra_args_rep = [itertools.repeat(arg) for arg in repeatable_args]\\n', '        results = pool.map(lambda g_args: function(*g_args), zip(args, *extra_args_rep))\\n', '        results = pool.map(lambda g_args: function(*g_args), args)\\n', '        results = pool.map(function, args)\\n', '        return list(itertools.chain.from_iterable(results))\\n', '        return dict(collections.ChainMap(*results))\\n', '    return results\\n', '        for key, value in data.items():\\n', '            data[key] = sort_internal_lists(value)\\n', '        LOGGER.warning(f\"Unable to find {file_to_hash}, no hashes generated\")\\n', '    hash_operation = consts.HASH_TO_GENERATE.copy()\\n', '    with file_to_hash.open(\"rb\") as file:\\n', '            data = file.read(block_size)\\n', '            if not data:\\n', '            hash_operation.update(data)\\n', '    return hash_operation.hexdigest()\\n', '    if not value:\\n', '    return str(value)\\n', '        LOGGER.warning(\"Pushover section not established. Skipping alerts\")\\n', '    pushover_app_token = consts.CONFIG.get(\"Pushover\", \"app_token\")\\n', '    pushover_app_users = list(\\n', '    if not (pushover_app_token and pushover_app_token):\\n', '        LOGGER.warning(\"Pushover keys values missing. Skipping alerts\")\\n', '    all_succeeded = True\\n', '    for user in pushover_app_users:\\n', '        response = requests.post(\\n', '                \"token\": pushover_app_token,\\n', '                \"user\": user,\\n', '        if not response.ok:\\n', '            LOGGER.warning(f\"Error sending Pushover notification: {response.text}\")\\n', '            all_succeeded = False\\n', '    return all_succeeded\\n', '    result = first_dict.copy()\\n', '    for dictionary in other_dicts:\\n', '        for key, new in dictionary.items():\\n', '            old = result.get(key)\\n', '            if isinstance(old, dict) and isinstance(new, dict):\\n', '                new = deep_merge_dictionaries(old, new)\\n', '            result[key] = new\\n', '    return result\\n', '    all_printings_content: Dict[str, Any]\\n', '    cards_and_tokens_with_set_code = []\\n', '    for value in all_printings_content.values():\\n', '        for card in value.get(\"cards\", []) + value.get(\"tokens\", []):\\n', '            cards_and_tokens_with_set_code.append(card)\\n', '    return cards_and_tokens_with_set_code\\n', '    all_printings_path: pathlib.Path,\\n', '    all_printings_path = all_printings_path.expanduser()\\n', '    if not all_printings_path.exists():\\n', '        LOGGER.error(f\"File {all_printings_path} does not exist, cannot iterate\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as f:\\n', '        file_contents = json.load(f).get(\"data\", {})\\n', '    for card in get_all_cards_and_tokens_from_content(file_contents):\\n', '        yield card\\n', '    for card in get_all_cards_and_tokens(all_printings_path):\\n', '            key = card\\n', '            for inside_component in left_side_components:\\n', '                key = key[inside_component]\\n', '            value = card\\n', '            for inside_component in right_side_components:\\n', '                value = value[inside_component]\\n', '            dump_map[str(key)] = value\\n']",
  "context": "mponent in right_side_components:\n                value = value[inside_component]\n\n            dump_map[str(key)] = value\n        ex"
 },
 "60": {
  "name": "mtgjson_set",
  "type": "classes.MtgjsonSetObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/referral_builder.py",
  "lineno": "14",
  "column": "33",
  "slicing": "['def build_and_write_referral_map(mtgjson_set: MtgjsonSetObject) -> None:\\n']",
  "context": "gger(__name__)\n\n\ndef build_and_write_referral_map(mtgjson_set: MtgjsonSetObject) -> None:\n    \"\"\"\n    Construct and then output the referral"
 },
 "61": {
  "name": "referral_map",
  "type": "build_referral_map",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/referral_builder.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    referral_map = build_referral_map(mtgjson_set)\\n', '    write_referral_map(referral_map)\\n']",
  "context": "p\n    :param mtgjson_set: MTGJSON Set\n    \"\"\"\n    referral_map = build_referral_map(mtgjson_set)\n    write_referral_map(referral_map)\n\n\ndef build_r"
 },
 "62": {
  "name": "mtgjson_set",
  "type": "classes.MtgjsonSetObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/referral_builder.py",
  "lineno": "23",
  "column": "23",
  "slicing": "['def build_referral_map(mtgjson_set: MtgjsonSetObject) -> List[Tuple[str, str]]:\\n']",
  "context": "ferral_map(referral_map)\n\n\ndef build_referral_map(mtgjson_set: MtgjsonSetObject) -> List[Tuple[str, str]]:\n    \"\"\"\n    Construct the referral map contents\n  "
 },
 "63": {
  "name": "return_list",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/referral_builder.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    return_list = []\\n', '            return_list.append(\\n', '    return return_list\\n']",
  "context": "    :return: Referral content to dump\n    \"\"\"\n    return_list = []\n    string_regex = re.compile(re.escape(\"scryfall\""
 },
 "64": {
  "name": "single_set_referral_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/referral_builder.py",
  "lineno": "51",
  "column": "23",
  "slicing": "['def write_referral_map(single_set_referral_map: List[Tuple[str, str]]) -> None:\\n']",
  "context": "\n\n    return return_list\n\n\ndef write_referral_map(single_set_referral_map: List[Tuple[str, str]]) -> None:\n    \"\"\"\n    Dump referral map content to the datab"
 },
 "65": {
  "name": "lines",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/referral_builder.py",
  "lineno": "67",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    referral_map = build_referral_map(mtgjson_set)\\n', '    write_referral_map(referral_map)\\n', '    return_list = []\\n', '    string_regex = re.compile(re.escape(\"scryfall\"), re.IGNORECASE)\\n', '    for mtgjson_card_object in mtgjson_set.cards:\\n', '        for service, url in mtgjson_card_object.purchase_urls.to_json().items():\\n', '            if service not in mtgjson_card_object.raw_purchase_urls:\\n', '                LOGGER.info(\\n', '                    f\"Service {service} not found for {mtgjson_card_object.name}\"\\n', '            return_list.append(\\n', '                    url.split(\"/\")[-1],\\n', '                    string_regex.sub(\\n', '                        \"mtgjson\", mtgjson_card_object.raw_purchase_urls[service]\\n', '    return return_list\\n', '    with OUTPUT_PATH.joinpath(\"ReferralMap.json\").open(\"a\", encoding=\"utf-8\") as file:\\n', '        for entry in single_set_referral_map:\\n', '            file.write(f\"/links/{entry[0]}\\\\t{entry[1]};\\\\n\")\\n', '    with OUTPUT_PATH.joinpath(\"ReferralMap.json\").open(encoding=\"utf-8\") as file:\\n', '        lines = list(set(file.readlines()))\\n', '        lines = sorted(lines)\\n', '        file.writelines(lines)\\n']",
  "context": "ap.json\").open(encoding=\"utf-8\") as file:\n        lines = list(set(file.readlines()))\n        lines = sorted(lines)\n\n    with OUTPUT_PAT"
 },
 "66": {
  "name": "lines",
  "type": "sorted",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/referral_builder.py",
  "lineno": "68",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    referral_map = build_referral_map(mtgjson_set)\\n', '    write_referral_map(referral_map)\\n', '    return_list = []\\n', '    string_regex = re.compile(re.escape(\"scryfall\"), re.IGNORECASE)\\n', '    for mtgjson_card_object in mtgjson_set.cards:\\n', '        for service, url in mtgjson_card_object.purchase_urls.to_json().items():\\n', '            if service not in mtgjson_card_object.raw_purchase_urls:\\n', '                LOGGER.info(\\n', '                    f\"Service {service} not found for {mtgjson_card_object.name}\"\\n', '            return_list.append(\\n', '                    url.split(\"/\")[-1],\\n', '                    string_regex.sub(\\n', '                        \"mtgjson\", mtgjson_card_object.raw_purchase_urls[service]\\n', '    return return_list\\n', '    with OUTPUT_PATH.joinpath(\"ReferralMap.json\").open(\"a\", encoding=\"utf-8\") as file:\\n', '        for entry in single_set_referral_map:\\n', '            file.write(f\"/links/{entry[0]}\\\\t{entry[1]};\\\\n\")\\n', '    with OUTPUT_PATH.joinpath(\"ReferralMap.json\").open(encoding=\"utf-8\") as file:\\n', '        lines = list(set(file.readlines()))\\n', '        lines = sorted(lines)\\n', '        file.writelines(lines)\\n']",
  "context": "      lines = list(set(file.readlines()))\n        lines = sorted(lines)\n\n    with OUTPUT_PATH.joinpath(\"ReferralMap.json\")"
 },
 "67": {
  "name": "MTGJSON_VERSION",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "26",
  "column": "0",
  "slicing": "['MTGJSON_VERSION: str = CONFIG.get(\"MTGJSON\", \"version\", fallback=\"5.X.X\")\\n', 'OUTPUT_PATH: pathlib.Path = ENV_OUT_PATH.joinpath(f\"mtgjson_build_{MTGJSON_VERSION}\")\\n']",
  "context": "f CONFIG_PATH:\n    CONFIG.read(str(CONFIG_PATH))\n\nMTGJSON_VERSION: str = CONFIG.get(\"MTGJSON\", \"version\", fallback=\"5.X.X\")\nMTGJSON_BUILD_DATE: str = CONFIG.get(\n    \"MTGJSON"
 },
 "68": {
  "name": "MTGJSON_BUILD_DATE",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "27",
  "column": "0",
  "slicing": "['MTGJSON_BUILD_DATE: str = CONFIG.get(\\n']",
  "context": "ONFIG.get(\"MTGJSON\", \"version\", fallback=\"5.X.X\")\nMTGJSON_BUILD_DATE: str = CONFIG.get(\n    \"MTGJSON\", \"date\", fallback=\"\"\n) or datetime.d"
 },
 "69": {
  "name": "USE_CACHE",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "31",
  "column": "0",
  "slicing": "['USE_CACHE: bool = (\\n']",
  "context": "r datetime.datetime.today().strftime(\"%Y-%m-%d\")\n\nUSE_CACHE: bool = (\n    CONFIG.get(\"MTGJSON\", \"use_cache\", fallback=\"f"
 },
 "70": {
  "name": "CARD_MARKET_BUFFER",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "43",
  "column": "0",
  "slicing": "['CARD_MARKET_BUFFER: str = \"10101\"\\n']",
  "context": "Hash Details\nHASH_TO_GENERATE = hashlib.sha256()\n\nCARD_MARKET_BUFFER: str = \"10101\"\nCARD_KINGDOM_REFERRAL: str = (\n    \"?partner=mtgjs"
 },
 "71": {
  "name": "CARD_KINGDOM_REFERRAL",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "44",
  "column": "0",
  "slicing": "['CARD_KINGDOM_REFERRAL: str = (\\n']",
  "context": "shlib.sha256()\n\nCARD_MARKET_BUFFER: str = \"10101\"\nCARD_KINGDOM_REFERRAL: str = (\n    \"?partner=mtgjson&utm_source=mtgjson&utm_mediu"
 },
 "72": {
  "name": "FOREIGN_SETS",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "50",
  "column": "0",
  "slicing": "['FOREIGN_SETS: Set[str] = {\\n']",
  "context": "=card_prices&utm_medium=text&utm_source=mtgjson\"\n\nFOREIGN_SETS: Set[str] = {\n    \"PMPS11\",\n    \"PS11\",\n    \"PSAL\",\n    \"PMPS10\""
 },
 "73": {
  "name": "SUPER_TYPES",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "69",
  "column": "0",
  "slicing": "['SUPER_TYPES: Set[str] = {\"Basic\", \"Host\", \"Legendary\", \"Ongoing\", \"Snow\", \"World\"}\\n']",
  "context": "D\",\n    \"REN\",\n    \"RIN\",\n    \"4BB\",\n    \"FBB\",\n}\nSUPER_TYPES: Set[str] = {\"Basic\", \"Host\", \"Legendary\", \"Ongoing\", \"Snow\", \"World\"}\nBASIC_LAND_NAMES: Set[str] = {\"Plains\", \"Island\", "
 },
 "74": {
  "name": "BASIC_LAND_NAMES",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "70",
  "column": "0",
  "slicing": "['BASIC_LAND_NAMES: Set[str] = {\"Plains\", \"Island\", \"Swamp\", \"Mountain\", \"Forest\"}\\n']",
  "context": " \"Host\", \"Legendary\", \"Ongoing\", \"Snow\", \"World\"}\nBASIC_LAND_NAMES: Set[str] = {\"Plains\", \"Island\", \"Swamp\", \"Mountain\", \"Forest\"}\nLANGUAGE_MAP: Dict[str, str] = {\n    \"en\": \"Englis"
 },
 "75": {
  "name": "LANGUAGE_MAP",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "71",
  "column": "0",
  "slicing": "['LANGUAGE_MAP: Dict[str, str] = {\\n']",
  "context": "Plains\", \"Island\", \"Swamp\", \"Mountain\", \"Forest\"}\nLANGUAGE_MAP: Dict[str, str] = {\n    \"en\": \"English\",\n    \"es\": \"Spanish\",\n    \"fr\""
 },
 "76": {
  "name": "WIZARDS_SUPPORTED_LANGUAGES",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "91",
  "column": "0",
  "slicing": "['WIZARDS_SUPPORTED_LANGUAGES: List[Tuple[str, str]] = [\\n']",
  "context": ",\n    \"ph\": \"Phyrexian\",\n    \"px\": \"Phyrexian\",\n}\nWIZARDS_SUPPORTED_LANGUAGES: List[Tuple[str, str]] = [\n    (\"zh-hans\", \"Chinese Simplified\"),\n    (\"zh-ha"
 },
 "77": {
  "name": "SYMBOL_MAP",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "104",
  "column": "0",
  "slicing": "['SYMBOL_MAP: Dict[str, str] = {\\n']",
  "context": ",\n    (\"es\", \"Spanish\"),\n    (\"en\", \"English\"),\n]\nSYMBOL_MAP: Dict[str, str] = {\n    \"White\": \"W\",\n    \"Blue\": \"U\",\n    \"Black\": \"B"
 },
 "78": {
  "name": "BAD_FILE_NAMES",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "143",
  "column": "0",
  "slicing": "['BAD_FILE_NAMES: Set[str] = {\\n']",
  "context": "p\": \"T\",\n    \"Untap\": \"Q\",\n    \"Infinite\": \"\",\n}\nBAD_FILE_NAMES: Set[str] = {\n    # File names that can't exist on Windows\n    \""
 },
 "79": {
  "name": "SUPPORTED_FORMAT_OUTPUTS",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "170",
  "column": "0",
  "slicing": "['SUPPORTED_FORMAT_OUTPUTS: Set[str] = {\\n']",
  "context": ",\n    \"LPT8\",\n    \"LPT9\",\n    \"NUL\",\n    \"PRN\",\n}\nSUPPORTED_FORMAT_OUTPUTS: Set[str] = {\n    \"standard\",\n    \"pioneer\",\n    \"modern\",\n    \""
 },
 "80": {
  "name": "SUPPORTED_SET_TYPES",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/consts.py",
  "lineno": "178",
  "column": "0",
  "slicing": "['SUPPORTED_SET_TYPES: Set[str] = {\\n']",
  "context": "rn\",\n    \"legacy\",\n    \"vintage\",\n    \"pauper\",\n}\nSUPPORTED_SET_TYPES: Set[str] = {\n    \"expansion\",\n    \"core\",\n    \"draft_innovation"
 },
 "81": {
  "name": "mtgjson_set_object",
  "type": "classes.MtgjsonSetObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "36",
  "column": "19",
  "slicing": "['def write_set_file(mtgjson_set_object: MtgjsonSetObject, pretty_print: bool) -> None:\\n']",
  "context": " logging.getLogger(__name__)\n\n\ndef write_set_file(mtgjson_set_object: MtgjsonSetObject, pretty_print: bool) -> None:\n    \"\"\"\n    Write MTGJSON Set out to a file\n    :p"
 },
 "82": {
  "name": "pretty_print",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "36",
  "column": "57",
  "slicing": "['def write_set_file(mtgjson_set_object: MtgjsonSetObject, pretty_print: bool) -> None:\\n']",
  "context": "te_set_file(mtgjson_set_object: MtgjsonSetObject, pretty_print: bool) -> None:\n    \"\"\"\n    Write MTGJSON Set out to a file\n    :p"
 },
 "83": {
  "name": "file_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "TPUT_PATH.mkdir(parents=True, exist_ok=True)\n\n    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\n    with OUTPUT_PATH.joinpath(file_name).open(\"w\","
 },
 "84": {
  "name": "price_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n']",
  "context": "     )\n\n\ndef generate_compiled_prices_output(\n    price_data: Dict[str, Dict[str, float]], pretty_print: bool\n) -> None:\n    \"\"\"\n    Dump AllPrices to a file\n  "
 },
 "85": {
  "name": "pretty_print",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "57",
  "column": "45",
  "slicing": "['    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        pretty_print,\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '            pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '            indent=(4 if pretty_print else None),\\n']",
  "context": "put(\n    price_data: Dict[str, Dict[str, float]], pretty_print: bool\n) -> None:\n    \"\"\"\n    Dump AllPrices to a file\n  "
 },
 "86": {
  "name": "all_printings",
  "type": "compiled_classes.MtgjsonAllPrintingsObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n']",
  "context": "int,\n    )\n\n\ndef build_format_specific_files(\n    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\n) -> None:\n    \"\"\"\n    Compile *Printings files ba"
 },
 "87": {
  "name": "pretty_print",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "72",
  "column": "46",
  "slicing": "['    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        pretty_print,\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '            pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '            indent=(4 if pretty_print else None),\\n']",
  "context": "es(\n    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\n) -> None:\n    \"\"\"\n    Compile *Printings files ba"
 },
 "88": {
  "name": "format_map",
  "type": "construct_format_map",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "  \"\"\"\n    # Format specific set code split up\n    format_map = construct_format_map()\n\n    # Standard.json\n    create_compiled_output(\n "
 },
 "89": {
  "name": "pretty_print",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "118",
  "column": "32",
  "slicing": "['def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    build_atomic_specific_files(pretty_print)\\n', '            pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '            indent=(4 if pretty_print else None),\\n']",
  "context": "ty_print,\n    )\n\n\ndef build_atomic_specific_files(pretty_print: bool) -> None:\n    \"\"\"\n    Compile *Atomic files based on AtomicC"
 },
 "90": {
  "name": "card_format_map",
  "type": "construct_atomic_cards_format_map",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "124",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "l\n    \"\"\"\n    # Format specific card split up\n    card_format_map = construct_atomic_cards_format_map()\n\n    # StandardCards.json\n    create_compiled_outp"
 },
 "91": {
  "name": "pretty_print",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "169",
  "column": "31",
  "slicing": "['def build_price_specific_files(pretty_print: bool) -> None:\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '            pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '            indent=(4 if pretty_print else None),\\n']",
  "context": "tty_print,\n    )\n\n\ndef build_price_specific_files(pretty_print: bool) -> None:\n    \"\"\"\n    Build prices related files (in this ca"
 },
 "92": {
  "name": "price_data_cache",
  "type": "price_builder.build_prices",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "178",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "GGER.info(\"Full Build - Building Prices\")\n        price_data_cache = build_prices()\n    else:\n        LOGGER.info(\"Full Build - Instal"
 },
 "93": {
  "name": "price_data_cache",
  "type": "price_builder.get_price_archive_data",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "181",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "fo(\"Full Build - Installing Price Cache\")\n        price_data_cache = get_price_archive_data()\n\n    # AllPrices.json\n    generate_compiled_prices"
 },
 "94": {
  "name": "pretty_print",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "187",
  "column": "30",
  "slicing": "['def build_all_printings_files(pretty_print: bool) -> None:\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '            pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '            indent=(4 if pretty_print else None),\\n']",
  "context": "he, pretty_print)\n\n\ndef build_all_printings_files(pretty_print: bool) -> None:\n    \"\"\"\n    Construct all entities that rely upon "
 },
 "95": {
  "name": "all_printings",
  "type": "compiled_classes.MtgjsonAllPrintingsObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "193",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "param pretty_print: Pretty or minimal\n    \"\"\"\n    all_printings = MtgjsonAllPrintingsObject()\n\n    # AllPrintings.json\n    create_compiled_outpu"
 },
 "96": {
  "name": "pretty_print",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "213",
  "column": "35",
  "slicing": "['def generate_compiled_output_files(pretty_print: bool) -> None:\\n']",
  "context": "print,\n    )\n\n\ndef generate_compiled_output_files(pretty_print: bool) -> None:\n    \"\"\"\n    Create and dump all compiled outputs\n "
 },
 "97": {
  "name": "deck_names",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "277",
  "column": "4",
  "slicing": "['    deck_names = []\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n']",
  "context": "retty_print)\n\n    # All Pre-constructed Decks\n    deck_names = []\n    for mtgjson_deck_obj in GitHubDecksProvider()."
 },
 "98": {
  "name": "mtgjson_deck_header_obj",
  "type": "classes.MtgjsonDeckHeaderObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "279",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "ubDecksProvider().iterate_precon_decks():\n        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\n        create_compiled_output(\n            f\"deck"
 },
 "99": {
  "name": "compiled_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "303",
  "column": "4",
  "slicing": "['    compiled_name: str, compiled_object: Any, pretty_print: bool\\n']",
  "context": "ty_print,\n    )\n\n\ndef create_compiled_output(\n    compiled_name: str, compiled_object: Any, pretty_print: bool\n) -> None:\n    \"\"\"\n    Log and write out a compile"
 },
 "100": {
  "name": "compiled_object",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "303",
  "column": "24",
  "slicing": "['    compiled_name: str, compiled_object: Any, pretty_print: bool\\n']",
  "context": "f create_compiled_output(\n    compiled_name: str, compiled_object: Any, pretty_print: bool\n) -> None:\n    \"\"\"\n    Log and write out a compile"
 },
 "101": {
  "name": "pretty_print",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "303",
  "column": "46",
  "slicing": "['    compiled_name: str, compiled_object: Any, pretty_print: bool\\n']",
  "context": "ut(\n    compiled_name: str, compiled_object: Any, pretty_print: bool\n) -> None:\n    \"\"\"\n    Log and write out a compile"
 },
 "102": {
  "name": "file_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "317",
  "column": "4",
  "slicing": "['    file_name: str, file_contents: Any, pretty_print: bool\\n']",
  "context": "_name}\")\n\n\ndef write_compiled_output_to_file(\n    file_name: str, file_contents: Any, pretty_print: bool\n) -> None:\n    \"\"\"\n    Dump content to a file in t"
 },
 "103": {
  "name": "file_contents",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "317",
  "column": "20",
  "slicing": "['    file_name: str, file_contents: Any, pretty_print: bool\\n']",
  "context": "rite_compiled_output_to_file(\n    file_name: str, file_contents: Any, pretty_print: bool\n) -> None:\n    \"\"\"\n    Dump content to a file in t"
 },
 "104": {
  "name": "pretty_print",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "317",
  "column": "40",
  "slicing": "['    file_name: str, file_contents: Any, pretty_print: bool\\n']",
  "context": "_to_file(\n    file_name: str, file_contents: Any, pretty_print: bool\n) -> None:\n    \"\"\"\n    Dump content to a file in t"
 },
 "105": {
  "name": "normal_sets_only",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "343",
  "column": "4",
  "slicing": "['    normal_sets_only: bool = True,\\n']",
  "context": "tructuresObject().all_printings}.json\"\n    ),\n    normal_sets_only: bool = True,\n) -> Dict[str, List[str]]:\n    \"\"\"\n    For each se"
 },
 "106": {
  "name": "format_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "353",
  "column": "4",
  "slicing": "['    format_map: Dict[str, List[str]] = {\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n']",
  "context": "Format Map for future identifications\n    \"\"\"\n    format_map: Dict[str, List[str]] = {\n        magic_format: [] for magic_format in SUPPO"
 },
 "107": {
  "name": "formats_set_legal_in",
  "type": "consts.SUPPORTED_FORMAT_OUTPUTS",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "368",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "UPPORTED_SET_TYPES:\n            continue\n\n        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\n        for card in set_code_content.get(\"cards\"):"
 },
 "108": {
  "name": "card_legalities",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "370",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "ard in set_code_content.get(\"cards\"):\n            card_legalities = set(card.get(\"legalities\").keys())\n            formats_set_legal_in = formats_set_leg"
 },
 "109": {
  "name": "format_card_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "391",
  "column": "4",
  "slicing": "['    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n']",
  "context": "on\n    :return: Cards in a format map\n    \"\"\"\n    format_card_map: Dict[str, List[Dict[str, Any]]] = {\n        magic_format: [] for magic_format in SUPPO"
 },
 "110": {
  "name": "generated_hash",
  "type": "utils.get_file_hash",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "425",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "_TO_GENERATE.name):\n            continue\n\n        generated_hash = get_file_hash(file)\n        if not generated_hash:\n            continu"
 },
 "111": {
  "name": "hash_file_name",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/output_generator.py",
  "lineno": "429",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    file_name: str = f\"{fix_windows_set_name(mtgjson_set_object.code)}.json\"\\n', '    with OUTPUT_PATH.joinpath(file_name).open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '    price_data: Dict[str, Dict[str, float]], pretty_print: bool\\n', '        price_data,\\n', '    all_printings: MtgjsonAllPrintingsObject, pretty_print: bool\\n', '    format_map = construct_format_map()\\n', '        all_printings.get_set_contents(format_map[\"standard\"]),\\n', '        all_printings.get_set_contents(format_map[\"pioneer\"]),\\n', '        all_printings.get_set_contents(format_map[\"modern\"]),\\n', '        all_printings.get_set_contents(format_map[\"legacy\"]),\\n', '        all_printings.get_set_contents(format_map[\"vintage\"]),\\n', 'def build_atomic_specific_files(pretty_print: bool) -> None:\\n', '    card_format_map = construct_atomic_cards_format_map()\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"standard\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pioneer\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"modern\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"legacy\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"vintage\"]),\\n', '        MtgjsonAtomicCardsObject(card_format_map[\"pauper\"]),\\n', 'def build_price_specific_files(pretty_print: bool) -> None:\\n', '        LOGGER.info(\"Full Build - Building Prices\")\\n', '        price_data_cache = build_prices()\\n', '        LOGGER.info(\"Full Build - Installing Price Cache\")\\n', '        price_data_cache = get_price_archive_data()\\n', '    generate_compiled_prices_output(price_data_cache, pretty_print)\\n', 'def build_all_printings_files(pretty_print: bool) -> None:\\n', '    all_printings = MtgjsonAllPrintingsObject()\\n', '        all_printings.get_set_contents(),\\n', '        pretty_print,\\n', '    build_format_specific_files(all_printings, pretty_print)\\n', '        MtgjsonAllIdentifiersObject(all_printings.to_json()),\\n', '        pretty_print,\\n', '    LOGGER.info(\"Building Compiled Outputs\")\\n', '    build_all_printings_files(pretty_print)\\n', '        pretty_print,\\n', '    build_price_specific_files(pretty_print)\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        pretty_print,\\n', '        MtgjsonStructuresObject().set_list, MtgjsonSetListObject(), pretty_print\\n', '        pretty_print,\\n', '    build_atomic_specific_files(pretty_print)\\n', '    deck_names = []\\n', '    for mtgjson_deck_obj in GitHubDecksProvider().iterate_precon_decks():\\n', '        mtgjson_deck_header_obj = MtgjsonDeckHeaderObject(mtgjson_deck_obj)\\n', '            f\"decks/{mtgjson_deck_header_obj.file_name}\",\\n', '            mtgjson_deck_obj,\\n', '            pretty_print,\\n', '        deck_names.append(mtgjson_deck_header_obj)\\n', '        MtgjsonDeckListObject(deck_names),\\n', '        pretty_print,\\n', '        pretty_print,\\n', '    LOGGER.info(f\"Generating {compiled_name}\")\\n', '    write_compiled_output_to_file(compiled_name, compiled_object, pretty_print)\\n', '    LOGGER.debug(f\"Finished Generating {compiled_name}\")\\n', '    write_file = OUTPUT_PATH.joinpath(f\"{file_name}.json\")\\n', '    write_file.parent.mkdir(parents=True, exist_ok=True)\\n', '    with write_file.open(\"w\", encoding=\"utf-8\") as file:\\n', '            fp=file,\\n', '            indent=(4 if pretty_print else None),\\n', '    format_map: Dict[str, List[str]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_code_key, set_code_content in content.get(\"data\", {}).items():\\n', '        if normal_sets_only and set_code_content.get(\"type\") not in SUPPORTED_SET_TYPES:\\n', '        formats_set_legal_in = SUPPORTED_FORMAT_OUTPUTS\\n', '        for card in set_code_content.get(\"cards\"):\\n', '            card_legalities = set(card.get(\"legalities\").keys())\\n', '            formats_set_legal_in = formats_set_legal_in.intersection(card_legalities)\\n', '        for magic_format in formats_set_legal_in:\\n', '            format_map[magic_format].append(set_code_key)\\n', '    return format_map\\n', '    format_card_map: Dict[str, List[Dict[str, Any]]] = {\\n', '        magic_format: [] for magic_format in SUPPORTED_FORMAT_OUTPUTS\\n', '        LOGGER.warning(f\"{all_printings_path} was not found, skipping format map\")\\n', '    with all_printings_path.open(encoding=\"utf-8\") as file:\\n', '        content = json.load(file)\\n', '    for set_contents in content.get(\"data\", {}).values():\\n', '        for card in set_contents.get(\"cards\", []):\\n', '            for magic_format in format_card_map.keys():\\n', '                if card.get(\"legalities\").get(magic_format) in {\"Legal\", \"Restricted\"}:\\n', '                    format_card_map[magic_format].append(card)\\n', '    return format_card_map\\n', '    for file in directory.glob(\"**/*\"):\\n', '        if file.is_dir():\\n', '        if file.name.endswith(HASH_TO_GENERATE.name):\\n', '        generated_hash = get_file_hash(file)\\n', '        if not generated_hash:\\n', '        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\\n', '        with file.parent.joinpath(hash_file_name).open(\\n', '            hash_file.write(generated_hash)\\n']",
  "context": "not generated_hash:\n            continue\n\n        hash_file_name = f\"{file.name}.{HASH_TO_GENERATE.name}\"\n        with file.parent.joinpath(hash_file_name)."
 },
 "112": {
  "name": "json_output_files",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/arg_parser.py",
  "lineno": "110",
  "column": "4",
  "slicing": "['    json_output_files: List[pathlib.Path] = list(OUTPUT_PATH.glob(\"**/*.json\"))\\n', '        {file.stem for file in json_output_files}\\n']",
  "context": " :return: List of all set codes found\n    \"\"\"\n    json_output_files: List[pathlib.Path] = list(OUTPUT_PATH.glob(\"**/*.json\"))\n\n    set_codes_found = list(\n        {file.stem fo"
 },
 "113": {
  "name": "set_codes_found",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/arg_parser.py",
  "lineno": "112",
  "column": "4",
  "slicing": "['    parser = argparse.ArgumentParser(\"mtgjson5\")\\n', '    sets_group = parser.add_mutually_exclusive_group()\\n', '    sets_group.add_argument(\\n', '    sets_group.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    mtgjson_arg_group = parser.add_argument_group(\"mtgjson maintainer arguments\")\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '        parser.print_help()\\n', '        parser.exit()\\n', '    return parser.parse_args()\\n', '    json_output_files: List[pathlib.Path] = list(OUTPUT_PATH.glob(\"**/*.json\"))\\n', '    set_codes_found = list(\\n', '        {file.stem for file in json_output_files}\\n', '    LOGGER.info(f\"Sets Built Already: {\\', \\'.join(set_codes_found)}\")\\n', '        for set_code in set_codes_found\\n', '    return set_codes_found\\n', '        set_code\\n', '        if not (set_code.startswith(\"t\") and set_code[1:] in scryfall_set_codes)\\n']",
  "context": ".Path] = list(OUTPUT_PATH.glob(\"**/*.json\"))\n\n    set_codes_found = list(\n        {file.stem for file in json_output_files}\n"
 },
 "114": {
  "name": "set_codes_found",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/arg_parser.py",
  "lineno": "119",
  "column": "4",
  "slicing": "['    set_codes_found = [\\n', '        for set_code in set_codes_found\\n', '    return set_codes_found\\n', '        set_code\\n', '        if not (set_code.startswith(\"t\") and set_code[1:] in scryfall_set_codes)\\n']",
  "context": "uilt Already: {', '.join(set_codes_found)}\")\n\n    set_codes_found = [\n        set_code[:-1] if set_code[:-1] in BAD_FILE"
 },
 "115": {
  "name": "scryfall_instance",
  "type": "providers.ScryfallProvider",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/arg_parser.py",
  "lineno": "132",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    parser = argparse.ArgumentParser(\"mtgjson5\")\\n', '    sets_group = parser.add_mutually_exclusive_group()\\n', '    sets_group.add_argument(\\n', '    sets_group.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    mtgjson_arg_group = parser.add_argument_group(\"mtgjson maintainer arguments\")\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '        parser.print_help()\\n', '        parser.exit()\\n', '    return parser.parse_args()\\n', '    json_output_files: List[pathlib.Path] = list(OUTPUT_PATH.glob(\"**/*.json\"))\\n', '    set_codes_found = list(\\n', '        {file.stem for file in json_output_files}\\n', '    LOGGER.info(f\"Sets Built Already: {\\', \\'.join(set_codes_found)}\")\\n', '    set_codes_found = [\\n', '        for set_code in set_codes_found\\n', '    return set_codes_found\\n', '    scryfall_instance = ScryfallProvider()\\n', '    scryfall_sets = scryfall_instance.download(scryfall_instance.ALL_SETS_URL)\\n', '    if scryfall_sets[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Downloading Scryfall data failed: {scryfall_sets}\")\\n', '    scryfall_set_codes = [set_obj[\"code\"].upper() for set_obj in scryfall_sets[\"data\"]]\\n', '        set_code\\n', '        for set_code in scryfall_set_codes\\n', '        if not (set_code.startswith(\"t\") and set_code[1:] in scryfall_set_codes)\\n', '    return sorted(scryfall_set_codes)\\n', '        s for s in scryfall_sets if not (s.startswith(\"T\") and s[1:] in scryfall_sets)\\n']",
  "context": "y supports\n    :return: Scryfall sets\n    \"\"\"\n    scryfall_instance = ScryfallProvider()\n    scryfall_sets = scryfall_instance.download(scr"
 },
 "116": {
  "name": "scryfall_set_codes",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/arg_parser.py",
  "lineno": "140",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    parser = argparse.ArgumentParser(\"mtgjson5\")\\n', '    sets_group = parser.add_mutually_exclusive_group()\\n', '    sets_group.add_argument(\\n', '    sets_group.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    mtgjson_arg_group = parser.add_argument_group(\"mtgjson maintainer arguments\")\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '        parser.print_help()\\n', '        parser.exit()\\n', '    return parser.parse_args()\\n', '    json_output_files: List[pathlib.Path] = list(OUTPUT_PATH.glob(\"**/*.json\"))\\n', '    set_codes_found = list(\\n', '        {file.stem for file in json_output_files}\\n', '    LOGGER.info(f\"Sets Built Already: {\\', \\'.join(set_codes_found)}\")\\n', '    set_codes_found = [\\n', '        for set_code in set_codes_found\\n', '    return set_codes_found\\n', '    scryfall_instance = ScryfallProvider()\\n', '    scryfall_sets = scryfall_instance.download(scryfall_instance.ALL_SETS_URL)\\n', '    if scryfall_sets[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Downloading Scryfall data failed: {scryfall_sets}\")\\n', '    scryfall_set_codes = [set_obj[\"code\"].upper() for set_obj in scryfall_sets[\"data\"]]\\n', '        set_code\\n', '        for set_code in scryfall_set_codes\\n', '        if not (set_code.startswith(\"t\") and set_code[1:] in scryfall_set_codes)\\n', '    return sorted(scryfall_set_codes)\\n', '        s for s in scryfall_sets if not (s.startswith(\"T\") and s[1:] in scryfall_sets)\\n']",
  "context": "     return []\n\n    # Get _ALL_ Scryfall sets\n    scryfall_set_codes = [set_obj[\"code\"].upper() for set_obj in scryfall_sets[\"data\"]]\n\n    # Remove Scryfall token sets (but leave extra"
 },
 "117": {
  "name": "scryfall_set_codes",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/arg_parser.py",
  "lineno": "143",
  "column": "4",
  "slicing": "['    scryfall_set_codes = [\\n', '        for set_code in scryfall_set_codes\\n', '        if not (set_code.startswith(\"t\") and set_code[1:] in scryfall_set_codes)\\n', '    return sorted(scryfall_set_codes)\\n']",
  "context": "ve Scryfall token sets (but leave extra sets)\n    scryfall_set_codes = [\n        set_code\n        for set_code in scryfall_"
 },
 "118": {
  "name": "scryfall_sets",
  "type": "get_all_scryfall_sets",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/arg_parser.py",
  "lineno": "166",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    parser = argparse.ArgumentParser(\"mtgjson5\")\\n', '    sets_group = parser.add_mutually_exclusive_group()\\n', '    sets_group.add_argument(\\n', '    sets_group.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    mtgjson_arg_group = parser.add_argument_group(\"mtgjson maintainer arguments\")\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '        parser.print_help()\\n', '        parser.exit()\\n', '    return parser.parse_args()\\n', '    json_output_files: List[pathlib.Path] = list(OUTPUT_PATH.glob(\"**/*.json\"))\\n', '    set_codes_found = list(\\n', '        {file.stem for file in json_output_files}\\n', '    LOGGER.info(f\"Sets Built Already: {\\', \\'.join(set_codes_found)}\")\\n', '    set_codes_found = [\\n', '        for set_code in set_codes_found\\n', '    return set_codes_found\\n', '    scryfall_instance = ScryfallProvider()\\n', '    scryfall_sets = scryfall_instance.download(scryfall_instance.ALL_SETS_URL)\\n', '    if scryfall_sets[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Downloading Scryfall data failed: {scryfall_sets}\")\\n', '    scryfall_set_codes = [set_obj[\"code\"].upper() for set_obj in scryfall_sets[\"data\"]]\\n', '    scryfall_set_codes = [\\n', '        set_code\\n', '        for set_code in scryfall_set_codes\\n', '        if not (set_code.startswith(\"t\") and set_code[1:] in scryfall_set_codes)\\n', '    return sorted(scryfall_set_codes)\\n', '    scryfall_sets = get_all_scryfall_sets()\\n', '        s for s in scryfall_sets if not (s.startswith(\"T\") and s[1:] in scryfall_sets)\\n']",
  "context": "(list(set(args.sets) - set(args.skip_sets)))\n\n    scryfall_sets = get_all_scryfall_sets()\n\n    # Remove Scryfall token sets (but leave extra"
 },
 "119": {
  "name": "non_token_sets",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/arg_parser.py",
  "lineno": "169",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    parser = argparse.ArgumentParser(\"mtgjson5\")\\n', '    sets_group = parser.add_mutually_exclusive_group()\\n', '    sets_group.add_argument(\\n', '    sets_group.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    mtgjson_arg_group = parser.add_argument_group(\"mtgjson maintainer arguments\")\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '        parser.print_help()\\n', '        parser.exit()\\n', '    return parser.parse_args()\\n', '    json_output_files: List[pathlib.Path] = list(OUTPUT_PATH.glob(\"**/*.json\"))\\n', '    set_codes_found = list(\\n', '        {file.stem for file in json_output_files}\\n', '    LOGGER.info(f\"Sets Built Already: {\\', \\'.join(set_codes_found)}\")\\n', '    set_codes_found = [\\n', '        for set_code in set_codes_found\\n', '    return set_codes_found\\n', '    scryfall_instance = ScryfallProvider()\\n', '    scryfall_sets = scryfall_instance.download(scryfall_instance.ALL_SETS_URL)\\n', '    if scryfall_sets[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Downloading Scryfall data failed: {scryfall_sets}\")\\n', '    scryfall_set_codes = [set_obj[\"code\"].upper() for set_obj in scryfall_sets[\"data\"]]\\n', '    scryfall_set_codes = [\\n', '        set_code\\n', '        for set_code in scryfall_set_codes\\n', '        if not (set_code.startswith(\"t\") and set_code[1:] in scryfall_set_codes)\\n', '    return sorted(scryfall_set_codes)\\n', '    scryfall_sets = get_all_scryfall_sets()\\n', '    non_token_sets = {\\n', '        s for s in scryfall_sets if not (s.startswith(\"T\") and s[1:] in scryfall_sets)\\n', '    return_list = list(non_token_sets - set(args.skip_sets))\\n', '    return sorted(return_list)\\n']",
  "context": "ve Scryfall token sets (but leave extra sets)\n    non_token_sets = {\n        s for s in scryfall_sets if not (s.startsw"
 },
 "120": {
  "name": "return_list",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/arg_parser.py",
  "lineno": "174",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    parser = argparse.ArgumentParser(\"mtgjson5\")\\n', '    sets_group = parser.add_mutually_exclusive_group()\\n', '    sets_group.add_argument(\\n', '    sets_group.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    parser.add_argument(\\n', '    mtgjson_arg_group = parser.add_argument_group(\"mtgjson maintainer arguments\")\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '    mtgjson_arg_group.add_argument(\\n', '        parser.print_help()\\n', '        parser.exit()\\n', '    return parser.parse_args()\\n', '    json_output_files: List[pathlib.Path] = list(OUTPUT_PATH.glob(\"**/*.json\"))\\n', '    set_codes_found = list(\\n', '        {file.stem for file in json_output_files}\\n', '    LOGGER.info(f\"Sets Built Already: {\\', \\'.join(set_codes_found)}\")\\n', '    set_codes_found = [\\n', '        for set_code in set_codes_found\\n', '    return set_codes_found\\n', '    scryfall_instance = ScryfallProvider()\\n', '    scryfall_sets = scryfall_instance.download(scryfall_instance.ALL_SETS_URL)\\n', '    if scryfall_sets[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Downloading Scryfall data failed: {scryfall_sets}\")\\n', '    scryfall_set_codes = [set_obj[\"code\"].upper() for set_obj in scryfall_sets[\"data\"]]\\n', '    scryfall_set_codes = [\\n', '        set_code\\n', '        for set_code in scryfall_set_codes\\n', '        if not (set_code.startswith(\"t\") and set_code[1:] in scryfall_set_codes)\\n', '    return sorted(scryfall_set_codes)\\n', '    scryfall_sets = get_all_scryfall_sets()\\n', '    non_token_sets = {\\n', '        s for s in scryfall_sets if not (s.startswith(\"T\") and s[1:] in scryfall_sets)\\n', '    return_list = list(non_token_sets - set(args.skip_sets))\\n', '    return sorted(return_list)\\n']",
  "context": "ryfall_sets)\n    }\n\n    # Remove sets to skip\n    return_list = list(non_token_sets - set(args.skip_sets))\n\n    return sorted(return_list)\n"
 },
 "121": {
  "name": "sf_prints_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "46",
  "column": "4",
  "slicing": "['    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n']",
  "context": "ging.getLogger(__name__)\n\n\ndef parse_foreign(\n    sf_prints_url: str, card_name: str, card_number: str, set_name: str\n) -> List[MtgjsonForeignDataObject]:\n    \"\"\"\n    G"
 },
 "122": {
  "name": "card_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "46",
  "column": "24",
  "slicing": "['    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n']",
  "context": "e__)\n\n\ndef parse_foreign(\n    sf_prints_url: str, card_name: str, card_number: str, set_name: str\n) -> List[MtgjsonForeignDataObject]:\n    \"\"\"\n    G"
 },
 "123": {
  "name": "card_number",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "46",
  "column": "40",
  "slicing": "['    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                if card_number > mtgjson_set.base_set_size:\\n']",
  "context": "_foreign(\n    sf_prints_url: str, card_name: str, card_number: str, set_name: str\n) -> List[MtgjsonForeignDataObject]:\n    \"\"\"\n    G"
 },
 "124": {
  "name": "set_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "46",
  "column": "58",
  "slicing": "['    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '            set_name != foreign_card[\"set\"]\\n']",
  "context": "rints_url: str, card_name: str, card_number: str, set_name: str\n) -> List[MtgjsonForeignDataObject]:\n    \"\"\"\n    G"
 },
 "125": {
  "name": "card_foreign_entries",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n']",
  "context": "e\n    :return: Foreign entries object\n    \"\"\"\n    card_foreign_entries: List[MtgjsonForeignDataObject] = []\n\n    # Add information to get all languages\n    sf"
 },
 "126": {
  "name": "prints_api_json",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "unique=prints\", \"+lang%3Aany&unique=prints\")\n\n    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\n    if prints_api_json[\"object\"] == \"error\":\n     "
 },
 "127": {
  "name": "card_foreign_entry",
  "type": "classes.MtgjsonForeignDataObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "74",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": " == \"en\"\n        ):\n            continue\n\n        card_foreign_entry = MtgjsonForeignDataObject()\n        try:\n            card_foreign_entry.langua"
 },
 "128": {
  "name": "foreign_card",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "97",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "es\"]\n                ]\n            )\n\n            foreign_card = foreign_card[\"card_faces\"][face]\n            card_foreign_entry.face_name = foreign"
 },
 "129": {
  "name": "card_type",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "115",
  "column": "21",
  "slicing": "['def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n']",
  "context": "eturn card_foreign_entries\n\n\ndef parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\n    \"\"\"\n    Given a card type string, split it up "
 },
 "130": {
  "name": "sub_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "121",
  "column": "4",
  "slicing": "['    sub_types: List[str] = []\\n', '    return super_types, types, sub_types\\n']",
  "context": ", type, sub) of the card's attributes\n    \"\"\"\n    sub_types: List[str] = []\n    super_types: List[str] = []\n    types: List[st"
 },
 "131": {
  "name": "super_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "122",
  "column": "4",
  "slicing": "['    super_types: List[str] = []\\n', '            super_types.append(value)\\n', '    return super_types, types, sub_types\\n']",
  "context": "ributes\n    \"\"\"\n    sub_types: List[str] = []\n    super_types: List[str] = []\n    types: List[str] = []\n\n    supertypes_and_type"
 },
 "132": {
  "name": "types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "123",
  "column": "4",
  "slicing": "['    types: List[str] = []\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n']",
  "context": "ist[str] = []\n    super_types: List[str] = []\n    types: List[str] = []\n\n    supertypes_and_types: str\n    if \"\" not in c"
 },
 "133": {
  "name": "supertypes_and_types",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "125",
  "column": "4",
  "slicing": "['    supertypes_and_types: str\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n']",
  "context": "es: List[str] = []\n    types: List[str] = []\n\n    supertypes_and_types: str\n    if \"\" not in card_type:\n        supertypes_an"
 },
 "134": {
  "name": "supertypes_and_types",
  "type": "card_type",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "127",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "d_types: str\n    if \"\" not in card_type:\n        supertypes_and_types = card_type\n    else:\n        split_type: List[str] = card_typ"
 },
 "135": {
  "name": "split_type",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "129",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "upertypes_and_types = card_type\n    else:\n        split_type: List[str] = card_type.split(\"\")\n        supertypes_and_types = split_type[0]\n     "
 },
 "136": {
  "name": "supertypes_and_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "130",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "it_type: List[str] = card_type.split(\"\")\n        supertypes_and_types = split_type[0]\n        subtypes: str = split_type[1]\n\n        # P"
 },
 "137": {
  "name": "subtypes",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "131",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "     supertypes_and_types = split_type[0]\n        subtypes: str = split_type[1]\n\n        # Planes are an entire sub-type, whereas "
 },
 "138": {
  "name": "sub_types",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "136",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "    if card_type.startswith(\"Plane\"):\n            sub_types = [subtypes.strip()]\n        else:\n            sub_types = [x.strip() f"
 },
 "139": {
  "name": "sub_types",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "138",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "es = [subtypes.strip()]\n        else:\n            sub_types = [x.strip() for x in subtypes.split() if x]\n\n    for value in supertypes_and_types.split():\n  "
 },
 "140": {
  "name": "mana_cost",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "149",
  "column": "20",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "per_types, types, sub_types\n\n\ndef get_card_colors(mana_cost: str) -> List[str]:\n    \"\"\"\n    For some cards, we may have to manuall"
 },
 "141": {
  "name": "color_options",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "155",
  "column": "4",
  "slicing": "['    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n']",
  "context": "   :return: Colors based on mana cost\n    \"\"\"\n    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\n\n    ret_val = []\n    for color in color_options:\n"
 },
 "142": {
  "name": "ret_val",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "157",
  "column": "4",
  "slicing": "['    ret_val = []\\n', '            ret_val.append(color)\\n', '    return ret_val\\n']",
  "context": "tions: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\n\n    ret_val = []\n    for color in color_options:\n        if color i"
 },
 "143": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "165",
  "column": "26",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": ")\n\n    return ret_val\n\n\ndef get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Get a Scryfall set header for a specif"
 },
 "144": {
  "name": "set_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "171",
  "column": "4",
  "slicing": "['    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '    return set_data\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n']",
  "context": "    :return: Set header, if it exists\n    \"\"\"\n    set_data: Dict[str, Any] = ScryfallProvider().download(\n        ScryfallProvider().ALL_SETS_URL + set_code"
 },
 "145": {
  "name": "string",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "182",
  "column": "14",
  "slicing": "['def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '        if is_number(element):\\n']",
  "context": " return None\n\n    return set_data\n\n\ndef is_number(string: str) -> bool:\n    \"\"\"See if a given string is a number (int or f"
 },
 "146": {
  "name": "mana_cost",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "199",
  "column": "17",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "        pass\n\n    return False\n\n\ndef get_card_cmc(mana_cost: str) -> float:\n    \"\"\"\n    For some cards, we may have to manuall"
 },
 "147": {
  "name": "total",
  "type": "float",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "207",
  "column": "4",
  "slicing": "['    total: float = 0\\n', '    return total\\n']",
  "context": "ost string\n    :return: One sided cmc\n    \"\"\"\n    total: float = 0\n\n    symbol: List[str] = re.findall(r\"{([^{]*)}\", "
 },
 "148": {
  "name": "symbol",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "209",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": ": One sided cmc\n    \"\"\"\n    total: float = 0\n\n    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\n    for element in symbol:\n        # Address 2/W, "
 },
 "149": {
  "name": "element",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "213",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "ways first\n        if \"/\" in element:\n            element = element.split(\"/\")[0]\n\n        if is_number(element):\n            total "
 },
 "150": {
  "name": "total",
  "type": "float",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "216",
  "column": "12",
  "slicing": "['            total += float(element)\\n', '    return total\\n']",
  "context": "\")[0]\n\n        if is_number(element):\n            total += float(element)\n        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeh"
 },
 "151": {
  "name": "sf_prints_url",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "227",
  "column": "20",
  "slicing": "['def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n']",
  "context": "otal += 1\n\n    return total\n\n\ndef parse_printings(sf_prints_url: Optional[str]) -> List[str]:\n    \"\"\"\n    Given a Scryfall printings URL, extrac"
 },
 "152": {
  "name": "card_sets",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "233",
  "column": "4",
  "slicing": "['    card_sets: Set[str] = set()\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '    return sorted(list(card_sets))\\n']",
  "context": "l sets a specific card was printed in\n    \"\"\"\n    card_sets: Set[str] = set()\n\n    while sf_prints_url:\n        prints_api_json:"
 },
 "153": {
  "name": "prints_api_json",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "236",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "et[str] = set()\n\n    while sf_prints_url:\n        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\n\n        if prints_api_json[\"object\"] == \"error\":\n"
 },
 "154": {
  "name": "sf_card_legalities",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "253",
  "column": "21",
  "slicing": "['def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n']",
  "context": "rn sorted(list(card_sets))\n\n\ndef parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\n    \"\"\"\n    Given a Scryfall legalities dictionary"
 },
 "155": {
  "name": "card_legalities",
  "type": "classes.MtgjsonLegalitiesObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "259",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "ities\n    :return: MTGJSON legalities\n    \"\"\"\n    card_legalities = MtgjsonLegalitiesObject()\n    for key, value in sf_card_legalities.items():\n"
 },
 "156": {
  "name": "rulings_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "267",
  "column": "18",
  "slicing": "['def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n']",
  "context": ")\n\n    return card_legalities\n\n\ndef parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\n    \"\"\"\n    Get the JSON data from Scryfall and co"
 },
 "157": {
  "name": "rules_api_json",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "273",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "rom\n    :return: MTGJSON rulings list\n    \"\"\"\n    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\n    if rules_api_json[\"object\"] == \"error\":\n      "
 },
 "158": {
  "name": "mtgjson_rules",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "278",
  "column": "4",
  "slicing": "['    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n']",
  "context": "s_url}: {rules_api_json}\")\n        return []\n\n    mtgjson_rules: List[MtgjsonRulingObject] = []\n\n    for sf_rule in rules_api_json[\"data\"]:\n      "
 },
 "159": {
  "name": "mtgjson_rule",
  "type": "classes.MtgjsonRulingObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "281",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '        card.identifiers.scryfall_id\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "   for sf_rule in rules_api_json[\"data\"]:\n        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\n        mtgjson_rules.append(mtgjson_rule)\n\n    re"
 },
 "160": {
  "name": "mtgjson_set",
  "type": "classes.MtgjsonSetObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "287",
  "column": "34",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": " ruling.date)\n\n\ndef relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\n    \"\"\"\n    Sometimes tokens find their way into t"
 },
 "161": {
  "name": "token_types",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "295",
  "column": "4",
  "slicing": "['    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '            card.is_starter = True\\n']",
  "context": "fo(f\"Relocate tokens for {mtgjson_set.code}\")\n    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\n\n    # Identify unique tokens from cards\n    token"
 },
 "162": {
  "name": "tokens_found",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "298",
  "column": "4",
  "slicing": "['    tokens_found = {\\n', '        for scryfall_id in tokens_found\\n']",
  "context": "es\"}\n\n    # Identify unique tokens from cards\n    tokens_found = {\n        card.identifiers.scryfall_id\n        for c"
 },
 "163": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "317",
  "column": "20",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "ns for {mtgjson_set.code}\")\n\n\ndef mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\n    \"\"\"\n    For Duel Decks, we need to determine w"
 },
 "164": {
  "name": "mtgjson_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "317",
  "column": "35",
  "slicing": "['def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    mtgjson_cards.sort()\\n', '    return mtgjson_cards\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '            card.is_starter = True\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '            item.uuid\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n']",
  "context": "_set.code}\")\n\n\ndef mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\n    \"\"\"\n    For Duel Decks, we need to determine w"
 },
 "165": {
  "name": "land_pile_marked",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "327",
  "column": "8",
  "slicing": "['        land_pile_marked = False\\n', '            elif land_pile_marked:\\n']",
  "context": ".startswith(\"DD\") or set_code in {\"GS1\"}:\n        land_pile_marked = False\n        side_letter_as_number = ord(\"a\")\n\n        "
 },
 "166": {
  "name": "side_letter_as_number",
  "type": "ord",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "328",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        side_letter_as_number = ord(\"a\")\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": "{\"GS1\"}:\n        land_pile_marked = False\n        side_letter_as_number = ord(\"a\")\n\n        for card in sorted(mtgjson_cards):\n      "
 },
 "167": {
  "name": "land_pile_marked",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "332",
  "column": "16",
  "slicing": "['                land_pile_marked = True\\n', '            elif land_pile_marked:\\n']",
  "context": "if card.name in BASIC_LAND_NAMES:\n                land_pile_marked = True\n            elif any(_type in card.type for _type "
 },
 "168": {
  "name": "side_letter_as_number",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "336",
  "column": "16",
  "slicing": "['                side_letter_as_number += 1\\n', '            card.duel_deck = chr(side_letter_as_number)\\n']",
  "context": "           elif land_pile_marked:\n                side_letter_as_number += 1\n                land_pile_marked = False\n\n        "
 },
 "169": {
  "name": "land_pile_marked",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "337",
  "column": "16",
  "slicing": "['                land_pile_marked = False\\n']",
  "context": "       side_letter_as_number += 1\n                land_pile_marked = False\n\n            card.duel_deck = chr(side_letter_as_n"
 },
 "170": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "343",
  "column": "23",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n']",
  "context": " status for {set_code}\")\n\n\ndef parse_keyrune_code(url: str) -> str:\n    \"\"\"\n    Convert a URL of a keyrune icon into i"
 },
 "171": {
  "name": "upstream_to_keyrune_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "354",
  "column": "8",
  "slicing": "['        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n']",
  "context": "(\n        encoding=\"utf-8\"\n    ) as file:\n        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\n\n    return upstream_to_keyrune_map.get(file_stem,"
 },
 "172": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "359",
  "column": "22",
  "slicing": "['def build_mtgjson_set(set_code: str) -> Optional[MtgjsonSetObject]:\\n']",
  "context": "get(file_stem, file_stem)\n\n\ndef build_mtgjson_set(set_code: str) -> Optional[MtgjsonSetObject]:\n    \"\"\"\n    Construct a MTGJSON Magic Set\n    :par"
 },
 "173": {
  "name": "mtgjson_set",
  "type": "classes.MtgjsonSetObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "366",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "eturn: Set object\n    \"\"\"\n    # Output Object\n    mtgjson_set = MtgjsonSetObject()\n\n    # Ensure we have a header for this set\n    se"
 },
 "174": {
  "name": "set_data",
  "type": "get_scryfall_set_data",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "369",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": ")\n\n    # Ensure we have a header for this set\n    set_data = get_scryfall_set_data(set_code)\n    if not set_data:\n        return None\n\n    # Ex"
 },
 "175": {
  "name": "base_total_sizes",
  "type": "get_base_and_total_set_sizes",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "393",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "tion_for_set(\n        mtgjson_set.code\n    )\n\n    base_total_sizes = get_base_and_total_set_sizes(set_code)\n    mtgjson_set.base_set_size = base_total_sizes[0"
 },
 "176": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "425",
  "column": "4",
  "slicing": "['    set_code: str, added_tokens: List[Dict[str, Any]]\\n']",
  "context": " mtgjson_set\n\n\ndef build_base_mtgjson_tokens(\n    set_code: str, added_tokens: List[Dict[str, Any]]\n) -> List[MtgjsonCardObject]:\n    \"\"\"\n    Construc"
 },
 "177": {
  "name": "added_tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "425",
  "column": "19",
  "slicing": "['    set_code: str, added_tokens: List[Dict[str, Any]]\\n']",
  "context": "def build_base_mtgjson_tokens(\n    set_code: str, added_tokens: List[Dict[str, Any]]\n) -> List[MtgjsonCardObject]:\n    \"\"\"\n    Construc"
 },
 "178": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "437",
  "column": "4",
  "slicing": "['    set_code: str,\\n']",
  "context": "tokens, True)\n\n\ndef build_base_mtgjson_cards(\n    set_code: str,\n    additional_cards: List[Dict[str, Any]] = None,"
 },
 "179": {
  "name": "additional_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "438",
  "column": "4",
  "slicing": "['    additional_cards: List[Dict[str, Any]] = None,\\n']",
  "context": " build_base_mtgjson_cards(\n    set_code: str,\n    additional_cards: List[Dict[str, Any]] = None,\n    is_token: bool = False,\n    set_release_date: "
 },
 "180": {
  "name": "is_token",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "439",
  "column": "4",
  "slicing": "['    is_token: bool = False,\\n']",
  "context": "dditional_cards: List[Dict[str, Any]] = None,\n    is_token: bool = False,\n    set_release_date: str = \"\",\n) -> List[MtgjsonC"
 },
 "181": {
  "name": "set_release_date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "440",
  "column": "4",
  "slicing": "['    set_release_date: str = \"\",\\n']",
  "context": "tr, Any]] = None,\n    is_token: bool = False,\n    set_release_date: str = \"\",\n) -> List[MtgjsonCardObject]:\n    \"\"\"\n    Construc"
 },
 "182": {
  "name": "cards",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "451",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "LOGGER.info(f\"Building cards for {set_code}\")\n    cards = ScryfallProvider().download_cards(set_code)\n    cards.extend(additional_cards or [])\n\n    mtgj"
 },
 "183": {
  "name": "mtgjson_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "454",
  "column": "4",
  "slicing": "['    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '    mtgjson_cards.sort()\\n', '    return mtgjson_cards\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '            item.uuid\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n']",
  "context": "de)\n    cards.extend(additional_cards or [])\n\n    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\n        build_mtgjson_card,\n        cards,\n       "
 },
 "184": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "469",
  "column": "4",
  "slicing": "['    set_code: str, search_url: str, mtgjson_cards: List[MtgjsonCardObject]\\n']",
  "context": "rn mtgjson_cards\n\n\ndef add_is_starter_option(\n    set_code: str, search_url: str, mtgjson_cards: List[MtgjsonCardObject]\n) -> None:\n    \"\"\"\n    There are cards that may no"
 },
 "185": {
  "name": "search_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "469",
  "column": "19",
  "slicing": "['    set_code: str, search_url: str, mtgjson_cards: List[MtgjsonCardObject]\\n']",
  "context": "s\n\n\ndef add_is_starter_option(\n    set_code: str, search_url: str, mtgjson_cards: List[MtgjsonCardObject]\n) -> None:\n    \"\"\"\n    There are cards that may no"
 },
 "186": {
  "name": "mtgjson_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "469",
  "column": "36",
  "slicing": "['    set_code: str, search_url: str, mtgjson_cards: List[MtgjsonCardObject]\\n']",
  "context": "arter_option(\n    set_code: str, search_url: str, mtgjson_cards: List[MtgjsonCardObject]\n) -> None:\n    \"\"\"\n    There are cards that may no"
 },
 "187": {
  "name": "mtgjson_cards_with_same_id",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "488",
  "column": "8",
  "slicing": "['        mtgjson_cards_with_same_id = [\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n']",
  "context": "scryfall_object in starter_cards[\"data\"]:\n        mtgjson_cards_with_same_id = [\n            item\n            for item in mtgjson_c"
 },
 "188": {
  "name": "mtgjson_card",
  "type": "classes.MtgjsonCardObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "499",
  "column": "26",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": " data to {set_code}\")\n\n\ndef add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\n    \"\"\"\n    Determine if a card is able to be your"
 },
 "189": {
  "name": "is_commander_legal",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "505",
  "column": "4",
  "slicing": "['    is_commander_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n']",
  "context": "\n    :param mtgjson_card: Card object\n    \"\"\"\n    is_commander_legal = (\n        \"Legendary\" in mtgjson_card.type\n        a"
 },
 "190": {
  "name": "is_oathbreaker_legal",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "514",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "can be your commander\" in mtgjson_card.text)\n\n    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\n\n    is_brawl_legal = (\n        mtgjson_card.set_c"
 },
 "191": {
  "name": "is_brawl_legal",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "516",
  "column": "4",
  "slicing": "['    is_brawl_legal = (\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n']",
  "context": "_legal = \"Planeswalker\" in mtgjson_card.type\n\n    is_brawl_legal = (\n        mtgjson_card.set_code.upper() in WhatsInSt"
 },
 "192": {
  "name": "mtgjson_card",
  "type": "classes.MtgjsonCardObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "527",
  "column": "13",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "al, is_oathbreaker_legal\n        )\n\n\ndef add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\n    \"\"\"\n    Construct a UUIDv5 for each MTGJSON ca"
 },
 "193": {
  "name": "scryfall_object",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "581",
  "column": "4",
  "slicing": "['    scryfall_object: Dict[str, Any],\\n']",
  "context": "id_source_v4)\n    )\n\n\ndef build_mtgjson_card(\n    scryfall_object: Dict[str, Any],\n    face_id: int = 0,\n    is_token: bool = False,\n"
 },
 "194": {
  "name": "face_id",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "582",
  "column": "4",
  "slicing": "['    face_id: int = 0,\\n']",
  "context": "on_card(\n    scryfall_object: Dict[str, Any],\n    face_id: int = 0,\n    is_token: bool = False,\n    set_release_date: "
 },
 "195": {
  "name": "is_token",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "583",
  "column": "4",
  "slicing": "['    is_token: bool = False,\\n']",
  "context": "object: Dict[str, Any],\n    face_id: int = 0,\n    is_token: bool = False,\n    set_release_date: str = \"\",\n) -> List[MtgjsonC"
 },
 "196": {
  "name": "set_release_date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "584",
  "column": "4",
  "slicing": "['    set_release_date: str = \"\",\\n']",
  "context": "face_id: int = 0,\n    is_token: bool = False,\n    set_release_date: str = \"\",\n) -> List[MtgjsonCardObject]:\n    \"\"\"\n    Construc"
 },
 "197": {
  "name": "mtgjson_cards",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "598",
  "column": "4",
  "slicing": "['    mtgjson_cards = []\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n']",
  "context": "scryfall_object['name']}\")\n\n    # Return List\n    mtgjson_cards = []\n\n    # Object Container\n    mtgjson_card = Mtgjson"
 },
 "198": {
  "name": "mtgjson_card",
  "type": "classes.MtgjsonCardObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "601",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "   mtgjson_cards = []\n\n    # Object Container\n    mtgjson_card = MtgjsonCardObject(is_token)\n\n    mtgjson_card.name = scryfall_object[\"name\"]\n "
 },
 "199": {
  "name": "face_data",
  "type": "scryfall_object",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "610",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "ect[\"oracle_id\"]\n\n    # Handle atypical cards\n    face_data = scryfall_object\n    if \"card_faces\" in scryfall_object:\n        mt"
 },
 "200": {
  "name": "face_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "621",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "\n\n        # Override face_data from above\n        face_data = scryfall_object[\"card_faces\"][face_id]\n\n        if \"//\" in scryfall_object.get(\"mana_cost"
 },
 "201": {
  "name": "ascii_name",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "748",
  "column": "4",
  "slicing": "['    ascii_name = (\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n']",
  "context": "json_card.loyalty = face_data.get(\"loyalty\")\n\n    ascii_name = (\n        unicodedata.normalize(\"NFD\", mtgjson_card."
 },
 "202": {
  "name": "card_types",
  "type": "parse_card_types",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "821",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "arse_rulings(scryfall_object[\"rulings_uri\"])\n\n    card_types = parse_card_types(mtgjson_card.type)\n    mtgjson_card.supertypes = card_types[0]\n    mt"
 },
 "203": {
  "name": "meld_object",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "838",
  "column": "8",
  "slicing": "['        meld_object = []\\n', '                    meld_object.append(a_part[\"component\"])\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n']",
  "context": "if \"all_parts\" in scryfall_object.keys():\n        meld_object = []\n        mtgjson_card.set_names(None)\n        for a"
 },
 "204": {
  "name": "reverse_related",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "911",
  "column": "8",
  "slicing": "['        reverse_related: List[str] = []\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n']",
  "context": "son_card.uuid\n        )\n\n    if is_token:\n        reverse_related: List[str] = []\n        if \"all_parts\" in scryfall_object:\n       "
 },
 "205": {
  "name": "gatherer_cards",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "920",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "f mtgjson_card.identifiers.multiverse_id:\n        gatherer_cards = GathererProvider().get_cards(\n            mtgjson_card.identifiers.multiverse_id"
 },
 "206": {
  "name": "mtgjson_set",
  "type": "classes.MtgjsonSetObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "932",
  "column": "42",
  "slicing": "['def add_variations_and_alternative_fields(mtgjson_set: MtgjsonSetObject) -> None:\\n']",
  "context": "cards\n\n\ndef add_variations_and_alternative_fields(mtgjson_set: MtgjsonSetObject) -> None:\n    \"\"\"\n    Set the variations, other_face_ids, an"
 },
 "207": {
  "name": "variations",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "966",
  "column": "8",
  "slicing": "['        variations = [\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '                len(variations) >= 1\\n']",
  "context": "her_card.uuid)\n\n        # Adds variations\n        variations = [\n            item.uuid\n            for item in mtgj"
 },
 "208": {
  "name": "card_number",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "994",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "ze, remove asterisk before comparison\n            card_number = int(this_card.number.replace(chr(9733), \"\"))\n            if card_number > mtgjson_set.base_set_"
 },
 "209": {
  "name": "card_number",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1009",
  "column": "16",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "remove asterisk before comparison\n                card_number = int(this_card.number.replace(chr(9733), \"\"))\n                if card_number > mtgjson_set.base_"
 },
 "210": {
  "name": "mtgjson_set",
  "type": "classes.MtgjsonSetObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1020",
  "column": "29",
  "slicing": "['def add_card_kingdom_details(mtgjson_set: MtgjsonSetObject) -> None:\\n']",
  "context": "tgjson_set.code}\")\n\n\ndef add_card_kingdom_details(mtgjson_set: MtgjsonSetObject) -> None:\n    \"\"\"\n    Add the CardKingdom components, like I"
 },
 "211": {
  "name": "entry",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1031",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": " translation_table:\n            continue\n\n        entry = translation_table[mtgjson_card.uuid]\n\n        if \"normal\" in entry:\n            mtgjson"
 },
 "212": {
  "name": "mtgjson_set",
  "type": "classes.MtgjsonSetObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1053",
  "column": "20",
  "slicing": "['def add_mcm_details(mtgjson_set: MtgjsonSetObject) -> None:\\n']",
  "context": "ls for {mtgjson_set.code}\")\n\n\ndef add_mcm_details(mtgjson_set: MtgjsonSetObject) -> None:\n    \"\"\"\n    Add the MKM components to a set's card"
 },
 "213": {
  "name": "mkm_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1059",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "f\"Adding MCM details for {mtgjson_set.code}\")\n    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\n\n    extras_cards: Dict[str, Dict[str, Any]] = {}\n"
 },
 "214": {
  "name": "extras_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1061",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "Provider().get_mkm_cards(mtgjson_set.mcm_id)\n\n    extras_cards: Dict[str, Dict[str, Any]] = {}\n    if mtgjson_set.mcm_id_extras:\n        extras_c"
 },
 "215": {
  "name": "extras_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1063",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "]] = {}\n    if mtgjson_set.mcm_id_extras:\n        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\n\n    for mtgjson_card in mtgjson_set.cards:\n      "
 },
 "216": {
  "name": "delete_key",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1066",
  "column": "8",
  "slicing": "['        delete_key = False\\n', '        if delete_key:\\n']",
  "context": "   for mtgjson_card in mtgjson_set.cards:\n        delete_key = False\n\n        # \"boosterfun\" is an alias for frame_effe"
 },
 "217": {
  "name": "search_cards",
  "type": "extras_cards",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1071",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "s, search in the \"Extras\" set instead\n            search_cards = extras_cards\n        else:\n            search_cards = mkm_cards"
 },
 "218": {
  "name": "mkm_obj",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1101",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "name} for MKM\")\n                continue\n\n        mkm_obj = search_cards[card_key]\n        if delete_key:\n            del search_card"
 },
 "219": {
  "name": "search_cards",
  "type": "mkm_cards",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1073",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "ch_cards = extras_cards\n        else:\n            search_cards = mkm_cards\n\n        # There are multiple ways MKM represents "
 },
 "220": {
  "name": "card_key",
  "type": "mkm_card",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1093",
  "column": "20",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "h(mtgjson_card.name.lower()):\n                    card_key = mkm_card\n                    delete_key = True\n            "
 },
 "221": {
  "name": "delete_key",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1094",
  "column": "20",
  "slicing": "['                    delete_key = True\\n', '        if delete_key:\\n']",
  "context": "          card_key = mkm_card\n                    delete_key = True\n                    break\n\n            if not card"
 },
 "222": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1121",
  "column": "33",
  "slicing": "['def get_base_and_total_set_sizes(set_code: str) -> Tuple[int, int]:\\n']",
  "context": "on_set.code}\")\n\n\ndef get_base_and_total_set_sizes(set_code: str) -> Tuple[int, int]:\n    \"\"\"\n    Get the size of a set from scryfall or"
 },
 "223": {
  "name": "base_set_size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1133",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "rride.keys():\n        # Manual correction\n        base_set_size = int(base_set_size_override[set_code])\n    else:\n        # Download on the fly\n        ba"
 },
 "224": {
  "name": "total_set_size",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1148",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "ase_set_size_download.get(\"total_cards\", 0))\n\n    total_set_size = len(ScryfallProvider().download_cards(set_code))\n\n    return base_set_size, total_set_size\n"
 },
 "225": {
  "name": "base_set_size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/set_builder.py",
  "lineno": "1146",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    sf_prints_url: str, card_name: str, card_number: str, set_name: str\\n', '    card_foreign_entries: List[MtgjsonForeignDataObject] = []\\n', '    sf_prints_url = sf_prints_url.replace(\"&unique=prints\", \"+lang%3Aany&unique=prints\")\\n', '    prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '    if prints_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"No data found for {sf_prints_url}: {prints_api_json}\")\\n', '    for foreign_card in prints_api_json[\"data\"]:\\n', '            set_name != foreign_card[\"set\"]\\n', '            or card_number != foreign_card[\"collector_number\"]\\n', '            or foreign_card[\"lang\"] == \"en\"\\n', '        card_foreign_entry = MtgjsonForeignDataObject()\\n', '            card_foreign_entry.language = LANGUAGE_MAP[foreign_card[\"lang\"]]\\n', '            LOGGER.warning(f\"Unable to get language {foreign_card}\")\\n', '        if foreign_card[\"multiverse_ids\"]:\\n', '            card_foreign_entry.multiverse_id = foreign_card[\"multiverse_ids\"][0]\\n', '        if \"card_faces\" in foreign_card:\\n', '            if card_name.lower() == foreign_card[\"name\"].split(\"/\")[0].strip().lower():\\n', '                face = 0\\n', '                face = 1\\n', '            LOGGER.debug(f\"Split card found: Using face {face} for {card_name}\")\\n', '            card_foreign_entry.name = \" // \".join(\\n', '                    for face_data in foreign_card[\"card_faces\"]\\n', '            foreign_card = foreign_card[\"card_faces\"][face]\\n', '            card_foreign_entry.face_name = foreign_card.get(\"printed_name\")\\n', '            if not card_foreign_entry.face_name:\\n', '                LOGGER.warning(f\"Unable to resolve name for {foreign_card}\")\\n', '                card_foreign_entry.face_name = foreign_card.get(\"name\")\\n', '        if not card_foreign_entry.name:\\n', '            card_foreign_entry.name = foreign_card.get(\"printed_name\")\\n', '        card_foreign_entry.text = foreign_card.get(\"printed_text\")\\n', '        card_foreign_entry.flavor_text = foreign_card.get(\"flavor_text\")\\n', '        card_foreign_entry.type = foreign_card.get(\"printed_type_line\")\\n', '        if card_foreign_entry.name:\\n', '            card_foreign_entries.append(card_foreign_entry)\\n', '    return card_foreign_entries\\n', 'def parse_card_types(card_type: str) -> Tuple[List[str], List[str], List[str]]:\\n', '    sub_types: List[str] = []\\n', '    super_types: List[str] = []\\n', '    types: List[str] = []\\n', '    supertypes_and_types: str\\n', '        supertypes_and_types = card_type\\n', '        split_type: List[str] = card_type.split(\"\")\\n', '        supertypes_and_types = split_type[0]\\n', '        subtypes: str = split_type[1]\\n', '            sub_types = [subtypes.strip()]\\n', '            sub_types = [x.strip() for x in subtypes.split() if x]\\n', '    for value in supertypes_and_types.split():\\n', '        if value in SUPER_TYPES:\\n', '            super_types.append(value)\\n', '        elif value:\\n', '            types.append(value)\\n', '    return super_types, types, sub_types\\n', 'def get_card_colors(mana_cost: str) -> List[str]:\\n', '    color_options: List[str] = [\"W\", \"U\", \"B\", \"R\", \"G\"]\\n', '    ret_val = []\\n', '    for color in color_options:\\n', '        if color in mana_cost:\\n', '            ret_val.append(color)\\n', '    return ret_val\\n', 'def get_scryfall_set_data(set_code: str) -> Optional[Dict[str, Any]]:\\n', '    set_data: Dict[str, Any] = ScryfallProvider().download(\\n', '    if set_data[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Failed to download {set_code}\")\\n', '    return set_data\\n', 'def is_number(string: str) -> bool:\\n', '        unicodedata.numeric(string)\\n', 'def get_card_cmc(mana_cost: str) -> float:\\n', '    total: float = 0\\n', '    symbol: List[str] = re.findall(r\"{([^{]*)}\", mana_cost.strip())\\n', '    for element in symbol:\\n', '        if \"/\" in element:\\n', '            element = element.split(\"/\")[0]\\n', '        if is_number(element):\\n', '            total += float(element)\\n', '        elif element in [\"X\", \"Y\", \"Z\"]:  # Placeholder mana\\n', '        elif element[0] == \"H\":  # Half mana\\n', '            total += 0.5\\n', '            total += 1\\n', '    return total\\n', 'def parse_printings(sf_prints_url: Optional[str]) -> List[str]:\\n', '    card_sets: Set[str] = set()\\n', '    while sf_prints_url:\\n', '        prints_api_json: Dict[str, Any] = ScryfallProvider().download(sf_prints_url)\\n', '        if prints_api_json[\"object\"] == \"error\":\\n', '            LOGGER.error(f\"Bad download: {sf_prints_url}\")\\n', '        for card in prints_api_json[\"data\"]:\\n', '            card_sets.add(card.get(\"set\").upper())\\n', '        if not prints_api_json.get(\"has_more\"):\\n', '        sf_prints_url = prints_api_json.get(\"next_page\")\\n', '    return sorted(list(card_sets))\\n', 'def parse_legalities(sf_card_legalities: Dict[str, str]) -> MtgjsonLegalitiesObject:\\n', '    card_legalities = MtgjsonLegalitiesObject()\\n', '    for key, value in sf_card_legalities.items():\\n', '        if value != \"not_legal\":\\n', '            setattr(card_legalities, key.lower(), value.capitalize())\\n', '    return card_legalities\\n', 'def parse_rulings(rulings_url: str) -> List[MtgjsonRulingObject]:\\n', '    rules_api_json: Dict[str, Any] = ScryfallProvider().download(rulings_url)\\n', '    if rules_api_json[\"object\"] == \"error\":\\n', '        LOGGER.error(f\"Error downloading URL {rulings_url}: {rules_api_json}\")\\n', '    mtgjson_rules: List[MtgjsonRulingObject] = []\\n', '    for sf_rule in rules_api_json[\"data\"]:\\n', '        mtgjson_rule = MtgjsonRulingObject(sf_rule[\"published_at\"], sf_rule[\"comment\"])\\n', '        mtgjson_rules.append(mtgjson_rule)\\n', '    return sorted(mtgjson_rules, key=lambda ruling: ruling.date)\\n', 'def relocate_miscellaneous_tokens(mtgjson_set: MtgjsonSetObject) -> None:\\n', '    LOGGER.info(f\"Relocate tokens for {mtgjson_set.code}\")\\n', '    token_types = {\"token\", \"double_faced_token\", \"emblem\", \"art_series\"}\\n', '    tokens_found = {\\n', '        card.identifiers.scryfall_id\\n', '        for card in mtgjson_set.cards\\n', '        if card.layout in token_types and card.identifiers.scryfall_id\\n', '        card for card in mtgjson_set.cards if card.layout not in token_types\\n', '        for scryfall_id in tokens_found\\n', '    LOGGER.info(f\"Finished relocating tokens for {mtgjson_set.code}\")\\n', 'def mark_duel_decks(set_code: str, mtgjson_cards: List[MtgjsonCardObject]) -> None:\\n', '    LOGGER.info(f\"Marking duel deck status for {set_code}\")\\n', '        land_pile_marked = False\\n', '        side_letter_as_number = ord(\"a\")\\n', '        for card in sorted(mtgjson_cards):\\n', '            if card.name in BASIC_LAND_NAMES:\\n', '                land_pile_marked = True\\n', '            elif any(_type in card.type for _type in (\"Token\", \"Emblem\")):\\n', '            elif land_pile_marked:\\n', '                side_letter_as_number += 1\\n', '                land_pile_marked = False\\n', '            card.duel_deck = chr(side_letter_as_number)\\n', '    LOGGER.info(f\"Finished marking duel deck status for {set_code}\")\\n', 'def parse_keyrune_code(url: str) -> str:\\n', '    file_stem = pathlib.Path(url).stem.upper()\\n', '    ) as file:\\n', '        upstream_to_keyrune_map: Dict[str, str] = json.load(file)\\n', '    return upstream_to_keyrune_map.get(file_stem, file_stem)\\n', '    mtgjson_set = MtgjsonSetObject()\\n', '    set_data = get_scryfall_set_data(set_code)\\n', '    if not set_data:\\n', '    mtgjson_set.name = set_data[\"name\"].strip()\\n', '    mtgjson_set.code = set_data[\"code\"].upper()\\n', '    mtgjson_set.type = set_data[\"set_type\"]\\n', '    mtgjson_set.keyrune_code = parse_keyrune_code(set_data[\"icon_svg_uri\"])\\n', '    mtgjson_set.release_date = set_data[\"released_at\"]\\n', '    mtgjson_set.mtgo_code = set_data.get(\"mtgo_code\", \"\").upper()\\n', '    mtgjson_set.parent_code = set_data.get(\"parent_set_code\", \"\").upper()\\n', '    mtgjson_set.block = set_data.get(\"block\", \"\")\\n', '    mtgjson_set.is_online_only = set_data.get(\"digital\", \"\")\\n', '    mtgjson_set.is_foil_only = set_data.get(\"foil_only\", \"\")\\n', '    mtgjson_set.is_non_foil_only = set_data.get(\"nonfoil_only\", \"\")\\n', '    mtgjson_set.search_uri = set_data[\"search_uri\"]\\n', '    mtgjson_set.mcm_name = CardMarketProvider().get_set_name(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id = CardMarketProvider().get_set_id(mtgjson_set.name)\\n', '    mtgjson_set.mcm_id_extras = CardMarketProvider().get_extras_set_id(mtgjson_set.name)\\n', '    mtgjson_set.translations = WizardsProvider().get_translation_for_set(\\n', '        mtgjson_set.code\\n', '    base_total_sizes = get_base_and_total_set_sizes(set_code)\\n', '    mtgjson_set.base_set_size = base_total_sizes[0]\\n', '    mtgjson_set.total_set_size = base_total_sizes[1]\\n', '    mtgjson_set.cards = build_base_mtgjson_cards(\\n', '        set_code, set_release_date=mtgjson_set.release_date\\n', '    add_is_starter_option(set_code, mtgjson_set.search_uri, mtgjson_set.cards)\\n', '    relocate_miscellaneous_tokens(mtgjson_set)\\n', '    add_variations_and_alternative_fields(mtgjson_set)\\n', '    add_mcm_details(mtgjson_set)\\n', '    add_card_kingdom_details(mtgjson_set)\\n', '    mtgjson_set.tokens = build_base_mtgjson_tokens(\\n', '        f\"T{set_code}\", mtgjson_set.extra_tokens or []\\n', '    mtgjson_set.tcgplayer_group_id = set_data.get(\"tcgplayer_id\")\\n', '    mtgjson_set.booster = GitHubBoostersProvider().get_set_booster_data(set_code)\\n', '    mark_duel_decks(set_code, mtgjson_set.cards)\\n', '    mtgjson_set.is_foreign_only = mtgjson_set.code in FOREIGN_SETS\\n', '    mtgjson_set.is_partial_preview = MtgjsonMetaObject().date < mtgjson_set.release_date\\n', '    return mtgjson_set\\n', '    return build_base_mtgjson_cards(set_code, added_tokens, True)\\n', '    LOGGER.info(f\"Building cards for {set_code}\")\\n', '    cards = ScryfallProvider().download_cards(set_code)\\n', '    cards.extend(additional_cards or [])\\n', '    mtgjson_cards: List[MtgjsonCardObject] = parallel_call(\\n', '        cards,\\n', '    mtgjson_cards.sort()\\n', '    LOGGER.info(f\"Finished building cards for {set_code}\")\\n', '    return mtgjson_cards\\n', '    LOGGER.info(f\"Add starter data to {set_code}\")\\n', '    starter_card_url = search_url.replace(\"&unique=\", \"++not:booster&unique=\")\\n', '    starter_cards = ScryfallProvider().download(starter_card_url)\\n', '    if starter_cards[\"object\"] == \"error\":\\n', '        LOGGER.debug(f\"All cards in {set_code} are available in boosters\")\\n', '        LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', '    for scryfall_object in starter_cards[\"data\"]:\\n', '        mtgjson_cards_with_same_id = [\\n', '            for item in mtgjson_cards\\n', '            if item.identifiers.scryfall_id == scryfall_object[\"id\"]\\n', '        for card in mtgjson_cards_with_same_id:\\n', '            card.is_starter = True\\n', '    LOGGER.info(f\"Finished adding starter data to {set_code}\")\\n', 'def add_leadership_skills(mtgjson_card: MtgjsonCardObject) -> None:\\n', '    is_commander_legal = (\\n', '    is_oathbreaker_legal = \"Planeswalker\" in mtgjson_card.type\\n', '    is_brawl_legal = (\\n', '        and (is_oathbreaker_legal or is_commander_legal)\\n', '    if is_commander_legal or is_oathbreaker_legal or is_brawl_legal:\\n', '            is_brawl_legal, is_commander_legal, is_oathbreaker_legal\\n', 'def add_uuid(mtgjson_card: MtgjsonCardObject) -> None:\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '        id_source_v5 = (\\n', '        id_source_v4 = (\\n', '    mtgjson_card.uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v5))\\n', '        uuid.uuid5(uuid.NAMESPACE_DNS, id_source_v4)\\n', '    LOGGER.info(f\"Building {scryfall_object[\\'set\\'].upper()}: {scryfall_object[\\'name\\']}\")\\n', '    mtgjson_cards = []\\n', '    mtgjson_card = MtgjsonCardObject(is_token)\\n', '    mtgjson_card.name = scryfall_object[\"name\"]\\n', '    mtgjson_card.flavor_name = scryfall_object.get(\"flavor_name\")\\n', '    mtgjson_card.set_code = scryfall_object[\"set\"].upper()\\n', '    mtgjson_card.identifiers.scryfall_id = scryfall_object[\"id\"]\\n', '    mtgjson_card.identifiers.scryfall_oracle_id = scryfall_object[\"oracle_id\"]\\n', '    face_data = scryfall_object\\n', '    if \"card_faces\" in scryfall_object:\\n', '        mtgjson_card.set_names(scryfall_object[\"name\"].split(\"//\"))\\n', '        mtgjson_card.set_illustration_ids(\\n', '                for card_face in scryfall_object[\"card_faces\"]\\n', '        face_data = scryfall_object[\"card_faces\"][face_id]\\n', '        if \"//\" in scryfall_object.get(\"mana_cost\", \"\"):\\n', '            mtgjson_card.colors = get_card_colors(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                scryfall_object[\"mana_cost\"].split(\"//\")[face_id]\\n', '        elif scryfall_object[\"layout\"] in {\\n', '            mtgjson_card.face_converted_mana_cost = get_card_cmc(\\n', '                face_data.get(\"mana_cost\", \"0\")\\n', '        mtgjson_card.set_watermark(scryfall_object[\"card_faces\"][0].get(\"watermark\"))\\n', '        if scryfall_object[\"card_faces\"][-1][\"oracle_text\"].startswith(\"Aftermath\"):\\n', '            mtgjson_card.layout = \"aftermath\"\\n', '        mtgjson_card.artist = scryfall_object[\"card_faces\"][face_id].get(\"artist\", \"\")\\n', '            for i in range(1, len(scryfall_object[\"card_faces\"])):\\n', '                mtgjson_cards.extend(build_mtgjson_card(scryfall_object, i, is_token))\\n', '    if face_data.get(\"mana_cost\"):\\n', '        mtgjson_card.mana_cost = face_data[\"mana_cost\"]\\n', '    mtgjson_card.identifiers.scryfall_illustration_id = scryfall_object.get(\\n', '        \"illustration_id\", face_data.get(\"illustration_id\")\\n', '    if not mtgjson_card.colors:\\n', '        mtgjson_card.colors = (\\n', '            face_data[\"colors\"]\\n', '            if \"colors\" in face_data.keys()\\n', '            else scryfall_object[\"colors\"]\\n', '    mtgjson_card.border_color = scryfall_object.get(\"border_color\", \"\")\\n', '    mtgjson_card.color_identity = scryfall_object.get(\"color_identity\", \"\")\\n', '    mtgjson_card.converted_mana_cost = scryfall_object.get(\"cmc\", \"\")\\n', '    mtgjson_card.edhrec_rank = scryfall_object.get(\"edhrec_rank\")\\n', '    mtgjson_card.frame_effects = scryfall_object.get(\"frame_effects\", \"\")\\n', '    mtgjson_card.frame_version = scryfall_object.get(\"frame\", \"\")\\n', '    mtgjson_card.hand = scryfall_object.get(\"hand_modifier\")\\n', '    mtgjson_card.has_foil = scryfall_object.get(\"foil\")\\n', '    mtgjson_card.has_non_foil = scryfall_object.get(\"nonfoil\")\\n', '    mtgjson_card.has_content_warning = scryfall_object.get(\"content_warning\")\\n', '    mtgjson_card.is_full_art = scryfall_object.get(\"full_art\")\\n', '    mtgjson_card.is_online_only = scryfall_object.get(\"digital\")\\n', '    mtgjson_card.is_oversized = scryfall_object.get(\"oversized\")\\n', '    mtgjson_card.is_promo = scryfall_object.get(\"promo\")\\n', '    mtgjson_card.is_reprint = scryfall_object.get(\"reprint\")\\n', '    mtgjson_card.is_reserved = scryfall_object.get(\"reserved\")\\n', '    mtgjson_card.is_story_spotlight = scryfall_object.get(\"story_spotlight\")\\n', '    mtgjson_card.is_textless = scryfall_object.get(\"textless\")\\n', '    mtgjson_card.life = scryfall_object.get(\"life_modifier\")\\n', '    mtgjson_card.identifiers.mcm_id = get_str_or_none(\\n', '        scryfall_object.get(\"cardmarket_id\")\\n', '    mtgjson_card.identifiers.mtg_arena_id = get_str_or_none(\\n', '        scryfall_object.get(\"arena_id\")\\n', '    mtgjson_card.identifiers.mtgo_id = get_str_or_none(scryfall_object.get(\"mtgo_id\"))\\n', '    mtgjson_card.identifiers.mtgo_foil_id = get_str_or_none(\\n', '        scryfall_object.get(\"mtgo_foil_id\")\\n', '    mtgjson_card.number = scryfall_object.get(\"collector_number\", \"0\")\\n', '    mtgjson_card.promo_types = scryfall_object.get(\"promo_types\", [])\\n', '    if mtgjson_card.number.endswith(\"p\"):\\n', '        mtgjson_card.promo_types.append(\"planeswalkerstamped\")\\n', '    mtgjson_card.promo_types = [\\n', '        for card_type in mtgjson_card.promo_types\\n', '        if card_type not in {\"starterdeck\", \"planeswalkerdeck\"}\\n', '    card_release_date = scryfall_object.get(\"released_at\")\\n', '    if set_release_date and set_release_date != card_release_date:\\n', '        mtgjson_card.original_release_date = card_release_date\\n', '    mtgjson_card.rarity = scryfall_object.get(\"rarity\", \"\")\\n', '    if not mtgjson_card.artist:\\n', '        mtgjson_card.artist = scryfall_object.get(\"artist\", \"\")\\n', '    if not mtgjson_card.watermark:\\n', '        mtgjson_card.set_watermark(face_data.get(\"watermark\"))\\n', '        type_line in scryfall_object.get(\"type_line\", \"\").lower()\\n', '        for type_line in (\"card\", \"token\")\\n', '        mtgjson_card.layout = \"token\"\\n', '    if not mtgjson_card.layout:\\n', '        mtgjson_card.layout = scryfall_object.get(\"layout\", \"\")\\n', '    mtgjson_card.availability = MtgjsonGameFormatsObject()\\n', '    mtgjson_card.availability.arena = \"arena\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtg_arena_id is not None\\n', '    mtgjson_card.availability.mtgo = \"mtgo\" in scryfall_object.get(\"games\", []) or (\\n', '        mtgjson_card.identifiers.mtgo_id is not None\\n', '    mtgjson_card.availability.paper = not mtgjson_card.is_online_only\\n', '    mtgjson_card.availability.shandalar = \"astral\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.availability.dreamcast = \"sega\" in scryfall_object.get(\"games\", [])\\n', '    mtgjson_card.loyalty = face_data.get(\"loyalty\")\\n', '    ascii_name = (\\n', '        unicodedata.normalize(\"NFD\", mtgjson_card.name)\\n', '    if mtgjson_card.name != ascii_name:\\n', '        LOGGER.debug(f\"Adding ascii name for {mtgjson_card.name} -> {ascii_name}\")\\n', '        mtgjson_card.ascii_name = ascii_name\\n', '    mtgjson_card.power = face_data.get(\"power\", \"\")\\n', '    mtgjson_card.text = face_data.get(\"oracle_text\", \"\")\\n', '    mtgjson_card.toughness = face_data.get(\"toughness\", \"\")\\n', '    mtgjson_card.type = face_data.get(\"type_line\", \"Card\")\\n', '    mtgjson_card.flavor_text = (\\n', '        face_data.get(\"flavor_text\")\\n', '        if face_data.get(\"flavor_text\")\\n', '        else scryfall_object.get(\"flavor_text\")\\n', '    if \"color_indicator\" in face_data.keys():\\n', '        mtgjson_card.color_indicator = face_data[\"color_indicator\"]\\n', '    elif \"color_indicator\" in scryfall_object.keys():\\n', '        mtgjson_card.color_indicator = scryfall_object[\"color_indicator\"]\\n', '    if scryfall_object[\"multiverse_ids\"]:\\n', '        if len(scryfall_object[\"multiverse_ids\"]) > face_id:\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][face_id]\\n', '            mtgjson_card.identifiers.multiverse_id = get_str_or_none(\\n', '                scryfall_object[\"multiverse_ids\"][0]\\n', '    face_names = mtgjson_card.get_names()\\n', '    if face_names:\\n', '        mtgjson_card.face_name = str(face_data[\"name\"])\\n', '        if mtgjson_card.layout != \"meld\":\\n', '            if mtgjson_card.set_code.lower() == \"tust\":\\n', '                mtgjson_card.side = \"a\" if mtgjson_card.type != \"Token\" else \"b\"\\n', '            elif face_names.count(face_names[0]) == len(face_names):\\n', '                face_illustration_ids = mtgjson_card.get_illustration_ids()\\n', '                for index in range(len(face_names)):\\n', '                        face_illustration_ids[index]\\n', '                        == mtgjson_card.identifiers.scryfall_illustration_id\\n', '                        mtgjson_card.side = chr(index + 97)\\n', '                mtgjson_card.side = chr(face_names.index(mtgjson_card.face_name) + 97)\\n', '    mtgjson_card.is_timeshifted = (\\n', '        scryfall_object.get(\"frame\") == \"future\"\\n', '        or mtgjson_card.set_code.lower() == \"tsb\"\\n', '    mtgjson_card.printings = parse_printings(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\")\\n', '    mtgjson_card.legalities = parse_legalities(scryfall_object[\"legalities\"])\\n', '    mtgjson_card.rulings = parse_rulings(scryfall_object[\"rulings_uri\"])\\n', '    card_types = parse_card_types(mtgjson_card.type)\\n', '    mtgjson_card.supertypes = card_types[0]\\n', '    mtgjson_card.types = card_types[1]\\n', '    mtgjson_card.subtypes = card_types[2]\\n', '    if \"Planeswalker\" in mtgjson_card.types:\\n', '        mtgjson_card.text = re.sub(r\"([+-]?[0-9X]+):\", r\"[\\\\1]:\", mtgjson_card.text)\\n', '    mtgjson_card.keywords = [\\n', '        for keyword in sorted(scryfall_object.get(\"keywords\", []))\\n', '        if keyword.lower() in mtgjson_card.text.lower()\\n', '    if \"all_parts\" in scryfall_object.keys():\\n', '        meld_object = []\\n', '        mtgjson_card.set_names(None)\\n', '        for a_part in scryfall_object[\"all_parts\"]:\\n', '            if a_part[\"component\"] != \"token\":\\n', '                if \"//\" in a_part.get(\"name\"):\\n', '                    mtgjson_card.set_names(a_part.get(\"name\").split(\"//\"))\\n', '                if \"meld\" in a_part[\"component\"]:\\n', '                    meld_object.append(a_part[\"component\"])\\n', '                    mtgjson_card.append_names(a_part.get(\"name\"))\\n', '            mtgjson_card.get_names()\\n', '            and len(mtgjson_card.get_names()) == 1\\n', '            and mtgjson_card.name in mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(None)\\n', '            len(meld_object) == 3\\n', '            and meld_object[1] != \"meld_result\"\\n', '            and mtgjson_card.get_names()\\n', '            mtgjson_card.set_names(\\n', '                    mtgjson_card.get_names()[0],\\n', '                    mtgjson_card.get_names()[2],\\n', '                    mtgjson_card.get_names()[1],\\n', '        if mtgjson_card.get_names() and len(mtgjson_card.get_names()) == 3:\\n', '            if mtgjson_card.name != mtgjson_card.get_names()[1]:\\n', '                mtgjson_card.side = \"a\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.name = (\\n', '                    f\"{mtgjson_card.name} // {mtgjson_card.get_names()[1]}\"\\n', '                mtgjson_card.face_name = mtgjson_card.name\\n', '                mtgjson_card.side = \"b\"\\n', '    mtgjson_card.foreign_data = parse_foreign(\\n', '        scryfall_object[\"prints_search_uri\"].replace(\"%22\", \"\"),\\n', '        mtgjson_card.face_name if mtgjson_card.face_name else mtgjson_card.name,\\n', '        mtgjson_card.number,\\n', '        mtgjson_card.set_code.lower(),\\n', '    if mtgjson_card.name in ScryfallProvider().cards_without_limits:\\n', '        mtgjson_card.has_alternative_deck_limit = True\\n', '    add_uuid(mtgjson_card)\\n', '    add_leadership_skills(mtgjson_card)\\n', '    mtgjson_card.raw_purchase_urls.update(scryfall_object.get(\"purchase_uris\", {}))\\n', '    if \"tcgplayer_id\" in scryfall_object:\\n', '        mtgjson_card.identifiers.tcgplayer_product_id = str(\\n', '            scryfall_object[\"tcgplayer_id\"]\\n', '        mtgjson_card.purchase_urls.tcgplayer = url_keygen(\\n', '            mtgjson_card.identifiers.tcgplayer_product_id + mtgjson_card.uuid\\n', '        reverse_related: List[str] = []\\n', '        if \"all_parts\" in scryfall_object:\\n', '            for a_part in scryfall_object[\"all_parts\"]:\\n', '                if a_part.get(\"name\") != mtgjson_card.name:\\n', '                    reverse_related.append(a_part.get(\"name\"))\\n', '        mtgjson_card.reverse_related = reverse_related\\n', '    if mtgjson_card.identifiers.multiverse_id:\\n', '        gatherer_cards = GathererProvider().get_cards(\\n', '            mtgjson_card.identifiers.multiverse_id, mtgjson_card.set_code.lower()\\n', '        if len(gatherer_cards) > face_id:\\n', '            mtgjson_card.original_type = gatherer_cards[face_id].original_types\\n', '            mtgjson_card.original_text = gatherer_cards[face_id].original_text\\n', '    mtgjson_cards.append(mtgjson_card)\\n', '    return mtgjson_cards\\n', '    if not mtgjson_set.cards:\\n', '    LOGGER.info(f\"Adding variations for {mtgjson_set.code}\")\\n', '    for this_card in mtgjson_set.cards:\\n', '        if this_card.get_names():\\n', '            this_card.other_face_ids = []\\n', '            for other_card in mtgjson_set.cards:\\n', '                if other_card.face_name not in this_card.get_names():\\n', '                if other_card.uuid == this_card.uuid:\\n', '                if this_card.layout == \"meld\":\\n', '                    if this_card.side != other_card.side:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                elif other_card.number:\\n', '                    if other_card.number == this_card.number:\\n', '                        this_card.other_face_ids.append(other_card.uuid)\\n', '                    this_card.other_face_ids.append(other_card.uuid)\\n', '        variations = [\\n', '            item.uuid\\n', '            for item in mtgjson_set.cards\\n', '            if item.name.split(\" (\")[0] == this_card.name.split(\" (\")[0]\\n', '            and item.face_name == this_card.face_name\\n', '            and item.uuid != this_card.uuid\\n', '            and (item.number != this_card.number if item.number else True)\\n', '        if variations:\\n', '            this_card.variations = variations\\n', '        if not variations or this_card.name in BASIC_LAND_NAMES:\\n', '        if mtgjson_set.code.upper() in {\"UNH\", \"10E\"}:\\n', '                len(variations) >= 1\\n', '                and this_card.has_foil\\n', '                and not this_card.has_non_foil\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CN2\", \"BBD\", \"JMP\", \"2XM\"}:\\n', '            card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '            if card_number > mtgjson_set.base_set_size:\\n', '                this_card.is_alternative = True\\n', '        elif mtgjson_set.code.upper() in {\"CMR\"}:\\n', '            for other_card in mtgjson_set.cards:\\n', '                    other_card.uuid == this_card.uuid\\n', '                    or other_card.name != this_card.name\\n', '                    or other_card.promo_types\\n', '                    or this_card.promo_types\\n', '                card_number = int(this_card.number.replace(chr(9733), \"\"))\\n', '                if card_number > mtgjson_set.base_set_size:\\n', '                    this_card.is_alternative = True\\n', '            if chr(9733) in this_card.number:\\n', '                this_card.is_alternative = True\\n', '    LOGGER.info(f\"Finished adding variations for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding CK details for {mtgjson_set.code}\")\\n', '    translation_table = MTGBanProvider().get_mtgjson_to_card_kingdom()\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        if mtgjson_card.uuid not in translation_table:\\n', '        entry = translation_table[mtgjson_card.uuid]\\n', '        if \"normal\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_id = str(entry[\"normal\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom = url_keygen(\\n', '                entry[\"normal\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdom\": entry[\"normal\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '        if \"foil\" in entry:\\n', '            mtgjson_card.identifiers.card_kingdom_foil_id = str(entry[\"foil\"][\"id\"])\\n', '            mtgjson_card.purchase_urls.card_kingdom_foil = url_keygen(\\n', '                entry[\"foil\"][\"url\"] + mtgjson_card.uuid\\n', '            mtgjson_card.raw_purchase_urls.update(\\n', '                {\"cardKingdomFoil\": entry[\"foil\"][\"url\"] + consts.CARD_KINGDOM_REFERRAL}\\n', '    LOGGER.info(f\"Finished adding CK details for {mtgjson_set.code}\")\\n', '    LOGGER.info(f\"Adding MCM details for {mtgjson_set.code}\")\\n', '    mkm_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id)\\n', '    extras_cards: Dict[str, Dict[str, Any]] = {}\\n', '    if mtgjson_set.mcm_id_extras:\\n', '        extras_cards = CardMarketProvider().get_mkm_cards(mtgjson_set.mcm_id_extras)\\n', '    for mtgjson_card in mtgjson_set.cards:\\n', '        delete_key = False\\n', '        if \"boosterfun\" in mtgjson_card.promo_types and extras_cards:\\n', '            search_cards = extras_cards\\n', '            search_cards = mkm_cards\\n', '        if mtgjson_card.name.lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.lower()\\n', '            mtgjson_card.face_name\\n', '            and mtgjson_card.face_name.lower() in search_cards.keys()\\n', '            card_key = mtgjson_card.face_name.lower()\\n', '        elif mtgjson_card.name.replace(\"//\", \"/\").lower() in search_cards.keys():\\n', '            card_key = mtgjson_card.name.replace(\"//\", \"/\").lower()\\n', '            card_key = \"\"\\n', '            for mkm_card in search_cards:\\n', '                if mkm_card.startswith(mtgjson_card.name.lower()):\\n', '                    card_key = mkm_card\\n', '                    delete_key = True\\n', '            if not card_key:\\n', '                LOGGER.debug(f\"Failed to find {mtgjson_card.name} for MKM\")\\n', '        mkm_obj = search_cards[card_key]\\n', '        if delete_key:\\n', '            del search_cards[card_key]\\n', '        if not mtgjson_card.identifiers.mcm_id:\\n', '            mtgjson_card.identifiers.mcm_id = str(mkm_obj[\"idProduct\"])\\n', '        mtgjson_card.identifiers.mcm_meta_id = str(mkm_obj[\"idMetaproduct\"])\\n', '        mtgjson_card.purchase_urls.cardmarket = url_keygen(\\n', '            mtgjson_card.identifiers.mcm_id\\n', '            + mtgjson_card.uuid\\n', '            + mtgjson_card.identifiers.mcm_meta_id\\n', '    LOGGER.info(f\"Finished adding MCM details for {mtgjson_set.code}\")\\n', '    with RESOURCE_PATH.joinpath(\"base_set_sizes.json\").open(encoding=\"utf-8\") as f:\\n', '        base_set_size_override = json.load(f)\\n', '    if set_code in base_set_size_override.keys():\\n', '        base_set_size = int(base_set_size_override[set_code])\\n', '        base_set_size_download = ScryfallProvider().download(\\n', '            ScryfallProvider().CARDS_IN_BASE_SET_URL.format(set_code)\\n', '        if base_set_size_download[\"object\"] == \"error\":\\n', '            base_set_size_download = ScryfallProvider().download(\\n', '                ScryfallProvider().CARDS_IN_SET.format(set_code)\\n', '        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\\n', '    total_set_size = len(ScryfallProvider().download_cards(set_code))\\n', '    return base_set_size, total_set_size\\n']",
  "context": "DS_IN_SET.format(set_code)\n            )\n\n        base_set_size = int(base_set_size_download.get(\"total_cards\", 0))\n\n    total_set_size = len(ScryfallProvider().downl"
 },
 "226": {
  "name": "single_set_files",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    single_set_files = [\\n', '    for set_file in single_set_files:\\n', '        _compress_mtgjson_file(set_file)\\n', '    if single_set_files:\\n', '            single_set_files, directory, MtgjsonStructuresObject().all_sets_directory\\n']",
  "context": "f\"Starting compression on {directory.name}\")\n\n    single_set_files = [\n        file\n        for file in directory.glob(\"*"
 },
 "227": {
  "name": "deck_files",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    LOGGER.info(f\"Starting compression on {directory.name}\")\\n', '    single_set_files = [\\n', '        for file in directory.glob(\"*.json\")\\n', '        if file.stem not in MtgjsonStructuresObject().get_all_compiled_file_names()\\n', '    for set_file in single_set_files:\\n', '        _compress_mtgjson_file(set_file)\\n', '    deck_files = list(directory.joinpath(\"decks\").glob(\"*.json\"))\\n', '    for deck_file in deck_files:\\n', '        _compress_mtgjson_file(deck_file)\\n', '        file\\n', '        if file.stem in MtgjsonStructuresObject().get_all_compiled_file_names()\\n', '    if single_set_files:\\n', '            single_set_files, directory, MtgjsonStructuresObject().all_sets_directory\\n', '    if deck_files:\\n', '            deck_files, directory, MtgjsonStructuresObject().all_decks_directory\\n', '    LOGGER.info(f\"Finished compression on {directory.name}\")\\n', '    LOGGER.info(f\"Creating temporary directory {output_file}\")\\n', '        shutil.copy(str(file), str(temp_dir))\\n', '    LOGGER.info(f\"Compressing {output_file}\")\\n', '    LOGGER.info(f\"Removing temporary directory {output_file}\")\\n', '    LOGGER.info(f\"Compressing {file.name}\")\\n', '        [\"bzip2\", \"--keep\", \"--force\", file],\\n', '        [\"gzip\", \"--keep\", \"--force\", file],\\n', '        [\"xz\", \"--keep\", \"--force\", file],\\n', '        [\"zip\", \"--junk-paths\", f\"{file}.zip\", file],\\n', '            LOGGER.error(f\"Failed to compress {str(process.args)}\")\\n']",
  "context": "es:\n        _compress_mtgjson_file(set_file)\n\n    deck_files = list(directory.joinpath(\"decks\").glob(\"*.json\"))\n    for deck_file in deck_files:\n        _compress"
 },
 "228": {
  "name": "sql_files",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    LOGGER.info(f\"Starting compression on {directory.name}\")\\n', '    single_set_files = [\\n', '        for file in directory.glob(\"*.json\")\\n', '        if file.stem not in MtgjsonStructuresObject().get_all_compiled_file_names()\\n', '    for set_file in single_set_files:\\n', '        _compress_mtgjson_file(set_file)\\n', '    deck_files = list(directory.joinpath(\"decks\").glob(\"*.json\"))\\n', '    for deck_file in deck_files:\\n', '        _compress_mtgjson_file(deck_file)\\n', '    sql_files = list(directory.glob(\"*.sql\")) + list(directory.glob(\"*.sqlite\"))\\n', '    for sql_file in sql_files:\\n', '        _compress_mtgjson_file(sql_file)\\n', '        file\\n', '        if file.stem in MtgjsonStructuresObject().get_all_compiled_file_names()\\n', '    if single_set_files:\\n', '            single_set_files, directory, MtgjsonStructuresObject().all_sets_directory\\n', '    if deck_files:\\n', '            deck_files, directory, MtgjsonStructuresObject().all_decks_directory\\n', '    LOGGER.info(f\"Finished compression on {directory.name}\")\\n', '    LOGGER.info(f\"Creating temporary directory {output_file}\")\\n', '        shutil.copy(str(file), str(temp_dir))\\n', '    LOGGER.info(f\"Compressing {output_file}\")\\n', '    LOGGER.info(f\"Removing temporary directory {output_file}\")\\n', '    LOGGER.info(f\"Compressing {file.name}\")\\n', '        [\"bzip2\", \"--keep\", \"--force\", file],\\n', '        [\"gzip\", \"--keep\", \"--force\", file],\\n', '        [\"xz\", \"--keep\", \"--force\", file],\\n', '        [\"zip\", \"--junk-paths\", f\"{file}.zip\", file],\\n', '            LOGGER.error(f\"Failed to compress {str(process.args)}\")\\n']",
  "context": "s:\n        _compress_mtgjson_file(deck_file)\n\n    sql_files = list(directory.glob(\"*.sql\")) + list(directory.glob(\"*.sqlite\"))\n    for sql_file in sql_files:\n        _compress_m"
 },
 "229": {
  "name": "csv_files",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    LOGGER.info(f\"Starting compression on {directory.name}\")\\n', '    single_set_files = [\\n', '        for file in directory.glob(\"*.json\")\\n', '        if file.stem not in MtgjsonStructuresObject().get_all_compiled_file_names()\\n', '    for set_file in single_set_files:\\n', '        _compress_mtgjson_file(set_file)\\n', '    deck_files = list(directory.joinpath(\"decks\").glob(\"*.json\"))\\n', '    for deck_file in deck_files:\\n', '        _compress_mtgjson_file(deck_file)\\n', '    sql_files = list(directory.glob(\"*.sql\")) + list(directory.glob(\"*.sqlite\"))\\n', '    for sql_file in sql_files:\\n', '        _compress_mtgjson_file(sql_file)\\n', '    csv_files = list(directory.joinpath(\"csv\").glob(\"*.csv\"))\\n', '    for csv_file in csv_files:\\n', '        _compress_mtgjson_file(csv_file)\\n', '        file\\n', '        if file.stem in MtgjsonStructuresObject().get_all_compiled_file_names()\\n', '    if single_set_files:\\n', '            single_set_files, directory, MtgjsonStructuresObject().all_sets_directory\\n', '    if deck_files:\\n', '            deck_files, directory, MtgjsonStructuresObject().all_decks_directory\\n', '    if csv_files:\\n', '            csv_files, directory, MtgjsonStructuresObject().all_csvs_directory\\n', '    LOGGER.info(f\"Finished compression on {directory.name}\")\\n', '    LOGGER.info(f\"Creating temporary directory {output_file}\")\\n', '        shutil.copy(str(file), str(temp_dir))\\n', '    LOGGER.info(f\"Compressing {output_file}\")\\n', '    LOGGER.info(f\"Removing temporary directory {output_file}\")\\n', '    LOGGER.info(f\"Compressing {file.name}\")\\n', '        [\"bzip2\", \"--keep\", \"--force\", file],\\n', '        [\"gzip\", \"--keep\", \"--force\", file],\\n', '        [\"xz\", \"--keep\", \"--force\", file],\\n', '        [\"zip\", \"--junk-paths\", f\"{file}.zip\", file],\\n', '            LOGGER.error(f\"Failed to compress {str(process.args)}\")\\n']",
  "context": "es:\n        _compress_mtgjson_file(sql_file)\n\n    csv_files = list(directory.joinpath(\"csv\").glob(\"*.csv\"))\n    for csv_file in csv_files:\n        _compress_m"
 },
 "230": {
  "name": "compiled_files",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    compiled_files = [\\n', '    for compiled_file in compiled_files:\\n', '        _compress_mtgjson_file(compiled_file)\\n']",
  "context": "es:\n        _compress_mtgjson_file(csv_file)\n\n    compiled_files = [\n        file\n        for file in directory.glob(\"*"
 },
 "231": {
  "name": "files",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['    files: List[pathlib.Path], directory: pathlib.Path, output_file: str\\n']",
  "context": "ry.name}\")\n\n\ndef _compress_mtgjson_directory(\n    files: List[pathlib.Path], directory: pathlib.Path, output_file: str\n) -> None:\n    \"\"\"\n    Create a temporary director"
 },
 "232": {
  "name": "output_file",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "69",
  "column": "56",
  "slicing": "['    files: List[pathlib.Path], directory: pathlib.Path, output_file: str\\n']",
  "context": "les: List[pathlib.Path], directory: pathlib.Path, output_file: str\n) -> None:\n    \"\"\"\n    Create a temporary director"
 },
 "233": {
  "name": "compression_commands",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['    compression_commands: List[List[Union[str, pathlib.Path]]] = [\\n', '    _compressor(compression_commands)\\n', '    _compressor(compression_commands)\\n', '        for command in compression_commands\\n']",
  "context": "   LOGGER.info(f\"Compressing {output_file}\")\n\n    compression_commands: List[List[Union[str, pathlib.Path]]] = [\n        [\"tar\", \"-jcf\", f\"{temp_dir}.tar.bz2\", \"-C"
 },
 "234": {
  "name": "compression_commands",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "105",
  "column": "4",
  "slicing": "['    compression_commands: List[List[Union[str, pathlib.Path]]] = [\\n', '    _compressor(compression_commands)\\n', '        for command in compression_commands\\n']",
  "context": "\n    LOGGER.info(f\"Compressing {file.name}\")\n\n    compression_commands: List[List[Union[str, pathlib.Path]]] = [\n        [\"bzip2\", \"--keep\", \"--force\", file],\n    "
 },
 "235": {
  "name": "compression_commands",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "114",
  "column": "16",
  "slicing": "['def _compressor(compression_commands: List[List[Union[str, pathlib.Path]]]) -> None:\\n']",
  "context": "ompressor(compression_commands)\n\n\ndef _compressor(compression_commands: List[List[Union[str, pathlib.Path]]]) -> None:\n    \"\"\"\n    Execute a series of compression comman"
 },
 "236": {
  "name": "processes",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compress_generator.py",
  "lineno": "121",
  "column": "4",
  "slicing": "['    processes = [\\n', '    for process in processes:\\n', '        if process.wait() != 0:\\n', '            LOGGER.error(f\"Failed to compress {str(process.args)}\")\\n']",
  "context": " # Multiprocessing cannot be used with gevent\n    processes = [\n        subprocess.Popen(command, stdout=subproces"
 },
 "237": {
  "name": "sets_to_build",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/__main__.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    sets_to_build: Union[Set[str], List[str]],\\n', '        build_mtgjson_sets(sets_to_build, args.pretty, args.referrals)\\n']",
  "context": "d_push_notification\n\n\ndef build_mtgjson_sets(\n    sets_to_build: Union[Set[str], List[str]],\n    output_pretty: bool,\n    include_referrals: bo"
 },
 "238": {
  "name": "output_pretty",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/__main__.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    output_pretty: bool,\\n', '        write_set_file(compiled_set, output_pretty)\\n']",
  "context": "   sets_to_build: Union[Set[str], List[str]],\n    output_pretty: bool,\n    include_referrals: bool,\n) -> None:\n    \"\"\"\n  "
 },
 "239": {
  "name": "include_referrals",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/__main__.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    include_referrals: bool,\\n', '    if sets_to_build and include_referrals:\\n']",
  "context": "et[str], List[str]],\n    output_pretty: bool,\n    include_referrals: bool,\n) -> None:\n    \"\"\"\n    Build each set one-by-one a"
 },
 "240": {
  "name": "compiled_set",
  "type": "mtgjson5.set_builder.build_mtgjson_set",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/__main__.py",
  "lineno": "49",
  "column": "8",
  "slicing": "['    for set_to_build in sets_to_build:\\n', '        compiled_set = build_mtgjson_set(set_to_build)\\n', '        if not compiled_set:\\n', '            build_and_write_referral_map(compiled_set)\\n', '        write_set_file(compiled_set, output_pretty)\\n']",
  "context": "ts_to_build:\n        # Build the full set\n        compiled_set = build_mtgjson_set(set_to_build)\n        if not compiled_set:\n            continue\n"
 },
 "241": {
  "name": "sets_to_build",
  "type": "mtgjson5.arg_parser.get_sets_to_build",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/__main__.py",
  "lineno": "91",
  "column": "4",
  "slicing": "['    for set_to_build in sets_to_build:\\n', '        compiled_set = build_mtgjson_set(set_to_build)\\n', '        if not compiled_set:\\n', '            build_and_write_referral_map(compiled_set)\\n', '        write_set_file(compiled_set, output_pretty)\\n', '    sets_to_build = get_sets_to_build(args)\\n', '    if sets_to_build:\\n', '        build_mtgjson_sets(sets_to_build, args.pretty, args.referrals)\\n']",
  "context": "tput_file_hashes(OUTPUT_PATH)\n        return\n\n    sets_to_build = get_sets_to_build(args)\n    if sets_to_build:\n        build_mtgjson_sets(s"
 },
 "242": {
  "name": "args",
  "type": "mtgjson5.arg_parser.parse_args",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/__main__.py",
  "lineno": "109",
  "column": "4",
  "slicing": "['    sets_to_build: Union[Set[str], List[str]],\\n', '    output_pretty: bool,\\n', '    include_referrals: bool,\\n', '    for set_to_build in sets_to_build:\\n', '        compiled_set = build_mtgjson_set(set_to_build)\\n', '        if not compiled_set:\\n', '            build_and_write_referral_map(compiled_set)\\n', '        write_set_file(compiled_set, output_pretty)\\n', '    if sets_to_build and include_referrals:\\n', '    sets_to_build = get_sets_to_build(args)\\n', '    if sets_to_build:\\n', '        build_mtgjson_sets(sets_to_build, args.pretty, args.referrals)\\n', '    args = parse_args()\\n', '        if not args.no_alerts:\\n', '            send_push_notification(f\"Starting build\\\\n{args}\")\\n', '        dispatcher(args)\\n', '        if not args.no_alerts:\\n', '        if not args.no_alerts:\\n']",
  "context": "R.info(f\"Starting MTGJSON {MTGJSON_VERSION}\")\n    args = parse_args()\n\n    validate_config_file_in_place()\n\n    try:\n   "
 },
 "243": {
  "name": "enhanced_tcgplayer_skus",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_tcgplayer_skus.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    enhanced_tcgplayer_skus: Dict[str, List[Dict[str, Union[int, str]]]]\\n']",
  "context": "\"\"\"\n    MTGJSON TcgplayerSkus Object\n    \"\"\"\n\n    enhanced_tcgplayer_skus: Dict[str, List[Dict[str, Union[int, str]]]]\n\n    def __init__(self, all_printings_path: pathli"
 },
 "244": {
  "name": "tcg_to_mtgjson_map",
  "type": "utils.generate_card_mapping",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_tcgplayer_skus.py",
  "lineno": "26",
  "column": "8",
  "slicing": "['        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        for group in TCGPlayerProvider().get_tcgplayer_magic_set_ids():\\n', '            tcgplayer_sku_data = get_tcgplayer_sku_data(group)\\n', '            for product in tcgplayer_sku_data:\\n', '                product_id = str(product[\"productId\"])\\n', '                key = tcg_to_mtgjson_map.get(product_id)\\n', '                if not key:\\n', '                    LOGGER.debug(f\"Unable to translate TCGPlayer product {product_id}\")\\n', '                self.enhanced_tcgplayer_skus[key] = [\\n', '                    convert_sku_data_enum(sku) for sku in product[\"skus\"]\\n']",
  "context": "       self.enhanced_tcgplayer_skus = {}\n\n        tcg_to_mtgjson_map = generate_card_mapping(\n            all_printings_path, (\"identifiers\", \"t"
 },
 "245": {
  "name": "tcgplayer_sku_data",
  "type": "providers.tcgplayer.get_tcgplayer_sku_data",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_tcgplayer_skus.py",
  "lineno": "30",
  "column": "12",
  "slicing": "['        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        for group in TCGPlayerProvider().get_tcgplayer_magic_set_ids():\\n', '            tcgplayer_sku_data = get_tcgplayer_sku_data(group)\\n', '            for product in tcgplayer_sku_data:\\n', '                product_id = str(product[\"productId\"])\\n', '                key = tcg_to_mtgjson_map.get(product_id)\\n', '                if not key:\\n', '                    LOGGER.debug(f\"Unable to translate TCGPlayer product {product_id}\")\\n', '                self.enhanced_tcgplayer_skus[key] = [\\n', '                    convert_sku_data_enum(sku) for sku in product[\"skus\"]\\n']",
  "context": "ider().get_tcgplayer_magic_set_ids():\n            tcgplayer_sku_data = get_tcgplayer_sku_data(group)\n            for product in tcgplayer_sku_data:\n   "
 },
 "246": {
  "name": "product_id",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_tcgplayer_skus.py",
  "lineno": "32",
  "column": "16",
  "slicing": "['        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        for group in TCGPlayerProvider().get_tcgplayer_magic_set_ids():\\n', '            tcgplayer_sku_data = get_tcgplayer_sku_data(group)\\n', '            for product in tcgplayer_sku_data:\\n', '                product_id = str(product[\"productId\"])\\n', '                key = tcg_to_mtgjson_map.get(product_id)\\n', '                if not key:\\n', '                    LOGGER.debug(f\"Unable to translate TCGPlayer product {product_id}\")\\n', '                self.enhanced_tcgplayer_skus[key] = [\\n', '                    convert_sku_data_enum(sku) for sku in product[\"skus\"]\\n']",
  "context": "or product in tcgplayer_sku_data:\n                product_id = str(product[\"productId\"])\n                key = tcg_to_mtgjson_map.get(produ"
 },
 "247": {
  "name": "set_list",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_set_list.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    set_list: List[Dict[str, str]]\\n']",
  "context": ":\n    \"\"\"\n    MTGJSON SetList Object\n    \"\"\"\n\n    set_list: List[Dict[str, str]]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "248": {
  "name": "files_to_ignore",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_set_list.py",
  "lineno": "27",
  "column": "25",
  "slicing": "['    def get_all_set_list(files_to_ignore: List[str]) -> List[Dict[str, str]]:\\n']",
  "context": "    )\n\n    @staticmethod\n    def get_all_set_list(files_to_ignore: List[str]) -> List[Dict[str, str]]:\n        \"\"\"\n        This will create the SetList.j"
 },
 "249": {
  "name": "all_sets_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_set_list.py",
  "lineno": "36",
  "column": "8",
  "slicing": "['        all_sets_data: List[Dict[str, str]] = []\\n', '            all_sets_data.append(set_data)\\n', '        return sorted(all_sets_data, key=lambda set_info: set_info[\"name\"])\\n']",
  "context": "return: List of all set dicts\n        \"\"\"\n        all_sets_data: List[Dict[str, str]] = []\n\n        for set_file in OUTPUT_PATH.glob(\"*.json\""
 },
 "250": {
  "name": "decks",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_deck_list.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    decks: List[MtgjsonDeckHeaderObject]\\n']",
  "context": "\n    \"\"\"\n    MTGJSON DeckList Object\n    \"\"\"\n\n    decks: List[MtgjsonDeckHeaderObject]\n\n    def __init__(self, deck_headers: List[Mtgjson"
 },
 "251": {
  "name": "deck_headers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_deck_list.py",
  "lineno": "16",
  "column": "23",
  "slicing": "['    def __init__(self, deck_headers: List[MtgjsonDeckHeaderObject]) -> None:\\n']",
  "context": "[MtgjsonDeckHeaderObject]\n\n    def __init__(self, deck_headers: List[MtgjsonDeckHeaderObject]) -> None:\n        \"\"\"\n        Initializer to build up the ob"
 },
 "252": {
  "name": "atomic_cards_dict",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    atomic_cards_dict: Dict[str, List[Dict[str, Any]]]\\n']",
  "context": "  \"\"\"\n    MTGJSON AtomicCards Object\n    \"\"\"\n\n    atomic_cards_dict: Dict[str, List[Dict[str, Any]]]\n    __name_regex = re.compile(r\"^([^\\n]+) \\([a-z]\\"
 },
 "253": {
  "name": "cards_to_parse",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "22",
  "column": "23",
  "slicing": "['    def __init__(self, cards_to_parse: List[Dict[str, Any]] = None) -> None:\\n']",
  "context": "(r\"^([^\\n]+) \\([a-z]\\)$\")\n\n    def __init__(self, cards_to_parse: List[Dict[str, Any]] = None) -> None:\n        \"\"\"\n        Initializer to build up the ob"
 },
 "254": {
  "name": "files_to_ignore",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "32",
  "column": "14",
  "slicing": "['        self, files_to_ignore: List[str], cards_to_load: List[Dict[str, Any]] = None\\n']",
  "context": "      )\n\n    def iterate_all_cards(\n        self, files_to_ignore: List[str], cards_to_load: List[Dict[str, Any]] = None\n    ) -> None:\n        \"\"\"\n        Iterate and all"
 },
 "255": {
  "name": "cards_to_load",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "32",
  "column": "42",
  "slicing": "['        self, files_to_ignore: List[str], cards_to_load: List[Dict[str, Any]] = None\\n']",
  "context": "_cards(\n        self, files_to_ignore: List[str], cards_to_load: List[Dict[str, Any]] = None\n    ) -> None:\n        \"\"\"\n        Iterate and all"
 },
 "256": {
  "name": "card_list",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "58",
  "column": "14",
  "slicing": "['        self, card_list: List[Dict[str, Any]], valid_keys: List[str]\\n']",
  "context": ")\n\n    def update_global_card_list(\n        self, card_list: List[Dict[str, Any]], valid_keys: List[str]\n    ) -> None:\n        \"\"\"\n        Update the glob"
 },
 "257": {
  "name": "valid_keys",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "58",
  "column": "47",
  "slicing": "['        self, card_list: List[Dict[str, Any]], valid_keys: List[str]\\n']",
  "context": "t(\n        self, card_list: List[Dict[str, Any]], valid_keys: List[str]\n    ) -> None:\n        \"\"\"\n        Update the glob"
 },
 "258": {
  "name": "atomic_card",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "67",
  "column": "12",
  "slicing": "['        valid_keys = MtgjsonCardObject().get_atomic_keys()\\n', '            self.update_global_card_list(cards_to_load, valid_keys)\\n', '        for set_file in OUTPUT_PATH.glob(\"*.json\"):\\n', '            if set_file.stem in files_to_ignore:\\n', '            with set_file.open(encoding=\"utf-8\") as file:\\n', '                file_content = json.load(file)\\n', '                file_content.get(\"data\", {}).get(\"cards\", []), valid_keys\\n', '        for card in card_list:\\n', '            atomic_card: Dict[str, Any] = {\\n', '                to_camel_case(key): card.get(to_camel_case(key))\\n', '                for key in valid_keys\\n', '                if card.get(to_camel_case(key)) is not None\\n', '            if \"scryfallOracleId\" in atomic_card.get(\"identifiers\", []):\\n', '                atomic_card[\"identifiers\"] = {\\n', '                    \"scryfallOracleId\": atomic_card[\"identifiers\"][\"scryfallOracleId\"]\\n', '            for foreign_data in atomic_card.get(\"foreignData\", {}):\\n', '                foreign_data.pop(\"multiverseId\", None)\\n', '            values = self.__name_regex.findall(atomic_card[\"name\"])\\n', '            card_name = values[0] if values else atomic_card[\"name\"]\\n', '            if card_name not in self.atomic_cards_dict.keys():\\n', '                self.atomic_cards_dict[card_name] = []\\n', '            should_add_card = True\\n', '            for card_entry in self.atomic_cards_dict[card_name]:\\n', '                if card_entry.get(\"text\") == atomic_card.get(\"text\"):\\n', '                    should_add_card = False\\n', '            if should_add_card:\\n', '                self.atomic_cards_dict[card_name].append(atomic_card)\\n', '            hold_entry = atomic_card\\n', '            if not atomic_card[\"foreignData\"]:\\n', '                for entry in self.atomic_cards_dict[card_name]:\\n', '                    if entry[\"foreignData\"]:\\n', '                        hold_entry = entry\\n', '            for entry in self.atomic_cards_dict[card_name]:\\n', '                if entry.get(\"text\") == hold_entry.get(\"text\"):\\n', '                    entry[\"foreignData\"] = hold_entry[\"foreignData\"]\\n']",
  "context": "   \"\"\"\n        for card in card_list:\n            atomic_card: Dict[str, Any] = {\n                to_camel_case(key): card.get(to_ca"
 },
 "259": {
  "name": "card_name",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "85",
  "column": "12",
  "slicing": "['        valid_keys = MtgjsonCardObject().get_atomic_keys()\\n', '            self.update_global_card_list(cards_to_load, valid_keys)\\n', '        for set_file in OUTPUT_PATH.glob(\"*.json\"):\\n', '            if set_file.stem in files_to_ignore:\\n', '            with set_file.open(encoding=\"utf-8\") as file:\\n', '                file_content = json.load(file)\\n', '                file_content.get(\"data\", {}).get(\"cards\", []), valid_keys\\n', '        for card in card_list:\\n', '            atomic_card: Dict[str, Any] = {\\n', '                to_camel_case(key): card.get(to_camel_case(key))\\n', '                for key in valid_keys\\n', '                if card.get(to_camel_case(key)) is not None\\n', '            if \"scryfallOracleId\" in atomic_card.get(\"identifiers\", []):\\n', '                atomic_card[\"identifiers\"] = {\\n', '                    \"scryfallOracleId\": atomic_card[\"identifiers\"][\"scryfallOracleId\"]\\n', '            for foreign_data in atomic_card.get(\"foreignData\", {}):\\n', '                foreign_data.pop(\"multiverseId\", None)\\n', '            values = self.__name_regex.findall(atomic_card[\"name\"])\\n', '            card_name = values[0] if values else atomic_card[\"name\"]\\n', '            if card_name not in self.atomic_cards_dict.keys():\\n', '                self.atomic_cards_dict[card_name] = []\\n', '            should_add_card = True\\n', '            for card_entry in self.atomic_cards_dict[card_name]:\\n', '                if card_entry.get(\"text\") == atomic_card.get(\"text\"):\\n', '                    should_add_card = False\\n', '            if should_add_card:\\n', '                self.atomic_cards_dict[card_name].append(atomic_card)\\n', '            hold_entry = atomic_card\\n', '            if not atomic_card[\"foreignData\"]:\\n', '                for entry in self.atomic_cards_dict[card_name]:\\n', '                    if entry[\"foreignData\"]:\\n', '                        hold_entry = entry\\n', '            for entry in self.atomic_cards_dict[card_name]:\\n', '                if entry.get(\"text\") == hold_entry.get(\"text\"):\\n', '                    entry[\"foreignData\"] = hold_entry[\"foreignData\"]\\n']",
  "context": "me_regex.findall(atomic_card[\"name\"])\n            card_name = values[0] if values else atomic_card[\"name\"]\n\n            if card_name not in self.atomic_cards"
 },
 "260": {
  "name": "should_add_card",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "90",
  "column": "12",
  "slicing": "['            should_add_card = True\\n', '            if should_add_card:\\n']",
  "context": "lf.atomic_cards_dict[card_name] = []\n\n            should_add_card = True\n            for card_entry in self.atomic_cards_di"
 },
 "261": {
  "name": "should_add_card",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "93",
  "column": "20",
  "slicing": "['                    should_add_card = False\\n', '            if should_add_card:\\n']",
  "context": ") == atomic_card.get(\"text\"):\n                    should_add_card = False\n                    break\n\n            if should_a"
 },
 "262": {
  "name": "hold_entry",
  "type": "atomic_card",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "101",
  "column": "12",
  "slicing": "['        valid_keys = MtgjsonCardObject().get_atomic_keys()\\n', '            self.update_global_card_list(cards_to_load, valid_keys)\\n', '        for set_file in OUTPUT_PATH.glob(\"*.json\"):\\n', '            if set_file.stem in files_to_ignore:\\n', '            with set_file.open(encoding=\"utf-8\") as file:\\n', '                file_content = json.load(file)\\n', '                file_content.get(\"data\", {}).get(\"cards\", []), valid_keys\\n', '        for card in card_list:\\n', '            atomic_card: Dict[str, Any] = {\\n', '                to_camel_case(key): card.get(to_camel_case(key))\\n', '                for key in valid_keys\\n', '                if card.get(to_camel_case(key)) is not None\\n', '            if \"scryfallOracleId\" in atomic_card.get(\"identifiers\", []):\\n', '                atomic_card[\"identifiers\"] = {\\n', '                    \"scryfallOracleId\": atomic_card[\"identifiers\"][\"scryfallOracleId\"]\\n', '            for foreign_data in atomic_card.get(\"foreignData\", {}):\\n', '                foreign_data.pop(\"multiverseId\", None)\\n', '            values = self.__name_regex.findall(atomic_card[\"name\"])\\n', '            card_name = values[0] if values else atomic_card[\"name\"]\\n', '            if card_name not in self.atomic_cards_dict.keys():\\n', '                self.atomic_cards_dict[card_name] = []\\n', '            should_add_card = True\\n', '            for card_entry in self.atomic_cards_dict[card_name]:\\n', '                if card_entry.get(\"text\") == atomic_card.get(\"text\"):\\n', '                    should_add_card = False\\n', '            if should_add_card:\\n', '                self.atomic_cards_dict[card_name].append(atomic_card)\\n', '            hold_entry = atomic_card\\n', '            if not atomic_card[\"foreignData\"]:\\n', '                for entry in self.atomic_cards_dict[card_name]:\\n', '                    if entry[\"foreignData\"]:\\n', '                        hold_entry = entry\\n', '            for entry in self.atomic_cards_dict[card_name]:\\n', '                if entry.get(\"text\") == hold_entry.get(\"text\"):\\n', '                    entry[\"foreignData\"] = hold_entry[\"foreignData\"]\\n']",
  "context": "This updates foreignData if necessary\n            hold_entry = atomic_card\n            if not atomic_card[\"foreignData\"]:\n   "
 },
 "263": {
  "name": "hold_entry",
  "type": "entry",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_atomic_cards.py",
  "lineno": "105",
  "column": "24",
  "slicing": "['        valid_keys = MtgjsonCardObject().get_atomic_keys()\\n', '            self.update_global_card_list(cards_to_load, valid_keys)\\n', '        for set_file in OUTPUT_PATH.glob(\"*.json\"):\\n', '            if set_file.stem in files_to_ignore:\\n', '            with set_file.open(encoding=\"utf-8\") as file:\\n', '                file_content = json.load(file)\\n', '                file_content.get(\"data\", {}).get(\"cards\", []), valid_keys\\n', '        for card in card_list:\\n', '            atomic_card: Dict[str, Any] = {\\n', '                to_camel_case(key): card.get(to_camel_case(key))\\n', '                for key in valid_keys\\n', '                if card.get(to_camel_case(key)) is not None\\n', '            if \"scryfallOracleId\" in atomic_card.get(\"identifiers\", []):\\n', '                atomic_card[\"identifiers\"] = {\\n', '                    \"scryfallOracleId\": atomic_card[\"identifiers\"][\"scryfallOracleId\"]\\n', '            for foreign_data in atomic_card.get(\"foreignData\", {}):\\n', '                foreign_data.pop(\"multiverseId\", None)\\n', '            values = self.__name_regex.findall(atomic_card[\"name\"])\\n', '            card_name = values[0] if values else atomic_card[\"name\"]\\n', '            if card_name not in self.atomic_cards_dict.keys():\\n', '                self.atomic_cards_dict[card_name] = []\\n', '            should_add_card = True\\n', '            for card_entry in self.atomic_cards_dict[card_name]:\\n', '                if card_entry.get(\"text\") == atomic_card.get(\"text\"):\\n', '                    should_add_card = False\\n', '            if should_add_card:\\n', '                self.atomic_cards_dict[card_name].append(atomic_card)\\n', '            hold_entry = atomic_card\\n', '            if not atomic_card[\"foreignData\"]:\\n', '                for entry in self.atomic_cards_dict[card_name]:\\n', '                    if entry[\"foreignData\"]:\\n', '                        hold_entry = entry\\n', '            for entry in self.atomic_cards_dict[card_name]:\\n', '                if entry.get(\"text\") == hold_entry.get(\"text\"):\\n', '                    entry[\"foreignData\"] = hold_entry[\"foreignData\"]\\n']",
  "context": " if entry[\"foreignData\"]:\n                        hold_entry = entry\n                        break\n\n            for ent"
 },
 "264": {
  "name": "all_identifiers_dict",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_all_identifiers.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    all_identifiers_dict: Dict[str, Any]\\n']",
  "context": "\"\"\n    MTGJSON AllIdentifiers Object\n    \"\"\"\n\n    all_identifiers_dict: Dict[str, Any]\n\n    def __init__(self, all_printings: Dict[str, A"
 },
 "265": {
  "name": "all_printings",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_all_identifiers.py",
  "lineno": "19",
  "column": "23",
  "slicing": "['    def __init__(self, all_printings: Dict[str, Any]) -> None:\\n']",
  "context": "iers_dict: Dict[str, Any]\n\n    def __init__(self, all_printings: Dict[str, Any]) -> None:\n        \"\"\"\n        Initialize to build up the obj"
 },
 "266": {
  "name": "all_sets_dict",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_all_printings.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    all_sets_dict: Dict[str, MtgjsonSetObject]\\n']",
  "context": " \"\"\"\n    MTGJSON AllPrintings Object\n    \"\"\"\n\n    all_sets_dict: Dict[str, MtgjsonSetObject]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "267": {
  "name": "files_to_build",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_all_printings.py",
  "lineno": "25",
  "column": "8",
  "slicing": "['        files_to_build = self.get_files_to_build(\\n', '        self.iterate_all_sets(files_to_build)\\n', '                for key in sets\\n', '                if key in self.all_sets_dict\\n', '            for file_path in OUTPUT_PATH.glob(\"*.json\")\\n', '            if file_path.stem not in files_to_ignore\\n', '        for set_file in files_to_build:\\n', '            with set_file.open(encoding=\"utf-8\") as file:\\n', '                file_content = json.load(file)\\n', '            set_code = set_file.stem\\n', '            if set_code.endswith(\"_\"):\\n', '                set_code = set_code[:-1]\\n', '            self.all_sets_dict[set_code] = file_content.get(\"data\", {})\\n']",
  "context": "      \"\"\"\n        self.all_sets_dict = {}\n        files_to_build = self.get_files_to_build(\n            MtgjsonStructuresObject().get_all_comp"
 },
 "268": {
  "name": "sets",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_all_printings.py",
  "lineno": "30",
  "column": "31",
  "slicing": "['    def get_set_contents(self, sets: List[str] = None) -> Dict[str, MtgjsonSetObject]:\\n']",
  "context": "s(files_to_build)\n\n    def get_set_contents(self, sets: List[str] = None) -> Dict[str, MtgjsonSetObject]:\n        \"\"\"\n        Give the contents of certain s"
 },
 "269": {
  "name": "files_to_ignore",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_all_printings.py",
  "lineno": "46",
  "column": "27",
  "slicing": "['    def get_files_to_build(files_to_ignore: List[str]) -> List[pathlib.Path]:\\n']",
  "context": "ict\n\n    @staticmethod\n    def get_files_to_build(files_to_ignore: List[str]) -> List[pathlib.Path]:\n        \"\"\"\n        Determine what file(s) to incl"
 },
 "270": {
  "name": "files_to_build",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_all_printings.py",
  "lineno": "58",
  "column": "31",
  "slicing": "['    def iterate_all_sets(self, files_to_build: List[pathlib.Path]) -> None:\\n']",
  "context": "_ignore\n        ]\n\n    def iterate_all_sets(self, files_to_build: List[pathlib.Path]) -> None:\n        \"\"\"\n        Iterate and all all MTGJSON se"
 },
 "271": {
  "name": "set_code",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_all_printings.py",
  "lineno": "71",
  "column": "16",
  "slicing": "['        files_to_build = self.get_files_to_build(\\n', '        self.iterate_all_sets(files_to_build)\\n', '                for key in sets\\n', '                if key in self.all_sets_dict\\n', '            for file_path in OUTPUT_PATH.glob(\"*.json\")\\n', '            if file_path.stem not in files_to_ignore\\n', '        for set_file in files_to_build:\\n', '            with set_file.open(encoding=\"utf-8\") as file:\\n', '                file_content = json.load(file)\\n', '            set_code = set_file.stem\\n', '            if set_code.endswith(\"_\"):\\n', '                set_code = set_code[:-1]\\n', '            self.all_sets_dict[set_code] = file_content.get(\"data\", {})\\n']",
  "context": "       if set_code.endswith(\"_\"):\n                set_code = set_code[:-1]\n\n            self.all_sets_dict[set_code] = file_c"
 },
 "272": {
  "name": "attr_value_dict",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_enum_values.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    attr_value_dict: Dict[str, Union[Dict[str, List[str]], List[str]]]\\n']",
  "context": "   \"\"\"\n    MTGJSON EnumValues Object\n    \"\"\"\n\n    attr_value_dict: Dict[str, Union[Dict[str, List[str]], List[str]]]\n\n    set_key_struct = {\n        \"card\": [\n        "
 },
 "273": {
  "name": "set_key_struct",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_enum_values.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    set_key_struct = {\\n']",
  "context": "str, Union[Dict[str, List[str]], List[str]]]\n\n    set_key_struct = {\n        \"card\": [\n            \"availability\",\n    "
 },
 "274": {
  "name": "deck_key_struct",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_enum_values.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['    deck_key_struct = {\"deck\": [\"type\"]}\\n']",
  "context": ",\n        \"foreignData\": [\"language\"],\n    }\n\n    deck_key_struct = {\"deck\": [\"type\"]}\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "275": {
  "name": "set_and_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_enum_values.py",
  "lineno": "55",
  "column": "8",
  "slicing": "['        set_and_cards = self.construct_set_and_card_enums(\\n', '        self.attr_value_dict.update(set_and_cards)\\n']",
  "context": "   \"\"\"\n        self.attr_value_dict = {}\n\n        set_and_cards = self.construct_set_and_card_enums(\n            MtgjsonAllPrintingsObject().to_json()\n"
 },
 "276": {
  "name": "decks",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_enum_values.py",
  "lineno": "60",
  "column": "8",
  "slicing": "['        set_and_cards = self.construct_set_and_card_enums(\\n', '        self.attr_value_dict.update(set_and_cards)\\n', '        decks = self.construct_deck_enums(OUTPUT_PATH.joinpath(\"decks\"))\\n', '        self.attr_value_dict.update(decks)\\n']",
  "context": "lf.attr_value_dict.update(set_and_cards)\n\n        decks = self.construct_deck_enums(OUTPUT_PATH.joinpath(\"decks\"))\n        self.attr_value_dict.update(decks)\n\n      "
 },
 "277": {
  "name": "type_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_enum_values.py",
  "lineno": "78",
  "column": "8",
  "slicing": "['        type_map: Dict[str, Any] = {}\\n', '            type_map[object_name] = dict()\\n', '                type_map[object_name][object_field_name] = set()\\n', '                    type_map[\"deck\"][key].add(content[key])\\n', '        return dict(sort_internal_lists(type_map))\\n', '            type_map[object_name] = dict()\\n', '                type_map[object_name][object_field_name] = set()\\n', '                    type_map[\"set\"][set_contents_key].add(\\n', '                            type_map[\"card\"][card_key].add(value)\\n', '                        type_map[\"card\"][card_key].add(card_value)\\n', '                            type_map[\"card\"][card_key].add(single_value)\\n', '                            type_map[card_key][attribute].add(single_value[attribute])\\n', '        return dict(sort_internal_lists(type_map))\\n']",
  "context": " of enum options for each key\n        \"\"\"\n        type_map: Dict[str, Any] = {}\n        for object_name, object_values in self.dec"
 },
 "278": {
  "name": "all_printing_content",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_enum_values.py",
  "lineno": "95",
  "column": "14",
  "slicing": "['        self, all_printing_content: Dict[str, Any]\\n']",
  "context": "  def construct_set_and_card_enums(\n        self, all_printing_content: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Given"
 },
 "279": {
  "name": "type_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_enum_values.py",
  "lineno": "102",
  "column": "8",
  "slicing": "['        type_map: Dict[str, Any] = {}\\n', '            type_map[object_name] = dict()\\n', '                type_map[object_name][object_field_name] = set()\\n', '                    type_map[\"set\"][set_contents_key].add(\\n', '                            type_map[\"card\"][card_key].add(value)\\n', '                        type_map[\"card\"][card_key].add(card_value)\\n', '                            type_map[\"card\"][card_key].add(single_value)\\n', '                            type_map[card_key][attribute].add(single_value[attribute])\\n', '        return dict(sort_internal_lists(type_map))\\n']",
  "context": " of enum options for each key\n        \"\"\"\n        type_map: Dict[str, Any] = {}\n        for object_name, object_values in self.set"
 },
 "280": {
  "name": "card_value",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_enum_values.py",
  "lineno": "124",
  "column": "20",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        set_and_cards = self.construct_set_and_card_enums(\\n', '        self.attr_value_dict.update(set_and_cards)\\n', '        decks = self.construct_deck_enums(OUTPUT_PATH.joinpath(\"decks\"))\\n', '        self.attr_value_dict.update(decks)\\n', '        keywords = OUTPUT_PATH.joinpath(MtgjsonStructuresObject().key_words + \".json\")\\n', '        if not keywords.is_file():\\n', '            LOGGER.warning(f\"Unable to find {keywords}\")\\n', '            with keywords.open(encoding=\"utf-8\") as file:\\n', '                content = json.load(file).get(\"data\", {})\\n', '            self.attr_value_dict.update({\"keywords\": content})\\n', '        type_map: Dict[str, Any] = {}\\n', '        for object_name, object_values in self.deck_key_struct.items():\\n', '            type_map[object_name] = dict()\\n', '            for object_field_name in object_values:\\n', '                type_map[object_name][object_field_name] = set()\\n', '        for deck in decks_directory.glob(\"**/*.json\"):\\n', '            with deck.open(encoding=\"utf-8\") as file:\\n', '                content = json.load(file).get(\"data\", {})\\n', '            for key in content.keys():\\n', '                if key in self.deck_key_struct[\"deck\"]:\\n', '                    type_map[\"deck\"][key].add(content[key])\\n', '        return dict(sort_internal_lists(type_map))\\n', '        type_map: Dict[str, Any] = {}\\n', '        for object_name, object_values in self.set_key_struct.items():\\n', '            type_map[object_name] = dict()\\n', '            for object_field_name in object_values:\\n', '                type_map[object_name][object_field_name] = set()\\n', '        for set_contents in all_printing_content.values():\\n', '            for set_contents_key in set_contents.keys():\\n', '                if set_contents_key in self.set_key_struct[\"set\"]:\\n', '                    type_map[\"set\"][set_contents_key].add(\\n', '                        set_contents.get(set_contents_key)\\n', '            match_keys = set(self.set_key_struct[\"card\"]).union(\\n', '            for card in set_contents.get(\"cards\", []) + set_contents.get(\"tokens\", []):\\n', '                for card_key in card.keys():\\n', '                    if card_key not in match_keys:\\n', '                    card_value = card[card_key]\\n', '                    if isinstance(card_value, dict):\\n', '                        for value in card_value.keys():\\n', '                            type_map[\"card\"][card_key].add(value)\\n', '                    if not isinstance(card_value, list):\\n', '                        type_map[\"card\"][card_key].add(card_value)\\n', '                    for single_value in card_value:\\n', '                        if not isinstance(single_value, dict):\\n', '                            type_map[\"card\"][card_key].add(single_value)\\n', '                        for attribute in self.set_key_struct.get(card_key, []):\\n', '                            type_map[card_key][attribute].add(single_value[attribute])\\n', '        return dict(sort_internal_lists(type_map))\\n']",
  "context": "he value when actually needed\n                    card_value = card[card_key]\n\n                    # For Dicts, we just enum the"
 },
 "281": {
  "name": "files",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_compiled_list.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    files: List[str]\\n']",
  "context": " \"\"\"\n    MTGJSON CompiledList Object\n    \"\"\"\n\n    files: List[str]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "282": {
  "name": "artifact",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "23",
  "column": "8",
  "slicing": "['        artifact: List[str]\\n']",
  "context": "dTypes.CardTypesInner Object\n        \"\"\"\n\n        artifact: List[str]\n        conspiracy: List[str]\n        creature: Li"
 },
 "283": {
  "name": "conspiracy",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "24",
  "column": "8",
  "slicing": "['        conspiracy: List[str]\\n']",
  "context": "\n        \"\"\"\n\n        artifact: List[str]\n        conspiracy: List[str]\n        creature: List[str]\n        enchantment: L"
 },
 "284": {
  "name": "creature",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "25",
  "column": "8",
  "slicing": "['        creature: List[str]\\n']",
  "context": ": List[str]\n        conspiracy: List[str]\n        creature: List[str]\n        enchantment: List[str]\n        instant: Li"
 },
 "285": {
  "name": "enchantment",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "26",
  "column": "8",
  "slicing": "['        enchantment: List[str]\\n']",
  "context": "cy: List[str]\n        creature: List[str]\n        enchantment: List[str]\n        instant: List[str]\n        land: List[str]"
 },
 "286": {
  "name": "instant",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "27",
  "column": "8",
  "slicing": "['        instant: List[str]\\n']",
  "context": " List[str]\n        enchantment: List[str]\n        instant: List[str]\n        land: List[str]\n        phenomenon: List[s"
 },
 "287": {
  "name": "land",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "28",
  "column": "8",
  "slicing": "['        land: List[str]\\n']",
  "context": "ent: List[str]\n        instant: List[str]\n        land: List[str]\n        phenomenon: List[str]\n        plane: List["
 },
 "288": {
  "name": "phenomenon",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "29",
  "column": "8",
  "slicing": "['        phenomenon: List[str]\\n']",
  "context": "nstant: List[str]\n        land: List[str]\n        phenomenon: List[str]\n        plane: List[str]\n        planeswalker: Lis"
 },
 "289": {
  "name": "plane",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "30",
  "column": "8",
  "slicing": "['        plane: List[str]\\n']",
  "context": ": List[str]\n        phenomenon: List[str]\n        plane: List[str]\n        planeswalker: List[str]\n        scheme: Li"
 },
 "290": {
  "name": "planeswalker",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "31",
  "column": "8",
  "slicing": "['        planeswalker: List[str]\\n']",
  "context": "menon: List[str]\n        plane: List[str]\n        planeswalker: List[str]\n        scheme: List[str]\n        sorcery: List[st"
 },
 "291": {
  "name": "scheme",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "32",
  "column": "8",
  "slicing": "['        scheme: List[str]\\n']",
  "context": "List[str]\n        planeswalker: List[str]\n        scheme: List[str]\n        sorcery: List[str]\n        tribal: List[st"
 },
 "292": {
  "name": "sorcery",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "33",
  "column": "8",
  "slicing": "['        sorcery: List[str]\\n']",
  "context": "lker: List[str]\n        scheme: List[str]\n        sorcery: List[str]\n        tribal: List[str]\n        vanguard: List[s"
 },
 "293": {
  "name": "tribal",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "34",
  "column": "8",
  "slicing": "['        tribal: List[str]\\n']",
  "context": "eme: List[str]\n        sorcery: List[str]\n        tribal: List[str]\n        vanguard: List[str]\n\n        def __init__("
 },
 "294": {
  "name": "vanguard",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "35",
  "column": "8",
  "slicing": "['        vanguard: List[str]\\n']",
  "context": "cery: List[str]\n        tribal: List[str]\n        vanguard: List[str]\n\n        def __init__(self, magic_rules: str) -> N"
 },
 "295": {
  "name": "magic_rules",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "37",
  "column": "27",
  "slicing": "['        def __init__(self, magic_rules: str) -> None:\\n']",
  "context": "  vanguard: List[str]\n\n        def __init__(self, magic_rules: str) -> None:\n            \"\"\"\n            Internal initializer\n "
 },
 "296": {
  "name": "types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['    types: Dict[str, Dict[str, List[str]]]\\n']",
  "context": "in key and not callable(value)\n            }\n\n    types: Dict[str, Dict[str, List[str]]]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "297": {
  "name": "comp_rules",
  "type": "utils.parse_magic_rules_subset",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "79",
  "column": "8",
  "slicing": "['            planar_regex = re.compile(r\".*The planar types are (.*)\\\\.\")\\n', '            self.plane = regex_str_to_list(planar_regex.search(magic_rules))\\n', '                for key, value in self.__dict__.items()\\n', '                if \"__\" not in key and not callable(value)\\n', '        comp_rules = parse_magic_rules_subset(WizardsProvider().get_magic_rules())\\n', '        inner_sets = self.MtgjsonCardTypesInnerObject(comp_rules)\\n', '        super_regex = re.compile(r\".*The supertypes are (.*)\\\\.\")\\n', '        super_types = regex_str_to_list(super_regex.search(comp_rules))\\n', '        for key, value in inner_sets.to_json().items():\\n', '            self.types[key] = {\"subTypes\": value, \"superTypes\": super_types}\\n', '            to_camel_case(key): value\\n', '            if \"__\" not in key and not callable(value)\\n', '        card_types_split[index] = string.capwords(value.split(\" (\")[0])\\n']",
  "context": "ject\n        \"\"\"\n        self.types = {}\n\n        comp_rules = parse_magic_rules_subset(WizardsProvider().get_magic_rules())\n\n        inner_sets = self.MtgjsonCardTypesInnerOb"
 },
 "298": {
  "name": "inner_sets",
  "type": "MtgjsonCardTypesInnerObject",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "81",
  "column": "8",
  "slicing": "['            planar_regex = re.compile(r\".*The planar types are (.*)\\\\.\")\\n', '            self.plane = regex_str_to_list(planar_regex.search(magic_rules))\\n', '                for key, value in self.__dict__.items()\\n', '                if \"__\" not in key and not callable(value)\\n', '        comp_rules = parse_magic_rules_subset(WizardsProvider().get_magic_rules())\\n', '        inner_sets = self.MtgjsonCardTypesInnerObject(comp_rules)\\n', '        super_regex = re.compile(r\".*The supertypes are (.*)\\\\.\")\\n', '        super_types = regex_str_to_list(super_regex.search(comp_rules))\\n', '        for key, value in inner_sets.to_json().items():\\n', '            self.types[key] = {\"subTypes\": value, \"superTypes\": super_types}\\n', '            to_camel_case(key): value\\n', '            if \"__\" not in key and not callable(value)\\n', '        card_types_split[index] = string.capwords(value.split(\" (\")[0])\\n']",
  "context": "set(WizardsProvider().get_magic_rules())\n\n        inner_sets = self.MtgjsonCardTypesInnerObject(comp_rules)\n\n        super_regex = re.compile(r\".*The supertyp"
 },
 "299": {
  "name": "super_types",
  "type": "regex_str_to_list",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "84",
  "column": "8",
  "slicing": "['            planar_regex = re.compile(r\".*The planar types are (.*)\\\\.\")\\n', '            self.plane = regex_str_to_list(planar_regex.search(magic_rules))\\n', '                for key, value in self.__dict__.items()\\n', '                if \"__\" not in key and not callable(value)\\n', '        comp_rules = parse_magic_rules_subset(WizardsProvider().get_magic_rules())\\n', '        inner_sets = self.MtgjsonCardTypesInnerObject(comp_rules)\\n', '        super_regex = re.compile(r\".*The supertypes are (.*)\\\\.\")\\n', '        super_types = regex_str_to_list(super_regex.search(comp_rules))\\n', '        for key, value in inner_sets.to_json().items():\\n', '            self.types[key] = {\"subTypes\": value, \"superTypes\": super_types}\\n', '            to_camel_case(key): value\\n', '            if \"__\" not in key and not callable(value)\\n', '        card_types_split[index] = string.capwords(value.split(\" (\")[0])\\n']",
  "context": "e.compile(r\".*The supertypes are (.*)\\.\")\n        super_types = regex_str_to_list(super_regex.search(comp_rules))\n\n        for key, value in inner_sets.to_json().it"
 },
 "300": {
  "name": "regex_match",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "101",
  "column": "22",
  "slicing": "['def regex_str_to_list(regex_match: Optional[Match]) -> List[str]:\\n']",
  "context": "callable(value)\n        }\n\n\ndef regex_str_to_list(regex_match: Optional[Match]) -> List[str]:\n    \"\"\"\n    Take a regex match object and turn a s"
 },
 "301": {
  "name": "card_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "112",
  "column": "4",
  "slicing": "['            planar_regex = re.compile(r\".*The planar types are (.*)\\\\.\")\\n', '            self.plane = regex_str_to_list(planar_regex.search(magic_rules))\\n', '                for key, value in self.__dict__.items()\\n', '                if \"__\" not in key and not callable(value)\\n', '        comp_rules = parse_magic_rules_subset(WizardsProvider().get_magic_rules())\\n', '        inner_sets = self.MtgjsonCardTypesInnerObject(comp_rules)\\n', '        super_regex = re.compile(r\".*The supertypes are (.*)\\\\.\")\\n', '        super_types = regex_str_to_list(super_regex.search(comp_rules))\\n', '        for key, value in inner_sets.to_json().items():\\n', '            self.types[key] = {\"subTypes\": value, \"superTypes\": super_types}\\n', '            to_camel_case(key): value\\n', '            for key, value in self.types.items()\\n', '            if \"__\" not in key and not callable(value)\\n', '    card_types = regex_match.group(1).split(\". \")[0]\\n', '    card_types_split: List[str] = card_types.split(\", \")\\n', '    if len(card_types_split) == 1:\\n', '        card_types_split = card_types.split(\" and \")\\n', '        card_types_split[-1] = card_types_split[-1].split(\" \", 1)[1]\\n', '    for index, value in enumerate(card_types_split):\\n', '        card_types_split[index] = string.capwords(value.split(\" (\")[0])\\n', '    return card_types_split\\n']",
  "context": "]\n\n    # Get only the sentence with the types\n    card_types = regex_match.group(1).split(\". \")[0]\n\n    # Split the types by comma\n    card_types_spl"
 },
 "302": {
  "name": "card_types_split",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_card_types.py",
  "lineno": "115",
  "column": "4",
  "slicing": "['    card_types_split: List[str] = card_types.split(\", \")\\n', '    if len(card_types_split) == 1:\\n', '        card_types_split[-1] = card_types_split[-1].split(\" \", 1)[1]\\n', '    for index, value in enumerate(card_types_split):\\n', '        card_types_split[index] = string.capwords(value.split(\" (\")[0])\\n', '    return card_types_split\\n']",
  "context": "plit(\". \")[0]\n\n    # Split the types by comma\n    card_types_split: List[str] = card_types.split(\", \")\n\n    # If there are only two elements, split by \" "
 },
 "303": {
  "name": "all_printings",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    all_printings: str\\n']",
  "context": "SON Internal Object for Output Files\n    \"\"\"\n\n    all_printings: str\n    atomic_cards: str\n    all_prices: str\n\n    all"
 },
 "304": {
  "name": "atomic_cards",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    atomic_cards: str\\n']",
  "context": " Output Files\n    \"\"\"\n\n    all_printings: str\n    atomic_cards: str\n    all_prices: str\n\n    all_decks_directory: str\n"
 },
 "305": {
  "name": "all_prices",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    all_prices: str\\n']",
  "context": "\n    all_printings: str\n    atomic_cards: str\n    all_prices: str\n\n    all_decks_directory: str\n    all_sets_directo"
 },
 "306": {
  "name": "all_decks_directory",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    all_decks_directory: str\\n']",
  "context": "tr\n    atomic_cards: str\n    all_prices: str\n\n    all_decks_directory: str\n    all_sets_directory: str\n\n    card_types: str\n "
 },
 "307": {
  "name": "all_sets_directory",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    all_sets_directory: str\\n']",
  "context": "all_prices: str\n\n    all_decks_directory: str\n    all_sets_directory: str\n\n    card_types: str\n    compiled_list: str\n    de"
 },
 "308": {
  "name": "card_types",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    card_types: str\\n']",
  "context": "s_directory: str\n    all_sets_directory: str\n\n    card_types: str\n    compiled_list: str\n    deck_list: str\n    key_"
 },
 "309": {
  "name": "compiled_list",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    compiled_list: str\\n']",
  "context": " all_sets_directory: str\n\n    card_types: str\n    compiled_list: str\n    deck_list: str\n    key_words: str\n    set_list"
 },
 "310": {
  "name": "deck_list",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    deck_list: str\\n']",
  "context": "r\n\n    card_types: str\n    compiled_list: str\n    deck_list: str\n    key_words: str\n    set_list: str\n\n    enum_val"
 },
 "311": {
  "name": "key_words",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    key_words: str\\n']",
  "context": "str\n    compiled_list: str\n    deck_list: str\n    key_words: str\n    set_list: str\n\n    enum_values: str\n\n    refer"
 },
 "312": {
  "name": "set_list",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    set_list: str\\n']",
  "context": "st: str\n    deck_list: str\n    key_words: str\n    set_list: str\n\n    enum_values: str\n\n    referral_database: str\n"
 },
 "313": {
  "name": "enum_values",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    enum_values: str\\n']",
  "context": "st: str\n    key_words: str\n    set_list: str\n\n    enum_values: str\n\n    referral_database: str\n    version: str\n\n    "
 },
 "314": {
  "name": "referral_database",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    referral_database: str\\n']",
  "context": " str\n    set_list: str\n\n    enum_values: str\n\n    referral_database: str\n    version: str\n\n    all_identifiers: str\n\n    al"
 },
 "315": {
  "name": "version",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    version: str\\n']",
  "context": " enum_values: str\n\n    referral_database: str\n    version: str\n\n    all_identifiers: str\n\n    all_tcgplayer_skus:"
 },
 "316": {
  "name": "all_identifiers",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['    all_identifiers: str\\n']",
  "context": "\n    referral_database: str\n    version: str\n\n    all_identifiers: str\n\n    all_tcgplayer_skus: str\n\n    all_printings_st"
 },
 "317": {
  "name": "all_tcgplayer_skus",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    all_tcgplayer_skus: str\\n']",
  "context": "r\n    version: str\n\n    all_identifiers: str\n\n    all_tcgplayer_skus: str\n\n    all_printings_standard: str\n    all_printings"
 },
 "318": {
  "name": "all_printings_standard",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['    all_printings_standard: str\\n']",
  "context": "dentifiers: str\n\n    all_tcgplayer_skus: str\n\n    all_printings_standard: str\n    all_printings_pioneer: str\n    all_printings_m"
 },
 "319": {
  "name": "all_printings_pioneer",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['    all_printings_pioneer: str\\n']",
  "context": "er_skus: str\n\n    all_printings_standard: str\n    all_printings_pioneer: str\n    all_printings_modern: str\n    all_printings_le"
 },
 "320": {
  "name": "all_printings_modern",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    all_printings_modern: str\\n']",
  "context": "_standard: str\n    all_printings_pioneer: str\n    all_printings_modern: str\n    all_printings_legacy: str\n    all_printings_vi"
 },
 "321": {
  "name": "all_printings_legacy",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    all_printings_legacy: str\\n']",
  "context": "gs_pioneer: str\n    all_printings_modern: str\n    all_printings_legacy: str\n    all_printings_vintage: str\n\n    atomic_cards_s"
 },
 "322": {
  "name": "all_printings_vintage",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    all_printings_vintage: str\\n']",
  "context": "ngs_modern: str\n    all_printings_legacy: str\n    all_printings_vintage: str\n\n    atomic_cards_standard: str\n    atomic_cards_p"
 },
 "323": {
  "name": "atomic_cards_standard",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['    atomic_cards_standard: str\\n']",
  "context": "s_legacy: str\n    all_printings_vintage: str\n\n    atomic_cards_standard: str\n    atomic_cards_pioneer: str\n    atomic_cards_mod"
 },
 "324": {
  "name": "atomic_cards_pioneer",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "46",
  "column": "4",
  "slicing": "['    atomic_cards_pioneer: str\\n']",
  "context": "_vintage: str\n\n    atomic_cards_standard: str\n    atomic_cards_pioneer: str\n    atomic_cards_modern: str\n    atomic_cards_lega"
 },
 "325": {
  "name": "atomic_cards_modern",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['    atomic_cards_modern: str\\n']",
  "context": "s_standard: str\n    atomic_cards_pioneer: str\n    atomic_cards_modern: str\n    atomic_cards_legacy: str\n    atomic_cards_vint"
 },
 "326": {
  "name": "atomic_cards_legacy",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "48",
  "column": "4",
  "slicing": "['    atomic_cards_legacy: str\\n']",
  "context": "rds_pioneer: str\n    atomic_cards_modern: str\n    atomic_cards_legacy: str\n    atomic_cards_vintage: str\n    atomic_cards_pau"
 },
 "327": {
  "name": "atomic_cards_vintage",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['    atomic_cards_vintage: str\\n']",
  "context": "ards_modern: str\n    atomic_cards_legacy: str\n    atomic_cards_vintage: str\n    atomic_cards_pauper: str\n\n    def __init__(sel"
 },
 "328": {
  "name": "atomic_cards_pauper",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_structures.py",
  "lineno": "50",
  "column": "4",
  "slicing": "['    atomic_cards_pauper: str\\n']",
  "context": "rds_legacy: str\n    atomic_cards_vintage: str\n    atomic_cards_pauper: str\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "329": {
  "name": "ability_words",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_keywords.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    ability_words: List[str]\\n']",
  "context": "\n    \"\"\"\n    MTGJSON Keywords Object\n    \"\"\"\n\n    ability_words: List[str]\n    keyword_actions: List[str]\n    keyword_abiliti"
 },
 "330": {
  "name": "keyword_actions",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_keywords.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    keyword_actions: List[str]\\n']",
  "context": " Object\n    \"\"\"\n\n    ability_words: List[str]\n    keyword_actions: List[str]\n    keyword_abilities: List[str]\n\n    def __init__"
 },
 "331": {
  "name": "keyword_abilities",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/compiled_classes/mtgjson_keywords.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    keyword_abilities: List[str]\\n']",
  "context": "rds: List[str]\n    keyword_actions: List[str]\n    keyword_abilities: List[str]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "332": {
  "name": "date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_rulings.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    date: str\\n', '        self.date = date\\n']",
  "context": "MTGJSON Singular Card.Rulings Object\n    \"\"\"\n\n    date: str\n    text: str\n\n    def __init__(self, date: str, t"
 },
 "333": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_rulings.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    text: str\\n', '        self.text = text\\n']",
  "context": "ar Card.Rulings Object\n    \"\"\"\n\n    date: str\n    text: str\n\n    def __init__(self, date: str, text: str) -> N"
 },
 "334": {
  "name": "date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_rulings.py",
  "lineno": "17",
  "column": "23",
  "slicing": "['    def __init__(self, date: str, text: str) -> None:\\n']",
  "context": "  date: str\n    text: str\n\n    def __init__(self, date: str, text: str) -> None:\n        \"\"\"\n        Set the ruling date and text\n "
 },
 "335": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_rulings.py",
  "lineno": "17",
  "column": "34",
  "slicing": "['    def __init__(self, date: str, text: str) -> None:\\n']",
  "context": "\n    text: str\n\n    def __init__(self, date: str, text: str) -> None:\n        \"\"\"\n        Set the ruling date and text\n "
 },
 "336": {
  "name": "card_kingdom",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_purchase_urls.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    card_kingdom: str\\n']",
  "context": "ON Singular Card.PurchaseURLs Object\n    \"\"\"\n\n    card_kingdom: str\n    card_kingdom_foil: str\n    cardmarket: str\n   "
 },
 "337": {
  "name": "card_kingdom_foil",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_purchase_urls.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    card_kingdom_foil: str\\n']",
  "context": "aseURLs Object\n    \"\"\"\n\n    card_kingdom: str\n    card_kingdom_foil: str\n    cardmarket: str\n    tcgplayer: str\n\n    def bu"
 },
 "338": {
  "name": "cardmarket",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_purchase_urls.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    cardmarket: str\\n']",
  "context": " card_kingdom: str\n    card_kingdom_foil: str\n    cardmarket: str\n    tcgplayer: str\n\n    def build_keys_to_skip(sel"
 },
 "339": {
  "name": "tcgplayer",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_purchase_urls.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    tcgplayer: str\\n']",
  "context": "   card_kingdom_foil: str\n    cardmarket: str\n    tcgplayer: str\n\n    def build_keys_to_skip(self) -> Set[str]:\n   "
 },
 "340": {
  "name": "excluded_keys",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_purchase_urls.py",
  "lineno": "24",
  "column": "8",
  "slicing": "['        excluded_keys = set()\\n', '                excluded_keys.add(value)\\n', '        return excluded_keys\\n']",
  "context": "return What keys to skip over\n        \"\"\"\n        excluded_keys = set()\n\n        for _, value in self.__dict__.items():\n  "
 },
 "341": {
  "name": "artist",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    artist: str\\n']",
  "context": "\"\"\"\n    MTGJSON Singular Card Object\n    \"\"\"\n\n    artist: str\n    ascii_name: Optional[str]\n    availability: Mt"
 },
 "342": {
  "name": "ascii_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    ascii_name: Optional[str]\\n']",
  "context": "Singular Card Object\n    \"\"\"\n\n    artist: str\n    ascii_name: Optional[str]\n    availability: MtgjsonGameFormatsObject\n    bor"
 },
 "343": {
  "name": "availability",
  "type": "classes.mtgjson_game_formats.MtgjsonGameFormatsObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    availability: MtgjsonGameFormatsObject\\n']",
  "context": "    artist: str\n    ascii_name: Optional[str]\n    availability: MtgjsonGameFormatsObject\n    border_color: str\n    color_identity: List[str"
 },
 "344": {
  "name": "border_color",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    border_color: str\\n']",
  "context": "r]\n    availability: MtgjsonGameFormatsObject\n    border_color: str\n    color_identity: List[str]\n    color_indicator:"
 },
 "345": {
  "name": "color_identity",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    color_identity: List[str]\\n']",
  "context": "tgjsonGameFormatsObject\n    border_color: str\n    color_identity: List[str]\n    color_indicator: Optional[List[str]]\n    color"
 },
 "346": {
  "name": "color_indicator",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    color_indicator: Optional[List[str]]\\n']",
  "context": "rder_color: str\n    color_identity: List[str]\n    color_indicator: Optional[List[str]]\n    colors: List[str]\n    converted_mana_cost: flo"
 },
 "347": {
  "name": "colors",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    colors: List[str]\\n']",
  "context": "str]\n    color_indicator: Optional[List[str]]\n    colors: List[str]\n    converted_mana_cost: float\n    count: int\n    "
 },
 "348": {
  "name": "converted_mana_cost",
  "type": "float",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['    converted_mana_cost: float\\n']",
  "context": "or: Optional[List[str]]\n    colors: List[str]\n    converted_mana_cost: float\n    count: int\n    duel_deck: Optional[str]\n    ed"
 },
 "349": {
  "name": "count",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    count: int\\n']",
  "context": "ors: List[str]\n    converted_mana_cost: float\n    count: int\n    duel_deck: Optional[str]\n    edhrec_rank: Opti"
 },
 "350": {
  "name": "duel_deck",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    duel_deck: Optional[str]\\n']",
  "context": "    converted_mana_cost: float\n    count: int\n    duel_deck: Optional[str]\n    edhrec_rank: Optional[int]\n    face_converted_"
 },
 "351": {
  "name": "edhrec_rank",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    edhrec_rank: Optional[int]\\n']",
  "context": "t\n    count: int\n    duel_deck: Optional[str]\n    edhrec_rank: Optional[int]\n    face_converted_mana_cost: float\n    face_name:"
 },
 "352": {
  "name": "face_converted_mana_cost",
  "type": "float",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['    face_converted_mana_cost: float\\n']",
  "context": " Optional[str]\n    edhrec_rank: Optional[int]\n    face_converted_mana_cost: float\n    face_name: Optional[str]\n    flavor_name: Opti"
 },
 "353": {
  "name": "face_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['    face_name: Optional[str]\\n']",
  "context": "onal[int]\n    face_converted_mana_cost: float\n    face_name: Optional[str]\n    flavor_name: Optional[str]\n    flavor_text: Op"
 },
 "354": {
  "name": "flavor_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    flavor_name: Optional[str]\\n']",
  "context": "mana_cost: float\n    face_name: Optional[str]\n    flavor_name: Optional[str]\n    flavor_text: Optional[str]\n    foreign_data: L"
 },
 "355": {
  "name": "flavor_text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['    flavor_text: Optional[str]\\n']",
  "context": " Optional[str]\n    flavor_name: Optional[str]\n    flavor_text: Optional[str]\n    foreign_data: List[MtgjsonForeignDataObject]\n "
 },
 "356": {
  "name": "foreign_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['    foreign_data: List[MtgjsonForeignDataObject]\\n']",
  "context": " Optional[str]\n    flavor_text: Optional[str]\n    foreign_data: List[MtgjsonForeignDataObject]\n    frame_effects: List[str]\n    frame_version: st"
 },
 "357": {
  "name": "frame_effects",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['    frame_effects: List[str]\\n']",
  "context": " foreign_data: List[MtgjsonForeignDataObject]\n    frame_effects: List[str]\n    frame_version: str\n    hand: Optional[str]\n   "
 },
 "358": {
  "name": "frame_version",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    frame_version: str\\n']",
  "context": "reignDataObject]\n    frame_effects: List[str]\n    frame_version: str\n    hand: Optional[str]\n    has_alternative_deck_l"
 },
 "359": {
  "name": "hand",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    hand: Optional[str]\\n']",
  "context": "ame_effects: List[str]\n    frame_version: str\n    hand: Optional[str]\n    has_alternative_deck_limit: Optional[bool]\n   "
 },
 "360": {
  "name": "has_alternative_deck_limit",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    has_alternative_deck_limit: Optional[bool]\\n']",
  "context": "   frame_version: str\n    hand: Optional[str]\n    has_alternative_deck_limit: Optional[bool]\n    has_content_warning: Optional[bool]\n    has_fo"
 },
 "361": {
  "name": "has_content_warning",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['    has_content_warning: Optional[bool]\\n']",
  "context": "   has_alternative_deck_limit: Optional[bool]\n    has_content_warning: Optional[bool]\n    has_foil: Optional[bool]\n    has_non_foil: Opt"
 },
 "362": {
  "name": "has_foil",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['    has_foil: Optional[bool]\\n']",
  "context": "bool]\n    has_content_warning: Optional[bool]\n    has_foil: Optional[bool]\n    has_non_foil: Optional[bool]\n    identifiers: "
 },
 "363": {
  "name": "has_non_foil",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "46",
  "column": "4",
  "slicing": "['    has_non_foil: Optional[bool]\\n']",
  "context": ": Optional[bool]\n    has_foil: Optional[bool]\n    has_non_foil: Optional[bool]\n    identifiers: MtgjsonIdentifiersObject\n    is_a"
 },
 "364": {
  "name": "identifiers",
  "type": "classes.mtgjson_identifiers.MtgjsonIdentifiersObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['    identifiers: MtgjsonIdentifiersObject\\n']",
  "context": "tional[bool]\n    has_non_foil: Optional[bool]\n    identifiers: MtgjsonIdentifiersObject\n    is_alternative: Optional[bool]\n    is_full_art"
 },
 "365": {
  "name": "is_alternative",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "48",
  "column": "4",
  "slicing": "['    is_alternative: Optional[bool]\\n']",
  "context": "ol]\n    identifiers: MtgjsonIdentifiersObject\n    is_alternative: Optional[bool]\n    is_full_art: Optional[bool]\n    is_online_only"
 },
 "366": {
  "name": "is_full_art",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "49",
  "column": "4",
  "slicing": "['    is_full_art: Optional[bool]\\n']",
  "context": "iersObject\n    is_alternative: Optional[bool]\n    is_full_art: Optional[bool]\n    is_online_only: Optional[bool]\n    is_oversize"
 },
 "367": {
  "name": "is_online_only",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "50",
  "column": "4",
  "slicing": "['    is_online_only: Optional[bool]\\n']",
  "context": "ptional[bool]\n    is_full_art: Optional[bool]\n    is_online_only: Optional[bool]\n    is_oversized: Optional[bool]\n    is_promo: Opt"
 },
 "368": {
  "name": "is_oversized",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "51",
  "column": "4",
  "slicing": "['    is_oversized: Optional[bool]\\n']",
  "context": "onal[bool]\n    is_online_only: Optional[bool]\n    is_oversized: Optional[bool]\n    is_promo: Optional[bool]\n    is_reprint: Optio"
 },
 "369": {
  "name": "is_promo",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "52",
  "column": "4",
  "slicing": "['    is_promo: Optional[bool]\\n']",
  "context": "tional[bool]\n    is_oversized: Optional[bool]\n    is_promo: Optional[bool]\n    is_reprint: Optional[bool]\n    is_reserved: Op"
 },
 "370": {
  "name": "is_reprint",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "53",
  "column": "4",
  "slicing": "['    is_reprint: Optional[bool]\\n']",
  "context": ": Optional[bool]\n    is_promo: Optional[bool]\n    is_reprint: Optional[bool]\n    is_reserved: Optional[bool]\n    is_starter: Op"
 },
 "371": {
  "name": "is_reserved",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "54",
  "column": "4",
  "slicing": "['    is_reserved: Optional[bool]\\n']",
  "context": "Optional[bool]\n    is_reprint: Optional[bool]\n    is_reserved: Optional[bool]\n    is_starter: Optional[bool]\n    is_story_spotli"
 },
 "372": {
  "name": "is_starter",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "55",
  "column": "4",
  "slicing": "['    is_starter: Optional[bool]\\n']",
  "context": "ptional[bool]\n    is_reserved: Optional[bool]\n    is_starter: Optional[bool]\n    is_story_spotlight: Optional[bool]\n    is_text"
 },
 "373": {
  "name": "is_story_spotlight",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    is_story_spotlight: Optional[bool]\\n']",
  "context": "Optional[bool]\n    is_starter: Optional[bool]\n    is_story_spotlight: Optional[bool]\n    is_textless: Optional[bool]\n    is_timeshifted"
 },
 "374": {
  "name": "is_textless",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "57",
  "column": "4",
  "slicing": "['    is_textless: Optional[bool]\\n']",
  "context": "[bool]\n    is_story_spotlight: Optional[bool]\n    is_textless: Optional[bool]\n    is_timeshifted: Optional[bool]\n    keywords: L"
 },
 "375": {
  "name": "is_timeshifted",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "58",
  "column": "4",
  "slicing": "['    is_timeshifted: Optional[bool]\\n']",
  "context": "ptional[bool]\n    is_textless: Optional[bool]\n    is_timeshifted: Optional[bool]\n    keywords: List[str]\n    layout: str\n    leader"
 },
 "376": {
  "name": "keywords",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "59",
  "column": "4",
  "slicing": "['    keywords: List[str]\\n']",
  "context": "onal[bool]\n    is_timeshifted: Optional[bool]\n    keywords: List[str]\n    layout: str\n    leadership_skills: Optional[Mt"
 },
 "377": {
  "name": "layout",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "60",
  "column": "4",
  "slicing": "['    layout: str\\n']",
  "context": "ifted: Optional[bool]\n    keywords: List[str]\n    layout: str\n    leadership_skills: Optional[MtgjsonLeadershipS"
 },
 "378": {
  "name": "leadership_skills",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['    leadership_skills: Optional[MtgjsonLeadershipSkillsObject]\\n']",
  "context": "bool]\n    keywords: List[str]\n    layout: str\n    leadership_skills: Optional[MtgjsonLeadershipSkillsObject]\n    legalities: MtgjsonLegalitiesObject\n    life: "
 },
 "379": {
  "name": "legalities",
  "type": "classes.mtgjson_legalities.MtgjsonLegalitiesObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "62",
  "column": "4",
  "slicing": "['    legalities: MtgjsonLegalitiesObject\\n']",
  "context": "ills: Optional[MtgjsonLeadershipSkillsObject]\n    legalities: MtgjsonLegalitiesObject\n    life: Optional[str]\n    loyalty: Optional[str]"
 },
 "380": {
  "name": "life",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "63",
  "column": "4",
  "slicing": "['    life: Optional[str]\\n']",
  "context": "ject]\n    legalities: MtgjsonLegalitiesObject\n    life: Optional[str]\n    loyalty: Optional[str]\n    mana_cost: str\n    "
 },
 "381": {
  "name": "loyalty",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "64",
  "column": "4",
  "slicing": "['    loyalty: Optional[str]\\n']",
  "context": "gjsonLegalitiesObject\n    life: Optional[str]\n    loyalty: Optional[str]\n    mana_cost: str\n    name: str\n    number: str\n "
 },
 "382": {
  "name": "mana_cost",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "65",
  "column": "4",
  "slicing": "['    mana_cost: str\\n']",
  "context": "ife: Optional[str]\n    loyalty: Optional[str]\n    mana_cost: str\n    name: str\n    number: str\n    original_release"
 },
 "383": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "66",
  "column": "4",
  "slicing": "['    name: str\\n', '            self.__names.append(name)\\n', '            self.set_names([name])\\n']",
  "context": "    loyalty: Optional[str]\n    mana_cost: str\n    name: str\n    number: str\n    original_release_date: Optiona"
 },
 "384": {
  "name": "number",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['    number: str\\n']",
  "context": "ptional[str]\n    mana_cost: str\n    name: str\n    number: str\n    original_release_date: Optional[str]\n    origi"
 },
 "385": {
  "name": "original_release_date",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['    original_release_date: Optional[str]\\n']",
  "context": " mana_cost: str\n    name: str\n    number: str\n    original_release_date: Optional[str]\n    original_text: Optional[str]\n    original_type"
 },
 "386": {
  "name": "original_text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "69",
  "column": "4",
  "slicing": "['    original_text: Optional[str]\\n']",
  "context": " str\n    original_release_date: Optional[str]\n    original_text: Optional[str]\n    original_type: Optional[str]\n    other_face_id"
 },
 "387": {
  "name": "original_type",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "70",
  "column": "4",
  "slicing": "['    original_type: Optional[str]\\n']",
  "context": "ptional[str]\n    original_text: Optional[str]\n    original_type: Optional[str]\n    other_face_ids: List[str]\n    power: str\n    p"
 },
 "388": {
  "name": "other_face_ids",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "71",
  "column": "4",
  "slicing": "['    other_face_ids: List[str]\\n']",
  "context": "ptional[str]\n    original_type: Optional[str]\n    other_face_ids: List[str]\n    power: str\n    prices: MtgjsonPricesObject\n   "
 },
 "389": {
  "name": "power",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "72",
  "column": "4",
  "slicing": "['    power: str\\n']",
  "context": ": Optional[str]\n    other_face_ids: List[str]\n    power: str\n    prices: MtgjsonPricesObject\n    printings: Lis"
 },
 "390": {
  "name": "prices",
  "type": "classes.mtgjson_prices.MtgjsonPricesObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "73",
  "column": "4",
  "slicing": "['    prices: MtgjsonPricesObject\\n']",
  "context": "\n    other_face_ids: List[str]\n    power: str\n    prices: MtgjsonPricesObject\n    printings: List[str]\n    promo_types: List[str"
 },
 "391": {
  "name": "printings",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "74",
  "column": "4",
  "slicing": "['    printings: List[str]\\n']",
  "context": "   power: str\n    prices: MtgjsonPricesObject\n    printings: List[str]\n    promo_types: List[str]\n    purchase_urls: Mtgj"
 },
 "392": {
  "name": "promo_types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['    promo_types: List[str]\\n']",
  "context": " MtgjsonPricesObject\n    printings: List[str]\n    promo_types: List[str]\n    purchase_urls: MtgjsonPurchaseUrlsObject\n    r"
 },
 "393": {
  "name": "purchase_urls",
  "type": "classes.mtgjson_purchase_urls.MtgjsonPurchaseUrlsObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "76",
  "column": "4",
  "slicing": "['    purchase_urls: MtgjsonPurchaseUrlsObject\\n']",
  "context": "intings: List[str]\n    promo_types: List[str]\n    purchase_urls: MtgjsonPurchaseUrlsObject\n    rarity: str\n    reverse_related: Optional[List"
 },
 "394": {
  "name": "rarity",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "77",
  "column": "4",
  "slicing": "['    rarity: str\\n']",
  "context": "\n    purchase_urls: MtgjsonPurchaseUrlsObject\n    rarity: str\n    reverse_related: Optional[List[str]]\n    rulin"
 },
 "395": {
  "name": "reverse_related",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "78",
  "column": "4",
  "slicing": "['    reverse_related: Optional[List[str]]\\n']",
  "context": "ls: MtgjsonPurchaseUrlsObject\n    rarity: str\n    reverse_related: Optional[List[str]]\n    rulings: List[MtgjsonRulingObject]\n    side: O"
 },
 "396": {
  "name": "rulings",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "79",
  "column": "4",
  "slicing": "['    rulings: List[MtgjsonRulingObject]\\n']",
  "context": " str\n    reverse_related: Optional[List[str]]\n    rulings: List[MtgjsonRulingObject]\n    side: Optional[str]\n    subtypes: List[str]\n  "
 },
 "397": {
  "name": "side",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['    side: Optional[str]\\n']",
  "context": "[str]]\n    rulings: List[MtgjsonRulingObject]\n    side: Optional[str]\n    subtypes: List[str]\n    supertypes: List[str]\n"
 },
 "398": {
  "name": "subtypes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "81",
  "column": "4",
  "slicing": "['    subtypes: List[str]\\n']",
  "context": "[MtgjsonRulingObject]\n    side: Optional[str]\n    subtypes: List[str]\n    supertypes: List[str]\n    text: str\n    toughn"
 },
 "399": {
  "name": "supertypes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "82",
  "column": "4",
  "slicing": "['    supertypes: List[str]\\n']",
  "context": "  side: Optional[str]\n    subtypes: List[str]\n    supertypes: List[str]\n    text: str\n    toughness: str\n    type: str\n   "
 },
 "400": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "83",
  "column": "4",
  "slicing": "['    text: str\\n']",
  "context": "subtypes: List[str]\n    supertypes: List[str]\n    text: str\n    toughness: str\n    type: str\n    types: List[s"
 },
 "401": {
  "name": "toughness",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "84",
  "column": "4",
  "slicing": "['    toughness: str\\n']",
  "context": "[str]\n    supertypes: List[str]\n    text: str\n    toughness: str\n    type: str\n    types: List[str]\n    uuid: str\n "
 },
 "402": {
  "name": "type",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "85",
  "column": "4",
  "slicing": "['    type: str\\n']",
  "context": "s: List[str]\n    text: str\n    toughness: str\n    type: str\n    types: List[str]\n    uuid: str\n    variations:"
 },
 "403": {
  "name": "types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "86",
  "column": "4",
  "slicing": "['    types: List[str]\\n']",
  "context": "   text: str\n    toughness: str\n    type: str\n    types: List[str]\n    uuid: str\n    variations: List[str]\n    waterm"
 },
 "404": {
  "name": "uuid",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "87",
  "column": "4",
  "slicing": "['    uuid: str\\n']",
  "context": "hness: str\n    type: str\n    types: List[str]\n    uuid: str\n    variations: List[str]\n    watermark: Optional["
 },
 "405": {
  "name": "variations",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "88",
  "column": "4",
  "slicing": "['    variations: List[str]\\n']",
  "context": " type: str\n    types: List[str]\n    uuid: str\n    variations: List[str]\n    watermark: Optional[str]\n\n    # Outside entiti"
 },
 "406": {
  "name": "watermark",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "89",
  "column": "4",
  "slicing": "['    watermark: Optional[str]\\n', '        if not watermark:\\n', '        if watermark == \"set\":\\n', '        self.watermark = watermark\\n']",
  "context": "[str]\n    uuid: str\n    variations: List[str]\n    watermark: Optional[str]\n\n    # Outside entities, not published\n    set_cod"
 },
 "407": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "92",
  "column": "4",
  "slicing": "['    set_code: str\\n']",
  "context": "l[str]\n\n    # Outside entities, not published\n    set_code: str\n    is_token: bool\n    raw_purchase_urls: Dict[str"
 },
 "408": {
  "name": "is_token",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "93",
  "column": "4",
  "slicing": "['    is_token: bool\\n', '        self.is_token = is_token\\n']",
  "context": "ide entities, not published\n    set_code: str\n    is_token: bool\n    raw_purchase_urls: Dict[str, str]\n    __names:"
 },
 "409": {
  "name": "raw_purchase_urls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "94",
  "column": "4",
  "slicing": "['    raw_purchase_urls: Dict[str, str]\\n']",
  "context": "ublished\n    set_code: str\n    is_token: bool\n    raw_purchase_urls: Dict[str, str]\n    __names: Optional[List[str]]\n    __illustratio"
 },
 "410": {
  "name": "__names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "95",
  "column": "4",
  "slicing": "['    __names: Optional[List[str]]\\n']",
  "context": "n: bool\n    raw_purchase_urls: Dict[str, str]\n    __names: Optional[List[str]]\n    __illustration_ids: List[str]\n    __watermark_"
 },
 "411": {
  "name": "__illustration_ids",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "96",
  "column": "4",
  "slicing": "['    __illustration_ids: List[str]\\n']",
  "context": "ct[str, str]\n    __names: Optional[List[str]]\n    __illustration_ids: List[str]\n    __watermark_resource: Dict[str, List[Any]]\n\n  "
 },
 "412": {
  "name": "__watermark_resource",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "97",
  "column": "4",
  "slicing": "['    __watermark_resource: Dict[str, List[Any]]\\n']",
  "context": "[List[str]]\n    __illustration_ids: List[str]\n    __watermark_resource: Dict[str, List[Any]]\n\n    __allow_if_falsey = {\n        \"supertypes\",\n "
 },
 "413": {
  "name": "__allow_if_falsey",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "99",
  "column": "4",
  "slicing": "['    __allow_if_falsey = {\\n']",
  "context": "  __watermark_resource: Dict[str, List[Any]]\n\n    __allow_if_falsey = {\n        \"supertypes\",\n        \"types\",\n        \"su"
 },
 "414": {
  "name": "__remove_for_tokens",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "114",
  "column": "4",
  "slicing": "['    __remove_for_tokens = {\\n']",
  "context": "eign_data\",\n        \"reverse_related\",\n    }\n\n    __remove_for_tokens = {\n        \"rulings\",\n        \"rarity\",\n        \"pric"
 },
 "415": {
  "name": "__remove_for_cards",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "126",
  "column": "4",
  "slicing": "['    __remove_for_cards = {\"reverse_related\"}\\n']",
  "context": "alities\",\n        \"leadership_skills\",\n    }\n\n    __remove_for_cards = {\"reverse_related\"}\n\n    __atomic_keys = [\n        \"ascii_name\",\n     "
 },
 "416": {
  "name": "__atomic_keys",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "128",
  "column": "4",
  "slicing": "['    __atomic_keys = [\\n']",
  "context": "    __remove_for_cards = {\"reverse_related\"}\n\n    __atomic_keys = [\n        \"ascii_name\",\n        \"color_identity\",\n  "
 },
 "417": {
  "name": "is_token",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "164",
  "column": "23",
  "slicing": "['    def __init__(self, is_token: bool = False) -> None:\\n']",
  "context": "\",\n        \"types\",\n    ]\n\n    def __init__(self, is_token: bool = False) -> None:\n        \"\"\"\n        Initializer for MTGJSON Singul"
 },
 "418": {
  "name": "other",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "182",
  "column": "21",
  "slicing": "['    def __eq__(self, other: Any) -> bool:\\n']",
  "context": " MtgjsonIdentifiersObject()\n\n    def __eq__(self, other: Any) -> bool:\n        \"\"\"\n        Determine if two MTGJSON Card "
 },
 "419": {
  "name": "other",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "194",
  "column": "21",
  "slicing": "['    def __lt__(self, other: Any) -> bool:\\n']",
  "context": "other.side or \"\")\n        )\n\n    def __lt__(self, other: Any) -> bool:\n        \"\"\"\n        Less than operation\n        Fi"
 },
 "420": {
  "name": "illustration_ids",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "209",
  "column": "35",
  "slicing": "['    def set_illustration_ids(self, illustration_ids: List[str]) -> None:\\n']",
  "context": "other.number)\n\n    def set_illustration_ids(self, illustration_ids: List[str]) -> None:\n        \"\"\"\n        Set internal illustration IDs "
 },
 "421": {
  "name": "names",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "232",
  "column": "24",
  "slicing": "['    def set_names(self, names: Optional[List[str]]) -> None:\\n']",
  "context": "eturn self.__names or []\n\n    def set_names(self, names: Optional[List[str]]) -> None:\n        \"\"\"\n        Set internal names array for t"
 },
 "422": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "239",
  "column": "27",
  "slicing": "['    def append_names(self, name: str) -> None:\\n']",
  "context": ")) if names else None\n\n    def append_names(self, name: str) -> None:\n        \"\"\"\n        Append to internal names array"
 },
 "423": {
  "name": "watermark",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "249",
  "column": "28",
  "slicing": "['    def set_watermark(self, watermark: Optional[str]) -> None:\\n']",
  "context": "lf.set_names([name])\n\n    def set_watermark(self, watermark: Optional[str]) -> None:\n        \"\"\"\n        Watermarks sometimes aren't sp"
 },
 "424": {
  "name": "watermark",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_card.py",
  "lineno": "270",
  "column": "20",
  "slicing": "['    name: str\\n', '    watermark: Optional[str]\\n', '    is_token: bool\\n', '        self.is_token = is_token\\n', '            self.__names.append(name)\\n', '            self.set_names([name])\\n', '        if not watermark:\\n', '            ) as f:\\n', '                self.__watermark_resource = json.load(f)\\n', '        if watermark == \"set\":\\n', '            for card in self.__watermark_resource.get(self.set_code.upper(), []):\\n', '                if self.name in card[\"name\"].split(\" // \"):\\n', '                    watermark = str(card[\"watermark\"])\\n', '        self.watermark = watermark\\n']",
  "context": "n card[\"name\"].split(\" // \"):\n                    watermark = str(card[\"watermark\"])\n                    break\n\n        self.watermark "
 },
 "425": {
  "name": "source",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "12",
  "column": "4",
  "slicing": "['    source: str\\n', '        self.source = source\\n']",
  "context": " MTGJSON Singular Prices.Card Object\n    \"\"\"\n\n    source: str\n    provider: str\n    date: str\n    currency: str\n"
 },
 "426": {
  "name": "provider",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "13",
  "column": "4",
  "slicing": "['    provider: str\\n', '        self.provider = provider\\n']",
  "context": "r Prices.Card Object\n    \"\"\"\n\n    source: str\n    provider: str\n    date: str\n    currency: str\n    buy_normal: Op"
 },
 "427": {
  "name": "date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    date: str\\n', '        self.date = date\\n']",
  "context": "ct\n    \"\"\"\n\n    source: str\n    provider: str\n    date: str\n    currency: str\n    buy_normal: Optional[float]\n"
 },
 "428": {
  "name": "currency",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    currency: str\\n', '        self.currency = currency\\n']",
  "context": "  source: str\n    provider: str\n    date: str\n    currency: str\n    buy_normal: Optional[float]\n    buy_foil: Opti"
 },
 "429": {
  "name": "buy_normal",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    buy_normal: Optional[float]\\n']",
  "context": "provider: str\n    date: str\n    currency: str\n    buy_normal: Optional[float]\n    buy_foil: Optional[float]\n    sell_normal: Opt"
 },
 "430": {
  "name": "buy_foil",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    buy_foil: Optional[float]\\n']",
  "context": "currency: str\n    buy_normal: Optional[float]\n    buy_foil: Optional[float]\n    sell_normal: Optional[float]\n    sell_foil: Op"
 },
 "431": {
  "name": "sell_normal",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    sell_normal: Optional[float]\\n']",
  "context": "Optional[float]\n    buy_foil: Optional[float]\n    sell_normal: Optional[float]\n    sell_foil: Optional[float]\n\n    def __init__(s"
 },
 "432": {
  "name": "sell_foil",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    sell_foil: Optional[float]\\n']",
  "context": "ional[float]\n    sell_normal: Optional[float]\n    sell_foil: Optional[float]\n\n    def __init__(self, source: str, provider: str"
 },
 "433": {
  "name": "source",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "21",
  "column": "23",
  "slicing": "['    def __init__(self, source: str, provider: str, date: str, currency: str) -> None:\\n']",
  "context": "ell_foil: Optional[float]\n\n    def __init__(self, source: str, provider: str, date: str, currency: str) -> None:\n        \"\"\"\n        Initializer for Pricing Contai"
 },
 "434": {
  "name": "provider",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "21",
  "column": "36",
  "slicing": "['    def __init__(self, source: str, provider: str, date: str, currency: str) -> None:\\n']",
  "context": "ional[float]\n\n    def __init__(self, source: str, provider: str, date: str, currency: str) -> None:\n        \"\"\"\n        Initializer for Pricing Contai"
 },
 "435": {
  "name": "date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "21",
  "column": "51",
  "slicing": "['    def __init__(self, source: str, provider: str, date: str, currency: str) -> None:\\n']",
  "context": "   def __init__(self, source: str, provider: str, date: str, currency: str) -> None:\n        \"\"\"\n        Initializer for Pricing Contai"
 },
 "436": {
  "name": "currency",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "21",
  "column": "62",
  "slicing": "['    def __init__(self, source: str, provider: str, date: str, currency: str) -> None:\\n']",
  "context": "it__(self, source: str, provider: str, date: str, currency: str) -> None:\n        \"\"\"\n        Initializer for Pricing Contai"
 },
 "437": {
  "name": "buy_sell_option",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "39",
  "column": "8",
  "slicing": "['        buy_sell_option: Dict[str, Any] = {}\\n', '            buy_sell_option[\"buylist\"] = {\"normal\": {}, \"foil\": {}}\\n', '                buy_sell_option[\"buylist\"][\"normal\"][self.date] = self.buy_normal\\n', '                buy_sell_option[\"buylist\"][\"foil\"][self.date] = self.buy_foil\\n', '            buy_sell_option[\"retail\"] = {\"normal\": {}, \"foil\": {}}\\n', '                buy_sell_option[\"retail\"][\"normal\"][self.date] = self.sell_normal\\n', '                buy_sell_option[\"retail\"][\"foil\"][self.date] = self.sell_foil\\n', '        buy_sell_option[\"currency\"] = self.currency\\n', '        return_object: Dict[str, Any] = {self.source: {self.provider: buy_sell_option}}\\n', '        return return_object\\n']",
  "context": "eturn: JSON serialized object\n        \"\"\"\n        buy_sell_option: Dict[str, Any] = {}\n        if (self.buy_normal is not None) or (self."
 },
 "438": {
  "name": "return_object",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_prices.py",
  "lineno": "54",
  "column": "8",
  "slicing": "['        return_object: Dict[str, Any] = {self.source: {self.provider: buy_sell_option}}\\n', '        return return_object\\n']",
  "context": "y_sell_option[\"currency\"] = self.currency\n        return_object: Dict[str, Any] = {self.source: {self.provider: buy_sell_option}}\n\n        return return_object\n"
 },
 "439": {
  "name": "chinese_simplified",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "12",
  "column": "4",
  "slicing": "['    chinese_simplified: Optional[str]\\n']",
  "context": "\n    MTGJSON Set.Translations Object\n    \"\"\"\n\n    chinese_simplified: Optional[str]\n    chinese_traditional: Optional[str]\n    french:"
 },
 "440": {
  "name": "chinese_traditional",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "13",
  "column": "4",
  "slicing": "['    chinese_traditional: Optional[str]\\n']",
  "context": "   \"\"\"\n\n    chinese_simplified: Optional[str]\n    chinese_traditional: Optional[str]\n    french: Optional[str]\n    german: Optional[str"
 },
 "441": {
  "name": "french",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    french: Optional[str]\\n']",
  "context": "l[str]\n    chinese_traditional: Optional[str]\n    french: Optional[str]\n    german: Optional[str]\n    italian: Optional[st"
 },
 "442": {
  "name": "german",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    german: Optional[str]\\n']",
  "context": "onal: Optional[str]\n    french: Optional[str]\n    german: Optional[str]\n    italian: Optional[str]\n    japanese: Optional["
 },
 "443": {
  "name": "italian",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    italian: Optional[str]\\n']",
  "context": "ench: Optional[str]\n    german: Optional[str]\n    italian: Optional[str]\n    japanese: Optional[str]\n    korean: Optional[s"
 },
 "444": {
  "name": "japanese",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    japanese: Optional[str]\\n']",
  "context": "man: Optional[str]\n    italian: Optional[str]\n    japanese: Optional[str]\n    korean: Optional[str]\n    portuguese_ob_brazil"
 },
 "445": {
  "name": "korean",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    korean: Optional[str]\\n']",
  "context": "an: Optional[str]\n    japanese: Optional[str]\n    korean: Optional[str]\n    portuguese_ob_brazil_cb: Optional[str]\n    rus"
 },
 "446": {
  "name": "portuguese_ob_brazil_cb",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    portuguese_ob_brazil_cb: Optional[str]\\n']",
  "context": "nese: Optional[str]\n    korean: Optional[str]\n    portuguese_ob_brazil_cb: Optional[str]\n    russian: Optional[str]\n    spanish: Optional[s"
 },
 "447": {
  "name": "russian",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    russian: Optional[str]\\n']",
  "context": "r]\n    portuguese_ob_brazil_cb: Optional[str]\n    russian: Optional[str]\n    spanish: Optional[str]\n\n    def __init__(self,"
 },
 "448": {
  "name": "spanish",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    spanish: Optional[str]\\n']",
  "context": "_cb: Optional[str]\n    russian: Optional[str]\n    spanish: Optional[str]\n\n    def __init__(self, active_dict: Dict[str, str"
 },
 "449": {
  "name": "active_dict",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "23",
  "column": "23",
  "slicing": "['    def __init__(self, active_dict: Dict[str, str] = None) -> None:\\n']",
  "context": "   spanish: Optional[str]\n\n    def __init__(self, active_dict: Dict[str, str] = None) -> None:\n        \"\"\"\n        Initializer, for each language"
 },
 "450": {
  "name": "key",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_translations.py",
  "lineno": "42",
  "column": "18",
  "slicing": "['    def parse_key(key: str) -> str:\\n']",
  "context": "t(\"Spanish\")\n\n    @staticmethod\n    def parse_key(key: str) -> str:\n        \"\"\"\n        Custom parsing of translation "
 },
 "451": {
  "name": "date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_meta.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    date: str\\n', '        self.date = date if isinstance(date, str) else date.strftime(\"%Y-%m-%d\")\\n']",
  "context": "ect:\n    \"\"\"\n    MTGJSON Meta Object\n    \"\"\"\n\n    date: str\n    version: str\n\n    def __init__(\n        self,\n"
 },
 "452": {
  "name": "version",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_meta.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    version: str\\n', '        self.version = version\\n']",
  "context": "   MTGJSON Meta Object\n    \"\"\"\n\n    date: str\n    version: str\n\n    def __init__(\n        self,\n        date: Uni"
 },
 "453": {
  "name": "date",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_meta.py",
  "lineno": "21",
  "column": "8",
  "slicing": "['        date: Union[str, datetime.datetime] = MTGJSON_BUILD_DATE,\\n']",
  "context": "ion: str\n\n    def __init__(\n        self,\n        date: Union[str, datetime.datetime] = MTGJSON_BUILD_DATE,\n        version: str = MTGJSON_VERSION,\n    ) -> N"
 },
 "454": {
  "name": "version",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_meta.py",
  "lineno": "22",
  "column": "8",
  "slicing": "['        version: str = MTGJSON_VERSION,\\n']",
  "context": " datetime.datetime] = MTGJSON_BUILD_DATE,\n        version: str = MTGJSON_VERSION,\n    ) -> None:\n        self.date = date if isinsta"
 },
 "455": {
  "name": "options",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_meta.py",
  "lineno": "32",
  "column": "8",
  "slicing": "['        options = {\\n', '        for key, value in options.items():\\n', '            if isinstance(value, datetime.datetime):\\n', '                options[key] = value.strftime(\"%Y-%m-%d\")\\n', '        return options\\n']",
  "context": "eturn: JSON serialized object\n        \"\"\"\n        options = {\n            to_camel_case(key): value\n            "
 },
 "456": {
  "name": "card_kingdom_foil_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    card_kingdom_foil_id: Optional[str]\\n']",
  "context": "SON Singular Card.Identifiers Object\n    \"\"\"\n\n    card_kingdom_foil_id: Optional[str]\n    card_kingdom_id: Optional[str]\n    mcm_id: Opt"
 },
 "457": {
  "name": "card_kingdom_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    card_kingdom_id: Optional[str]\\n']",
  "context": " \"\"\"\n\n    card_kingdom_foil_id: Optional[str]\n    card_kingdom_id: Optional[str]\n    mcm_id: Optional[str]\n    mcm_meta_id: Optiona"
 },
 "458": {
  "name": "mcm_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    mcm_id: Optional[str]\\n']",
  "context": "ional[str]\n    card_kingdom_id: Optional[str]\n    mcm_id: Optional[str]\n    mcm_meta_id: Optional[str]\n    mtg_arena_id: O"
 },
 "459": {
  "name": "mcm_meta_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    mcm_meta_id: Optional[str]\\n']",
  "context": "m_id: Optional[str]\n    mcm_id: Optional[str]\n    mcm_meta_id: Optional[str]\n    mtg_arena_id: Optional[str]\n    mtgo_foil_id: "
 },
 "460": {
  "name": "mtg_arena_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    mtg_arena_id: Optional[str]\\n']",
  "context": " Optional[str]\n    mcm_meta_id: Optional[str]\n    mtg_arena_id: Optional[str]\n    mtgo_foil_id: Optional[str]\n    mtgo_id: Optio"
 },
 "461": {
  "name": "mtgo_foil_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    mtgo_foil_id: Optional[str]\\n']",
  "context": "Optional[str]\n    mtg_arena_id: Optional[str]\n    mtgo_foil_id: Optional[str]\n    mtgo_id: Optional[str]\n    multiverse_id: Opti"
 },
 "462": {
  "name": "mtgo_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    mtgo_id: Optional[str]\\n']",
  "context": "Optional[str]\n    mtgo_foil_id: Optional[str]\n    mtgo_id: Optional[str]\n    multiverse_id: Optional[str]\n    scryfall_id: "
 },
 "463": {
  "name": "multiverse_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    multiverse_id: Optional[str]\\n']",
  "context": "_id: Optional[str]\n    mtgo_id: Optional[str]\n    multiverse_id: Optional[str]\n    scryfall_id: Optional[str]\n    scryfall_illust"
 },
 "464": {
  "name": "scryfall_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    scryfall_id: Optional[str]\\n']",
  "context": "ptional[str]\n    multiverse_id: Optional[str]\n    scryfall_id: Optional[str]\n    scryfall_illustration_id: Optional[str]\n    sc"
 },
 "465": {
  "name": "scryfall_illustration_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    scryfall_illustration_id: Optional[str]\\n']",
  "context": " Optional[str]\n    scryfall_id: Optional[str]\n    scryfall_illustration_id: Optional[str]\n    scryfall_oracle_id: Optional[str]\n    tcgplaye"
 },
 "466": {
  "name": "scryfall_oracle_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    scryfall_oracle_id: Optional[str]\\n']",
  "context": "]\n    scryfall_illustration_id: Optional[str]\n    scryfall_oracle_id: Optional[str]\n    tcgplayer_product_id: Optional[str]\n    mtgjso"
 },
 "467": {
  "name": "tcgplayer_product_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    tcgplayer_product_id: Optional[str]\\n']",
  "context": "al[str]\n    scryfall_oracle_id: Optional[str]\n    tcgplayer_product_id: Optional[str]\n    mtgjson_v4_id: Optional[str]\n\n    def __init__"
 },
 "468": {
  "name": "mtgjson_v4_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_identifiers.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    mtgjson_v4_id: Optional[str]\\n']",
  "context": "[str]\n    tcgplayer_product_id: Optional[str]\n    mtgjson_v4_id: Optional[str]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "469": {
  "name": "brawl",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    brawl: str\\n']",
  "context": "JSON Singular Card.Legalities Object\n    \"\"\"\n\n    brawl: str\n    commander: str\n    duel: str\n    future: str\n "
 },
 "470": {
  "name": "commander",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    commander: str\\n']",
  "context": "ard.Legalities Object\n    \"\"\"\n\n    brawl: str\n    commander: str\n    duel: str\n    future: str\n    frontier: str\n  "
 },
 "471": {
  "name": "duel",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    duel: str\\n']",
  "context": "ct\n    \"\"\"\n\n    brawl: str\n    commander: str\n    duel: str\n    future: str\n    frontier: str\n    legacy: str\n"
 },
 "472": {
  "name": "future",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    future: str\\n']",
  "context": "  brawl: str\n    commander: str\n    duel: str\n    future: str\n    frontier: str\n    legacy: str\n    modern: str\n"
 },
 "473": {
  "name": "frontier",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    frontier: str\\n']",
  "context": " commander: str\n    duel: str\n    future: str\n    frontier: str\n    legacy: str\n    modern: str\n    pauper: str\n  "
 },
 "474": {
  "name": "legacy",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    legacy: str\\n']",
  "context": "  duel: str\n    future: str\n    frontier: str\n    legacy: str\n    modern: str\n    pauper: str\n    penny: str\n   "
 },
 "475": {
  "name": "modern",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    modern: str\\n']",
  "context": "future: str\n    frontier: str\n    legacy: str\n    modern: str\n    pauper: str\n    penny: str\n    pioneer: str\n  "
 },
 "476": {
  "name": "pauper",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    pauper: str\\n']",
  "context": "frontier: str\n    legacy: str\n    modern: str\n    pauper: str\n    penny: str\n    pioneer: str\n    standard: str\n"
 },
 "477": {
  "name": "penny",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    penny: str\\n']",
  "context": "  legacy: str\n    modern: str\n    pauper: str\n    penny: str\n    pioneer: str\n    standard: str\n    vintage: st"
 },
 "478": {
  "name": "pioneer",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    pioneer: str\\n']",
  "context": "   modern: str\n    pauper: str\n    penny: str\n    pioneer: str\n    standard: str\n    vintage: str\n\n    def to_jso"
 },
 "479": {
  "name": "standard",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    standard: str\\n']",
  "context": "  pauper: str\n    penny: str\n    pioneer: str\n    standard: str\n    vintage: str\n\n    def to_json(self) -> Dict[st"
 },
 "480": {
  "name": "vintage",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_legalities.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    vintage: str\\n']",
  "context": "penny: str\n    pioneer: str\n    standard: str\n    vintage: str\n\n    def to_json(self) -> Dict[str, Any]:\n        "
 },
 "481": {
  "name": "language",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_foreign_data.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    language: str\\n']",
  "context": "SON Singular Card.ForeignData Object\n    \"\"\"\n\n    language: str\n    multiverse_id: Optional[int]\n    face_name: Op"
 },
 "482": {
  "name": "multiverse_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_foreign_data.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    multiverse_id: Optional[int]\\n']",
  "context": "ForeignData Object\n    \"\"\"\n\n    language: str\n    multiverse_id: Optional[int]\n    face_name: Optional[str]\n    flavor_text: Opti"
 },
 "483": {
  "name": "face_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_foreign_data.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    face_name: Optional[str]\\n']",
  "context": "anguage: str\n    multiverse_id: Optional[int]\n    face_name: Optional[str]\n    flavor_text: Optional[str]\n    name: Optional["
 },
 "484": {
  "name": "flavor_text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_foreign_data.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    flavor_text: Optional[str]\\n']",
  "context": "d: Optional[int]\n    face_name: Optional[str]\n    flavor_text: Optional[str]\n    name: Optional[str]\n    text: Optional[str]\n  "
 },
 "485": {
  "name": "name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_foreign_data.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    name: Optional[str]\\n']",
  "context": " Optional[str]\n    flavor_text: Optional[str]\n    name: Optional[str]\n    text: Optional[str]\n    type: Optional[str]\n\n "
 },
 "486": {
  "name": "text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_foreign_data.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    text: Optional[str]\\n']",
  "context": "r_text: Optional[str]\n    name: Optional[str]\n    text: Optional[str]\n    type: Optional[str]\n\n    def __init__(self) ->"
 },
 "487": {
  "name": "type",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_foreign_data.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    type: Optional[str]\\n']",
  "context": "  name: Optional[str]\n    text: Optional[str]\n    type: Optional[str]\n\n    def __init__(self) -> None:\n        self.mult"
 },
 "488": {
  "name": "skip_keys",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_foreign_data.py",
  "lineno": "36",
  "column": "8",
  "slicing": "['        skip_keys = (\"url\", \"number\", \"set_code\")\\n', '            and key not in skip_keys\\n']",
  "context": "eturn: JSON serialized object\n        \"\"\"\n        skip_keys = (\"url\", \"number\", \"set_code\")\n\n        return {\n            to_camel_case(key): "
 },
 "489": {
  "name": "code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    code: str\\n']",
  "context": "\"\"\"\n    MTGJSON Singular Card Object\n    \"\"\"\n\n    code: str\n    commander: List[Dict[str, Any]]  # MtgjsonCard"
 },
 "490": {
  "name": "commander",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    commander: List[Dict[str, Any]]  # MtgjsonCardObject\\n']",
  "context": "N Singular Card Object\n    \"\"\"\n\n    code: str\n    commander: List[Dict[str, Any]]  # MtgjsonCardObject\n    main_board: List[Dict[str, Any]]  # MtgjsonCar"
 },
 "491": {
  "name": "main_board",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    main_board: List[Dict[str, Any]]  # MtgjsonCardObject\\n']",
  "context": "er: List[Dict[str, Any]]  # MtgjsonCardObject\n    main_board: List[Dict[str, Any]]  # MtgjsonCardObject\n    name: str\n    side_board: List[Dict[str, Any]]"
 },
 "492": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    name: str\\n', '        word_characters_only_regex = re.compile(r\"[^\\\\w]\")\\n', '        capital_case = \"\".join(x for x in name.title() if not x.isspace())\\n', '        deck_name_sanitized = word_characters_only_regex.sub(\"\", capital_case)\\n', '        self.file_name = f\"{deck_name_sanitized}_{self.code}\"\\n']",
  "context": "rd: List[Dict[str, Any]]  # MtgjsonCardObject\n    name: str\n    side_board: List[Dict[str, Any]]  # MtgjsonCar"
 },
 "493": {
  "name": "side_board",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    side_board: List[Dict[str, Any]]  # MtgjsonCardObject\\n']",
  "context": "str, Any]]  # MtgjsonCardObject\n    name: str\n    side_board: List[Dict[str, Any]]  # MtgjsonCardObject\n    release_date: str\n    type: str\n    file_name:"
 },
 "494": {
  "name": "release_date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    release_date: str\\n']",
  "context": "rd: List[Dict[str, Any]]  # MtgjsonCardObject\n    release_date: str\n    type: str\n    file_name: str\n\n    def set_sani"
 },
 "495": {
  "name": "type",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    type: str\\n']",
  "context": "]]  # MtgjsonCardObject\n    release_date: str\n    type: str\n    file_name: str\n\n    def set_sanitized_name(sel"
 },
 "496": {
  "name": "file_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    file_name: str\\n']",
  "context": "ardObject\n    release_date: str\n    type: str\n    file_name: str\n\n    def set_sanitized_name(self, name: str) -> No"
 },
 "497": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "24",
  "column": "33",
  "slicing": "['    def set_sanitized_name(self, name: str) -> None:\\n']",
  "context": " file_name: str\n\n    def set_sanitized_name(self, name: str) -> None:\n        \"\"\"\n        Turn an unsanitary file name t"
 },
 "498": {
  "name": "skip_keys",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck.py",
  "lineno": "41",
  "column": "8",
  "slicing": "['        skip_keys = {\"file_name\"}\\n', '            if \"__\" not in key and not callable(value) and key not in skip_keys\\n']",
  "context": "eturn: JSON serialized object\n        \"\"\"\n        skip_keys = {\"file_name\"}\n\n        return {\n            to_camel_case(key): "
 },
 "499": {
  "name": "base_set_size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    base_set_size: int\\n']",
  "context": " \"\"\"\n    MTGJSON Singular Set Object\n    \"\"\"\n\n    base_set_size: int\n    block: str\n    booster: Optional[Dict[str, Any"
 },
 "500": {
  "name": "block",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    block: str\\n']",
  "context": "ar Set Object\n    \"\"\"\n\n    base_set_size: int\n    block: str\n    booster: Optional[Dict[str, Any]]\n    cards: L"
 },
 "501": {
  "name": "booster",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    booster: Optional[Dict[str, Any]]\\n']",
  "context": "   \"\"\"\n\n    base_set_size: int\n    block: str\n    booster: Optional[Dict[str, Any]]\n    cards: List[MtgjsonCardObject]\n    code: str\n "
 },
 "502": {
  "name": "cards",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    cards: List[MtgjsonCardObject]\\n']",
  "context": "ck: str\n    booster: Optional[Dict[str, Any]]\n    cards: List[MtgjsonCardObject]\n    code: str\n    code_v3: str\n    is_foreign_only"
 },
 "503": {
  "name": "code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    code: str\\n']",
  "context": "str, Any]]\n    cards: List[MtgjsonCardObject]\n    code: str\n    code_v3: str\n    is_foreign_only: bool\n    is_"
 },
 "504": {
  "name": "code_v3",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    code_v3: str\\n']",
  "context": " cards: List[MtgjsonCardObject]\n    code: str\n    code_v3: str\n    is_foreign_only: bool\n    is_foil_only: bool\n "
 },
 "505": {
  "name": "is_foreign_only",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    is_foreign_only: bool\\n']",
  "context": "sonCardObject]\n    code: str\n    code_v3: str\n    is_foreign_only: bool\n    is_foil_only: bool\n    is_non_foil_only: bool\n"
 },
 "506": {
  "name": "is_foil_only",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    is_foil_only: bool\\n']",
  "context": "tr\n    code_v3: str\n    is_foreign_only: bool\n    is_foil_only: bool\n    is_non_foil_only: bool\n    is_online_only: boo"
 },
 "507": {
  "name": "is_non_foil_only",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    is_non_foil_only: bool\\n']",
  "context": " is_foreign_only: bool\n    is_foil_only: bool\n    is_non_foil_only: bool\n    is_online_only: bool\n    is_partial_preview: b"
 },
 "508": {
  "name": "is_online_only",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    is_online_only: bool\\n']",
  "context": "is_foil_only: bool\n    is_non_foil_only: bool\n    is_online_only: bool\n    is_partial_preview: bool\n    keyrune_code: str"
 },
 "509": {
  "name": "is_partial_preview",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    is_partial_preview: bool\\n']",
  "context": "_non_foil_only: bool\n    is_online_only: bool\n    is_partial_preview: bool\n    keyrune_code: str\n    mcm_id: Optional[int]\n  "
 },
 "510": {
  "name": "keyrune_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    keyrune_code: str\\n']",
  "context": "nline_only: bool\n    is_partial_preview: bool\n    keyrune_code: str\n    mcm_id: Optional[int]\n    mcm_id_extras: Optio"
 },
 "511": {
  "name": "mcm_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    mcm_id: Optional[int]\\n']",
  "context": "s_partial_preview: bool\n    keyrune_code: str\n    mcm_id: Optional[int]\n    mcm_id_extras: Optional[int]\n    mcm_name: Opt"
 },
 "512": {
  "name": "mcm_id_extras",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    mcm_id_extras: Optional[int]\\n']",
  "context": "  keyrune_code: str\n    mcm_id: Optional[int]\n    mcm_id_extras: Optional[int]\n    mcm_name: Optional[str]\n    mtgo_code: str\n   "
 },
 "513": {
  "name": "mcm_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    mcm_name: Optional[str]\\n']",
  "context": "ptional[int]\n    mcm_id_extras: Optional[int]\n    mcm_name: Optional[str]\n    mtgo_code: str\n    name: str\n    parent_code: "
 },
 "514": {
  "name": "mtgo_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "31",
  "column": "4",
  "slicing": "['    mtgo_code: str\\n']",
  "context": "as: Optional[int]\n    mcm_name: Optional[str]\n    mtgo_code: str\n    name: str\n    parent_code: str\n    release_dat"
 },
 "515": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    name: str\\n']",
  "context": "   mcm_name: Optional[str]\n    mtgo_code: str\n    name: str\n    parent_code: str\n    release_date: str\n    tcg"
 },
 "516": {
  "name": "parent_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    parent_code: str\\n']",
  "context": "ptional[str]\n    mtgo_code: str\n    name: str\n    parent_code: str\n    release_date: str\n    tcgplayer_group_id: Opti"
 },
 "517": {
  "name": "release_date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "34",
  "column": "4",
  "slicing": "['    release_date: str\\n']",
  "context": "_code: str\n    name: str\n    parent_code: str\n    release_date: str\n    tcgplayer_group_id: Optional[int]\n    tokens: "
 },
 "518": {
  "name": "tcgplayer_group_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['    tcgplayer_group_id: Optional[int]\\n']",
  "context": "tr\n    parent_code: str\n    release_date: str\n    tcgplayer_group_id: Optional[int]\n    tokens: List[MtgjsonCardObject]\n    total_set_"
 },
 "519": {
  "name": "tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['    tokens: List[MtgjsonCardObject]\\n']",
  "context": "te: str\n    tcgplayer_group_id: Optional[int]\n    tokens: List[MtgjsonCardObject]\n    total_set_size: int\n    translations: MtgjsonT"
 },
 "520": {
  "name": "total_set_size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    total_set_size: int\\n']",
  "context": "onal[int]\n    tokens: List[MtgjsonCardObject]\n    total_set_size: int\n    translations: MtgjsonTranslationsObject\n    ty"
 },
 "521": {
  "name": "translations",
  "type": "classes.mtgjson_translations.MtgjsonTranslationsObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['    translations: MtgjsonTranslationsObject\\n']",
  "context": "st[MtgjsonCardObject]\n    total_set_size: int\n    translations: MtgjsonTranslationsObject\n    type: str\n\n    extra_tokens: List[Dict[str, An"
 },
 "522": {
  "name": "type",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "39",
  "column": "4",
  "slicing": "['    type: str\\n']",
  "context": "t\n    translations: MtgjsonTranslationsObject\n    type: str\n\n    extra_tokens: List[Dict[str, Any]]\n    search"
 },
 "523": {
  "name": "extra_tokens",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "41",
  "column": "4",
  "slicing": "['    extra_tokens: List[Dict[str, Any]]\\n']",
  "context": "ons: MtgjsonTranslationsObject\n    type: str\n\n    extra_tokens: List[Dict[str, Any]]\n    search_uri: str\n\n    __allow_if_falsey = {\n   "
 },
 "524": {
  "name": "search_uri",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['    search_uri: str\\n']",
  "context": ": str\n\n    extra_tokens: List[Dict[str, Any]]\n    search_uri: str\n\n    __allow_if_falsey = {\n        \"cards\",\n      "
 },
 "525": {
  "name": "__allow_if_falsey",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['    __allow_if_falsey = {\\n']",
  "context": "ns: List[Dict[str, Any]]\n    search_uri: str\n\n    __allow_if_falsey = {\n        \"cards\",\n        \"tokens\",\n        \"is_foi"
 },
 "526": {
  "name": "excluded_keys",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "73",
  "column": "8",
  "slicing": "['        excluded_keys: Set[str] = {\\n', '                    excluded_keys.add(key)\\n', '        return excluded_keys\\n']",
  "context": "return What keys to skip over\n        \"\"\"\n        excluded_keys: Set[str] = {\n            \"added_scryfall_tokens\",\n            \""
 },
 "527": {
  "name": "skip_keys",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_set.py",
  "lineno": "91",
  "column": "8",
  "slicing": "['        excluded_keys: Set[str] = {\\n', '        for key, value in self.__dict__.items():\\n', '            if not value:\\n', '                if key not in self.__allow_if_falsey:\\n', '                    excluded_keys.add(key)\\n', '        return excluded_keys\\n', '        skip_keys = self.build_keys_to_skip()\\n', '            to_camel_case(key): value\\n', '            if \"__\" not in key and not callable(value) and key not in skip_keys\\n']",
  "context": "eturn: JSON serialized object\n        \"\"\"\n        skip_keys = self.build_keys_to_skip()\n\n        return {\n            to_camel_case(key): "
 },
 "528": {
  "name": "paper",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_game_formats.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    paper: bool\\n']",
  "context": "SON Singular Card.GameFormats Object\n    \"\"\"\n\n    paper: bool\n    mtgo: bool\n    arena: bool\n    shandalar: bool"
 },
 "529": {
  "name": "mtgo",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_game_formats.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    mtgo: bool\\n']",
  "context": "d.GameFormats Object\n    \"\"\"\n\n    paper: bool\n    mtgo: bool\n    arena: bool\n    shandalar: bool\n    dreamcast:"
 },
 "530": {
  "name": "arena",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_game_formats.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    arena: bool\\n']",
  "context": "bject\n    \"\"\"\n\n    paper: bool\n    mtgo: bool\n    arena: bool\n    shandalar: bool\n    dreamcast: bool\n\n    def _"
 },
 "531": {
  "name": "shandalar",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_game_formats.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    shandalar: bool\\n']",
  "context": "   paper: bool\n    mtgo: bool\n    arena: bool\n    shandalar: bool\n    dreamcast: bool\n\n    def __init__(self) -> Non"
 },
 "532": {
  "name": "dreamcast",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_game_formats.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    dreamcast: bool\\n']",
  "context": "tgo: bool\n    arena: bool\n    shandalar: bool\n    dreamcast: bool\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "533": {
  "name": "code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck_header.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    code: str\\n']",
  "context": " MTGJSON Singular Deck Header Object\n    \"\"\"\n\n    code: str\n    file_name: str\n    name: str\n    release_date:"
 },
 "534": {
  "name": "file_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck_header.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    file_name: str\\n']",
  "context": "lar Deck Header Object\n    \"\"\"\n\n    code: str\n    file_name: str\n    name: str\n    release_date: str\n    type: str\n"
 },
 "535": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck_header.py",
  "lineno": "17",
  "column": "4",
  "slicing": "['    name: str\\n']",
  "context": "ect\n    \"\"\"\n\n    code: str\n    file_name: str\n    name: str\n    release_date: str\n    type: str\n\n    def __ini"
 },
 "536": {
  "name": "release_date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck_header.py",
  "lineno": "18",
  "column": "4",
  "slicing": "['    release_date: str\\n']",
  "context": "   code: str\n    file_name: str\n    name: str\n    release_date: str\n    type: str\n\n    def __init__(self, output_deck:"
 },
 "537": {
  "name": "type",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck_header.py",
  "lineno": "19",
  "column": "4",
  "slicing": "['    type: str\\n']",
  "context": "name: str\n    name: str\n    release_date: str\n    type: str\n\n    def __init__(self, output_deck: MtgjsonDeckOb"
 },
 "538": {
  "name": "output_deck",
  "type": "classes.mtgjson_deck.MtgjsonDeckObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_deck_header.py",
  "lineno": "21",
  "column": "23",
  "slicing": "['    def __init__(self, output_deck: MtgjsonDeckObject) -> None:\\n']",
  "context": "e_date: str\n    type: str\n\n    def __init__(self, output_deck: MtgjsonDeckObject) -> None:\n        \"\"\"\n        Initialize the header given a "
 },
 "539": {
  "name": "brawl",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_leadership_skills.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    brawl: bool\\n', '        self.brawl = brawl\\n']",
  "context": "ingular Card.LeadershipSkills Object\n    \"\"\"\n\n    brawl: bool\n    commander: bool\n    oathbreaker: bool\n\n    def"
 },
 "540": {
  "name": "commander",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_leadership_skills.py",
  "lineno": "15",
  "column": "4",
  "slicing": "['    commander: bool\\n', '        self.commander = commander\\n']",
  "context": "dershipSkills Object\n    \"\"\"\n\n    brawl: bool\n    commander: bool\n    oathbreaker: bool\n\n    def __init__(self, braw"
 },
 "541": {
  "name": "oathbreaker",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_leadership_skills.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    oathbreaker: bool\\n', '        self.oathbreaker = oathbreaker\\n']",
  "context": "\n    \"\"\"\n\n    brawl: bool\n    commander: bool\n    oathbreaker: bool\n\n    def __init__(self, brawl: bool, commander: bo"
 },
 "542": {
  "name": "brawl",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_leadership_skills.py",
  "lineno": "18",
  "column": "23",
  "slicing": "['    def __init__(self, brawl: bool, commander: bool, oathbreaker: bool) -> None:\\n']",
  "context": "ool\n    oathbreaker: bool\n\n    def __init__(self, brawl: bool, commander: bool, oathbreaker: bool) -> None:\n        self.brawl = brawl\n        self.commander "
 },
 "543": {
  "name": "commander",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_leadership_skills.py",
  "lineno": "18",
  "column": "36",
  "slicing": "['    def __init__(self, brawl: bool, commander: bool, oathbreaker: bool) -> None:\\n']",
  "context": "reaker: bool\n\n    def __init__(self, brawl: bool, commander: bool, oathbreaker: bool) -> None:\n        self.brawl = brawl\n        self.commander "
 },
 "544": {
  "name": "oathbreaker",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/classes/mtgjson_leadership_skills.py",
  "lineno": "18",
  "column": "53",
  "slicing": "['    def __init__(self, brawl: bool, commander: bool, oathbreaker: bool) -> None:\\n']",
  "context": " def __init__(self, brawl: bool, commander: bool, oathbreaker: bool) -> None:\n        self.brawl = brawl\n        self.commander "
 },
 "545": {
  "name": "api_version",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "66",
  "column": "4",
  "slicing": "['    api_version: str = \"\"\\n']",
  "context": "er):\n    \"\"\"\n    TCGPlayer container\n    \"\"\"\n\n    api_version: str = \"\"\n    tcg_to_mtgjson_map: Dict[str, str]\n    __keys_"
 },
 "546": {
  "name": "tcg_to_mtgjson_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "67",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": " container\n    \"\"\"\n\n    api_version: str = \"\"\n    tcg_to_mtgjson_map: Dict[str, str]\n    __keys_found: bool\n\n    def __init__(self) -> "
 },
 "547": {
  "name": "__keys_found",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "68",
  "column": "4",
  "slicing": "['    __keys_found: bool\\n']",
  "context": "r = \"\"\n    tcg_to_mtgjson_map: Dict[str, str]\n    __keys_found: bool\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "548": {
  "name": "headers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "81",
  "column": "8",
  "slicing": "['        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n']",
  "context": ":return: Authorization header\n        \"\"\"\n        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\n        return headers\n\n    def _request_tcgplayer"
 },
 "549": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "125",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": ".get(\"access_token\", \"\"))\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from Scryfall"
 },
 "550": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "125",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "ss_token\", \"\"))\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from Scryfall"
 },
 "551": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "132",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "ams: Options for URL download\n        \"\"\"\n        session = retryable_session()\n        session.headers.update(self.session_header"
 },
 "552": {
  "name": "magic_set_ids",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "145",
  "column": "8",
  "slicing": "['        magic_set_ids = []\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '        return magic_set_ids\\n']",
  "context": " List of TCGPlayer Magic sets\n        \"\"\"\n        magic_set_ids = []\n        api_offset = 0\n\n        while True:\n      "
 },
 "553": {
  "name": "api_offset",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "166",
  "column": "12",
  "slicing": "['            api_offset += len(response[\"results\"])\\n', '                \"offset\": str(api_offset),\\n']",
  "context": "_set[\"groupId\"], magic_set[\"name\"]))\n\n            api_offset += len(response[\"results\"])\n\n        return magic_set_ids\n\n    def generate_to"
 },
 "554": {
  "name": "ids_and_names",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "182",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "Player, skipping\")\n            return {}\n\n        ids_and_names = self.get_tcgplayer_magic_set_ids()\n        tcg_to_mtgjson_map = generate_card_mapping"
 },
 "555": {
  "name": "tcg_to_mtgjson_map",
  "type": "utils.generate_card_mapping",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "183",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "ames = self.get_tcgplayer_magic_set_ids()\n        tcg_to_mtgjson_map = generate_card_mapping(\n            all_printings_path, (\"identifiers\", \"t"
 },
 "556": {
  "name": "buylist_dict",
  "type": "utils.parallel_call",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "188",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "R.info(\"Building TCGPlayer buylist data\")\n        buylist_dict = parallel_call(\n            get_tcgplayer_buylist_prices_map,\n    "
 },
 "557": {
  "name": "retail_dict",
  "type": "utils.parallel_call",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "196",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "fo(\"Building TCGPlayer retail list data\")\n        retail_dict = parallel_call(\n            get_tcgplayer_prices_map,\n            "
 },
 "558": {
  "name": "group_id_and_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "217",
  "column": "27",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "t(combined_listings)\n\n\ndef get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\n    \"\"\"\n    Finds all sku data for a given group u"
 },
 "559": {
  "name": "magic_set_product_data",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "223",
  "column": "4",
  "slicing": "['    magic_set_product_data = []\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '    return magic_set_product_data\\n']",
  "context": "ding skus to be parsed into a sku map\n    \"\"\"\n    magic_set_product_data = []\n    api_offset = 0\n\n    while True:\n        api_re"
 },
 "560": {
  "name": "api_offset",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "248",
  "column": "8",
  "slicing": "['        api_offset += len(response[\"results\"])\\n']",
  "context": "_product_data.extend(response[\"results\"])\n        api_offset += len(response[\"results\"])\n\n    return magic_set_product_data\n\n\ndef get_tcgpl"
 },
 "561": {
  "name": "tcgplayer_set_sku_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "254",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "set_product_data\n\n\ndef get_tcgplayer_sku_map(\n    tcgplayer_set_sku_data: List[Dict[str, Any]],\n) -> Dict[str, Dict[str, Optional[int]]]:\n    \"\"\"\n"
 },
 "562": {
  "name": "tcgplayer_sku_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "261",
  "column": "4",
  "slicing": "['    tcgplayer_sku_map = {}\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n']",
  "context": "CGPlayerID -> NM Foil and Nonfoil SKU\n    \"\"\"\n    tcgplayer_sku_map = {}\n\n    for product_data in tcgplayer_set_sku_data:\n "
 },
 "563": {
  "name": "map_entry",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "264",
  "column": "8",
  "slicing": "['        map_entry = {}\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n']",
  "context": "r product_data in tcgplayer_set_sku_data:\n        map_entry = {}\n\n        for sku in product_data[\"skus\"]:\n        "
 },
 "564": {
  "name": "product_id",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "280",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "TCGPlayer unidentified printing: {sku}\")\n\n        product_id = str(product_data[\"productId\"])\n        tcgplayer_sku_map[product_id] = map_entry\n"
 },
 "565": {
  "name": "group_id_and_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "287",
  "column": "4",
  "slicing": "['    group_id_and_name: Tuple[str, str], tcg_to_mtgjson_map: Dict[str, str]\\n']",
  "context": "u_map\n\n\ndef get_tcgplayer_buylist_prices_map(\n    group_id_and_name: Tuple[str, str], tcg_to_mtgjson_map: Dict[str, str]\n) -> Dict[str, MtgjsonPricesObject]:\n    \"\"\"\n    t"
 },
 "566": {
  "name": "tcg_to_mtgjson_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "287",
  "column": "40",
  "slicing": "['    group_id_and_name: Tuple[str, str], tcg_to_mtgjson_map: Dict[str, str]\\n']",
  "context": "ices_map(\n    group_id_and_name: Tuple[str, str], tcg_to_mtgjson_map: Dict[str, str]\n) -> Dict[str, MtgjsonPricesObject]:\n    \"\"\"\n    t"
 },
 "567": {
  "name": "prices_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "307",
  "column": "4",
  "slicing": "['    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n']",
  "context": "f not response[\"results\"]:\n        return {}\n\n    prices_map: Dict[str, MtgjsonPricesObject] = {}\n\n    tcgplayer_sku_data = get_tcgplayer_sku_data(g"
 },
 "568": {
  "name": "tcgplayer_sku_data",
  "type": "providers.tcgplayer.get_tcgplayer_sku_data",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "309",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "ces_map: Dict[str, MtgjsonPricesObject] = {}\n\n    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\n    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_"
 },
 "569": {
  "name": "sku_map",
  "type": "get_tcgplayer_sku_map",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "310",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "a = get_tcgplayer_sku_data(group_id_and_name)\n    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\n\n    for buylist_data in response[\"results\"]:\n    "
 },
 "570": {
  "name": "product_id",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "313",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": " for buylist_data in response[\"results\"]:\n        product_id = str(buylist_data[\"productId\"])\n        key = tcg_to_mtgjson_map.get(product_id)\n "
 },
 "571": {
  "name": "product_sku",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "332",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": ".today_date, \"USD\"\n                )\n\n            product_sku = sku[\"skuId\"]\n\n            if sku_map[product_id].get(\"nonfoil_s"
 },
 "572": {
  "name": "group_id_and_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "343",
  "column": "4",
  "slicing": "['    group_id_and_name: Tuple[str, str], tcg_to_mtgjson_map: Dict[str, str]\\n']",
  "context": "rn prices_map\n\n\ndef get_tcgplayer_prices_map(\n    group_id_and_name: Tuple[str, str], tcg_to_mtgjson_map: Dict[str, str]\n) -> Dict[str, MtgjsonPricesObject]:\n    \"\"\"\n    C"
 },
 "573": {
  "name": "tcg_to_mtgjson_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "343",
  "column": "40",
  "slicing": "['    group_id_and_name: Tuple[str, str], tcg_to_mtgjson_map: Dict[str, str]\\n']",
  "context": "ices_map(\n    group_id_and_name: Tuple[str, str], tcg_to_mtgjson_map: Dict[str, str]\n) -> Dict[str, MtgjsonPricesObject]:\n    \"\"\"\n    C"
 },
 "574": {
  "name": "prices_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "362",
  "column": "4",
  "slicing": "['    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n']",
  "context": "f not response[\"results\"]:\n        return {}\n\n    prices_map: Dict[str, MtgjsonPricesObject] = {}\n    for tcgplayer_object in response[\"results\"]:\n "
 },
 "575": {
  "name": "is_non_foil",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "368",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "        if not key:\n            continue\n\n        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\n        card_price = tcgplayer_object[\"marketPrice"
 },
 "576": {
  "name": "card_price",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "369",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    tcg_to_mtgjson_map: Dict[str, str]\\n', '        headers = {\"Authorization\": f\"Bearer {self._request_tcgplayer_bearer()}\"}\\n', '        return headers\\n', '        config = self.get_configs()\\n', '        if \"TCGPlayer\" not in config.sections():\\n', '            LOGGER.warning(\"TCGPlayer section not established. Skipping requests\")\\n', '            config.get(\"TCGPlayer\", \"client_id\")\\n', '            and config.get(\"TCGPlayer\", \"client_secret\")\\n', '            LOGGER.warning(\"TCGPlayer keys not established. Skipping requests\")\\n', '        tcg_post = requests.post(\\n', '                \"client_id\": config.get(\"TCGPlayer\", \"client_id\"),\\n', '                \"client_secret\": config.get(\"TCGPlayer\", \"client_secret\"),\\n', '        if not tcg_post.ok:\\n', '            LOGGER.error(f\"Unable to contact TCGPlayer. Reason: {tcg_post.reason}\")\\n', '        self.api_version = config.get(\"TCGPlayer\", \"api_version\")\\n', '        request_as_json = json.loads(tcg_post.text)\\n', '        return str(request_as_json.get(\"access_token\", \"\"))\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        magic_set_ids = []\\n', '        api_offset = 0\\n', '            api_response = self.download(\\n', '                {\"offset\": str(api_offset)},\\n', '            if not api_response:\\n', '            response = json.loads(api_response)\\n', '            if not response[\"results\"]:\\n', '            for magic_set in response[\"results\"]:\\n', '                magic_set_ids.append((magic_set[\"groupId\"], magic_set[\"name\"]))\\n', '            api_offset += len(response[\"results\"])\\n', '        return magic_set_ids\\n', '            LOGGER.warning(\"Keys not found for TCGPlayer, skipping\")\\n', '        ids_and_names = self.get_tcgplayer_magic_set_ids()\\n', '        tcg_to_mtgjson_map = generate_card_mapping(\\n', '        LOGGER.info(\"Building TCGPlayer buylist data\")\\n', '        buylist_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        LOGGER.info(\"Building TCGPlayer retail list data\")\\n', '        retail_dict = parallel_call(\\n', '            ids_and_names,\\n', '            repeatable_args=[tcg_to_mtgjson_map],\\n', '        combined_listings = buylist_dict.copy()\\n', '        for key, value in combined_listings.items():\\n', '            if key in retail_dict:\\n', '                combined_listings[key].sell_normal = retail_dict[key].sell_normal\\n', '                combined_listings[key].sell_foil = retail_dict[key].sell_foil\\n', '        for key, value in retail_dict.items():\\n', '            if key not in combined_listings:\\n', '                combined_listings[key] = value\\n', '        return dict(combined_listings)\\n', 'def get_tcgplayer_sku_data(group_id_and_name: Tuple[str, str]) -> List[Dict[str, Any]]:\\n', '    magic_set_product_data = []\\n', '    api_offset = 0\\n', '        api_response = TCGPlayerProvider().download(\\n', '                \"offset\": str(api_offset),\\n', '        if not api_response:\\n', '        response = json.loads(api_response)\\n', '        if not response[\"results\"]:\\n', '        magic_set_product_data.extend(response[\"results\"])\\n', '        api_offset += len(response[\"results\"])\\n', '    return magic_set_product_data\\n', '    tcgplayer_set_sku_data: List[Dict[str, Any]],\\n', '    tcgplayer_sku_map = {}\\n', '    for product_data in tcgplayer_set_sku_data:\\n', '        map_entry = {}\\n', '        for sku in product_data[\"skus\"]:\\n', '            if CardCondition(sku[\"conditionId\"]) is not CardCondition.NEAR_MINT:\\n', '            if CardLanguage(sku[\"languageId\"]) is not CardLanguage.ENGLISH:\\n', '            if CardPrinting(sku[\"printingId\"]) is CardPrinting.NON_FOIL:\\n', '                map_entry[\"nonfoil_sku\"] = sku[\"skuId\"]\\n', '            elif CardPrinting(sku[\"printingId\"]) is CardPrinting.FOIL:\\n', '                map_entry[\"foil_sku\"] = sku[\"skuId\"]\\n', '                LOGGER.warning(f\"TCGPlayer unidentified printing: {sku}\")\\n', '        product_id = str(product_data[\"productId\"])\\n', '        tcgplayer_sku_map[product_id] = map_entry\\n', '    return tcgplayer_sku_map\\n', '    LOGGER.debug(f\"Tcgplayer Building buylist data for {group_id_and_name[1]}\")\\n', '    api_response = TCGPlayerProvider().download(\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    tcgplayer_sku_data = get_tcgplayer_sku_data(group_id_and_name)\\n', '    sku_map = get_tcgplayer_sku_map(tcgplayer_sku_data)\\n', '    for buylist_data in response[\"results\"]:\\n', '        product_id = str(buylist_data[\"productId\"])\\n', '        key = tcg_to_mtgjson_map.get(product_id)\\n', '        if not key:\\n', '        for sku in buylist_data[\"skus\"]:\\n', '            if not sku[\"prices\"][\"high\"]:\\n', '            if not sku_map.get(product_id):\\n', '                LOGGER.debug(f\"TCGPlayer ProductId {product_id} not found\")\\n', '            if key not in prices_map.keys():\\n', '                prices_map[key] = MtgjsonPricesObject(\\n', '            product_sku = sku[\"skuId\"]\\n', '            if sku_map[product_id].get(\"nonfoil_sku\") == product_sku:\\n', '                prices_map[key].buy_normal = sku[\"prices\"][\"high\"]\\n', '            elif sku_map[product_id].get(\"foil_sku\") == product_sku:\\n', '                prices_map[key].buy_foil = sku[\"prices\"][\"high\"]\\n', '    return prices_map\\n', '    api_response = TCGPlayerProvider().download(\\n', '        f\"https://api.tcgplayer.com/[API_VERSION]/pricing/group/{group_id_and_name[0]}\"\\n', '    if not api_response:\\n', '    response = json.loads(api_response)\\n', '    if not response[\"results\"]:\\n', '    prices_map: Dict[str, MtgjsonPricesObject] = {}\\n', '    for tcgplayer_object in response[\"results\"]:\\n', '        key = tcg_to_mtgjson_map.get(str(tcgplayer_object[\"productId\"]))\\n', '        if not key:\\n', '        is_non_foil = tcgplayer_object[\"subTypeName\"] == \"Normal\"\\n', '        card_price = tcgplayer_object[\"marketPrice\"]\\n', '        if key not in prices_map.keys():\\n', '            prices_map[key] = MtgjsonPricesObject(\\n', '        if is_non_foil:\\n', '            prices_map[key].sell_normal = card_price\\n', '            prices_map[key].sell_foil = card_price\\n', '    return prices_map\\n', '        \"skuId\": sku[\"skuId\"],\\n', '        \"productId\": sku[\"productId\"],\\n', '        \"language\": CardLanguage(sku[\"languageId\"]).name.replace(\"_\", \" \"),\\n', '        \"printing\": CardPrinting(sku[\"printingId\"]).name.replace(\"_\", \" \"),\\n', '        \"condition\": CardCondition(sku[\"conditionId\"]).name.replace(\"_\", \" \"),\\n']",
  "context": "gplayer_object[\"subTypeName\"] == \"Normal\"\n        card_price = tcgplayer_object[\"marketPrice\"]\n\n        if key not in prices_map.keys():\n        "
 },
 "577": {
  "name": "sku",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/tcgplayer.py",
  "lineno": "384",
  "column": "26",
  "slicing": "['def convert_sku_data_enum(sku: Dict[str, int]) -> Dict[str, Union[int, str]]:\\n']",
  "context": "    return prices_map\n\n\ndef convert_sku_data_enum(sku: Dict[str, int]) -> Dict[str, Union[int, str]]:\n    \"\"\"\n    Converts a TCGPlayer SKU from IDs to c"
 },
 "578": {
  "name": "api_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/mtgban.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    api_url: str = \"https://www.mtgban.com/api/mtgjson/ck.json?sig={}\"\\n']",
  "context": "vider):\n    \"\"\"\n    MTGBan container\n    \"\"\"\n\n    api_url: str = \"https://www.mtgban.com/api/mtgjson/ck.json?sig={}\"\n    __mtgjson_to_card_kingdom: Dict[str, Dict[str,"
 },
 "579": {
  "name": "__mtgjson_to_card_kingdom",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/mtgban.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    __mtgjson_to_card_kingdom: Dict[str, Dict[str, Dict[str, str]]]\\n']",
  "context": "://www.mtgban.com/api/mtgjson/ck.json?sig={}\"\n    __mtgjson_to_card_kingdom: Dict[str, Dict[str, Dict[str, str]]]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "580": {
  "name": "headers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/mtgban.py",
  "lineno": "36",
  "column": "8",
  "slicing": "['        headers: Dict[str, str] = {}\\n', '            return headers\\n', '        return headers\\n']",
  "context": ":return: Authorization header\n        \"\"\"\n        headers: Dict[str, str] = {}\n        __keys_found: bool\n\n        config = self."
 },
 "581": {
  "name": "__keys_found",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/mtgban.py",
  "lineno": "37",
  "column": "8",
  "slicing": "['        __keys_found: bool\\n']",
  "context": " \"\"\"\n        headers: Dict[str, str] = {}\n        __keys_found: bool\n\n        config = self.get_configs()\n        if \"M"
 },
 "582": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/mtgban.py",
  "lineno": "56",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "\"\n\n        return headers\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download a URL\n        :param "
 },
 "583": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/mtgban.py",
  "lineno": "56",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": " return headers\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download a URL\n        :param "
 },
 "584": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/mtgban.py",
  "lineno": "62",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"MTGBan\" not in config.sections():\\n', '            LOGGER.warning(\"MTGBan section not established. Skipping alerts\")\\n', '            return headers\\n', '        if config.get(\"MTGBan\", \"api_key\"):\\n', '            self.api_url = self.api_url.format(config.get(\"MTGBan\", \"api_key\"))\\n', '            LOGGER.info(\"MTGBan keys values missing. Skipping imports\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.json()\\n']",
  "context": "ams: Options for URL download\n        \"\"\"\n        session = retryable_session()\n        session.headers.update(self.session_header"
 },
 "585": {
  "name": "TRANSLATION_URL",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    TRANSLATION_URL: str = \"https://magic.wizards.com/{}/products/card-set-archive\"\\n']",
  "context": ":\n    \"\"\"\n    Wizards Site Container\n    \"\"\"\n\n    TRANSLATION_URL: str = \"https://magic.wizards.com/{}/products/card-set-archive\"\n    magic_rules_url: str = (\n        \"https://magi"
 },
 "586": {
  "name": "magic_rules_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    magic_rules_url: str = (\\n']",
  "context": "gic.wizards.com/{}/products/card-set-archive\"\n    magic_rules_url: str = (\n        \"https://magic.wizards.com/en/game-info/ga"
 },
 "587": {
  "name": "translation_table",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    translation_table: Dict[str, Dict[str, str]] = {}\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        soup = bs4.BeautifulSoup(\\n', '        set_lines = soup.find_all(\"a\", href=re.compile(r\".*(node|content).*\"))\\n', '        for set_line in set_lines:\\n', '            icon = set_line.find(\"span\", class_=\"icon\")\\n', '            if not icon or len(icon) == 1:\\n', '                set_name = set_line.find(\"span\", class_=\"nameSet\")\\n', '                if set_name:\\n', '                        f\"Unable to find set icon for {set_name.text.strip()}\"\\n', '            set_name = set_line.find(\"span\", class_=\"nameSet\").text.strip()\\n', '            set_icon_url = icon.find(\"img\")[\"src\"]\\n', '            if set_icon_url in translation_table.keys():\\n', '                translation_table[set_icon_url] = {\\n', '                    **translation_table[set_icon_url],\\n', '                    **{long_lang_name: set_name},\\n', '                translation_table[set_icon_url] = {long_lang_name: set_name}\\n', '        return translation_table\\n', '        return_table = {}\\n', '        for key, value in table.items():\\n', '            if \"English\" not in value.keys():\\n', '                self.logger.debug(f\"VALUE INCOMPLETE\\\\t{key}: {value}\")\\n', '            new_key = value[\"English\"]\\n', '            del value[\"English\"]\\n', '            return_table[new_key] = value\\n', '        return return_table\\n', '        with self.__translation_table_cache.open(encoding=\"utf-8\") as file:\\n', '            self.translation_table = json.load(file)\\n', '        translation_table: Dict[str, Dict[str, str]] = {}\\n', '        for short_code, long_name in WIZARDS_SUPPORTED_LANGUAGES:\\n', '            self.logger.info(f\"Building translations for {long_name}\")\\n', '            translation_table = self.build_single_language(\\n', '                short_code, long_name, translation_table\\n', '        translation_table = self.convert_keys_to_set_names(translation_table)\\n', '        translation_table = self.set_names_to_set_codes(translation_table)\\n', '        translation_table = self.override_set_translations(translation_table)\\n', '        with self.__translation_table_cache.open(\"w\", encoding=\"utf-8\") as file:\\n', '            json.dump(translation_table, file)\\n', '        self.translation_table = translation_table\\n', '        ) as f:\\n', '            translation_fixes = json.load(f)\\n', '        for set_code, override_translations in translation_fixes.items():\\n', '            if set_code not in table:\\n', '                table[set_code] = override_translations\\n', '                table[set_code].update(override_translations)\\n', '        ) as f:\\n', '            set_name_fixes = json.load(f)\\n', '        for key, value in set_name_fixes.items():\\n', '            if key in table:\\n', '                table[value] = table[key]\\n', '                del table[key]\\n', '        new_table = parallel_call(\\n', '        return dict(new_table)\\n', '        response = self.download(self.magic_rules_url).content.decode()\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        response = (\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n', '    if not key:\\n', '    new_table = {}\\n', '    key = key.translate({ord(i): None for i in \":\\'.& \"})\\n', '    set_header = ScryfallProvider().download(f\"{ScryfallProvider().ALL_SETS_URL}/{key}\")\\n', '    if set_header:\\n', '        new_table[set_header[\"code\"].upper()] = value\\n', '    return new_table\\n']",
  "context": "-info/gameplay/rules-and-formats/rules\"\n    )\n    translation_table: Dict[str, Dict[str, str]] = {}\n    magic_rules: str = \"\"\n    __translation_table_"
 },
 "588": {
  "name": "magic_rules",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    magic_rules: str = \"\"\\n']",
  "context": "slation_table: Dict[str, Dict[str, str]] = {}\n    magic_rules: str = \"\"\n    __translation_table_cache: pathlib.Path = CACH"
 },
 "589": {
  "name": "__one_week_ago",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "37",
  "column": "4",
  "slicing": "['    __one_week_ago: int = int(time.time() - 7 * 86400)\\n']",
  "context": "npath(\n        \"translation_table.json\"\n    )\n    __one_week_ago: int = int(time.time() - 7 * 86400)\n\n    def __init__(self) -> None:\n        self.logg"
 },
 "590": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "51",
  "column": "14",
  "slicing": "['        self, url: str, params: Dict[str, Union[str, int]] = None\\n']",
  "context": "   return dict()\n\n    def download(\n        self, url: str, params: Dict[str, Union[str, int]] = None\n    ) -> requests.Response:\n        \"\"\"\n        Do"
 },
 "591": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "51",
  "column": "24",
  "slicing": "['        self, url: str, params: Dict[str, Union[str, int]] = None\\n']",
  "context": "dict()\n\n    def download(\n        self, url: str, params: Dict[str, Union[str, int]] = None\n    ) -> requests.Response:\n        \"\"\"\n        Do"
 },
 "592": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "59",
  "column": "8",
  "slicing": "['        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n']",
  "context": "sed\n        :return: Response\n        \"\"\"\n        session = retryable_session()\n        session.headers.update(self.session_header"
 },
 "593": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "65",
  "column": "38",
  "slicing": "['    def get_translation_for_set(self, set_code: str) -> MtgjsonTranslationsObject:\\n']",
  "context": "n response\n\n    def get_translation_for_set(self, set_code: str) -> MtgjsonTranslationsObject:\n        \"\"\"\n        Get translations for a specifi"
 },
 "594": {
  "name": "short_lang_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "90",
  "column": "8",
  "slicing": "['        short_lang_code: str,\\n']",
  "context": " def build_single_language(\n        self,\n        short_lang_code: str,\n        long_lang_name: str,\n        translation_t"
 },
 "595": {
  "name": "long_lang_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "91",
  "column": "8",
  "slicing": "['        long_lang_name: str,\\n']",
  "context": "      self,\n        short_lang_code: str,\n        long_lang_name: str,\n        translation_table: Dict[str, Dict[str, str"
 },
 "596": {
  "name": "translation_table",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "92",
  "column": "8",
  "slicing": "['        translation_table: Dict[str, Dict[str, str]],\\n']",
  "context": "g_code: str,\n        long_lang_name: str,\n        translation_table: Dict[str, Dict[str, str]],\n    ) -> Dict[str, Dict[str, str]]:\n        \"\"\"\n  "
 },
 "597": {
  "name": "set_icon_url",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "125",
  "column": "12",
  "slicing": "['        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        soup = bs4.BeautifulSoup(\\n', '        set_lines = soup.find_all(\"a\", href=re.compile(r\".*(node|content).*\"))\\n', '        for set_line in set_lines:\\n', '            icon = set_line.find(\"span\", class_=\"icon\")\\n', '            if not icon or len(icon) == 1:\\n', '                set_name = set_line.find(\"span\", class_=\"nameSet\")\\n', '                if set_name:\\n', '                        f\"Unable to find set icon for {set_name.text.strip()}\"\\n', '            set_name = set_line.find(\"span\", class_=\"nameSet\").text.strip()\\n', '            set_icon_url = icon.find(\"img\")[\"src\"]\\n', '            if set_icon_url in translation_table.keys():\\n', '                translation_table[set_icon_url] = {\\n', '                    **translation_table[set_icon_url],\\n', '                    **{long_lang_name: set_name},\\n', '                translation_table[set_icon_url] = {long_lang_name: set_name}\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n']",
  "context": "span\", class_=\"nameSet\").text.strip()\n            set_icon_url = icon.find(\"img\")[\"src\"]\n            if set_icon_url in translation_table.k"
 },
 "598": {
  "name": "table",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "137",
  "column": "14",
  "slicing": "['        self, table: Dict[str, Dict[str, str]]\\n']",
  "context": "\n    def convert_keys_to_set_names(\n        self, table: Dict[str, Dict[str, str]]\n    ) -> Dict[str, Dict[str, str]]:\n        \"\"\"\n  "
 },
 "599": {
  "name": "return_table",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "146",
  "column": "8",
  "slicing": "['        return_table = {}\\n', '            return_table[new_key] = value\\n', '        return return_table\\n']",
  "context": "slation table w/ correct keys\n        \"\"\"\n        return_table = {}\n        for key, value in table.items():\n         "
 },
 "600": {
  "name": "new_key",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "152",
  "column": "12",
  "slicing": "['    translation_table: Dict[str, Dict[str, str]] = {}\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        soup = bs4.BeautifulSoup(\\n', '        set_lines = soup.find_all(\"a\", href=re.compile(r\".*(node|content).*\"))\\n', '        for set_line in set_lines:\\n', '            icon = set_line.find(\"span\", class_=\"icon\")\\n', '            if not icon or len(icon) == 1:\\n', '                set_name = set_line.find(\"span\", class_=\"nameSet\")\\n', '                if set_name:\\n', '                        f\"Unable to find set icon for {set_name.text.strip()}\"\\n', '            set_name = set_line.find(\"span\", class_=\"nameSet\").text.strip()\\n', '            set_icon_url = icon.find(\"img\")[\"src\"]\\n', '            if set_icon_url in translation_table.keys():\\n', '                translation_table[set_icon_url] = {\\n', '                    **translation_table[set_icon_url],\\n', '                    **{long_lang_name: set_name},\\n', '                translation_table[set_icon_url] = {long_lang_name: set_name}\\n', '        return translation_table\\n', '        return_table = {}\\n', '        for key, value in table.items():\\n', '            if \"English\" not in value.keys():\\n', '                self.logger.debug(f\"VALUE INCOMPLETE\\\\t{key}: {value}\")\\n', '            new_key = value[\"English\"]\\n', '            del value[\"English\"]\\n', '            return_table[new_key] = value\\n', '        return return_table\\n', '        with self.__translation_table_cache.open(encoding=\"utf-8\") as file:\\n', '            self.translation_table = json.load(file)\\n', '        translation_table: Dict[str, Dict[str, str]] = {}\\n', '        for short_code, long_name in WIZARDS_SUPPORTED_LANGUAGES:\\n', '            self.logger.info(f\"Building translations for {long_name}\")\\n', '            translation_table = self.build_single_language(\\n', '                short_code, long_name, translation_table\\n', '        translation_table = self.convert_keys_to_set_names(translation_table)\\n', '        translation_table = self.set_names_to_set_codes(translation_table)\\n', '        translation_table = self.override_set_translations(translation_table)\\n', '        with self.__translation_table_cache.open(\"w\", encoding=\"utf-8\") as file:\\n', '            json.dump(translation_table, file)\\n', '        self.translation_table = translation_table\\n', '        ) as f:\\n', '            translation_fixes = json.load(f)\\n', '        for set_code, override_translations in translation_fixes.items():\\n', '            if set_code not in table:\\n', '                table[set_code] = override_translations\\n', '                table[set_code].update(override_translations)\\n', '        ) as f:\\n', '            set_name_fixes = json.load(f)\\n', '        for key, value in set_name_fixes.items():\\n', '            if key in table:\\n', '                table[value] = table[key]\\n', '                del table[key]\\n', '        new_table = parallel_call(\\n', '        return dict(new_table)\\n', '        response = self.download(self.magic_rules_url).content.decode()\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        response = (\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n', '    if not key:\\n', '    new_table = {}\\n', '    key = key.translate({ord(i): None for i in \":\\'.& \"})\\n', '    set_header = ScryfallProvider().download(f\"{ScryfallProvider().ALL_SETS_URL}/{key}\")\\n', '    if set_header:\\n', '        new_table[set_header[\"code\"].upper()] = value\\n', '    return new_table\\n']",
  "context": ": {value}\")\n                continue\n\n            new_key = value[\"English\"]\n            del value[\"English\"]\n            retur"
 },
 "601": {
  "name": "translation_table",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "173",
  "column": "8",
  "slicing": "['    translation_table: Dict[str, Dict[str, str]] = {}\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        soup = bs4.BeautifulSoup(\\n', '        set_lines = soup.find_all(\"a\", href=re.compile(r\".*(node|content).*\"))\\n', '        for set_line in set_lines:\\n', '            icon = set_line.find(\"span\", class_=\"icon\")\\n', '            if not icon or len(icon) == 1:\\n', '                set_name = set_line.find(\"span\", class_=\"nameSet\")\\n', '                if set_name:\\n', '                        f\"Unable to find set icon for {set_name.text.strip()}\"\\n', '            set_name = set_line.find(\"span\", class_=\"nameSet\").text.strip()\\n', '            set_icon_url = icon.find(\"img\")[\"src\"]\\n', '            if set_icon_url in translation_table.keys():\\n', '                translation_table[set_icon_url] = {\\n', '                    **translation_table[set_icon_url],\\n', '                    **{long_lang_name: set_name},\\n', '                translation_table[set_icon_url] = {long_lang_name: set_name}\\n', '        return translation_table\\n', '        return_table = {}\\n', '        for key, value in table.items():\\n', '            if \"English\" not in value.keys():\\n', '                self.logger.debug(f\"VALUE INCOMPLETE\\\\t{key}: {value}\")\\n', '            new_key = value[\"English\"]\\n', '            del value[\"English\"]\\n', '            return_table[new_key] = value\\n', '        return return_table\\n', '        with self.__translation_table_cache.open(encoding=\"utf-8\") as file:\\n', '            self.translation_table = json.load(file)\\n', '        translation_table: Dict[str, Dict[str, str]] = {}\\n', '        for short_code, long_name in WIZARDS_SUPPORTED_LANGUAGES:\\n', '            self.logger.info(f\"Building translations for {long_name}\")\\n', '            translation_table = self.build_single_language(\\n', '                short_code, long_name, translation_table\\n', '        translation_table = self.convert_keys_to_set_names(translation_table)\\n', '        translation_table = self.set_names_to_set_codes(translation_table)\\n', '        translation_table = self.override_set_translations(translation_table)\\n', '        with self.__translation_table_cache.open(\"w\", encoding=\"utf-8\") as file:\\n', '            json.dump(translation_table, file)\\n', '        self.translation_table = translation_table\\n', '        ) as f:\\n', '            translation_fixes = json.load(f)\\n', '        for set_code, override_translations in translation_fixes.items():\\n', '            if set_code not in table:\\n', '                table[set_code] = override_translations\\n', '                table[set_code].update(override_translations)\\n', '        ) as f:\\n', '            set_name_fixes = json.load(f)\\n', '        for key, value in set_name_fixes.items():\\n', '            if key in table:\\n', '                table[value] = table[key]\\n', '                del table[key]\\n', '        new_table = parallel_call(\\n', '        return dict(new_table)\\n', '        response = self.download(self.magic_rules_url).content.decode()\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        response = (\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n', '    if not key:\\n', '    new_table = {}\\n', '    key = key.translate({ord(i): None for i in \":\\'.& \"})\\n', '    set_header = ScryfallProvider().download(f\"{ScryfallProvider().ALL_SETS_URL}/{key}\")\\n', '    if set_header:\\n', '        new_table[set_header[\"code\"].upper()] = value\\n', '    return new_table\\n']",
  "context": "return: New translation table\n        \"\"\"\n        translation_table: Dict[str, Dict[str, str]] = {}\n\n        for short_code, long_name in WIZARDS_SUPP"
 },
 "602": {
  "name": "translation_table",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "177",
  "column": "12",
  "slicing": "['    translation_table: Dict[str, Dict[str, str]] = {}\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        soup = bs4.BeautifulSoup(\\n', '        set_lines = soup.find_all(\"a\", href=re.compile(r\".*(node|content).*\"))\\n', '        for set_line in set_lines:\\n', '            icon = set_line.find(\"span\", class_=\"icon\")\\n', '            if not icon or len(icon) == 1:\\n', '                set_name = set_line.find(\"span\", class_=\"nameSet\")\\n', '                if set_name:\\n', '                        f\"Unable to find set icon for {set_name.text.strip()}\"\\n', '            set_name = set_line.find(\"span\", class_=\"nameSet\").text.strip()\\n', '            set_icon_url = icon.find(\"img\")[\"src\"]\\n', '            if set_icon_url in translation_table.keys():\\n', '                translation_table[set_icon_url] = {\\n', '                    **translation_table[set_icon_url],\\n', '                    **{long_lang_name: set_name},\\n', '                translation_table[set_icon_url] = {long_lang_name: set_name}\\n', '        return translation_table\\n', '        return_table = {}\\n', '        for key, value in table.items():\\n', '            if \"English\" not in value.keys():\\n', '                self.logger.debug(f\"VALUE INCOMPLETE\\\\t{key}: {value}\")\\n', '            new_key = value[\"English\"]\\n', '            del value[\"English\"]\\n', '            return_table[new_key] = value\\n', '        return return_table\\n', '        with self.__translation_table_cache.open(encoding=\"utf-8\") as file:\\n', '            self.translation_table = json.load(file)\\n', '        translation_table: Dict[str, Dict[str, str]] = {}\\n', '        for short_code, long_name in WIZARDS_SUPPORTED_LANGUAGES:\\n', '            self.logger.info(f\"Building translations for {long_name}\")\\n', '            translation_table = self.build_single_language(\\n', '                short_code, long_name, translation_table\\n', '        translation_table = self.convert_keys_to_set_names(translation_table)\\n', '        translation_table = self.set_names_to_set_codes(translation_table)\\n', '        translation_table = self.override_set_translations(translation_table)\\n', '        with self.__translation_table_cache.open(\"w\", encoding=\"utf-8\") as file:\\n', '            json.dump(translation_table, file)\\n', '        self.translation_table = translation_table\\n', '        ) as f:\\n', '            translation_fixes = json.load(f)\\n', '        for set_code, override_translations in translation_fixes.items():\\n', '            if set_code not in table:\\n', '                table[set_code] = override_translations\\n', '                table[set_code].update(override_translations)\\n', '        ) as f:\\n', '            set_name_fixes = json.load(f)\\n', '        for key, value in set_name_fixes.items():\\n', '            if key in table:\\n', '                table[value] = table[key]\\n', '                del table[key]\\n', '        new_table = parallel_call(\\n', '        return dict(new_table)\\n', '        response = self.download(self.magic_rules_url).content.decode()\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        response = (\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n', '    if not key:\\n', '    new_table = {}\\n', '    key = key.translate({ord(i): None for i in \":\\'.& \"})\\n', '    set_header = ScryfallProvider().download(f\"{ScryfallProvider().ALL_SETS_URL}/{key}\")\\n', '    if set_header:\\n', '        new_table[set_header[\"code\"].upper()] = value\\n', '    return new_table\\n']",
  "context": "ilding translations for {long_name}\")\n            translation_table = self.build_single_language(\n                short_code, long_name, translation"
 },
 "603": {
  "name": "translation_table",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "182",
  "column": "8",
  "slicing": "['    translation_table: Dict[str, Dict[str, str]] = {}\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        soup = bs4.BeautifulSoup(\\n', '        set_lines = soup.find_all(\"a\", href=re.compile(r\".*(node|content).*\"))\\n', '        for set_line in set_lines:\\n', '            icon = set_line.find(\"span\", class_=\"icon\")\\n', '            if not icon or len(icon) == 1:\\n', '                set_name = set_line.find(\"span\", class_=\"nameSet\")\\n', '                if set_name:\\n', '                        f\"Unable to find set icon for {set_name.text.strip()}\"\\n', '            set_name = set_line.find(\"span\", class_=\"nameSet\").text.strip()\\n', '            set_icon_url = icon.find(\"img\")[\"src\"]\\n', '            if set_icon_url in translation_table.keys():\\n', '                translation_table[set_icon_url] = {\\n', '                    **translation_table[set_icon_url],\\n', '                    **{long_lang_name: set_name},\\n', '                translation_table[set_icon_url] = {long_lang_name: set_name}\\n', '        return translation_table\\n', '        return_table = {}\\n', '        for key, value in table.items():\\n', '            if \"English\" not in value.keys():\\n', '                self.logger.debug(f\"VALUE INCOMPLETE\\\\t{key}: {value}\")\\n', '            new_key = value[\"English\"]\\n', '            del value[\"English\"]\\n', '            return_table[new_key] = value\\n', '        return return_table\\n', '        with self.__translation_table_cache.open(encoding=\"utf-8\") as file:\\n', '            self.translation_table = json.load(file)\\n', '        translation_table: Dict[str, Dict[str, str]] = {}\\n', '        for short_code, long_name in WIZARDS_SUPPORTED_LANGUAGES:\\n', '            self.logger.info(f\"Building translations for {long_name}\")\\n', '            translation_table = self.build_single_language(\\n', '                short_code, long_name, translation_table\\n', '        translation_table = self.convert_keys_to_set_names(translation_table)\\n', '        translation_table = self.set_names_to_set_codes(translation_table)\\n', '        translation_table = self.override_set_translations(translation_table)\\n', '        with self.__translation_table_cache.open(\"w\", encoding=\"utf-8\") as file:\\n', '            json.dump(translation_table, file)\\n', '        self.translation_table = translation_table\\n', '        ) as f:\\n', '            translation_fixes = json.load(f)\\n', '        for set_code, override_translations in translation_fixes.items():\\n', '            if set_code not in table:\\n', '                table[set_code] = override_translations\\n', '                table[set_code].update(override_translations)\\n', '        ) as f:\\n', '            set_name_fixes = json.load(f)\\n', '        for key, value in set_name_fixes.items():\\n', '            if key in table:\\n', '                table[value] = table[key]\\n', '                del table[key]\\n', '        new_table = parallel_call(\\n', '        return dict(new_table)\\n', '        response = self.download(self.magic_rules_url).content.decode()\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        response = (\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n', '    if not key:\\n', '    new_table = {}\\n', '    key = key.translate({ord(i): None for i in \":\\'.& \"})\\n', '    set_header = ScryfallProvider().download(f\"{ScryfallProvider().ALL_SETS_URL}/{key}\")\\n', '    if set_header:\\n', '        new_table[set_header[\"code\"].upper()] = value\\n', '    return new_table\\n']",
  "context": "le\n            )\n\n        # Oh Wizards...\n        translation_table = self.convert_keys_to_set_names(translation_table)\n        translation_table = self.set_names_to_set_"
 },
 "604": {
  "name": "translation_table",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "183",
  "column": "8",
  "slicing": "['    translation_table: Dict[str, Dict[str, str]] = {}\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        soup = bs4.BeautifulSoup(\\n', '        set_lines = soup.find_all(\"a\", href=re.compile(r\".*(node|content).*\"))\\n', '        for set_line in set_lines:\\n', '            icon = set_line.find(\"span\", class_=\"icon\")\\n', '            if not icon or len(icon) == 1:\\n', '                set_name = set_line.find(\"span\", class_=\"nameSet\")\\n', '                if set_name:\\n', '                        f\"Unable to find set icon for {set_name.text.strip()}\"\\n', '            set_name = set_line.find(\"span\", class_=\"nameSet\").text.strip()\\n', '            set_icon_url = icon.find(\"img\")[\"src\"]\\n', '            if set_icon_url in translation_table.keys():\\n', '                translation_table[set_icon_url] = {\\n', '                    **translation_table[set_icon_url],\\n', '                    **{long_lang_name: set_name},\\n', '                translation_table[set_icon_url] = {long_lang_name: set_name}\\n', '        return translation_table\\n', '        return_table = {}\\n', '        for key, value in table.items():\\n', '            if \"English\" not in value.keys():\\n', '                self.logger.debug(f\"VALUE INCOMPLETE\\\\t{key}: {value}\")\\n', '            new_key = value[\"English\"]\\n', '            del value[\"English\"]\\n', '            return_table[new_key] = value\\n', '        return return_table\\n', '        with self.__translation_table_cache.open(encoding=\"utf-8\") as file:\\n', '            self.translation_table = json.load(file)\\n', '        translation_table: Dict[str, Dict[str, str]] = {}\\n', '        for short_code, long_name in WIZARDS_SUPPORTED_LANGUAGES:\\n', '            self.logger.info(f\"Building translations for {long_name}\")\\n', '            translation_table = self.build_single_language(\\n', '                short_code, long_name, translation_table\\n', '        translation_table = self.convert_keys_to_set_names(translation_table)\\n', '        translation_table = self.set_names_to_set_codes(translation_table)\\n', '        translation_table = self.override_set_translations(translation_table)\\n', '        with self.__translation_table_cache.open(\"w\", encoding=\"utf-8\") as file:\\n', '            json.dump(translation_table, file)\\n', '        self.translation_table = translation_table\\n', '        ) as f:\\n', '            translation_fixes = json.load(f)\\n', '        for set_code, override_translations in translation_fixes.items():\\n', '            if set_code not in table:\\n', '                table[set_code] = override_translations\\n', '                table[set_code].update(override_translations)\\n', '        ) as f:\\n', '            set_name_fixes = json.load(f)\\n', '        for key, value in set_name_fixes.items():\\n', '            if key in table:\\n', '                table[value] = table[key]\\n', '                del table[key]\\n', '        new_table = parallel_call(\\n', '        return dict(new_table)\\n', '        response = self.download(self.magic_rules_url).content.decode()\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        response = (\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n', '    if not key:\\n', '    new_table = {}\\n', '    key = key.translate({ord(i): None for i in \":\\'.& \"})\\n', '    set_header = ScryfallProvider().download(f\"{ScryfallProvider().ALL_SETS_URL}/{key}\")\\n', '    if set_header:\\n', '        new_table[set_header[\"code\"].upper()] = value\\n', '    return new_table\\n']",
  "context": "vert_keys_to_set_names(translation_table)\n        translation_table = self.set_names_to_set_codes(translation_table)\n        translation_table = self.override_set_tran"
 },
 "605": {
  "name": "translation_table",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "184",
  "column": "8",
  "slicing": "['    translation_table: Dict[str, Dict[str, str]] = {}\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        soup = bs4.BeautifulSoup(\\n', '        set_lines = soup.find_all(\"a\", href=re.compile(r\".*(node|content).*\"))\\n', '        for set_line in set_lines:\\n', '            icon = set_line.find(\"span\", class_=\"icon\")\\n', '            if not icon or len(icon) == 1:\\n', '                set_name = set_line.find(\"span\", class_=\"nameSet\")\\n', '                if set_name:\\n', '                        f\"Unable to find set icon for {set_name.text.strip()}\"\\n', '            set_name = set_line.find(\"span\", class_=\"nameSet\").text.strip()\\n', '            set_icon_url = icon.find(\"img\")[\"src\"]\\n', '            if set_icon_url in translation_table.keys():\\n', '                translation_table[set_icon_url] = {\\n', '                    **translation_table[set_icon_url],\\n', '                    **{long_lang_name: set_name},\\n', '                translation_table[set_icon_url] = {long_lang_name: set_name}\\n', '        return translation_table\\n', '        return_table = {}\\n', '        for key, value in table.items():\\n', '            if \"English\" not in value.keys():\\n', '                self.logger.debug(f\"VALUE INCOMPLETE\\\\t{key}: {value}\")\\n', '            new_key = value[\"English\"]\\n', '            del value[\"English\"]\\n', '            return_table[new_key] = value\\n', '        return return_table\\n', '        with self.__translation_table_cache.open(encoding=\"utf-8\") as file:\\n', '            self.translation_table = json.load(file)\\n', '        translation_table: Dict[str, Dict[str, str]] = {}\\n', '        for short_code, long_name in WIZARDS_SUPPORTED_LANGUAGES:\\n', '            self.logger.info(f\"Building translations for {long_name}\")\\n', '            translation_table = self.build_single_language(\\n', '                short_code, long_name, translation_table\\n', '        translation_table = self.convert_keys_to_set_names(translation_table)\\n', '        translation_table = self.set_names_to_set_codes(translation_table)\\n', '        translation_table = self.override_set_translations(translation_table)\\n', '        with self.__translation_table_cache.open(\"w\", encoding=\"utf-8\") as file:\\n', '            json.dump(translation_table, file)\\n', '        self.translation_table = translation_table\\n', '        ) as f:\\n', '            translation_fixes = json.load(f)\\n', '        for set_code, override_translations in translation_fixes.items():\\n', '            if set_code not in table:\\n', '                table[set_code] = override_translations\\n', '                table[set_code].update(override_translations)\\n', '        ) as f:\\n', '            set_name_fixes = json.load(f)\\n', '        for key, value in set_name_fixes.items():\\n', '            if key in table:\\n', '                table[value] = table[key]\\n', '                del table[key]\\n', '        new_table = parallel_call(\\n', '        return dict(new_table)\\n', '        response = self.download(self.magic_rules_url).content.decode()\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        response = (\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n', '    if not key:\\n', '    new_table = {}\\n', '    key = key.translate({ord(i): None for i in \":\\'.& \"})\\n', '    set_header = ScryfallProvider().download(f\"{ScryfallProvider().ALL_SETS_URL}/{key}\")\\n', '    if set_header:\\n', '        new_table[set_header[\"code\"].upper()] = value\\n', '    return new_table\\n']",
  "context": "set_names_to_set_codes(translation_table)\n        translation_table = self.override_set_translations(translation_table)\n\n        # Cache the table for future uses\n       "
 },
 "606": {
  "name": "table",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "196",
  "column": "8",
  "slicing": "['        table: Dict[str, Dict[str, str]]\\n']",
  "context": "method\n    def override_set_translations(\n        table: Dict[str, Dict[str, str]]\n    ) -> Dict[str, Dict[str, str]]:\n        \"\"\"\n  "
 },
 "607": {
  "name": "table",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "220",
  "column": "8",
  "slicing": "['        table: Dict[str, Dict[str, str]]\\n']",
  "context": "ticmethod\n    def set_names_to_set_codes(\n        table: Dict[str, Dict[str, str]]\n    ) -> Dict[str, Dict[str, str]]:\n        \"\"\"\n  "
 },
 "608": {
  "name": "new_table",
  "type": "utils.parallel_call",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "239",
  "column": "8",
  "slicing": "['    translation_table: Dict[str, Dict[str, str]] = {}\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response\\n', '        soup = bs4.BeautifulSoup(\\n', '        set_lines = soup.find_all(\"a\", href=re.compile(r\".*(node|content).*\"))\\n', '        for set_line in set_lines:\\n', '            icon = set_line.find(\"span\", class_=\"icon\")\\n', '            if not icon or len(icon) == 1:\\n', '                set_name = set_line.find(\"span\", class_=\"nameSet\")\\n', '                if set_name:\\n', '                        f\"Unable to find set icon for {set_name.text.strip()}\"\\n', '            set_name = set_line.find(\"span\", class_=\"nameSet\").text.strip()\\n', '            set_icon_url = icon.find(\"img\")[\"src\"]\\n', '            if set_icon_url in translation_table.keys():\\n', '                translation_table[set_icon_url] = {\\n', '                    **translation_table[set_icon_url],\\n', '                    **{long_lang_name: set_name},\\n', '                translation_table[set_icon_url] = {long_lang_name: set_name}\\n', '        return translation_table\\n', '        return_table = {}\\n', '        for key, value in table.items():\\n', '            if \"English\" not in value.keys():\\n', '                self.logger.debug(f\"VALUE INCOMPLETE\\\\t{key}: {value}\")\\n', '            new_key = value[\"English\"]\\n', '            del value[\"English\"]\\n', '            return_table[new_key] = value\\n', '        return return_table\\n', '        with self.__translation_table_cache.open(encoding=\"utf-8\") as file:\\n', '            self.translation_table = json.load(file)\\n', '        translation_table: Dict[str, Dict[str, str]] = {}\\n', '        for short_code, long_name in WIZARDS_SUPPORTED_LANGUAGES:\\n', '            self.logger.info(f\"Building translations for {long_name}\")\\n', '            translation_table = self.build_single_language(\\n', '                short_code, long_name, translation_table\\n', '        translation_table = self.convert_keys_to_set_names(translation_table)\\n', '        translation_table = self.set_names_to_set_codes(translation_table)\\n', '        translation_table = self.override_set_translations(translation_table)\\n', '        with self.__translation_table_cache.open(\"w\", encoding=\"utf-8\") as file:\\n', '            json.dump(translation_table, file)\\n', '        self.translation_table = translation_table\\n', '        ) as f:\\n', '            translation_fixes = json.load(f)\\n', '        for set_code, override_translations in translation_fixes.items():\\n', '            if set_code not in table:\\n', '                table[set_code] = override_translations\\n', '                table[set_code].update(override_translations)\\n', '        ) as f:\\n', '            set_name_fixes = json.load(f)\\n', '        for key, value in set_name_fixes.items():\\n', '            if key in table:\\n', '                table[value] = table[key]\\n', '                del table[key]\\n', '        new_table = parallel_call(\\n', '        return dict(new_table)\\n', '        response = self.download(self.magic_rules_url).content.decode()\\n', '        self.magic_rules_url = str(re.findall(r\"href=\\\\\".*\\\\.txt\\\\\"\", response)[0][6:-1])\\n', '        response = (\\n', '        self.magic_rules = \"\\\\n\".join(response.splitlines())\\n', '    if not key:\\n', '    new_table = {}\\n', '    key = key.translate({ord(i): None for i in \":\\'.& \"})\\n', '    set_header = ScryfallProvider().download(f\"{ScryfallProvider().ALL_SETS_URL}/{key}\")\\n', '    if set_header:\\n', '        new_table[set_header[\"code\"].upper()] = value\\n', '    return new_table\\n']",
  "context": "table with set codes instead of set names\n        new_table = parallel_call(\n            build_single_set_code, table.items(), "
 },
 "609": {
  "name": "key",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "267",
  "column": "26",
  "slicing": "['def build_single_set_code(key: str, value: Dict[str, str]) -> Dict[str, Dict[str, str]]:\\n']",
  "context": "turn self.magic_rules\n\n\ndef build_single_set_code(key: str, value: Dict[str, str]) -> Dict[str, Dict[str, str]]:\n    \"\"\"\n    Download upstream data to identify set"
 },
 "610": {
  "name": "value",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "267",
  "column": "36",
  "slicing": "['def build_single_set_code(key: str, value: Dict[str, str]) -> Dict[str, Dict[str, str]]:\\n']",
  "context": "magic_rules\n\n\ndef build_single_set_code(key: str, value: Dict[str, str]) -> Dict[str, Dict[str, str]]:\n    \"\"\"\n    Download upstream data to identify set"
 },
 "611": {
  "name": "new_table",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/wizards.py",
  "lineno": "277",
  "column": "4",
  "slicing": "['    new_table = {}\\n', '        new_table[set_header[\"code\"].upper()] = value\\n', '    return new_table\\n']",
  "context": "ts\n    \"\"\"\n    if not key:\n        return {}\n\n    new_table = {}\n\n    # Strip chars not in line with Scryfall's API"
 },
 "612": {
  "name": "connection",
  "type": "mkmsdk.mkm.Mkm",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "35",
  "column": "4",
  "slicing": "['    connection: Mkm\\n']",
  "context": "Provider):\n    \"\"\"\n    MKM container\n    \"\"\"\n\n    connection: Mkm\n    set_map: Dict[str, Dict[str, Any]]\n\n    __keys"
 },
 "613": {
  "name": "set_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "36",
  "column": "4",
  "slicing": "['    set_map: Dict[str, Dict[str, Any]]\\n']",
  "context": "   MKM container\n    \"\"\"\n\n    connection: Mkm\n    set_map: Dict[str, Dict[str, Any]]\n\n    __keys_found: bool\n\n    def __init__(self, he"
 },
 "614": {
  "name": "__keys_found",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "38",
  "column": "4",
  "slicing": "['    __keys_found: bool\\n']",
  "context": ": Mkm\n    set_map: Dict[str, Dict[str, Any]]\n\n    __keys_found: bool\n\n    def __init__(self, headers: Dict[str, str] = "
 },
 "615": {
  "name": "headers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "40",
  "column": "23",
  "slicing": "['    def __init__(self, headers: Dict[str, str] = None):\\n']",
  "context": "]\n\n    __keys_found: bool\n\n    def __init__(self, headers: Dict[str, str] = None):\n        super().__init__(headers or {})\n\n        c"
 },
 "616": {
  "name": "price_data",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "79",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '                LOGGER.warning(\\n', '                LOGGER.warning(\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n']",
  "context": "_response[\"priceguidefile\"])  # Un-base64\n        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\n        decoded_data = price_data.decode(\"utf-8\") "
 },
 "617": {
  "name": "decoded_data",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "80",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '                LOGGER.warning(\\n', '                LOGGER.warning(\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n']",
  "context": "ice_data, 16 + zlib.MAX_WBITS)  # Un-gzip\n        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\n        return io.StringIO(decoded_data)\n\n    def "
 },
 "618": {
  "name": "mtgjson_id_map",
  "type": "utils.generate_card_mapping",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "93",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '                LOGGER.warning(\\n', '                LOGGER.warning(\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n']",
  "context": "self.__keys_found:\n            return {}\n\n        mtgjson_id_map = generate_card_mapping(\n            all_printings_path, (\"identifiers\", \"m"
 },
 "619": {
  "name": "data_frame_columns",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "98",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '                LOGGER.warning(\\n', '                LOGGER.warning(\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n']",
  "context": "as.read_csv(self._get_card_market_data())\n        data_frame_columns = list(price_data.columns)\n\n        product_id_index = data_frame_columns.ind"
 },
 "620": {
  "name": "today_dict",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "104",
  "column": "8",
  "slicing": "['        today_dict: Dict[str, MtgjsonPricesObject] = {}\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '        return today_dict\\n']",
  "context": " = data_frame_columns.index(\"Foil AVG1\")\n\n        today_dict: Dict[str, MtgjsonPricesObject] = {}\n        for row in price_data.iterrows():\n        "
 },
 "621": {
  "name": "columns",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "106",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '                LOGGER.warning(\\n', '                LOGGER.warning(\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n']",
  "context": "    for row in price_data.iterrows():\n            columns: List[float] = [\n                -1 if math.isnan(value) else value"
 },
 "622": {
  "name": "product_id",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "110",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '                LOGGER.warning(\\n', '                LOGGER.warning(\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n']",
  "context": "lue in row[1].tolist()\n            ]\n\n            product_id = str(int(columns[product_id_index]))\n            if product_id in mtgjson_id_map.keys()"
 },
 "623": {
  "name": "mtgjson_uuid",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "112",
  "column": "16",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '                LOGGER.warning(\\n', '                LOGGER.warning(\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n']",
  "context": "duct_id in mtgjson_id_map.keys():\n                mtgjson_uuid = mtgjson_id_map[product_id]\n                avg_sell_price = columns[avg_sell_"
 },
 "624": {
  "name": "avg_sell_price",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "113",
  "column": "16",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '                LOGGER.warning(\\n', '                LOGGER.warning(\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n']",
  "context": "uuid = mtgjson_id_map[product_id]\n                avg_sell_price = columns[avg_sell_price_index]\n                avg_foil_price = columns[avg_foil_"
 },
 "625": {
  "name": "avg_foil_price",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "114",
  "column": "16",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '                LOGGER.warning(\\n', '                LOGGER.warning(\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n']",
  "context": "e = columns[avg_sell_price_index]\n                avg_foil_price = columns[avg_foil_price_index]\n\n                if mtgjson_uuid not in today_dict"
 },
 "626": {
  "name": "set_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "161",
  "column": "25",
  "slicing": "['    def get_set_id(self, set_name: str) -> Optional[int]:\\n']",
  "context": "p[old_set_name.lower()]\n\n    def get_set_id(self, set_name: str) -> Optional[int]:\n        \"\"\"\n        Get MKM Set ID from pre-genera"
 },
 "627": {
  "name": "set_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "174",
  "column": "32",
  "slicing": "['    def get_extras_set_id(self, set_name: str) -> Optional[int]:\\n']",
  "context": "     return None\n\n    def get_extras_set_id(self, set_name: str) -> Optional[int]:\n        \"\"\"\n        Get \"Extras\" MKM Set ID from p"
 },
 "628": {
  "name": "extras_set_name",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "184",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        today_dict: Dict[str, MtgjsonPricesObject] = {}\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '        return today_dict\\n', '        mkm_resp = self.connection.market_place.expansions(game=1)\\n', '        if mkm_resp.status_code != 200:\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '        for set_content in mkm_resp.json()[\"expansion\"]:\\n', '            self.set_map[set_content[\"enName\"].lower()] = {\\n', '                \"mcmId\": set_content[\"idExpansion\"],\\n', '                \"mcmName\": set_content[\"enName\"],\\n', '        with RESOURCE_PATH.joinpath(\"mkm_set_name_fixes.json\").open() as f:\\n', '            mkm_set_name_fixes = json.load(f)\\n', '        for old_set_name, new_set_name in mkm_set_name_fixes.items():\\n', '            if old_set_name.lower() not in self.set_map:\\n', '                LOGGER.warning(\\n', '                    f\"MKM Manual override {old_set_name} to {new_set_name} not found\"\\n', '            self.set_map[new_set_name.lower()] = self.set_map[old_set_name.lower()]\\n', '            del self.set_map[old_set_name.lower()]\\n', '        extras_set_name = f\"{set_name.lower()}: extras\"\\n', '        if extras_set_name in self.set_map.keys():\\n', '            return int(self.set_map[extras_set_name][\"mcmId\"])\\n', '        mkm_resp = None\\n', '                mkm_resp = self.connection.market_place.expansion_singles(\\n', '                LOGGER.warning(\\n', '        if mkm_resp is None:\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n', '        for set_content in mkm_resp.json()[\"single\"]:\\n', '            if not set_content[\"number\"]:\\n', '                set_content[\"number\"] = \"\"\\n', '            set_content[\"number\"].lstrip(\"0\")\\n', '            for name in set_content[\"enName\"].split(\"//\"):\\n', '                name_no_special_chars = name.strip().lower()\\n', '                set_in_progress[name_no_special_chars] = set_content\\n']",
  "context": "lf.__keys_found:\n            return None\n\n        extras_set_name = f\"{set_name.lower()}: extras\"\n        if extras_set_name in self.set_map.keys():"
 },
 "629": {
  "name": "set_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "189",
  "column": "27",
  "slicing": "['    def get_set_name(self, set_name: str) -> Optional[str]:\\n']",
  "context": ")\n        return None\n\n    def get_set_name(self, set_name: str) -> Optional[str]:\n        \"\"\"\n        Get MKM Set Name from pre-gene"
 },
 "630": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "209",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "\"\"\"\n        return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download Content -- Not Used\n "
 },
 "631": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "209",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "  return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download Content -- Not Used\n "
 },
 "632": {
  "name": "mcm_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "218",
  "column": "28",
  "slicing": "['    def get_mkm_cards(self, mcm_id: Optional[int]) -> Dict[str, Dict[str, Any]]:\\n']",
  "context": "\n        return None\n\n    def get_mkm_cards(self, mcm_id: Optional[int]) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        Initialize the MKM global with"
 },
 "633": {
  "name": "mkm_resp",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "226",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"CardMarket\" not in config.sections():\\n', '            LOGGER.warning(\"CardMarket section not established. Skipping requests\")\\n', '        os.environ[\"MKM_APP_TOKEN\"] = config.get(\"CardMarket\", \"app_token\")\\n', '        os.environ[\"MKM_APP_SECRET\"] = config.get(\"CardMarket\", \"app_secret\")\\n', '        os.environ[\"MKM_ACCESS_TOKEN\"] = config.get(\\n', '        os.environ[\"MKM_ACCESS_TOKEN_SECRET\"] = config.get(\\n', '            LOGGER.warning(\"CardMarket keys values missing. Skipping requests\")\\n', '        mkm_response = self.connection.market_place.price_guide().json()\\n', '        price_data = base64.b64decode(mkm_response[\"priceguidefile\"])  # Un-base64\\n', '        price_data = zlib.decompress(price_data, 16 + zlib.MAX_WBITS)  # Un-gzip\\n', '        decoded_data = price_data.decode(\"utf-8\")  # byte array to string\\n', '        return io.StringIO(decoded_data)\\n', '        mtgjson_id_map = generate_card_mapping(\\n', '        price_data = pandas.read_csv(self._get_card_market_data())\\n', '        data_frame_columns = list(price_data.columns)\\n', '        product_id_index = data_frame_columns.index(\"idProduct\")\\n', '        avg_sell_price_index = data_frame_columns.index(\"AVG1\")\\n', '        avg_foil_price_index = data_frame_columns.index(\"Foil AVG1\")\\n', '        today_dict: Dict[str, MtgjsonPricesObject] = {}\\n', '        for row in price_data.iterrows():\\n', '            columns: List[float] = [\\n', '                -1 if math.isnan(value) else value for value in row[1].tolist()\\n', '            product_id = str(int(columns[product_id_index]))\\n', '            if product_id in mtgjson_id_map.keys():\\n', '                mtgjson_uuid = mtgjson_id_map[product_id]\\n', '                avg_sell_price = columns[avg_sell_price_index]\\n', '                avg_foil_price = columns[avg_foil_price_index]\\n', '                if mtgjson_uuid not in today_dict.keys():\\n', '                    if avg_sell_price == -1 and avg_foil_price == -1:\\n', '                    today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                if avg_sell_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_normal = avg_sell_price\\n', '                if avg_foil_price != -1:\\n', '                    today_dict[mtgjson_uuid].sell_foil = avg_foil_price\\n', '        return today_dict\\n', '        mkm_resp = self.connection.market_place.expansions(game=1)\\n', '        if mkm_resp.status_code != 200:\\n', '            LOGGER.error(f\"Unable to download MKM correctly: {mkm_resp}\")\\n', '        for set_content in mkm_resp.json()[\"expansion\"]:\\n', '            self.set_map[set_content[\"enName\"].lower()] = {\\n', '                \"mcmId\": set_content[\"idExpansion\"],\\n', '                \"mcmName\": set_content[\"enName\"],\\n', '        with RESOURCE_PATH.joinpath(\"mkm_set_name_fixes.json\").open() as f:\\n', '            mkm_set_name_fixes = json.load(f)\\n', '        for old_set_name, new_set_name in mkm_set_name_fixes.items():\\n', '            if old_set_name.lower() not in self.set_map:\\n', '                LOGGER.warning(\\n', '                    f\"MKM Manual override {old_set_name} to {new_set_name} not found\"\\n', '            self.set_map[new_set_name.lower()] = self.set_map[old_set_name.lower()]\\n', '            del self.set_map[old_set_name.lower()]\\n', '        extras_set_name = f\"{set_name.lower()}: extras\"\\n', '        if extras_set_name in self.set_map.keys():\\n', '            return int(self.set_map[extras_set_name][\"mcmId\"])\\n', '        mkm_resp = None\\n', '                mkm_resp = self.connection.market_place.expansion_singles(\\n', '                LOGGER.warning(\\n', '        if mkm_resp is None:\\n', '            LOGGER.error(\"MKM had a critical failure. Skipping this import.\")\\n', '        for set_content in mkm_resp.json()[\"single\"]:\\n', '            if not set_content[\"number\"]:\\n', '                set_content[\"number\"] = \"\"\\n', '            set_content[\"number\"].lstrip(\"0\")\\n', '            for name in set_content[\"enName\"].split(\"//\"):\\n', '                name_no_special_chars = name.strip().lower()\\n', '                set_in_progress[name_no_special_chars] = set_content\\n']",
  "context": "if mcm_id is None:\n            return {}\n\n        mkm_resp = None\n        for _ in range(5):\n            try:\n      "
 },
 "634": {
  "name": "set_in_progress",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardmarket.py",
  "lineno": "244",
  "column": "8",
  "slicing": "['        set_in_progress = {}\\n', '                set_in_progress[name_no_special_chars] = set_content\\n', '        return set_in_progress\\n']",
  "context": "turn {}\n\n        # {SetNum: Object, ... }\n        set_in_progress = {}\n        for set_content in mkm_resp.json()[\"single"
 },
 "635": {
  "name": "card_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    card_name: str\\n', '            card_name=card_name,\\n']",
  "context": "ad for fetching a card from Gatherer\n    \"\"\"\n\n    card_name: str\n    original_types: str\n    original_text: Optiona"
 },
 "636": {
  "name": "original_types",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    original_types: str\\n']",
  "context": "ard from Gatherer\n    \"\"\"\n\n    card_name: str\n    original_types: str\n    original_text: Optional[str]\n    flavor_text: "
 },
 "637": {
  "name": "original_text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    original_text: Optional[str]\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '                response = session.get(url, params=params)\\n', '                LOGGER.error(f\"Unable to download {url} -> {error}. Retrying.\")\\n', '        self.log_download(response)\\n', '        return response\\n', '        response = self.download(\\n', '            response.text, set_code in self.SETS_TO_REMOVE_PARENTHESES\\n', '        soup = bs4.BeautifulSoup(gatherer_data, \"html.parser\")\\n', '        columns = soup.find_all(\"td\", class_=\"rightCol\")\\n', '        return [self._parse_column(c, strip_parentheses) for c in columns]\\n', '        label_to_values = {\\n', '            for row in gatherer_column.find_all(\"div\", class_=\"row\")\\n', '        card_name = label_to_values[\"Card Name\"].getText(strip=True)\\n', '        card_types = label_to_values[\"Types\"].getText(strip=True)\\n', '        flavor_lines = []\\n', '        if \"Flavor Text\" in label_to_values:\\n', '            for flavor_box in label_to_values[\"Flavor Text\"].find_all(\\n', '                flavor_lines.append(flavor_box.getText(strip=True))\\n', '        text_lines = []\\n', '        if \"Card Text\" in label_to_values:\\n', '            for textbox in label_to_values[\"Card Text\"].find_all(\\n', '                text_lines.append(self._replace_symbols(textbox).getText().strip())\\n', '        original_text: Optional[str] = \"\\\\n\".join(text_lines).strip() or None\\n', '        if strip_parentheses and original_text:\\n', '            original_text = self.strip_parentheses_from_text(original_text)\\n', '            card_name=card_name,\\n', '            original_types=card_types,\\n', '            original_text=re.sub(r\"<[^>]+>\", \"\", original_text)\\n', '            if original_text\\n', '            flavor_text=\"\\\\n\".join(flavor_lines).strip() or None,\\n']",
  "context": "\"\n\n    card_name: str\n    original_types: str\n    original_text: Optional[str]\n    flavor_text: Optional[str]\n\n\n@singleton\nclass "
 },
 "638": {
  "name": "flavor_text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    flavor_text: Optional[str]\\n']",
  "context": "l_types: str\n    original_text: Optional[str]\n    flavor_text: Optional[str]\n\n\n@singleton\nclass GathererProvider(AbstractProvid"
 },
 "639": {
  "name": "SETS_TO_REMOVE_PARENTHESES",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "40",
  "column": "4",
  "slicing": "['    SETS_TO_REMOVE_PARENTHESES = {\"10E\"}\\n']",
  "context": "gatherer.wizards.com/Pages/Card/Details.aspx\"\n    SETS_TO_REMOVE_PARENTHESES = {\"10E\"}\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "640": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "58",
  "column": "14",
  "slicing": "['        self, url: str, params: Dict[str, Union[str, int]] = None\\n']",
  "context": "lls=40, period=1)\n    def download(\n        self, url: str, params: Dict[str, Union[str, int]] = None\n    ) -> requests.Response:\n        \"\"\"\n        Do"
 },
 "641": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "58",
  "column": "24",
  "slicing": "['        self, url: str, params: Dict[str, Union[str, int]] = None\\n']",
  "context": "riod=1)\n    def download(\n        self, url: str, params: Dict[str, Union[str, int]] = None\n    ) -> requests.Response:\n        \"\"\"\n        Do"
 },
 "642": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "66",
  "column": "8",
  "slicing": "['        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '                response = session.get(url, params=params)\\n', '        self.log_download(response)\\n', '        return response\\n', '            response.text, set_code in self.SETS_TO_REMOVE_PARENTHESES\\n']",
  "context": "\n        :return URL response\n        \"\"\"\n        session = retryable_session()\n        session.headers.update(self.session_header"
 },
 "643": {
  "name": "multiverse_id",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "80",
  "column": "24",
  "slicing": "['    def get_cards(self, multiverse_id: str, set_code: str = \"\") -> List[GathererCard]:\\n']",
  "context": "\n        return response\n\n    def get_cards(self, multiverse_id: str, set_code: str = \"\") -> List[GathererCard]:\n        \"\"\"\n        Get card(s) matching a given m"
 },
 "644": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "80",
  "column": "44",
  "slicing": "['    def get_cards(self, multiverse_id: str, set_code: str = \"\") -> List[GathererCard]:\\n']",
  "context": "onse\n\n    def get_cards(self, multiverse_id: str, set_code: str = \"\") -> List[GathererCard]:\n        \"\"\"\n        Get card(s) matching a given m"
 },
 "645": {
  "name": "gatherer_data",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "96",
  "column": "14",
  "slicing": "['        self, gatherer_data: str, strip_parentheses: bool = False\\n']",
  "context": "SES\n        )\n\n    def parse_cards(\n        self, gatherer_data: str, strip_parentheses: bool = False\n    ) -> List[GathererCard]:\n        \"\"\"\n        P"
 },
 "646": {
  "name": "strip_parentheses",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "96",
  "column": "34",
  "slicing": "['        self, gatherer_data: str, strip_parentheses: bool = False\\n']",
  "context": "ef parse_cards(\n        self, gatherer_data: str, strip_parentheses: bool = False\n    ) -> List[GathererCard]:\n        \"\"\"\n        P"
 },
 "647": {
  "name": "strip_parentheses",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "109",
  "column": "48",
  "slicing": "['        self, gatherer_column: bs4.element.Tag, strip_parentheses: bool\\n']",
  "context": "(\n        self, gatherer_column: bs4.element.Tag, strip_parentheses: bool\n    ) -> GathererCard:\n        \"\"\"\n        Parse a"
 },
 "648": {
  "name": "label_to_values",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "117",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '                response = session.get(url, params=params)\\n', '                LOGGER.error(f\"Unable to download {url} -> {error}. Retrying.\")\\n', '        self.log_download(response)\\n', '        return response\\n', '        response = self.download(\\n', '            response.text, set_code in self.SETS_TO_REMOVE_PARENTHESES\\n', '        soup = bs4.BeautifulSoup(gatherer_data, \"html.parser\")\\n', '        columns = soup.find_all(\"td\", class_=\"rightCol\")\\n', '        return [self._parse_column(c, strip_parentheses) for c in columns]\\n', '        label_to_values = {\\n', '            for row in gatherer_column.find_all(\"div\", class_=\"row\")\\n', '        card_name = label_to_values[\"Card Name\"].getText(strip=True)\\n', '        card_types = label_to_values[\"Types\"].getText(strip=True)\\n', '        if \"Flavor Text\" in label_to_values:\\n', '            for flavor_box in label_to_values[\"Flavor Text\"].find_all(\\n', '                flavor_lines.append(flavor_box.getText(strip=True))\\n', '        if \"Card Text\" in label_to_values:\\n', '            for textbox in label_to_values[\"Card Text\"].find_all(\\n', '                text_lines.append(self._replace_symbols(textbox).getText().strip())\\n', '            card_name=card_name,\\n', '            original_types=card_types,\\n']",
  "context": "   :return Magic card details\n        \"\"\"\n        label_to_values = {\n            row.find(\"div\", class_=\"label\")\n      "
 },
 "649": {
  "name": "flavor_lines",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "127",
  "column": "8",
  "slicing": "['        flavor_lines = []\\n', '                flavor_lines.append(flavor_box.getText(strip=True))\\n', '            flavor_text=\"\\\\n\".join(flavor_lines).strip() or None,\\n']",
  "context": "l_to_values[\"Types\"].getText(strip=True)\n\n        flavor_lines = []\n        if \"Flavor Text\" in label_to_values:\n     "
 },
 "650": {
  "name": "text_lines",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "134",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    original_text: Optional[str]\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '                response = session.get(url, params=params)\\n', '                LOGGER.error(f\"Unable to download {url} -> {error}. Retrying.\")\\n', '        self.log_download(response)\\n', '        return response\\n', '        response = self.download(\\n', '            response.text, set_code in self.SETS_TO_REMOVE_PARENTHESES\\n', '        soup = bs4.BeautifulSoup(gatherer_data, \"html.parser\")\\n', '        columns = soup.find_all(\"td\", class_=\"rightCol\")\\n', '        return [self._parse_column(c, strip_parentheses) for c in columns]\\n', '        label_to_values = {\\n', '            for row in gatherer_column.find_all(\"div\", class_=\"row\")\\n', '        card_name = label_to_values[\"Card Name\"].getText(strip=True)\\n', '        card_types = label_to_values[\"Types\"].getText(strip=True)\\n', '        flavor_lines = []\\n', '        if \"Flavor Text\" in label_to_values:\\n', '            for flavor_box in label_to_values[\"Flavor Text\"].find_all(\\n', '                flavor_lines.append(flavor_box.getText(strip=True))\\n', '        text_lines = []\\n', '        if \"Card Text\" in label_to_values:\\n', '            for textbox in label_to_values[\"Card Text\"].find_all(\\n', '                text_lines.append(self._replace_symbols(textbox).getText().strip())\\n', '        original_text: Optional[str] = \"\\\\n\".join(text_lines).strip() or None\\n', '        if strip_parentheses and original_text:\\n', '            original_text = self.strip_parentheses_from_text(original_text)\\n', '            card_name=card_name,\\n', '            original_types=card_types,\\n', '            original_text=re.sub(r\"<[^>]+>\", \"\", original_text)\\n', '            if original_text\\n', '            flavor_text=\"\\\\n\".join(flavor_lines).strip() or None,\\n']",
  "context": "s.append(flavor_box.getText(strip=True))\n\n        text_lines = []\n        if \"Card Text\" in label_to_values:\n       "
 },
 "651": {
  "name": "original_text",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "141",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    original_text: Optional[str]\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '                response = session.get(url, params=params)\\n', '                LOGGER.error(f\"Unable to download {url} -> {error}. Retrying.\")\\n', '        self.log_download(response)\\n', '        return response\\n', '        response = self.download(\\n', '            response.text, set_code in self.SETS_TO_REMOVE_PARENTHESES\\n', '        soup = bs4.BeautifulSoup(gatherer_data, \"html.parser\")\\n', '        columns = soup.find_all(\"td\", class_=\"rightCol\")\\n', '        return [self._parse_column(c, strip_parentheses) for c in columns]\\n', '        label_to_values = {\\n', '            for row in gatherer_column.find_all(\"div\", class_=\"row\")\\n', '        card_name = label_to_values[\"Card Name\"].getText(strip=True)\\n', '        card_types = label_to_values[\"Types\"].getText(strip=True)\\n', '        flavor_lines = []\\n', '        if \"Flavor Text\" in label_to_values:\\n', '            for flavor_box in label_to_values[\"Flavor Text\"].find_all(\\n', '                flavor_lines.append(flavor_box.getText(strip=True))\\n', '        text_lines = []\\n', '        if \"Card Text\" in label_to_values:\\n', '            for textbox in label_to_values[\"Card Text\"].find_all(\\n', '                text_lines.append(self._replace_symbols(textbox).getText().strip())\\n', '        original_text: Optional[str] = \"\\\\n\".join(text_lines).strip() or None\\n', '        if strip_parentheses and original_text:\\n', '            original_text = self.strip_parentheses_from_text(original_text)\\n', '            card_name=card_name,\\n', '            original_types=card_types,\\n', '            original_text=re.sub(r\"<[^>]+>\", \"\", original_text)\\n', '            if original_text\\n', '            flavor_text=\"\\\\n\".join(flavor_lines).strip() or None,\\n']",
  "context": "lace_symbols(textbox).getText().strip())\n\n        original_text: Optional[str] = \"\\n\".join(text_lines).strip() or None\n        if strip_parentheses and original_text:\n  "
 },
 "652": {
  "name": "alt",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "164",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '    card_name: str\\n', '    original_text: Optional[str]\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '                response = session.get(url, params=params)\\n', '                LOGGER.error(f\"Unable to download {url} -> {error}. Retrying.\")\\n', '        self.log_download(response)\\n', '        return response\\n', '        response = self.download(\\n', '            response.text, set_code in self.SETS_TO_REMOVE_PARENTHESES\\n', '        soup = bs4.BeautifulSoup(gatherer_data, \"html.parser\")\\n', '        columns = soup.find_all(\"td\", class_=\"rightCol\")\\n', '        return [self._parse_column(c, strip_parentheses) for c in columns]\\n', '        label_to_values = {\\n', '            for row in gatherer_column.find_all(\"div\", class_=\"row\")\\n', '        card_name = label_to_values[\"Card Name\"].getText(strip=True)\\n', '        card_types = label_to_values[\"Types\"].getText(strip=True)\\n', '        flavor_lines = []\\n', '        if \"Flavor Text\" in label_to_values:\\n', '            for flavor_box in label_to_values[\"Flavor Text\"].find_all(\\n', '                flavor_lines.append(flavor_box.getText(strip=True))\\n', '        text_lines = []\\n', '        if \"Card Text\" in label_to_values:\\n', '            for textbox in label_to_values[\"Card Text\"].find_all(\\n', '                text_lines.append(self._replace_symbols(textbox).getText().strip())\\n', '        original_text: Optional[str] = \"\\\\n\".join(text_lines).strip() or None\\n', '        if strip_parentheses and original_text:\\n', '            original_text = self.strip_parentheses_from_text(original_text)\\n', '            card_name=card_name,\\n', '            original_types=card_types,\\n', '            original_text=re.sub(r\"<[^>]+>\", \"\", original_text)\\n', '            if original_text\\n', '            flavor_text=\"\\\\n\".join(flavor_lines).strip() or None,\\n', '        tag_copy = copy.copy(tag)\\n', '        images = tag_copy.find_all(\"img\")\\n', '        for image in images:\\n', '            alt = image[\"alt\"]\\n', '            symbol = SYMBOL_MAP.get(alt, alt)\\n', '            image.replace_with(\"{\" + symbol + \"}\")\\n', '        return tag_copy\\n']",
  "context": "l(\"img\")\n        for image in images:\n            alt = image[\"alt\"]\n            symbol = SYMBOL_MAP.get(alt, alt)\n    "
 },
 "653": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/gatherer.py",
  "lineno": "170",
  "column": "36",
  "slicing": "['    def strip_parentheses_from_text(text: str) -> str:\\n']",
  "context": "@staticmethod\n    def strip_parentheses_from_text(text: str) -> str:\n        \"\"\"\n        Remove all text within parenth"
 },
 "654": {
  "name": "booster_api_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_boosters.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    booster_api_url: str = \"https://github.com/taw/magic-sealed-data/blob/master/experimental_export_for_mtgjson.json?raw=true\"\\n']",
  "context": "    GitHubBoostersProvider container\n    \"\"\"\n\n    booster_api_url: str = \"https://github.com/taw/magic-sealed-data/blob/master/experimental_export_for_mtgjson.json?raw=true\"\n    booster_data: Dict[str, Any]\n\n    def __init__"
 },
 "655": {
  "name": "booster_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_boosters.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    booster_data: Dict[str, Any]\\n']",
  "context": "xperimental_export_for_mtgjson.json?raw=true\"\n    booster_data: Dict[str, Any]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "656": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_boosters.py",
  "lineno": "38",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "\"\"\"\n        return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from GitHub\n "
 },
 "657": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_boosters.py",
  "lineno": "38",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "  return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from GitHub\n "
 },
 "658": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_boosters.py",
  "lineno": "44",
  "column": "8",
  "slicing": "['        session = retryable_session()\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        if response.ok:\\n', '            return response.json()\\n', '            f\"Error downloading GitHub Boosters: {response} --- {response.text}\"\\n']",
  "context": "ams: Options for URL download\n        \"\"\"\n        session = retryable_session()\n\n        response = session.get(url)\n        self."
 },
 "659": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_boosters.py",
  "lineno": "56",
  "column": "35",
  "slicing": "['    def get_set_booster_data(self, set_code: str) -> Optional[Dict[str, Any]]:\\n']",
  "context": "    return {}\n\n    def get_set_booster_data(self, set_code: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Grab an individual set's boost"
 },
 "660": {
  "name": "api_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardkingdom.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    api_url: str = \"https://api.cardkingdom.com/api/pricelist\"\\n']",
  "context": ":\n    \"\"\"\n    Card Kingdom container\n    \"\"\"\n\n    api_url: str = \"https://api.cardkingdom.com/api/pricelist\"\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "661": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardkingdom.py",
  "lineno": "38",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "    \"\"\"\n        return {}\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content\n        Api c"
 },
 "662": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardkingdom.py",
  "lineno": "38",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "      return {}\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content\n        Api c"
 },
 "663": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardkingdom.py",
  "lineno": "45",
  "column": "8",
  "slicing": "['        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.json()\\n']",
  "context": "ams: Options for URL download\n        \"\"\"\n        session = retryable_session()\n        session.headers.update(self.session_header"
 },
 "664": {
  "name": "request_api_response",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardkingdom.py",
  "lineno": "60",
  "column": "8",
  "slicing": "['        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.json()\\n', '        request_api_response: Dict[str, Any] = self.download(self.api_url)\\n', '        card_kingdom_id_to_mtgjson = generate_card_mapping(\\n', '        card_kingdom_id_to_mtgjson.update(\\n', '        card_rows = request_api_response.get(\"data\", [])\\n', '        for card in card_rows:\\n', '            card_id = str(card[\"id\"])\\n', '            if card_id not in card_kingdom_id_to_mtgjson:\\n', '            mtgjson_uuid = card_kingdom_id_to_mtgjson[card_id]\\n', '            if mtgjson_uuid not in today_dict:\\n', '                today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '            if card[\"is_foil\"] == \"true\":\\n', '                today_dict[mtgjson_uuid].sell_foil = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_foil = float(card[\"price_buy\"])\\n', '                today_dict[mtgjson_uuid].sell_normal = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_normal = float(card[\"price_buy\"])\\n']",
  "context": "N prices single day structure\n        \"\"\"\n        request_api_response: Dict[str, Any] = self.download(self.api_url)\n\n        # Start with non-foil IDs\n        card_ki"
 },
 "665": {
  "name": "card_kingdom_id_to_mtgjson",
  "type": "utils.generate_card_mapping",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardkingdom.py",
  "lineno": "63",
  "column": "8",
  "slicing": "['        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.json()\\n', '        request_api_response: Dict[str, Any] = self.download(self.api_url)\\n', '        card_kingdom_id_to_mtgjson = generate_card_mapping(\\n', '        card_kingdom_id_to_mtgjson.update(\\n', '        card_rows = request_api_response.get(\"data\", [])\\n', '        for card in card_rows:\\n', '            card_id = str(card[\"id\"])\\n', '            if card_id not in card_kingdom_id_to_mtgjson:\\n', '            mtgjson_uuid = card_kingdom_id_to_mtgjson[card_id]\\n', '            if mtgjson_uuid not in today_dict:\\n', '                today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '            if card[\"is_foil\"] == \"true\":\\n', '                today_dict[mtgjson_uuid].sell_foil = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_foil = float(card[\"price_buy\"])\\n', '                today_dict[mtgjson_uuid].sell_normal = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_normal = float(card[\"price_buy\"])\\n']",
  "context": "i_url)\n\n        # Start with non-foil IDs\n        card_kingdom_id_to_mtgjson = generate_card_mapping(\n            all_printings_path, (\"identifiers\", \"c"
 },
 "666": {
  "name": "today_dict",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardkingdom.py",
  "lineno": "74",
  "column": "8",
  "slicing": "['        today_dict: Dict[str, MtgjsonPricesObject] = {}\\n', '            if mtgjson_uuid not in today_dict:\\n', '                today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '                today_dict[mtgjson_uuid].sell_foil = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_foil = float(card[\"price_buy\"])\\n', '                today_dict[mtgjson_uuid].sell_normal = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_normal = float(card[\"price_buy\"])\\n', '        return today_dict\\n']",
  "context": "lId\"), (\"uuid\",)\n            )\n        )\n\n        today_dict: Dict[str, MtgjsonPricesObject] = {}\n\n        card_rows = request_api_response.get(\"dat"
 },
 "667": {
  "name": "card_id",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardkingdom.py",
  "lineno": "78",
  "column": "12",
  "slicing": "['        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.json()\\n', '        request_api_response: Dict[str, Any] = self.download(self.api_url)\\n', '        card_kingdom_id_to_mtgjson = generate_card_mapping(\\n', '        card_kingdom_id_to_mtgjson.update(\\n', '        card_rows = request_api_response.get(\"data\", [])\\n', '        for card in card_rows:\\n', '            card_id = str(card[\"id\"])\\n', '            if card_id not in card_kingdom_id_to_mtgjson:\\n', '            mtgjson_uuid = card_kingdom_id_to_mtgjson[card_id]\\n', '            if mtgjson_uuid not in today_dict:\\n', '                today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '            if card[\"is_foil\"] == \"true\":\\n', '                today_dict[mtgjson_uuid].sell_foil = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_foil = float(card[\"price_buy\"])\\n', '                today_dict[mtgjson_uuid].sell_normal = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_normal = float(card[\"price_buy\"])\\n']",
  "context": "\", [])\n        for card in card_rows:\n            card_id = str(card[\"id\"])\n            if card_id not in card_kingdom_id_to_m"
 },
 "668": {
  "name": "mtgjson_uuid",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardkingdom.py",
  "lineno": "82",
  "column": "12",
  "slicing": "['        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.json()\\n', '        request_api_response: Dict[str, Any] = self.download(self.api_url)\\n', '        card_kingdom_id_to_mtgjson = generate_card_mapping(\\n', '        card_kingdom_id_to_mtgjson.update(\\n', '        card_rows = request_api_response.get(\"data\", [])\\n', '        for card in card_rows:\\n', '            card_id = str(card[\"id\"])\\n', '            if card_id not in card_kingdom_id_to_mtgjson:\\n', '            mtgjson_uuid = card_kingdom_id_to_mtgjson[card_id]\\n', '            if mtgjson_uuid not in today_dict:\\n', '                today_dict[mtgjson_uuid] = MtgjsonPricesObject(\\n', '            if card[\"is_foil\"] == \"true\":\\n', '                today_dict[mtgjson_uuid].sell_foil = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_foil = float(card[\"price_buy\"])\\n', '                today_dict[mtgjson_uuid].sell_normal = float(card[\"price_retail\"])\\n', '                today_dict[mtgjson_uuid].buy_normal = float(card[\"price_buy\"])\\n']",
  "context": "to_mtgjson:\n                continue\n\n            mtgjson_uuid = card_kingdom_id_to_mtgjson[card_id]\n\n            if mtgjson_uuid not in today_dict:\n  "
 },
 "669": {
  "name": "API_ENDPOINT",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/whats_in_standard.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    API_ENDPOINT: str = \"https://whatsinstandard.com/api/v6/standard.json\"\\n']",
  "context": "\"\n    Whats In Standard API provider\n    \"\"\"\n\n    API_ENDPOINT: str = \"https://whatsinstandard.com/api/v6/standard.json\"\n    set_codes: Set[str]\n    standard_legal_sets: S"
 },
 "670": {
  "name": "set_codes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/whats_in_standard.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    set_codes: Set[str]\\n']",
  "context": "s://whatsinstandard.com/api/v6/standard.json\"\n    set_codes: Set[str]\n    standard_legal_sets: Set[str]\n\n    def __init_"
 },
 "671": {
  "name": "standard_legal_sets",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/whats_in_standard.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    standard_legal_sets: Set[str]\\n']",
  "context": "api/v6/standard.json\"\n    set_codes: Set[str]\n    standard_legal_sets: Set[str]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "672": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/whats_in_standard.py",
  "lineno": "42",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "\"\"\"\n        return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from Whats in"
 },
 "673": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/whats_in_standard.py",
  "lineno": "42",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "  return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from Whats in"
 },
 "674": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/whats_in_standard.py",
  "lineno": "49",
  "column": "8",
  "slicing": "['        session = retryable_session()\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        if not response.ok:\\n', '                f\"WhatsInStandard Download Error ({response.status_code}): {response.content.decode()}\"\\n', '        return response.json()\\n']",
  "context": "ams: Options for URL download\n        \"\"\"\n        session = retryable_session()\n        response = session.get(url)\n        self.l"
 },
 "675": {
  "name": "standard_set_codes",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/whats_in_standard.py",
  "lineno": "71",
  "column": "8",
  "slicing": "['        standard_set_codes = {\\n', '        self.standard_legal_sets = standard_set_codes\\n', '        return standard_set_codes\\n']",
  "context": "ponse = self.download(self.API_ENDPOINT)\n\n        standard_set_codes = {\n            set_object.get(\"code\", \"\").upper()\n   "
 },
 "676": {
  "name": "class_id",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/abstract.py",
  "lineno": "22",
  "column": "4",
  "slicing": "['    class_id: str\\n']",
  "context": " what other providers should provide\n    \"\"\"\n\n    class_id: str\n    session_header: Dict[str, str]\n    today_date:"
 },
 "677": {
  "name": "session_header",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/abstract.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    session_header: Dict[str, str]\\n']",
  "context": "ers should provide\n    \"\"\"\n\n    class_id: str\n    session_header: Dict[str, str]\n    today_date: str = datetime.datetime.today().st"
 },
 "678": {
  "name": "today_date",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/abstract.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    today_date: str = datetime.datetime.today().strftime(\"%Y-%m-%d\")\\n']",
  "context": "ss_id: str\n    session_header: Dict[str, str]\n    today_date: str = datetime.datetime.today().strftime(\"%Y-%m-%d\")\n\n    def __init__(self, headers: Dict[str, str]):\n"
 },
 "679": {
  "name": "headers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/abstract.py",
  "lineno": "26",
  "column": "23",
  "slicing": "['    def __init__(self, headers: Dict[str, str]):\\n']",
  "context": "ay().strftime(\"%Y-%m-%d\")\n\n    def __init__(self, headers: Dict[str, str]):\n        super().__init__()\n        self.class_id ="
 },
 "680": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/abstract.py",
  "lineno": "41",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "\"\n\n    @abc.abstractmethod\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download an object from a serv"
 },
 "681": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/abstract.py",
  "lineno": "41",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "c.abstractmethod\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download an object from a serv"
 },
 "682": {
  "name": "cls",
  "type": "providers.abstract.AbstractProvider",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/abstract.py",
  "lineno": "50",
  "column": "23",
  "slicing": "['    def get_class_name(cls) -> str:\\n']",
  "context": "s Methods\n    @classmethod\n    def get_class_name(cls) -> str:\n        \"\"\"\n        Get the name of the calling cl"
 },
 "683": {
  "name": "cls",
  "type": "providers.abstract.AbstractProvider",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/abstract.py",
  "lineno": "58",
  "column": "21",
  "slicing": "['    def get_class_id(cls) -> str:\\n']",
  "context": "s.__name__\n\n    @classmethod\n    def get_class_id(cls) -> str:\n        \"\"\"\n        Grab the class ID for hashing "
 },
 "684": {
  "name": "response",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/abstract.py",
  "lineno": "74",
  "column": "21",
  "slicing": "['    def log_download(response: Any) -> None:\\n']",
  "context": "rn CONFIG\n\n    @staticmethod\n    def log_download(response: Any) -> None:\n        \"\"\"\n        Log how the URL was acquired\n "
 },
 "685": {
  "name": "class_id",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    class_id: str = \"sf\"\\n']",
  "context": "der):\n    \"\"\"\n    Scryfall container\n    \"\"\"\n\n    class_id: str = \"sf\"\n    ALL_SETS_URL: str = \"https://api.scryfall.com/"
 },
 "686": {
  "name": "ALL_SETS_URL",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['    ALL_SETS_URL: str = \"https://api.scryfall.com/sets/\"\\n']",
  "context": "l container\n    \"\"\"\n\n    class_id: str = \"sf\"\n    ALL_SETS_URL: str = \"https://api.scryfall.com/sets/\"\n    CARDS_URL: str = \"https://api.scryfall.com/car"
 },
 "687": {
  "name": "CARDS_URL",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "25",
  "column": "4",
  "slicing": "['    CARDS_URL: str = \"https://api.scryfall.com/cards/\"\\n']",
  "context": "S_URL: str = \"https://api.scryfall.com/sets/\"\n    CARDS_URL: str = \"https://api.scryfall.com/cards/\"\n    VARIATIONS_URL: str = \"https://api.scryfall.co"
 },
 "688": {
  "name": "VARIATIONS_URL",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    VARIATIONS_URL: str = \"https://api.scryfall.com/cards/search?q=is%3Avariation%20set%3A{0}&unique=prints\"\\n']",
  "context": "_URL: str = \"https://api.scryfall.com/cards/\"\n    VARIATIONS_URL: str = \"https://api.scryfall.com/cards/search?q=is%3Avariation%20set%3A{0}&unique=prints\"\n    CARDS_WITHOUT_LIMITS_URL: str = \"https://api.s"
 },
 "689": {
  "name": "CARDS_WITHOUT_LIMITS_URL",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "27",
  "column": "4",
  "slicing": "['    CARDS_WITHOUT_LIMITS_URL: str = \"https://api.scryfall.com/cards/search?q=(o:deck%20o:any%20o:number%20o:cards%20o:named)\"\\n']",
  "context": "h?q=is%3Avariation%20set%3A{0}&unique=prints\"\n    CARDS_WITHOUT_LIMITS_URL: str = \"https://api.scryfall.com/cards/search?q=(o:deck%20o:any%20o:number%20o:cards%20o:named)\"\n    CARDS_IN_BASE_SET_URL: str = \"https://api.scry"
 },
 "690": {
  "name": "CARDS_IN_BASE_SET_URL",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    CARDS_IN_BASE_SET_URL: str = \"https://api.scryfall.com/cards/search?order=set&q=set:{0}%20is:booster%20unique:prints\"\\n']",
  "context": "deck%20o:any%20o:number%20o:cards%20o:named)\"\n    CARDS_IN_BASE_SET_URL: str = \"https://api.scryfall.com/cards/search?order=set&q=set:{0}%20is:booster%20unique:prints\"\n    CARDS_IN_SET: str = (\n        \"https://api.scr"
 },
 "691": {
  "name": "CARDS_IN_SET",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "29",
  "column": "4",
  "slicing": "['    CARDS_IN_SET: str = (\\n']",
  "context": "r=set&q=set:{0}%20is:booster%20unique:prints\"\n    CARDS_IN_SET: str = (\n        \"https://api.scryfall.com/cards/search?ord"
 },
 "692": {
  "name": "TYPE_CATALOG",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "32",
  "column": "4",
  "slicing": "['    TYPE_CATALOG: str = \"https://api.scryfall.com/catalog/{0}\"\\n']",
  "context": "ch?order=set&q=set:{0}%20unique:prints\"\n    )\n    TYPE_CATALOG: str = \"https://api.scryfall.com/catalog/{0}\"\n    cards_without_limits: Set[str]\n\n    def __init"
 },
 "693": {
  "name": "cards_without_limits",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['    cards_without_limits: Set[str]\\n']",
  "context": " str = \"https://api.scryfall.com/catalog/{0}\"\n    cards_without_limits: Set[str]\n\n    def __init__(self) -> None:\n        super()._"
 },
 "694": {
  "name": "headers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "57",
  "column": "8",
  "slicing": "['        headers: Dict[str, str] = {\\n', '        return headers\\n']",
  "context": "ode\"\n            )\n            return {}\n\n        headers: Dict[str, str] = {\n            \"Authorization\": f\"Bearer {config.get("
 },
 "695": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "65",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "limits(calls=40, period=1)\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from Scryfall"
 },
 "696": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "65",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "ls=40, period=1)\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from Scryfall"
 },
 "697": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "72",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"Scryfall\" not in config.sections():\\n', '            LOGGER.warning(\\n', '        if not config.get(\"Scryfall\", \"client_secret\"):\\n', '            LOGGER.warning(\\n', '        headers: Dict[str, str] = {\\n', '            \"Authorization\": f\"Bearer {config.get(\\'Scryfall\\', \\'client_secret\\')}\",\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '            return response.json()\\n', '            if \"504\" in response.text:\\n', '                LOGGER.warning(\"Scryfall 504 error, sleeping...\")\\n', '                LOGGER.error(\\n', '                    f\\'Unable to convert response: \"{response.text}\" to JSON for URL: {url} -> {error}\\'\\n', '        LOGGER.info(f\"Downloading {set_code} cards\")\\n', '                LOGGER.info(f\"Downloading {set_code} cards failed -- Set not found\")\\n', '                LOGGER.error(f\\'Scryfall download failure: {set_api_json[\"details\"]}\\')\\n', '                LOGGER.info(\\n', '                        LOGGER.warning(\\n', '            LOGGER.error(f\"Unable to build {catalog_key}. Not found\")\\n']",
  "context": "ams: Options for URL download\n        \"\"\"\n        session = retryable_session()\n        session.headers.update(self.session_header"
 },
 "698": {
  "name": "set_code",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "89",
  "column": "29",
  "slicing": "['    def download_cards(self, set_code: str) -> List[Dict[str, Any]]:\\n']",
  "context": "wnload(url, params)\n\n    def download_cards(self, set_code: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Connects to Scryfall API and g"
 },
 "699": {
  "name": "set_api_json",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "97",
  "column": "8",
  "slicing": "['        set_api_json: Dict[str, Any] = self.download(self.ALL_SETS_URL + set_code)\\n', '        if set_api_json[\"object\"] == \"error\":\\n', '            if set_api_json[\"details\"].startswith(\"No Magic set found\"):\\n', '                LOGGER.error(f\\'Scryfall download failure: {set_api_json[\"details\"]}\\')\\n', '            [set_api_json.get(\"search_uri\"), self.VARIATIONS_URL.format(set_code)]\\n']",
  "context": "GER.info(f\"Downloading {set_code} cards\")\n        set_api_json: Dict[str, Any] = self.download(self.ALL_SETS_URL + set_code)\n        if set_api_json[\"object\"] == \"error\":\n    "
 },
 "700": {
  "name": "scryfall_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "106",
  "column": "8",
  "slicing": "['        scryfall_cards: List[Dict[str, Any]] = []\\n', '                    scryfall_cards.append(card_obj)\\n', '            scryfall_cards, key=lambda card: (card[\"name\"], card[\"collector_number\"])\\n']",
  "context": "\n        # All cards in the set structure\n        scryfall_cards: List[Dict[str, Any]] = []\n\n        # Download both normal card and variation"
 },
 "701": {
  "name": "page_downloaded",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "113",
  "column": "12",
  "slicing": "['            page_downloaded: int = 1\\n', '                    f\"Downloading {set_code} card data page {setup_index} - {page_downloaded}\"\\n']",
  "context": " append all the data, go to next page\n            page_downloaded: int = 1\n            while cards_api_url:\n                L"
 },
 "702": {
  "name": "cards_api_json",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "120",
  "column": "16",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        config = self.get_configs()\\n', '        if \"Scryfall\" not in config.sections():\\n', '            LOGGER.warning(\\n', '        if not config.get(\"Scryfall\", \"client_secret\"):\\n', '            LOGGER.warning(\\n', '        headers: Dict[str, str] = {\\n', '            \"Authorization\": f\"Bearer {config.get(\\'Scryfall\\', \\'client_secret\\')}\",\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '            return response.json()\\n', '            if \"504\" in response.text:\\n', '                LOGGER.warning(\"Scryfall 504 error, sleeping...\")\\n', '                LOGGER.error(\\n', '                    f\\'Unable to convert response: \"{response.text}\" to JSON for URL: {url} -> {error}\\'\\n', '        LOGGER.info(f\"Downloading {set_code} cards\")\\n', '        set_api_json: Dict[str, Any] = self.download(self.ALL_SETS_URL + set_code)\\n', '        if set_api_json[\"object\"] == \"error\":\\n', '            if set_api_json[\"details\"].startswith(\"No Magic set found\"):\\n', '                LOGGER.info(f\"Downloading {set_code} cards failed -- Set not found\")\\n', '                LOGGER.error(f\\'Scryfall download failure: {set_api_json[\"details\"]}\\')\\n', '        scryfall_cards: List[Dict[str, Any]] = []\\n', '        for setup_index, cards_api_url in enumerate(\\n', '            [set_api_json.get(\"search_uri\"), self.VARIATIONS_URL.format(set_code)]\\n', '            page_downloaded: int = 1\\n', '            while cards_api_url:\\n', '                LOGGER.info(\\n', '                    f\"Downloading {set_code} card data page {setup_index} - {page_downloaded}\"\\n', '                page_downloaded += 1\\n', '                cards_api_json: Dict[str, Any] = self.download(cards_api_url)\\n', '                if cards_api_json[\"object\"] == \"error\":\\n', '                    if not cards_api_json[\"details\"].startswith(\\n', '                        LOGGER.warning(\\n', '                            f\"Error downloading {set_code}: {cards_api_json}\"\\n', '                for card_obj in cards_api_json[\"data\"]:\\n', '                    scryfall_cards.append(card_obj)\\n', '                if not cards_api_json.get(\"has_more\"):\\n', '                cards_api_url = cards_api_json.get(\"next_page\")\\n', '            scryfall_cards, key=lambda card: (card[\"name\"], card[\"collector_number\"])\\n', '            LOGGER.error(f\"Unable to build {catalog_key}. Not found\")\\n']",
  "context": "            page_downloaded += 1\n\n                cards_api_json: Dict[str, Any] = self.download(cards_api_url)\n                if cards_api_json[\"object\"] == \"er"
 },
 "703": {
  "name": "catalog_key",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/scryfall.py",
  "lineno": "157",
  "column": "32",
  "slicing": "['    def get_catalog_entry(self, catalog_key: str) -> List[str]:\\n']",
  "context": "data\"]\n        }\n\n    def get_catalog_entry(self, catalog_key: str) -> List[str]:\n        \"\"\"\n        Grab the Scryfall catalog of a"
 },
 "704": {
  "name": "repo_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_mtgsqlite.py",
  "lineno": "28",
  "column": "4",
  "slicing": "['    repo_url: str = \"https://github.com/mtgjson/mtgsqlive/\"\\n']",
  "context": "   GitHubMTGSqliteProvider container\n    \"\"\"\n\n    repo_url: str = \"https://github.com/mtgjson/mtgsqlive/\"\n    all_printings_file: pathlib.Path = OUTPUT_PATH"
 },
 "705": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_mtgsqlite.py",
  "lineno": "48",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "\"\"\"\n        return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from GitHub\n "
 },
 "706": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_mtgsqlite.py",
  "lineno": "48",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "  return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from GitHub\n "
 },
 "707": {
  "name": "decks_api_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_decks.py",
  "lineno": "26",
  "column": "4",
  "slicing": "['    decks_api_url: str = \"https://github.com/taw/magic-preconstructed-decks-data/blob/master/decks_v2.json?raw=true\"\\n']",
  "context": "\"\"\n    GitHubDecksProvider container\n    \"\"\"\n\n    decks_api_url: str = \"https://github.com/taw/magic-preconstructed-decks-data/blob/master/decks_v2.json?raw=true\"\n    all_printings_file: pathlib.Path = OUTPUT_PATH"
 },
 "708": {
  "name": "all_printings_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_decks.py",
  "lineno": "30",
  "column": "4",
  "slicing": "['    all_printings_cards: Dict[str, Any]\\n']",
  "context": "StructuresObject().all_printings}.json\"\n    )\n    all_printings_cards: Dict[str, Any]\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "709": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_decks.py",
  "lineno": "45",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "\"\"\"\n        return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from GitHub\n "
 },
 "710": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_decks.py",
  "lineno": "45",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "  return dict()\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from GitHub\n "
 },
 "711": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_decks.py",
  "lineno": "51",
  "column": "8",
  "slicing": "['        session = retryable_session()\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        if response.ok:\\n', '            return response.json()\\n', '        LOGGER.error(f\"Error downloading GitHub Decks: {response} --- {response.text}\")\\n']",
  "context": "ams: Options for URL download\n        \"\"\"\n        session = retryable_session()\n\n        response = session.get(url)\n        self."
 },
 "712": {
  "name": "this_deck",
  "type": "classes.mtgjson_deck.MtgjsonDeckObject",
  "class": "customized",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_decks.py",
  "lineno": "79",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        session = retryable_session()\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        if response.ok:\\n', '            return response.json()\\n', '        LOGGER.error(f\"Error downloading GitHub Decks: {response} --- {response.text}\")\\n', '            LOGGER.error(\"Unable to construct decks. AllPrintings not found\")\\n', '            LOGGER.error(\"Unable to construct decks. AllPrintings not fully formed\")\\n', '        with self.all_printings_file.open(encoding=\"utf-8\") as file:\\n', '            self.all_printings_cards = json.load(file).get(\"data\", {})\\n', '            this_deck = MtgjsonDeckObject()\\n', '            this_deck.name = deck[\"name\"]\\n', '            this_deck.code = deck[\"set_code\"].upper()\\n', '            this_deck.set_sanitized_name(this_deck.name)\\n', '            this_deck.type = deck[\"type\"]\\n', '            this_deck.release_date = deck[\"release_date\"]\\n', '                this_deck.main_board = parallel_call(\\n', '                this_deck.side_board = parallel_call(\\n', '                this_deck.commander = parallel_call(\\n', '                LOGGER.warning(\\n', '                    f\\'GitHub Deck \"{this_deck.name}\" failed to build -- Missing Set {error}\\'\\n', '            yield this_deck\\n', '        LOGGER.warning(f\"Set {card[\\'set_code\\'].upper()} not found for {card[\\'name\\']}\")\\n', '        LOGGER.warning(f\"No matches found for {card}\")\\n']",
  "context": "in self.download(self.decks_api_url):\n            this_deck = MtgjsonDeckObject()\n            this_deck.name = deck[\"name\"]\n        "
 },
 "713": {
  "name": "card",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_decks.py",
  "lineno": "105",
  "column": "22",
  "slicing": "['def build_single_card(card: Dict[str, Any]) -> List[Dict[str, Any]]:\\n']",
  "context": "          yield this_deck\n\n\ndef build_single_card(card: Dict[str, Any]) -> List[Dict[str, Any]]:\n    \"\"\"\n    Given a card, add components necessary"
 },
 "714": {
  "name": "cards",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/github_decks.py",
  "lineno": "112",
  "column": "4",
  "slicing": "['    cards = []\\n', '            cards.append(mtgjson_card)\\n', '    if not cards:\\n', '    return cards\\n']",
  "context": "return: List of enhanced cards in set\n    \"\"\"\n    cards = []\n    set_to_build_from = GitHubDecksProvider().all_"
 },
 "715": {
  "name": "ch_api_url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    ch_api_url: str = \"https://www.cardhoarder.com/affiliates/pricefile/{}\"\\n']",
  "context": "):\n    \"\"\"\n    CardHoarder container\n    \"\"\"\n\n    ch_api_url: str = \"https://www.cardhoarder.com/affiliates/pricefile/{}\"\n\n    def __init__(self) -> None:\n        \"\"\"\n     "
 },
 "716": {
  "name": "headers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "36",
  "column": "8",
  "slicing": "['        headers: Dict[str, str] = {}\\n', '            return headers\\n', '        return headers\\n']",
  "context": ":return: Authorization header\n        \"\"\"\n        headers: Dict[str, str] = {}\n        __keys_found: bool\n\n        config = self."
 },
 "717": {
  "name": "__keys_found",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "37",
  "column": "8",
  "slicing": "['        __keys_found: bool\\n']",
  "context": " \"\"\"\n        headers: Dict[str, str] = {}\n        __keys_found: bool\n\n        config = self.get_configs()\n\n        if \""
 },
 "718": {
  "name": "url",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "57",
  "column": "23",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": "\"\n\n        return headers\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from Scryfall"
 },
 "719": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "57",
  "column": "33",
  "slicing": "['    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\\n']",
  "context": " return headers\n\n    def download(self, url: str, params: Dict[str, Union[str, int]] = None) -> Any:\n        \"\"\"\n        Download content from Scryfall"
 },
 "720": {
  "name": "session",
  "type": "utils.retryable_session",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "64",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"CardHoarder\" not in config.sections():\\n', '            LOGGER.warning(\"CardHoarder section not established. Skipping upload\")\\n', '            return headers\\n', '        if config.get(\"CardHoarder\", \"token\"):\\n', '            self.ch_api_url = self.ch_api_url.format(config.get(\"CardHoarder\", \"token\"))\\n', '            LOGGER.info(\"CardHoarder keys values missing. Skipping pricing\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '                LOGGER.debug(f\"CardHoarder {card_row} unable to be mapped, skipping\")\\n', '                LOGGER.warning(f\"CardHoarder entry {card_row} malformed, skipping\")\\n']",
  "context": "ams: Options for URL download\n        \"\"\"\n        session = retryable_session()\n        session.headers.update(self.session_header"
 },
 "721": {
  "name": "url_to_parse",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "73",
  "column": "14",
  "slicing": "['        self, url_to_parse: str, mtgo_to_mtgjson_map: Dict[str, str]\\n']",
  "context": "def convert_cardhoarder_to_mtgjson(\n        self, url_to_parse: str, mtgo_to_mtgjson_map: Dict[str, str]\n    ) -> Dict[str, float]:\n        \"\"\"\n        Dow"
 },
 "722": {
  "name": "mtgo_to_mtgjson_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "73",
  "column": "33",
  "slicing": "['        self, url_to_parse: str, mtgo_to_mtgjson_map: Dict[str, str]\\n']",
  "context": "rder_to_mtgjson(\n        self, url_to_parse: str, mtgo_to_mtgjson_map: Dict[str, str]\n    ) -> Dict[str, float]:\n        \"\"\"\n        Dow"
 },
 "723": {
  "name": "mtgjson_price_map",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "82",
  "column": "8",
  "slicing": "['        mtgjson_price_map = {}\\n', '            mtgjson_price_map[card_uuid] = float(card_row[5])\\n', '        return mtgjson_price_map\\n']",
  "context": "return: Consumable dictionary\n        \"\"\"\n        mtgjson_price_map = {}\n\n        request_api_response: str = self.download"
 },
 "724": {
  "name": "request_api_response",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "84",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"CardHoarder\" not in config.sections():\\n', '            LOGGER.warning(\"CardHoarder section not established. Skipping upload\")\\n', '            return headers\\n', '        if config.get(\"CardHoarder\", \"token\"):\\n', '            self.ch_api_url = self.ch_api_url.format(config.get(\"CardHoarder\", \"token\"))\\n', '            LOGGER.info(\"CardHoarder keys values missing. Skipping pricing\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        request_api_response: str = self.download(url_to_parse)\\n', '        file_rows: List[str] = request_api_response.splitlines()[2:]\\n', '        for file_row in file_rows:\\n', '            card_row = file_row.split(\"\\\\t\")\\n', '            mtgo_id = card_row[0]\\n', '            card_uuid = mtgo_to_mtgjson_map.get(mtgo_id)\\n', '            if not card_uuid:\\n', '                LOGGER.debug(f\"CardHoarder {card_row} unable to be mapped, skipping\")\\n', '            if len(card_row) <= 6:\\n', '                LOGGER.warning(f\"CardHoarder entry {card_row} malformed, skipping\")\\n', '            mtgjson_price_map[card_uuid] = float(card_row[5])\\n']",
  "context": "      \"\"\"\n        mtgjson_price_map = {}\n\n        request_api_response: str = self.download(url_to_parse)\n\n        # All Entries from CH, cutting off header"
 },
 "725": {
  "name": "file_rows",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "87",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"CardHoarder\" not in config.sections():\\n', '            LOGGER.warning(\"CardHoarder section not established. Skipping upload\")\\n', '            return headers\\n', '        if config.get(\"CardHoarder\", \"token\"):\\n', '            self.ch_api_url = self.ch_api_url.format(config.get(\"CardHoarder\", \"token\"))\\n', '            LOGGER.info(\"CardHoarder keys values missing. Skipping pricing\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        request_api_response: str = self.download(url_to_parse)\\n', '        file_rows: List[str] = request_api_response.splitlines()[2:]\\n', '        for file_row in file_rows:\\n', '            card_row = file_row.split(\"\\\\t\")\\n', '            mtgo_id = card_row[0]\\n', '            card_uuid = mtgo_to_mtgjson_map.get(mtgo_id)\\n', '            if not card_uuid:\\n', '                LOGGER.debug(f\"CardHoarder {card_row} unable to be mapped, skipping\")\\n', '            if len(card_row) <= 6:\\n', '                LOGGER.warning(f\"CardHoarder entry {card_row} malformed, skipping\")\\n', '            mtgjson_price_map[card_uuid] = float(card_row[5])\\n']",
  "context": " All Entries from CH, cutting off headers\n        file_rows: List[str] = request_api_response.splitlines()[2:]\n        for file_row in file_rows:\n            car"
 },
 "726": {
  "name": "mtgo_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "91",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"CardHoarder\" not in config.sections():\\n', '            LOGGER.warning(\"CardHoarder section not established. Skipping upload\")\\n', '            return headers\\n', '        if config.get(\"CardHoarder\", \"token\"):\\n', '            self.ch_api_url = self.ch_api_url.format(config.get(\"CardHoarder\", \"token\"))\\n', '            LOGGER.info(\"CardHoarder keys values missing. Skipping pricing\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        request_api_response: str = self.download(url_to_parse)\\n', '        file_rows: List[str] = request_api_response.splitlines()[2:]\\n', '        for file_row in file_rows:\\n', '            card_row = file_row.split(\"\\\\t\")\\n', '            mtgo_id = card_row[0]\\n', '            card_uuid = mtgo_to_mtgjson_map.get(mtgo_id)\\n', '            if not card_uuid:\\n', '                LOGGER.debug(f\"CardHoarder {card_row} unable to be mapped, skipping\")\\n', '            if len(card_row) <= 6:\\n', '                LOGGER.warning(f\"CardHoarder entry {card_row} malformed, skipping\")\\n', '            mtgjson_price_map[card_uuid] = float(card_row[5])\\n']",
  "context": "     card_row = file_row.split(\"\\t\")\n\n            mtgo_id = card_row[0]\n            card_uuid = mtgo_to_mtgjson_map.get(mt"
 },
 "727": {
  "name": "all_printings_path",
  "type": "typing.Any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "107",
  "column": "14",
  "slicing": "['        self, all_printings_path: Any\\n']",
  "context": "\n    def generate_today_price_dict(\n        self, all_printings_path: Any\n    ) -> Dict[str, MtgjsonPricesObject]:\n        \""
 },
 "728": {
  "name": "mtgo_to_mtgjson_map",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "116",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"CardHoarder\" not in config.sections():\\n', '            LOGGER.warning(\"CardHoarder section not established. Skipping upload\")\\n', '            return headers\\n', '        if config.get(\"CardHoarder\", \"token\"):\\n', '            self.ch_api_url = self.ch_api_url.format(config.get(\"CardHoarder\", \"token\"))\\n', '            LOGGER.info(\"CardHoarder keys values missing. Skipping pricing\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        mtgjson_price_map = {}\\n', '        request_api_response: str = self.download(url_to_parse)\\n', '        file_rows: List[str] = request_api_response.splitlines()[2:]\\n', '        for file_row in file_rows:\\n', '            card_row = file_row.split(\"\\\\t\")\\n', '            mtgo_id = card_row[0]\\n', '            card_uuid = mtgo_to_mtgjson_map.get(mtgo_id)\\n', '            if not card_uuid:\\n', '                LOGGER.debug(f\"CardHoarder {card_row} unable to be mapped, skipping\")\\n', '            if len(card_row) <= 6:\\n', '                LOGGER.warning(f\"CardHoarder entry {card_row} malformed, skipping\")\\n', '            mtgjson_price_map[card_uuid] = float(card_row[5])\\n', '        return mtgjson_price_map\\n', '        mtgo_to_mtgjson_map = self.get_mtgo_to_mtgjson_map(all_printings_path)\\n', '            self.ch_api_url, mtgo_to_mtgjson_map\\n', '            self.ch_api_url + \"/foil\", mtgo_to_mtgjson_map\\n']",
  "context": "self.__keys_found:\n            return {}\n\n        mtgo_to_mtgjson_map = self.get_mtgo_to_mtgjson_map(all_printings_path)\n\n        normal_cards = self.convert_cardhoarder_t"
 },
 "729": {
  "name": "normal_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "118",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"CardHoarder\" not in config.sections():\\n', '            LOGGER.warning(\"CardHoarder section not established. Skipping upload\")\\n', '            return headers\\n', '        if config.get(\"CardHoarder\", \"token\"):\\n', '            self.ch_api_url = self.ch_api_url.format(config.get(\"CardHoarder\", \"token\"))\\n', '            LOGGER.info(\"CardHoarder keys values missing. Skipping pricing\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        mtgjson_price_map = {}\\n', '        request_api_response: str = self.download(url_to_parse)\\n', '        file_rows: List[str] = request_api_response.splitlines()[2:]\\n', '        for file_row in file_rows:\\n', '            card_row = file_row.split(\"\\\\t\")\\n', '            mtgo_id = card_row[0]\\n', '            card_uuid = mtgo_to_mtgjson_map.get(mtgo_id)\\n', '            if not card_uuid:\\n', '                LOGGER.debug(f\"CardHoarder {card_row} unable to be mapped, skipping\")\\n', '            if len(card_row) <= 6:\\n', '                LOGGER.warning(f\"CardHoarder entry {card_row} malformed, skipping\")\\n', '            mtgjson_price_map[card_uuid] = float(card_row[5])\\n', '        return mtgjson_price_map\\n', '        mtgo_to_mtgjson_map = self.get_mtgo_to_mtgjson_map(all_printings_path)\\n', '        normal_cards = self.convert_cardhoarder_to_mtgjson(\\n', '            self.ch_api_url, mtgo_to_mtgjson_map\\n', '            self.ch_api_url + \"/foil\", mtgo_to_mtgjson_map\\n', '        self._construct_for_cards(db_contents, normal_cards, True)\\n']",
  "context": "_mtgo_to_mtgjson_map(all_printings_path)\n\n        normal_cards = self.convert_cardhoarder_to_mtgjson(\n            self.ch_api_url, mtgo_to_mtgjson_map\n "
 },
 "730": {
  "name": "foil_cards",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "121",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"CardHoarder\" not in config.sections():\\n', '            LOGGER.warning(\"CardHoarder section not established. Skipping upload\")\\n', '            return headers\\n', '        if config.get(\"CardHoarder\", \"token\"):\\n', '            self.ch_api_url = self.ch_api_url.format(config.get(\"CardHoarder\", \"token\"))\\n', '            LOGGER.info(\"CardHoarder keys values missing. Skipping pricing\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        mtgjson_price_map = {}\\n', '        request_api_response: str = self.download(url_to_parse)\\n', '        file_rows: List[str] = request_api_response.splitlines()[2:]\\n', '        for file_row in file_rows:\\n', '            card_row = file_row.split(\"\\\\t\")\\n', '            mtgo_id = card_row[0]\\n', '            card_uuid = mtgo_to_mtgjson_map.get(mtgo_id)\\n', '            if not card_uuid:\\n', '                LOGGER.debug(f\"CardHoarder {card_row} unable to be mapped, skipping\")\\n', '            if len(card_row) <= 6:\\n', '                LOGGER.warning(f\"CardHoarder entry {card_row} malformed, skipping\")\\n', '            mtgjson_price_map[card_uuid] = float(card_row[5])\\n', '        return mtgjson_price_map\\n', '        mtgo_to_mtgjson_map = self.get_mtgo_to_mtgjson_map(all_printings_path)\\n', '            self.ch_api_url, mtgo_to_mtgjson_map\\n', '        foil_cards = self.convert_cardhoarder_to_mtgjson(\\n', '            self.ch_api_url + \"/foil\", mtgo_to_mtgjson_map\\n', '        self._construct_for_cards(db_contents, foil_cards)\\n']",
  "context": "ch_api_url, mtgo_to_mtgjson_map\n        )\n        foil_cards = self.convert_cardhoarder_to_mtgjson(\n            self.ch_api_url + \"/foil\", mtgo_to_mtg"
 },
 "731": {
  "name": "db_contents",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "125",
  "column": "8",
  "slicing": "['        db_contents: Dict[str, MtgjsonPricesObject] = {}\\n', '        self._construct_for_cards(db_contents, normal_cards, True)\\n', '        self._construct_for_cards(db_contents, foil_cards)\\n', '        return db_contents\\n']",
  "context": "+ \"/foil\", mtgo_to_mtgjson_map\n        )\n\n        db_contents: Dict[str, MtgjsonPricesObject] = {}\n\n        self._construct_for_cards(db_contents, no"
 },
 "732": {
  "name": "semi_completed_data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "133",
  "column": "8",
  "slicing": "['        semi_completed_data: Dict[str, MtgjsonPricesObject],\\n']",
  "context": "  def _construct_for_cards(\n        self,\n        semi_completed_data: Dict[str, MtgjsonPricesObject],\n        cards: Dict[str, float],\n        is_mtgo_n"
 },
 "733": {
  "name": "cards",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "134",
  "column": "8",
  "slicing": "['        cards: Dict[str, float],\\n']",
  "context": "ted_data: Dict[str, MtgjsonPricesObject],\n        cards: Dict[str, float],\n        is_mtgo_normal: bool = False,\n    ) -> Non"
 },
 "734": {
  "name": "is_mtgo_normal",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "135",
  "column": "8",
  "slicing": "['        is_mtgo_normal: bool = False,\\n']",
  "context": "Object],\n        cards: Dict[str, float],\n        is_mtgo_normal: bool = False,\n    ) -> None:\n        \"\"\"\n        Construct MTGJS"
 },
 "735": {
  "name": "mtgo_to_mtgjson",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "160",
  "column": "8",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"CardHoarder\" not in config.sections():\\n', '            LOGGER.warning(\"CardHoarder section not established. Skipping upload\")\\n', '            return headers\\n', '        if config.get(\"CardHoarder\", \"token\"):\\n', '            self.ch_api_url = self.ch_api_url.format(config.get(\"CardHoarder\", \"token\"))\\n', '            LOGGER.info(\"CardHoarder keys values missing. Skipping pricing\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        mtgjson_price_map = {}\\n', '        request_api_response: str = self.download(url_to_parse)\\n', '        file_rows: List[str] = request_api_response.splitlines()[2:]\\n', '        for file_row in file_rows:\\n', '            card_row = file_row.split(\"\\\\t\")\\n', '            mtgo_id = card_row[0]\\n', '            card_uuid = mtgo_to_mtgjson_map.get(mtgo_id)\\n', '            if not card_uuid:\\n', '                LOGGER.debug(f\"CardHoarder {card_row} unable to be mapped, skipping\")\\n', '            if len(card_row) <= 6:\\n', '                LOGGER.warning(f\"CardHoarder entry {card_row} malformed, skipping\")\\n', '            mtgjson_price_map[card_uuid] = float(card_row[5])\\n', '        return mtgjson_price_map\\n', '        mtgo_to_mtgjson_map = self.get_mtgo_to_mtgjson_map(all_printings_path)\\n', '        normal_cards = self.convert_cardhoarder_to_mtgjson(\\n', '            self.ch_api_url, mtgo_to_mtgjson_map\\n', '        foil_cards = self.convert_cardhoarder_to_mtgjson(\\n', '            self.ch_api_url + \"/foil\", mtgo_to_mtgjson_map\\n', '        db_contents: Dict[str, MtgjsonPricesObject] = {}\\n', '        self._construct_for_cards(db_contents, normal_cards, True)\\n', '        self._construct_for_cards(db_contents, foil_cards)\\n', '        return db_contents\\n', '        for key, value in cards.items():\\n', '            if key not in semi_completed_data.keys():\\n', '                semi_completed_data[key] = MtgjsonPricesObject(\\n', '                semi_completed_data[key].sell_normal = float(value)\\n', '                semi_completed_data[key].sell_foil = float(value)\\n', '        mtgo_to_mtgjson = dict()\\n', '                mtgo_to_mtgjson[identifiers[\"mtgoId\"]] = card[\"uuid\"]\\n', '                mtgo_to_mtgjson[identifiers[\"mtgoFoilId\"]] = card[\"uuid\"]\\n', '        return mtgo_to_mtgjson\\n']",
  "context": "eturn MTGO to MTGJSON mapping\n        \"\"\"\n        mtgo_to_mtgjson = dict()\n        for card in get_all_cards_and_tokens(all_p"
 },
 "736": {
  "name": "identifiers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/mtgjson5/providers/cardhoarder.py",
  "lineno": "162",
  "column": "12",
  "slicing": "['LOGGER = logging.getLogger(__name__)\\n', '        headers: Dict[str, str] = {}\\n', '        config = self.get_configs()\\n', '        if \"CardHoarder\" not in config.sections():\\n', '            LOGGER.warning(\"CardHoarder section not established. Skipping upload\")\\n', '            return headers\\n', '        if config.get(\"CardHoarder\", \"token\"):\\n', '            self.ch_api_url = self.ch_api_url.format(config.get(\"CardHoarder\", \"token\"))\\n', '            LOGGER.info(\"CardHoarder keys values missing. Skipping pricing\")\\n', '        return headers\\n', '        session = retryable_session()\\n', '        session.headers.update(self.session_header)\\n', '        response = session.get(url)\\n', '        self.log_download(response)\\n', '        return response.content.decode()\\n', '        mtgjson_price_map = {}\\n', '        request_api_response: str = self.download(url_to_parse)\\n', '        file_rows: List[str] = request_api_response.splitlines()[2:]\\n', '        for file_row in file_rows:\\n', '            card_row = file_row.split(\"\\\\t\")\\n', '            mtgo_id = card_row[0]\\n', '            card_uuid = mtgo_to_mtgjson_map.get(mtgo_id)\\n', '            if not card_uuid:\\n', '                LOGGER.debug(f\"CardHoarder {card_row} unable to be mapped, skipping\")\\n', '            if len(card_row) <= 6:\\n', '                LOGGER.warning(f\"CardHoarder entry {card_row} malformed, skipping\")\\n', '            mtgjson_price_map[card_uuid] = float(card_row[5])\\n', '        return mtgjson_price_map\\n', '        mtgo_to_mtgjson_map = self.get_mtgo_to_mtgjson_map(all_printings_path)\\n', '        normal_cards = self.convert_cardhoarder_to_mtgjson(\\n', '            self.ch_api_url, mtgo_to_mtgjson_map\\n', '        foil_cards = self.convert_cardhoarder_to_mtgjson(\\n', '            self.ch_api_url + \"/foil\", mtgo_to_mtgjson_map\\n', '        db_contents: Dict[str, MtgjsonPricesObject] = {}\\n', '        self._construct_for_cards(db_contents, normal_cards, True)\\n', '        self._construct_for_cards(db_contents, foil_cards)\\n', '        return db_contents\\n', '        for key, value in cards.items():\\n', '            if key not in semi_completed_data.keys():\\n', '                semi_completed_data[key] = MtgjsonPricesObject(\\n', '                semi_completed_data[key].sell_normal = float(value)\\n', '                semi_completed_data[key].sell_foil = float(value)\\n', '        for card in get_all_cards_and_tokens(all_printings_path):\\n', '            identifiers = card[\"identifiers\"]\\n', '            if \"mtgoId\" in identifiers:\\n', '                mtgo_to_mtgjson[identifiers[\"mtgoId\"]] = card[\"uuid\"]\\n', '            if \"mtgoFoilId\" in identifiers:\\n', '                mtgo_to_mtgjson[identifiers[\"mtgoFoilId\"]] = card[\"uuid\"]\\n']",
  "context": "cards_and_tokens(all_printings_path):\n            identifiers = card[\"identifiers\"]\n            if \"mtgoId\" in identifiers:\n          "
 },
 "737": {
  "name": "testdata",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "mtgjson/tests/mtgjson5/providers/test_cardmarket.py",
  "lineno": "11",
  "column": "0",
  "slicing": "['testdata = [\\n', '@pytest.mark.parametrize(\"keys_found,set_map,expected\", testdata)\\n']",
  "context": "t Dict\nfrom singleton_decorator import singleton\n\ntestdata = [\n    pytest.param(\n        True,\n        {\n        "
 }
}