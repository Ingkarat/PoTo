{
 "1": {
  "name": "HEADER",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "6",
  "column": "0",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "port os\nimport platform\nfrom pathlib import Path\n\nHEADER = f'# DO NOT EDIT!\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\n'\n\nPF = platform.system()\n\nHOME_DIR = str(Path.home("
 },
 "2": {
  "name": "HOME_DIR",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "10",
  "column": "0",
  "slicing": "['HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n']",
  "context": ".basename(__file__)}\"\\n'\n\nPF = platform.system()\n\nHOME_DIR = str(Path.home())\nDATA_JSON = {\n    \"Darwin\": HOME_DIR + \"/Library/A"
 },
 "3": {
  "name": "DATA_JSON",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "11",
  "column": "0",
  "slicing": "['DATA_JSON = {\\n', '    with open(DATA_JSON[PF], encoding=\"utf-8\") as data_file:\\n']",
  "context": " = platform.system()\n\nHOME_DIR = str(Path.home())\nDATA_JSON = {\n    \"Darwin\": HOME_DIR + \"/Library/Application Sup"
 },
 "4": {
  "name": "ENUM_TRANSLATE",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "16",
  "column": "0",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "DIR + \"/Documents/StarCraft II/stableid.json\",\n}\n\nENUM_TRANSLATE = {\n    \"Units\": \"UnitTypeId\",\n    \"Abilities\": \"Abili"
 },
 "5": {
  "name": "FILE_TRANSLATE",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "24",
  "column": "0",
  "slicing": "['FILE_TRANSLATE = {\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n']",
  "context": " \"Buffs\": \"BuffId\",\n    \"Effects\": \"EffectId\",\n}\n\nFILE_TRANSLATE = {\n    \"Units\": \"unit_typeid\",\n    \"Abilities\": \"abil"
 },
 "6": {
  "name": "units",
  "type": "parse_simple",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "42",
  "column": "4",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "# Units, Abilities, Upgrades, Buffs, Effects\n\n    units = parse_simple(\"Units\", data)\n    upgrades = parse_simple(\"Upgrades\", data)\n    "
 },
 "7": {
  "name": "upgrades",
  "type": "parse_simple",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "ects\n\n    units = parse_simple(\"Units\", data)\n    upgrades = parse_simple(\"Upgrades\", data)\n    effects = parse_simple(\"Effects\", data)\n    bu"
 },
 "8": {
  "name": "effects",
  "type": "parse_simple",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "    upgrades = parse_simple(\"Upgrades\", data)\n    effects = parse_simple(\"Effects\", data)\n    buffs = parse_simple(\"Buffs\", data)\n\n    abili"
 },
 "9": {
  "name": "buffs",
  "type": "parse_simple",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "45",
  "column": "4",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": ")\n    effects = parse_simple(\"Effects\", data)\n    buffs = parse_simple(\"Buffs\", data)\n\n    abilities = {}\n    for v in data[\"Abilities\"]"
 },
 "10": {
  "name": "abilities",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "47",
  "column": "4",
  "slicing": "['    abilities = {}\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums[\"Abilities\"] = abilities\\n']",
  "context": "ata)\n    buffs = parse_simple(\"Buffs\", data)\n\n    abilities = {}\n    for v in data[\"Abilities\"]:\n        key = v[\"b"
 },
 "11": {
  "name": "key",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "49",
  "column": "8",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "ties = {}\n    for v in data[\"Abilities\"]:\n        key = v[\"buttonname\"]\n        remapid = v.get(\"remapid\")\n\n        if (no"
 },
 "12": {
  "name": "key",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "58",
  "column": "16",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "      if v[\"friendlyname\"] != \"\":\n                key = v[\"friendlyname\"]\n            else:\n                exit(f\"Not mappe"
 },
 "13": {
  "name": "enums",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "80",
  "column": "4",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "s[key] = v[\"id\"]\n\n    abilities[\"SMART\"] = 1\n\n    enums = {}\n    enums[\"Units\"] = units\n    enums[\"Abilities\"] "
 },
 "14": {
  "name": "units",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "91",
  "column": "4",
  "slicing": "['    units = {}\\n', '        if key_to_insert in units:\\n', '            while tmp in units:\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n']",
  "context": "    return enums\n\n\ndef parse_simple(d, data):\n    units = {}\n    for v in data[d]:\n        key = v[\"name\"]\n\n   "
 },
 "15": {
  "name": "key",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "93",
  "column": "8",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "ta):\n    units = {}\n    for v in data[d]:\n        key = v[\"name\"]\n\n        if not key:\n            continue\n        "
 },
 "16": {
  "name": "key_to_insert",
  "type": "make_key",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "97",
  "column": "8",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "\n        if not key:\n            continue\n        key_to_insert = make_key(key)\n        if key_to_insert in units:\n            ind"
 },
 "17": {
  "name": "tmp",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "100",
  "column": "12",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "nsert in units:\n            index = 2\n            tmp = f\"{key_to_insert}_{index}\"\n            while tmp in units:\n                in"
 },
 "18": {
  "name": "tmp",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "103",
  "column": "16",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "units:\n                index += 1\n                tmp = f\"{key_to_insert}_{index}\"\n            key_to_insert = tmp\n        units[key_"
 },
 "19": {
  "name": "key_to_insert",
  "type": "tmp",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "104",
  "column": "12",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "     tmp = f\"{key_to_insert}_{index}\"\n            key_to_insert = tmp\n        units[key_to_insert] = v[\"id\"]\n\n    return"
 },
 "20": {
  "name": "enums",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "110",
  "column": "25",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', 'def generate_python_code(enums):\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "id\"]\n\n    return units\n\n\ndef generate_python_code(enums):\n    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buf"
 },
 "21": {
  "name": "sc2dir",
  "type": "pathlib.Path",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "113",
  "column": "4",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "grades\", \"Buffs\", \"Effects\"} <= enums.keys()\n\n    sc2dir = Path(\"sc2/\")\n    idsdir = sc2dir / \"ids\"\n    idsdir.mkdir(exist"
 },
 "22": {
  "name": "class_name",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "121",
  "column": "8",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "]))\n\n    for name, body in enums.items():\n        class_name = ENUM_TRANSLATE[name]\n\n        code = [HEADER, \"import enum\", \"\", f\"clas"
 },
 "23": {
  "name": "code",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "123",
  "column": "8",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'HOME_DIR = str(Path.home())\\n', '    \"Darwin\": HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\\n', '    \"Windows\": HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\\n', 'ENUM_TRANSLATE = {\\n', 'FILE_TRANSLATE = {\\n', 'def make_key(key):\\n', '        key = \"_\" + key\\n', '    return key.upper().replace(\" \", \"_\")\\n', '    units = parse_simple(\"Units\", data)\\n', '    upgrades = parse_simple(\"Upgrades\", data)\\n', '    effects = parse_simple(\"Effects\", data)\\n', '    buffs = parse_simple(\"Buffs\", data)\\n', '    abilities = {}\\n', '    for v in data[\"Abilities\"]:\\n', '        key = v[\"buttonname\"]\\n', '        remapid = v.get(\"remapid\")\\n', '        if (not key) and (remapid is None):\\n', '            assert v[\"buttonname\"] == \"\"\\n', '        if not key:\\n', '            if v[\"friendlyname\"] != \"\":\\n', '                key = v[\"friendlyname\"]\\n', '                exit(f\"Not mapped: {v !r}\")\\n', '        key = key.upper().replace(\" \", \"_\")\\n', '        if \"name\" in v:\\n', '            key = \"{}_{}\".format(v[\"name\"].upper().replace(\" \", \"_\"), key)\\n', '        if \"friendlyname\" in v:\\n', '            key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\\n', '        if key[0].isdigit():\\n', '            key = \"_\" + key\\n', '        if key in abilities and v[\"index\"] == 0:\\n', '            print(key)\\n', '        abilities[key] = v[\"id\"]\\n', '    abilities[\"SMART\"] = 1\\n', '    enums = {}\\n', '    enums[\"Units\"] = units\\n', '    enums[\"Abilities\"] = abilities\\n', '    enums[\"Upgrades\"] = upgrades\\n', '    enums[\"Buffs\"] = buffs\\n', '    enums[\"Effects\"] = effects\\n', '    return enums\\n', '    units = {}\\n', '    for v in data[d]:\\n', '        key = v[\"name\"]\\n', '        if not key:\\n', '        key_to_insert = make_key(key)\\n', '        if key_to_insert in units:\\n', '            index = 2\\n', '            tmp = f\"{key_to_insert}_{index}\"\\n', '            while tmp in units:\\n', '                index += 1\\n', '                tmp = f\"{key_to_insert}_{index}\"\\n', '            key_to_insert = tmp\\n', '        units[key_to_insert] = v[\"id\"]\\n', '    return units\\n', '    assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in FILE_TRANSLATE.values()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = ENUM_TRANSLATE[name]\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            code.append(f\"    {key} = {value}\")\\n', '            f\"for item in {class_name}:\",\\n', '        with (idsdir / FILE_TRANSLATE[name]).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "       class_name = ENUM_TRANSLATE[name]\n\n        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\n\n        for key, value in sorted(body.items(), ke"
 },
 "24": {
  "name": "code",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants_from_stableid.py",
  "lineno": "128",
  "column": "8",
  "slicing": "['        code += [\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "     code.append(f\"    {key} = {value}\")\n\n        code += [\n            \"\",\n            f\"for item in {class_n"
 },
 "25": {
  "name": "requirements",
  "type": "pipenv.utils.convert_deps_to_pip",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/setup.py",
  "lineno": "7",
  "column": "0",
  "slicing": "['pfile = Project(chdir=False).parsed_pipfile\\n', \"requirements = convert_deps_to_pip(pfile['packages'], r=False)\\n\", \"test_requirements = convert_deps_to_pip(pfile['dev-packages'], r=False)\\n\", '    install_requires=requirements,\\n']",
  "context": "_pip\n\npfile = Project(chdir=False).parsed_pipfile\nrequirements = convert_deps_to_pip(pfile['packages'], r=False)\ntest_requirements = convert_deps_to_pip(pfile['dev"
 },
 "26": {
  "name": "test_requirements",
  "type": "pipenv.utils.convert_deps_to_pip",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/setup.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['pfile = Project(chdir=False).parsed_pipfile\\n', \"requirements = convert_deps_to_pip(pfile['packages'], r=False)\\n\", \"test_requirements = convert_deps_to_pip(pfile['dev-packages'], r=False)\\n\", '    install_requires=requirements,\\n']",
  "context": "= convert_deps_to_pip(pfile['packages'], r=False)\ntest_requirements = convert_deps_to_pip(pfile['dev-packages'], r=False)\n\nsetup(\n    name = \"sc2\",\n    packages = find_pack"
 },
 "27": {
  "name": "HEADER",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "7",
  "column": "0",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', '    code = re.sub(r\"#[^\\\\n]*\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"//[^\\\\n]+\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"/\\\\*.*?\\\\*/\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"\\\\s+\", \" \", code)\\n', '    enums = {}\\n', '    for enum in re.findall(r\"enum(?: class)? ([a-zA-Z_][a-zA-Z0-9_]*) {\\\\s?(.+?)\\\\s?}\", code):\\n', '        name, body = enum\\n', '        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\\\d+),?\\\\s?\", body)}\\n', '        enums[name] = body\\n', '    return enums\\n', '    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in enums.keys()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = \"\".join(p.capitalize() for p in name.split(\"_\")).replace(\"Typeid\", \"TypeId\")\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n', '                code.append(f\"    {key.split(\\'_\\',1)[1]} = {value}\")\\n', '            code.append(f\"    {key} = {value}\")\\n', '        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '        with (idsdir / name.lower()).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "ort re\nfrom pathlib import Path\n\nimport requests\n\nHEADER = f'# DO NOT EDIT!\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\n'\nPREFIXES = [\"Protoss\", \"Terran\", \"Zerg\", \"Neutral\""
 },
 "28": {
  "name": "PREFIXES",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['PREFIXES = [\"Protoss\", \"Terran\", \"Zerg\", \"Neutral\", \"Effect\"]\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n']",
  "context": "ly generated by \"{os.path.basename(__file__)}\"\\n'\nPREFIXES = [\"Protoss\", \"Terran\", \"Zerg\", \"Neutral\", \"Effect\"]\n\n\ndef clike_enum_parse(code):\n    # remove comment"
 },
 "29": {
  "name": "enums",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', '    code = re.sub(r\"#[^\\\\n]*\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"//[^\\\\n]+\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"/\\\\*.*?\\\\*/\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"\\\\s+\", \" \", code)\\n', '    enums = {}\\n', '    for enum in re.findall(r\"enum(?: class)? ([a-zA-Z_][a-zA-Z0-9_]*) {\\\\s?(.+?)\\\\s?}\", code):\\n', '        name, body = enum\\n', '        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\\\d+),?\\\\s?\", body)}\\n', '        enums[name] = body\\n', '    return enums\\n', '    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in enums.keys()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = \"\".join(p.capitalize() for p in name.split(\"_\")).replace(\"Typeid\", \"TypeId\")\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n', '                code.append(f\"    {key.split(\\'_\\',1)[1]} = {value}\")\\n', '            code.append(f\"    {key} = {value}\")\\n', '        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '        with (idsdir / name.lower()).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "b(r\"\\s+\", \" \", code)\n\n    # parse enum blocks\n    enums = {}\n    for enum in re.findall(r\"enum(?: class)? ([a-z"
 },
 "30": {
  "name": "name",
  "type": "enum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "23",
  "column": "8",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', '    code = re.sub(r\"#[^\\\\n]*\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"//[^\\\\n]+\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"/\\\\*.*?\\\\*/\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"\\\\s+\", \" \", code)\\n', '    enums = {}\\n', '    for enum in re.findall(r\"enum(?: class)? ([a-zA-Z_][a-zA-Z0-9_]*) {\\\\s?(.+?)\\\\s?}\", code):\\n', '        name, body = enum\\n', '        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\\\d+),?\\\\s?\", body)}\\n', '        enums[name] = body\\n', '    return enums\\n', '    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in enums.keys()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = \"\".join(p.capitalize() for p in name.split(\"_\")).replace(\"Typeid\", \"TypeId\")\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n', '                code.append(f\"    {key.split(\\'_\\',1)[1]} = {value}\")\\n', '            code.append(f\"    {key} = {value}\")\\n', '        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '        with (idsdir / name.lower()).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "-Z_][a-zA-Z0-9_]*) {\\s?(.+?)\\s?}\", code):\n        name, body = enum\n        body = {key: int(value) for key, value in "
 },
 "31": {
  "name": "body",
  "type": "enum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "23",
  "column": "14",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', '    code = re.sub(r\"#[^\\\\n]*\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"//[^\\\\n]+\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"/\\\\*.*?\\\\*/\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"\\\\s+\", \" \", code)\\n', '    enums = {}\\n', '    for enum in re.findall(r\"enum(?: class)? ([a-zA-Z_][a-zA-Z0-9_]*) {\\\\s?(.+?)\\\\s?}\", code):\\n', '        name, body = enum\\n', '        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\\\d+),?\\\\s?\", body)}\\n', '        enums[name] = body\\n', '    return enums\\n', '    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in enums.keys()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = \"\".join(p.capitalize() for p in name.split(\"_\")).replace(\"Typeid\", \"TypeId\")\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n', '                code.append(f\"    {key.split(\\'_\\',1)[1]} = {value}\")\\n', '            code.append(f\"    {key} = {value}\")\\n', '        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '        with (idsdir / name.lower()).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "-zA-Z0-9_]*) {\\s?(.+?)\\s?}\", code):\n        name, body = enum\n        body = {key: int(value) for key, value in "
 },
 "32": {
  "name": "body",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "24",
  "column": "8",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', '    code = re.sub(r\"#[^\\\\n]*\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"//[^\\\\n]+\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"/\\\\*.*?\\\\*/\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"\\\\s+\", \" \", code)\\n', '    enums = {}\\n', '    for enum in re.findall(r\"enum(?: class)? ([a-zA-Z_][a-zA-Z0-9_]*) {\\\\s?(.+?)\\\\s?}\", code):\\n', '        name, body = enum\\n', '        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\\\d+),?\\\\s?\", body)}\\n', '        enums[name] = body\\n', '    return enums\\n', '    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in enums.keys()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = \"\".join(p.capitalize() for p in name.split(\"_\")).replace(\"Typeid\", \"TypeId\")\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n', '                code.append(f\"    {key.split(\\'_\\',1)[1]} = {value}\")\\n', '            code.append(f\"    {key} = {value}\")\\n', '        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '        with (idsdir / name.lower()).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "?)\\s?}\", code):\n        name, body = enum\n        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\d+),?\\s?\", body)}\n        enums[name] = body\n\n    return enums\n\n\ndef"
 },
 "33": {
  "name": "enums",
  "type": "dict",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "30",
  "column": "25",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', '    code = re.sub(r\"#[^\\\\n]*\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"//[^\\\\n]+\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"/\\\\*.*?\\\\*/\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"\\\\s+\", \" \", code)\\n', '    enums = {}\\n', '    for enum in re.findall(r\"enum(?: class)? ([a-zA-Z_][a-zA-Z0-9_]*) {\\\\s?(.+?)\\\\s?}\", code):\\n', '        name, body = enum\\n', '        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\\\d+),?\\\\s?\", body)}\\n', '        enums[name] = body\\n', '    return enums\\n', 'def generate_python_code(enums):\\n', '    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in enums.keys()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = \"\".join(p.capitalize() for p in name.split(\"_\")).replace(\"Typeid\", \"TypeId\")\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n', '                code.append(f\"    {key.split(\\'_\\',1)[1]} = {value}\")\\n', '            code.append(f\"    {key} = {value}\")\\n', '        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '        with (idsdir / name.lower()).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "body\n\n    return enums\n\n\ndef generate_python_code(enums):\n    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_"
 },
 "34": {
  "name": "sc2dir",
  "type": "pathlib.Path",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "33",
  "column": "4",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', '    code = re.sub(r\"#[^\\\\n]*\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"//[^\\\\n]+\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"/\\\\*.*?\\\\*/\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"\\\\s+\", \" \", code)\\n', '    enums = {}\\n', '    for enum in re.findall(r\"enum(?: class)? ([a-zA-Z_][a-zA-Z0-9_]*) {\\\\s?(.+?)\\\\s?}\", code):\\n', '        name, body = enum\\n', '        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\\\d+),?\\\\s?\", body)}\\n', '        enums[name] = body\\n', '    return enums\\n', '    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in enums.keys()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = \"\".join(p.capitalize() for p in name.split(\"_\")).replace(\"Typeid\", \"TypeId\")\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n', '                code.append(f\"    {key.split(\\'_\\',1)[1]} = {value}\")\\n', '            code.append(f\"    {key} = {value}\")\\n', '        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '        with (idsdir / name.lower()).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "D\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\n\n    sc2dir = Path(\"sc2/\")\n    idsdir = sc2dir / \"ids\"\n    idsdir.mkdir(exist"
 },
 "35": {
  "name": "code",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "43",
  "column": "8",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', '    code = re.sub(r\"#[^\\\\n]*\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"//[^\\\\n]+\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"/\\\\*.*?\\\\*/\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"\\\\s+\", \" \", code)\\n', '    enums = {}\\n', '    for enum in re.findall(r\"enum(?: class)? ([a-zA-Z_][a-zA-Z0-9_]*) {\\\\s?(.+?)\\\\s?}\", code):\\n', '        name, body = enum\\n', '        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\\\d+),?\\\\s?\", body)}\\n', '        enums[name] = body\\n', '    return enums\\n', '    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in enums.keys()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = \"\".join(p.capitalize() for p in name.split(\"_\")).replace(\"Typeid\", \"TypeId\")\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n', '                code.append(f\"    {key.split(\\'_\\',1)[1]} = {value}\")\\n', '            code.append(f\"    {key} = {value}\")\\n', '        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '        with (idsdir / name.lower()).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": ".split(\"_\")).replace(\"Typeid\", \"TypeId\")\n\n        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\n\n        for key, value in sorted(body.items(), ke"
 },
 "36": {
  "name": "code",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "53",
  "column": "8",
  "slicing": "['        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '            f.write(\"\\\\n\".join(code))\\n']",
  "context": "     code.append(f\"    {key} = {value}\")\n\n        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\n\n        with (idsdir / name.lower()).with_suffix("
 },
 "37": {
  "name": "code",
  "type": "generate_python_code",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/generate_id_constants.py",
  "lineno": "61",
  "column": "4",
  "slicing": "['HEADER = f\\'# DO NOT EDIT!\\\\n# This file was automatically generated by \"{os.path.basename(__file__)}\"\\\\n\\'\\n', 'PREFIXES = [\"Protoss\", \"Terran\", \"Zerg\", \"Neutral\", \"Effect\"]\\n', 'def clike_enum_parse(code):\\n', '    code = re.sub(r\"#[^\\\\n]*\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"//[^\\\\n]+\\\\n\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"/\\\\*.*?\\\\*/\", \"\", code, flags=re.DOTALL)\\n', '    code = re.sub(r\"\\\\s+\", \" \", code)\\n', '    enums = {}\\n', '    for enum in re.findall(r\"enum(?: class)? ([a-zA-Z_][a-zA-Z0-9_]*) {\\\\s?(.+?)\\\\s?}\", code):\\n', '        name, body = enum\\n', '        body = {key: int(value) for key, value in re.findall(r\"([a-zA-Z_][a-zA-Z0-9_]*) = (\\\\d+),?\\\\s?\", body)}\\n', '        enums[name] = body\\n', '    return enums\\n', 'def generate_python_code(enums):\\n', '    assert {\"UNIT_TYPEID\", \"ABILITY_ID\", \"UPGRADE_ID\", \"BUFF_ID\"} <= enums.keys()\\n', '    sc2dir = Path(\"sc2/\")\\n', '    idsdir = sc2dir / \"ids\"\\n', '    idsdir.mkdir(exist_ok=True)\\n', '    with (idsdir / \"__init__.py\").open(\"w\") as f:\\n', '        f.write(\"\\\\n\".join([HEADER, f\"__all__ = {[n.lower() for n in enums.keys()] !r}\\\\n\"]))\\n', '    for name, body in enums.items():\\n', '        class_name = \"\".join(p.capitalize() for p in name.split(\"_\")).replace(\"Typeid\", \"TypeId\")\\n', '        code = [HEADER, \"import enum\", \"\", f\"class {class_name}(enum.Enum):\"]\\n', '        for key, value in sorted(body.items(), key=lambda p: p[1]):\\n', '            if any(key.startswith(p.upper() + \"_\") for p in PREFIXES):\\n', '                code.append(f\"    {key.split(\\'_\\',1)[1]} = {value}\")\\n', '            code.append(f\"    {key} = {value}\")\\n', '        code += [\"\", f\"for item in {class_name}:\", f\"    globals()[item.name] = item\", \"\"]\\n', '        with (idsdir / name.lower()).with_suffix(\".py\").open(\"w\") as f:\\n', '            f.write(\"\\\\n\".join(code))\\n', '    r = requests.get(\"https://raw.githubusercontent.com/Blizzard/s2client-api/master/include/sc2api/sc2_typeenums.h\")\\n', '    code = generate_python_code(clike_enum_parse(r.text))\\n']",
  "context": "t-api/master/include/sc2api/sc2_typeenums.h\")\n    code = generate_python_code(clike_enum_parse(r.text))\n"
 },
 "38": {
  "name": "P0",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "5",
  "column": "0",
  "slicing": "['P0 = Point2((0, 0))\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    verify_distances(P0, 1e2)\\n', '    verify_angles(P0, 1e2)\\n', '    verify(P0, P1)\\n', '    verify(P1, P0)\\n']",
  "context": " random\nfrom sc2.position import Point2, EPSILON\n\nP0 = Point2((0, 0))\nP1 = Point2((1, 1))\nP2 = Point2((3, 1))\nP3 = Point"
 },
 "39": {
  "name": "P1",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "6",
  "column": "0",
  "slicing": "['P1 = Point2((1, 1))\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    verify_distances(P1, 1e3)\\n', '    verify_angles(P1, 1e3)\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n']",
  "context": "ition import Point2, EPSILON\n\nP0 = Point2((0, 0))\nP1 = Point2((1, 1))\nP2 = Point2((3, 1))\nP3 = Point2((3, 3))\n\ndef rad_d"
 },
 "40": {
  "name": "P2",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "7",
  "column": "0",
  "slicing": "['P2 = Point2((3, 1))\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P2, 1e4)\\n', '    verify(P1, P2)\\n', '    verify(P2, P3)\\n', '    verify(P2, P1)\\n', '    verify(P3, P2)\\n']",
  "context": " EPSILON\n\nP0 = Point2((0, 0))\nP1 = Point2((1, 1))\nP2 = Point2((3, 1))\nP3 = Point2((3, 3))\n\ndef rad_diff(a, b):\n    r1 = "
 },
 "41": {
  "name": "P3",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['P3 = Point2((3, 3))\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": "2((0, 0))\nP1 = Point2((1, 1))\nP2 = Point2((3, 1))\nP3 = Point2((3, 3))\n\ndef rad_diff(a, b):\n    r1 = abs(a - b)\n    r2 = "
 },
 "42": {
  "name": "a",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "10",
  "column": "13",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": " Point2((3, 1))\nP3 = Point2((3, 3))\n\ndef rad_diff(a, b):\n    r1 = abs(a - b)\n    r2 = abs(b - a)\n    r3 = m"
 },
 "43": {
  "name": "b",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "10",
  "column": "16",
  "slicing": "['def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n']",
  "context": "int2((3, 1))\nP3 = Point2((3, 3))\n\ndef rad_diff(a, b):\n    r1 = abs(a - b)\n    r2 = abs(b - a)\n    r3 = m"
 },
 "44": {
  "name": "r1",
  "type": "abs",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "11",
  "column": "4",
  "slicing": "['    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n']",
  "context": " 1))\nP3 = Point2((3, 3))\n\ndef rad_diff(a, b):\n    r1 = abs(a - b)\n    r2 = abs(b - a)\n    r3 = min(r1, r2)\n    r4 = "
 },
 "45": {
  "name": "r2",
  "type": "abs",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "12",
  "column": "4",
  "slicing": "['    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n']",
  "context": " 3))\n\ndef rad_diff(a, b):\n    r1 = abs(a - b)\n    r2 = abs(b - a)\n    r3 = min(r1, r2)\n    r4 = abs(2*pi - r3)\n    r"
 },
 "46": {
  "name": "r3",
  "type": "min",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "13",
  "column": "4",
  "slicing": "['    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n']",
  "context": ", b):\n    r1 = abs(a - b)\n    r2 = abs(b - a)\n    r3 = min(r1, r2)\n    r4 = abs(2*pi - r3)\n    return min(r3, r4)\n\nde"
 },
 "47": {
  "name": "r4",
  "type": "abs",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n']",
  "context": "- b)\n    r2 = abs(b - a)\n    r3 = min(r1, r2)\n    r4 = abs(2*pi - r3)\n    return min(r3, r4)\n\ndef test_test_rad_diff():\n"
 },
 "48": {
  "name": "source",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "38",
  "column": "19",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": "istance():\n    random.seed(1)\n\n    def get_points(source, distance, n=1000):\n        return {source.random_on_distance(distance"
 },
 "49": {
  "name": "source",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "41",
  "column": "25",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": "nce) for _ in range(n)}\n\n    def verify_distances(source, distance, n=1000):\n        for p in get_points(source, distance, n):\n"
 },
 "50": {
  "name": "source",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "45",
  "column": "22",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": "(p) - distance) < 0.000001\n\n    def verify_angles(source, distance, n=1000):\n        angles_rad = {\n            atan2(p.y - sou"
 },
 "51": {
  "name": "angles_rad",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "46",
  "column": "8",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": " verify_angles(source, distance, n=1000):\n        angles_rad = {\n            atan2(p.y - source.y, p.x - source.x)\n"
 },
 "52": {
  "name": "quadrants",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "51",
  "column": "8",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": "et_points(source, distance, n)\n        }\n\n        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\n        assert len(quadrants) == 4\n\n\n    verify_di"
 },
 "53": {
  "name": "source",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "70",
  "column": "15",
  "slicing": "['    def verify(source, target, max_difference=(pi/4), n=1000):\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n', '            verify(p1, p2, n=10)\\n']",
  "context": "0, rs()*1000)) for _ in range(n)}\n\n    def verify(source, target, max_difference=(pi/4), n=1000):\n        d = 1 + random.random() * 100\n        poin"
 },
 "54": {
  "name": "target",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "70",
  "column": "23",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '    def verify(source, target, max_difference=(pi/4), n=1000):\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n', '            verify(p1, p2, n=10)\\n']",
  "context": "1000)) for _ in range(n)}\n\n    def verify(source, target, max_difference=(pi/4), n=1000):\n        d = 1 + random.random() * 100\n        poin"
 },
 "55": {
  "name": "max_difference",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "70",
  "column": "31",
  "slicing": "['    def verify(source, target, max_difference=(pi/4), n=1000):\\n']",
  "context": "or _ in range(n)}\n\n    def verify(source, target, max_difference=(pi/4), n=1000):\n        d = 1 + random.random() * 100\n        poin"
 },
 "56": {
  "name": "points",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "72",
  "column": "8",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": "0):\n        d = 1 + random.random() * 100\n        points = {\n            source.towards_with_random_angle(targe"
 },
 "57": {
  "name": "dx",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "77",
  "column": "8",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": "\n            for _ in range(n)\n        }\n\n        dx, dy = target.x - source.x, target.y - source.y\n        src_angle = atan2(dy, dx)\n\n        for p i"
 },
 "58": {
  "name": "dy",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "77",
  "column": "12",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": "         for _ in range(n)\n        }\n\n        dx, dy = target.x - source.x, target.y - source.y\n        src_angle = atan2(dy, dx)\n\n        for p i"
 },
 "59": {
  "name": "src_angle",
  "type": "math.atan2",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "78",
  "column": "8",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": " target.x - source.x, target.y - source.y\n        src_angle = atan2(dy, dx)\n\n        for p in points:\n            angle = atan"
 },
 "60": {
  "name": "angle",
  "type": "math.atan2",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "81",
  "column": "12",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n']",
  "context": "an2(dy, dx)\n\n        for p in points:\n            angle = atan2(p.y - source.y, p.x - source.x)\n            assert rad_diff(src_angle, angle) <= m"
 },
 "61": {
  "name": "ps",
  "type": "random_points",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/test_directions.py",
  "lineno": "96",
  "column": "4",
  "slicing": "['P0 = Point2((0, 0))\\n', 'P1 = Point2((1, 1))\\n', 'P2 = Point2((3, 1))\\n', 'P3 = Point2((3, 3))\\n', 'def rad_diff(a, b):\\n', '    r1 = abs(a - b)\\n', '    r2 = abs(b - a)\\n', '    r3 = min(r1, r2)\\n', '    r4 = abs(2*pi - r3)\\n', '    return min(r3, r4)\\n', '    assert rad_diff(0, pi) == pi\\n', '    assert rad_diff(pi, pi) == 0\\n', '    assert rad_diff(pi, -pi) == 0\\n', '    assert P0.distance_to(P1) == sqrt(2)\\n', '    assert P1.distance_to(P2) == 2\\n', '    assert P0.distance_to(P2) == sqrt(10)\\n', '    assert P0.towards(P1, 1) == Point2((sqrt(2) / 2, sqrt(2) / 2))\\n', '    def get_points(source, distance, n=1000):\\n', '    def verify_distances(source, distance, n=1000):\\n', '        for p in get_points(source, distance, n):\\n', '            assert abs(source.distance_to(p) - distance) < 0.000001\\n', '    def verify_angles(source, distance, n=1000):\\n', '        angles_rad = {\\n', '            atan2(p.y - source.y, p.x - source.x)\\n', '            for p in get_points(source, distance, n)\\n', '        quadrants = {(cos(a) < 0, sin(a) < 0) for a in angles_rad}\\n', '        assert len(quadrants) == 4\\n', '    verify_distances(P0, 1e2)\\n', '    verify_distances(P1, 1e3)\\n', '    verify_distances(P2, 1e4)\\n', '    verify_angles(P0, 1e2)\\n', '    verify_angles(P1, 1e3)\\n', '    verify_angles(P2, 1e4)\\n', '        rs = lambda: 1 - random.random() * 2\\n', '        return {Point2((rs()*1000, rs()*1000)) for _ in range(n)}\\n', '    def verify(source, target, max_difference=(pi/4), n=1000):\\n', '        d = 1 + random.random() * 100\\n', '        points = {\\n', '            source.towards_with_random_angle(target, distance=d, max_difference=max_difference)\\n', '            for _ in range(n)\\n', '        dx, dy = target.x - source.x, target.y - source.y\\n', '        src_angle = atan2(dy, dx)\\n', '        for p in points:\\n', '            angle = atan2(p.y - source.y, p.x - source.x)\\n', '            assert rad_diff(src_angle, angle) <= max_difference\\n', '            assert abs(source.distance_to(p) - d) <= EPSILON\\n', '    verify(P0, P1)\\n', '    verify(P1, P2)\\n', '    verify(P1, P3)\\n', '    verify(P2, P3)\\n', '    verify(P1, P0)\\n', '    verify(P2, P1)\\n', '    verify(P3, P1)\\n', '    verify(P3, P2)\\n', '    ps = random_points(n=50)\\n', '    for p1 in ps:\\n', '        for p2 in ps:\\n', '            if p1 == p2:\\n', '            verify(p1, p2, n=10)\\n']",
  "context": "2, P1)\n    verify(P3, P1)\n    verify(P3, P2)\n\n    ps = random_points(n=50)\n    for p1 in ps:\n        for p2 in ps:\n          "
 },
 "62": {
  "name": "combined_actions",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "121",
  "column": "8",
  "slicing": "['        combined_actions = []\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '            combined_actions.append(scv.move(center))\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n']",
  "context": "\n    async def test_botai_actions2(self):\n        combined_actions = []\n        center = self._game_info.map_center\n      "
 },
 "63": {
  "name": "combined_actions",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "129",
  "column": "8",
  "slicing": "['        combined_actions = []\\n', '            combined_actions.append(scv.move(center))\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n']",
  "context": "\n    async def test_botai_actions3(self):\n        combined_actions = []\n        center = self._game_info.map_center\n      "
 },
 "64": {
  "name": "scvs1",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "132",
  "column": "8",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n']",
  "context": "fo.map_center\n        scvs = self.workers\n        scvs1 = scvs[:6]\n        scvs2 = scvs[6:]\n        for scv in scvs1:"
 },
 "65": {
  "name": "scvs2",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "133",
  "column": "8",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n']",
  "context": "s = self.workers\n        scvs1 = scvs[:6]\n        scvs2 = scvs[6:]\n        for scv in scvs1:\n            combined_act"
 },
 "66": {
  "name": "combined_actions",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "143",
  "column": "8",
  "slicing": "['        combined_actions = []\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n']",
  "context": "\n    async def test_botai_actions4(self):\n        combined_actions = []\n        mf = self.state.mineral_field.closest_to(s"
 },
 "67": {
  "name": "p1",
  "type": "sc2.position.Pointlike",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "205",
  "column": "8",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p1 = Pointlike((2.3, 2.7))\\n', '        assert p1 == Pointlike((2.3, 2.7))\\n', '        assert p1.rounded == Pointlike((2, 3))\\n', '        assert p1.position == p1\\n', '        assert p1.distance_to(Pointlike((-0.7, 6.7))) == 5\\n', '        assert p1.closest([\\n', '        assert p1.furthest([\\n', '        assert p1.offset(Pointlike((-1, -1))) == Pointlike((1.3, 1.7))\\n', '        assert p1.offset(Pointlike((-1, 1))) == Pointlike((1.3, 3.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), 5) == Pointlike((2.3, 7.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), -5) == Pointlike((2.3, -2.3))\\n']",
  "context": "ns.py\n    async def test_positions(self):\n        p1 = Pointlike((2.3, 2.7))\n        p2 = Point2((-5.3, -7.9))\n        p3 = Poi"
 },
 "68": {
  "name": "p2",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "206",
  "column": "8",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p2 = Point2((-5.3, -7.9))\\n', '        assert p2.x == -5.3\\n', '        assert p2.y == -7.9\\n', '        assert p2.to2 == p2\\n', '        assert p2.to3 == Point3((-5.3, -7.9, 0))\\n', '        assert (p2.neighbors4 ==\\n', '        assert p2.neighbors8 == (p2.neighbors4 |\\n']",
  "context": "self):\n        p1 = Pointlike((2.3, 2.7))\n        p2 = Point2((-5.3, -7.9))\n        p3 = Point3((-2.7, 5.4, 133.2))\n\n        #"
 },
 "69": {
  "name": "p3",
  "type": "sc2.position.Point3",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "207",
  "column": "8",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p3 = Point3((-2.7, 5.4, 133.2))\\n', '        assert p3.z == 133.2\\n', '        assert p3.to3 == p3\\n']",
  "context": ", 2.7))\n        p2 = Point2((-5.3, -7.9))\n        p3 = Point3((-2.7, 5.4, 133.2))\n\n        # Testing Pointlike\n        assert p1 == "
 },
 "70": {
  "name": "scv1",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "254",
  "column": "8",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p1 = Pointlike((2.3, 2.7))\\n', '        p2 = Point2((-5.3, -7.9))\\n', '        p3 = Point3((-2.7, 5.4, 133.2))\\n', '        assert p1 == Pointlike((2.3, 2.7))\\n', '        assert p1.rounded == Pointlike((2, 3))\\n', '        assert p1.position == p1\\n', '        assert p1.distance_to(Pointlike((-0.7, 6.7))) == 5\\n', '        assert p1.closest([\\n', '        assert p1.furthest([\\n', '        assert p1.offset(Pointlike((-1, -1))) == Pointlike((1.3, 1.7))\\n', '        assert p1.offset(Pointlike((-1, 1))) == Pointlike((1.3, 3.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), 5) == Pointlike((2.3, 7.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), -5) == Pointlike((2.3, -2.3))\\n', '        assert p2.x == -5.3\\n', '        assert p2.y == -7.9\\n', '        assert p2.to2 == p2\\n', '        assert p2.to3 == Point3((-5.3, -7.9, 0))\\n', '        assert (p2.neighbors4 ==\\n', '        assert p2.neighbors8 == (p2.neighbors4 |\\n', '        assert p3.z == 133.2\\n', '        assert p3.to3 == p3\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        assert scv1.type_id == UnitTypeId.SCV\\n', '        assert scv1._type_data == self._game_data.units[UnitTypeId.SCV.value]\\n', '        assert scv1.alliance == Alliance.Self.value\\n', '        assert scv1.is_mine == True\\n', '        assert isinstance(scv1.position, Point2)\\n', '        assert isinstance(scv1.position3d, Point3)\\n', '        assert scv1.health == 45\\n', '        assert scv1.health_max == 45\\n', '        assert scv1.health_percentage == 45/45\\n', '        assert scv1.energy == 0\\n', '        assert scv1.energy_max == 0\\n', '        assert scv1.energy_percentage == 0\\n', '        assert not scv1.target_in_range(self.workers.tags_not_in({scv1.tag}).furthest_to(scv1.position))\\n', '        assert scv1.target_in_range(scv1)\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        scv_group = self.workers.tags_in({scv1.tag, scv2.tag, scv3.tag})\\n', '        empty_group = self.workers & []\\n', '        assert scv_group.amount == 3\\n', '        assert empty_group.amount == 0\\n', '        assert not scv_group.empty\\n', '        assert empty_group.empty\\n', '        assert scv_group.exists\\n', '        assert not empty_group.exists\\n', '        assert scv_group.find_by_tag(scv1.tag) == scv1\\n', '        assert scv_group.find_by_tag(1337) is None\\n', '        assert scv_group.random in [scv1, scv2, scv3]\\n', '        test_point = scv1.position.offset(Point2((0.01, 0.01)))\\n', '        assert abs(scv_group.closest_distance_to(test_point) - (0.01**2 + 0.01**2)**0.5) < 0.01\\n', '        assert scv_group.closest_to(test_point) == scv1\\n', '        assert scv_group.furthest_to(test_point) != scv1\\n', '        assert scv_group.furthest_to(test_point) in [scv2, scv3]\\n', '        assert scv_group.closer_than(0.02, test_point) == self.workers.tags_in({scv1.tag})\\n', '        assert scv_group.closer_than(30, test_point) == scv_group\\n', '        assert scv_group.further_than(0.02, test_point) == self.workers.tags_in({scv2.tag, scv3.tag})\\n', '        assert scv_group.closer_than(50, test_point).further_than(0.00001, test_point).of_type(UnitTypeId.SCV) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.SCV}) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.MARINE}) == empty_group\\n', '        assert scv_group.tags == {u.tag for u in scv_group}\\n', '        assert scv_group.owned == scv_group\\n', '        assert scv_group.enemy == empty_group\\n']",
  "context": "st unit.py\n    async def test_unit(self):\n        scv1, scv2, scv3 = self.workers[:3]\n\n        assert scv1.type_id == UnitTypeId.SCV\n   "
 },
 "71": {
  "name": "scv2",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "254",
  "column": "14",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p1 = Pointlike((2.3, 2.7))\\n', '        p2 = Point2((-5.3, -7.9))\\n', '        p3 = Point3((-2.7, 5.4, 133.2))\\n', '        assert p1 == Pointlike((2.3, 2.7))\\n', '        assert p1.rounded == Pointlike((2, 3))\\n', '        assert p1.position == p1\\n', '        assert p1.distance_to(Pointlike((-0.7, 6.7))) == 5\\n', '        assert p1.closest([\\n', '        assert p1.furthest([\\n', '        assert p1.offset(Pointlike((-1, -1))) == Pointlike((1.3, 1.7))\\n', '        assert p1.offset(Pointlike((-1, 1))) == Pointlike((1.3, 3.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), 5) == Pointlike((2.3, 7.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), -5) == Pointlike((2.3, -2.3))\\n', '        assert p2.x == -5.3\\n', '        assert p2.y == -7.9\\n', '        assert p2.to2 == p2\\n', '        assert p2.to3 == Point3((-5.3, -7.9, 0))\\n', '        assert (p2.neighbors4 ==\\n', '        assert p2.neighbors8 == (p2.neighbors4 |\\n', '        assert p3.z == 133.2\\n', '        assert p3.to3 == p3\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        assert scv1.type_id == UnitTypeId.SCV\\n', '        assert scv1._type_data == self._game_data.units[UnitTypeId.SCV.value]\\n', '        assert scv1.alliance == Alliance.Self.value\\n', '        assert scv1.is_mine == True\\n', '        assert isinstance(scv1.position, Point2)\\n', '        assert isinstance(scv1.position3d, Point3)\\n', '        assert scv1.health == 45\\n', '        assert scv1.health_max == 45\\n', '        assert scv1.health_percentage == 45/45\\n', '        assert scv1.energy == 0\\n', '        assert scv1.energy_max == 0\\n', '        assert scv1.energy_percentage == 0\\n', '        assert not scv1.target_in_range(self.workers.tags_not_in({scv1.tag}).furthest_to(scv1.position))\\n', '        assert scv1.target_in_range(scv1)\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        scv_group = self.workers.tags_in({scv1.tag, scv2.tag, scv3.tag})\\n', '        empty_group = self.workers & []\\n', '        assert scv_group.amount == 3\\n', '        assert empty_group.amount == 0\\n', '        assert not scv_group.empty\\n', '        assert empty_group.empty\\n', '        assert scv_group.exists\\n', '        assert not empty_group.exists\\n', '        assert scv_group.find_by_tag(scv1.tag) == scv1\\n', '        assert scv_group.find_by_tag(1337) is None\\n', '        assert scv_group.random in [scv1, scv2, scv3]\\n', '        test_point = scv1.position.offset(Point2((0.01, 0.01)))\\n', '        assert abs(scv_group.closest_distance_to(test_point) - (0.01**2 + 0.01**2)**0.5) < 0.01\\n', '        assert scv_group.closest_to(test_point) == scv1\\n', '        assert scv_group.furthest_to(test_point) != scv1\\n', '        assert scv_group.furthest_to(test_point) in [scv2, scv3]\\n', '        assert scv_group.closer_than(0.02, test_point) == self.workers.tags_in({scv1.tag})\\n', '        assert scv_group.closer_than(30, test_point) == scv_group\\n', '        assert scv_group.further_than(0.02, test_point) == self.workers.tags_in({scv2.tag, scv3.tag})\\n', '        assert scv_group.closer_than(50, test_point).further_than(0.00001, test_point).of_type(UnitTypeId.SCV) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.SCV}) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.MARINE}) == empty_group\\n', '        assert scv_group.tags == {u.tag for u in scv_group}\\n', '        assert scv_group.owned == scv_group\\n', '        assert scv_group.enemy == empty_group\\n']",
  "context": "t.py\n    async def test_unit(self):\n        scv1, scv2, scv3 = self.workers[:3]\n\n        assert scv1.type_id == UnitTypeId.SCV\n   "
 },
 "72": {
  "name": "scv3",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "254",
  "column": "20",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p1 = Pointlike((2.3, 2.7))\\n', '        p2 = Point2((-5.3, -7.9))\\n', '        p3 = Point3((-2.7, 5.4, 133.2))\\n', '        assert p1 == Pointlike((2.3, 2.7))\\n', '        assert p1.rounded == Pointlike((2, 3))\\n', '        assert p1.position == p1\\n', '        assert p1.distance_to(Pointlike((-0.7, 6.7))) == 5\\n', '        assert p1.closest([\\n', '        assert p1.furthest([\\n', '        assert p1.offset(Pointlike((-1, -1))) == Pointlike((1.3, 1.7))\\n', '        assert p1.offset(Pointlike((-1, 1))) == Pointlike((1.3, 3.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), 5) == Pointlike((2.3, 7.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), -5) == Pointlike((2.3, -2.3))\\n', '        assert p2.x == -5.3\\n', '        assert p2.y == -7.9\\n', '        assert p2.to2 == p2\\n', '        assert p2.to3 == Point3((-5.3, -7.9, 0))\\n', '        assert (p2.neighbors4 ==\\n', '        assert p2.neighbors8 == (p2.neighbors4 |\\n', '        assert p3.z == 133.2\\n', '        assert p3.to3 == p3\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        assert scv1.type_id == UnitTypeId.SCV\\n', '        assert scv1._type_data == self._game_data.units[UnitTypeId.SCV.value]\\n', '        assert scv1.alliance == Alliance.Self.value\\n', '        assert scv1.is_mine == True\\n', '        assert isinstance(scv1.position, Point2)\\n', '        assert isinstance(scv1.position3d, Point3)\\n', '        assert scv1.health == 45\\n', '        assert scv1.health_max == 45\\n', '        assert scv1.health_percentage == 45/45\\n', '        assert scv1.energy == 0\\n', '        assert scv1.energy_max == 0\\n', '        assert scv1.energy_percentage == 0\\n', '        assert not scv1.target_in_range(self.workers.tags_not_in({scv1.tag}).furthest_to(scv1.position))\\n', '        assert scv1.target_in_range(scv1)\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        scv_group = self.workers.tags_in({scv1.tag, scv2.tag, scv3.tag})\\n', '        empty_group = self.workers & []\\n', '        assert scv_group.amount == 3\\n', '        assert empty_group.amount == 0\\n', '        assert not scv_group.empty\\n', '        assert empty_group.empty\\n', '        assert scv_group.exists\\n', '        assert not empty_group.exists\\n', '        assert scv_group.find_by_tag(scv1.tag) == scv1\\n', '        assert scv_group.find_by_tag(1337) is None\\n', '        assert scv_group.random in [scv1, scv2, scv3]\\n', '        test_point = scv1.position.offset(Point2((0.01, 0.01)))\\n', '        assert abs(scv_group.closest_distance_to(test_point) - (0.01**2 + 0.01**2)**0.5) < 0.01\\n', '        assert scv_group.closest_to(test_point) == scv1\\n', '        assert scv_group.furthest_to(test_point) != scv1\\n', '        assert scv_group.furthest_to(test_point) in [scv2, scv3]\\n', '        assert scv_group.closer_than(0.02, test_point) == self.workers.tags_in({scv1.tag})\\n', '        assert scv_group.closer_than(30, test_point) == scv_group\\n', '        assert scv_group.further_than(0.02, test_point) == self.workers.tags_in({scv2.tag, scv3.tag})\\n', '        assert scv_group.closer_than(50, test_point).further_than(0.00001, test_point).of_type(UnitTypeId.SCV) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.SCV}) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.MARINE}) == empty_group\\n', '        assert scv_group.tags == {u.tag for u in scv_group}\\n', '        assert scv_group.owned == scv_group\\n', '        assert scv_group.enemy == empty_group\\n']",
  "context": "   async def test_unit(self):\n        scv1, scv2, scv3 = self.workers[:3]\n\n        assert scv1.type_id == UnitTypeId.SCV\n   "
 },
 "73": {
  "name": "scv1",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "273",
  "column": "8",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p1 = Pointlike((2.3, 2.7))\\n', '        p2 = Point2((-5.3, -7.9))\\n', '        p3 = Point3((-2.7, 5.4, 133.2))\\n', '        assert p1 == Pointlike((2.3, 2.7))\\n', '        assert p1.rounded == Pointlike((2, 3))\\n', '        assert p1.position == p1\\n', '        assert p1.distance_to(Pointlike((-0.7, 6.7))) == 5\\n', '        assert p1.closest([\\n', '        assert p1.furthest([\\n', '        assert p1.offset(Pointlike((-1, -1))) == Pointlike((1.3, 1.7))\\n', '        assert p1.offset(Pointlike((-1, 1))) == Pointlike((1.3, 3.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), 5) == Pointlike((2.3, 7.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), -5) == Pointlike((2.3, -2.3))\\n', '        assert p2.x == -5.3\\n', '        assert p2.y == -7.9\\n', '        assert p2.to2 == p2\\n', '        assert p2.to3 == Point3((-5.3, -7.9, 0))\\n', '        assert (p2.neighbors4 ==\\n', '        assert p2.neighbors8 == (p2.neighbors4 |\\n', '        assert p3.z == 133.2\\n', '        assert p3.to3 == p3\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        assert scv1.type_id == UnitTypeId.SCV\\n', '        assert scv1._type_data == self._game_data.units[UnitTypeId.SCV.value]\\n', '        assert scv1.alliance == Alliance.Self.value\\n', '        assert scv1.is_mine == True\\n', '        assert isinstance(scv1.position, Point2)\\n', '        assert isinstance(scv1.position3d, Point3)\\n', '        assert scv1.health == 45\\n', '        assert scv1.health_max == 45\\n', '        assert scv1.health_percentage == 45/45\\n', '        assert scv1.energy == 0\\n', '        assert scv1.energy_max == 0\\n', '        assert scv1.energy_percentage == 0\\n', '        assert not scv1.target_in_range(self.workers.tags_not_in({scv1.tag}).furthest_to(scv1.position))\\n', '        assert scv1.target_in_range(scv1)\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        scv_group = self.workers.tags_in({scv1.tag, scv2.tag, scv3.tag})\\n', '        empty_group = self.workers & []\\n', '        assert scv_group.amount == 3\\n', '        assert empty_group.amount == 0\\n', '        assert not scv_group.empty\\n', '        assert empty_group.empty\\n', '        assert scv_group.exists\\n', '        assert not empty_group.exists\\n', '        assert scv_group.find_by_tag(scv1.tag) == scv1\\n', '        assert scv_group.find_by_tag(1337) is None\\n', '        assert scv_group.random in [scv1, scv2, scv3]\\n', '        test_point = scv1.position.offset(Point2((0.01, 0.01)))\\n', '        assert abs(scv_group.closest_distance_to(test_point) - (0.01**2 + 0.01**2)**0.5) < 0.01\\n', '        assert scv_group.closest_to(test_point) == scv1\\n', '        assert scv_group.furthest_to(test_point) != scv1\\n', '        assert scv_group.furthest_to(test_point) in [scv2, scv3]\\n', '        assert scv_group.closer_than(0.02, test_point) == self.workers.tags_in({scv1.tag})\\n', '        assert scv_group.closer_than(30, test_point) == scv_group\\n', '        assert scv_group.further_than(0.02, test_point) == self.workers.tags_in({scv2.tag, scv3.tag})\\n', '        assert scv_group.closer_than(50, test_point).further_than(0.00001, test_point).of_type(UnitTypeId.SCV) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.SCV}) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.MARINE}) == empty_group\\n', '        assert scv_group.tags == {u.tag for u in scv_group}\\n', '        assert scv_group.owned == scv_group\\n', '        assert scv_group.enemy == empty_group\\n']",
  "context": " units.py\n    async def test_units(self):\n        scv1, scv2, scv3 = self.workers[:3]\n        scv_group = self.workers.tags_in({scv1.tag"
 },
 "74": {
  "name": "scv2",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "273",
  "column": "14",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p1 = Pointlike((2.3, 2.7))\\n', '        p2 = Point2((-5.3, -7.9))\\n', '        p3 = Point3((-2.7, 5.4, 133.2))\\n', '        assert p1 == Pointlike((2.3, 2.7))\\n', '        assert p1.rounded == Pointlike((2, 3))\\n', '        assert p1.position == p1\\n', '        assert p1.distance_to(Pointlike((-0.7, 6.7))) == 5\\n', '        assert p1.closest([\\n', '        assert p1.furthest([\\n', '        assert p1.offset(Pointlike((-1, -1))) == Pointlike((1.3, 1.7))\\n', '        assert p1.offset(Pointlike((-1, 1))) == Pointlike((1.3, 3.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), 5) == Pointlike((2.3, 7.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), -5) == Pointlike((2.3, -2.3))\\n', '        assert p2.x == -5.3\\n', '        assert p2.y == -7.9\\n', '        assert p2.to2 == p2\\n', '        assert p2.to3 == Point3((-5.3, -7.9, 0))\\n', '        assert (p2.neighbors4 ==\\n', '        assert p2.neighbors8 == (p2.neighbors4 |\\n', '        assert p3.z == 133.2\\n', '        assert p3.to3 == p3\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        assert scv1.type_id == UnitTypeId.SCV\\n', '        assert scv1._type_data == self._game_data.units[UnitTypeId.SCV.value]\\n', '        assert scv1.alliance == Alliance.Self.value\\n', '        assert scv1.is_mine == True\\n', '        assert isinstance(scv1.position, Point2)\\n', '        assert isinstance(scv1.position3d, Point3)\\n', '        assert scv1.health == 45\\n', '        assert scv1.health_max == 45\\n', '        assert scv1.health_percentage == 45/45\\n', '        assert scv1.energy == 0\\n', '        assert scv1.energy_max == 0\\n', '        assert scv1.energy_percentage == 0\\n', '        assert not scv1.target_in_range(self.workers.tags_not_in({scv1.tag}).furthest_to(scv1.position))\\n', '        assert scv1.target_in_range(scv1)\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        scv_group = self.workers.tags_in({scv1.tag, scv2.tag, scv3.tag})\\n', '        empty_group = self.workers & []\\n', '        assert scv_group.amount == 3\\n', '        assert empty_group.amount == 0\\n', '        assert not scv_group.empty\\n', '        assert empty_group.empty\\n', '        assert scv_group.exists\\n', '        assert not empty_group.exists\\n', '        assert scv_group.find_by_tag(scv1.tag) == scv1\\n', '        assert scv_group.find_by_tag(1337) is None\\n', '        assert scv_group.random in [scv1, scv2, scv3]\\n', '        test_point = scv1.position.offset(Point2((0.01, 0.01)))\\n', '        assert abs(scv_group.closest_distance_to(test_point) - (0.01**2 + 0.01**2)**0.5) < 0.01\\n', '        assert scv_group.closest_to(test_point) == scv1\\n', '        assert scv_group.furthest_to(test_point) != scv1\\n', '        assert scv_group.furthest_to(test_point) in [scv2, scv3]\\n', '        assert scv_group.closer_than(0.02, test_point) == self.workers.tags_in({scv1.tag})\\n', '        assert scv_group.closer_than(30, test_point) == scv_group\\n', '        assert scv_group.further_than(0.02, test_point) == self.workers.tags_in({scv2.tag, scv3.tag})\\n', '        assert scv_group.closer_than(50, test_point).further_than(0.00001, test_point).of_type(UnitTypeId.SCV) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.SCV}) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.MARINE}) == empty_group\\n', '        assert scv_group.tags == {u.tag for u in scv_group}\\n', '        assert scv_group.owned == scv_group\\n', '        assert scv_group.enemy == empty_group\\n']",
  "context": ".py\n    async def test_units(self):\n        scv1, scv2, scv3 = self.workers[:3]\n        scv_group = self.workers.tags_in({scv1.tag"
 },
 "75": {
  "name": "scv3",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "273",
  "column": "20",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p1 = Pointlike((2.3, 2.7))\\n', '        p2 = Point2((-5.3, -7.9))\\n', '        p3 = Point3((-2.7, 5.4, 133.2))\\n', '        assert p1 == Pointlike((2.3, 2.7))\\n', '        assert p1.rounded == Pointlike((2, 3))\\n', '        assert p1.position == p1\\n', '        assert p1.distance_to(Pointlike((-0.7, 6.7))) == 5\\n', '        assert p1.closest([\\n', '        assert p1.furthest([\\n', '        assert p1.offset(Pointlike((-1, -1))) == Pointlike((1.3, 1.7))\\n', '        assert p1.offset(Pointlike((-1, 1))) == Pointlike((1.3, 3.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), 5) == Pointlike((2.3, 7.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), -5) == Pointlike((2.3, -2.3))\\n', '        assert p2.x == -5.3\\n', '        assert p2.y == -7.9\\n', '        assert p2.to2 == p2\\n', '        assert p2.to3 == Point3((-5.3, -7.9, 0))\\n', '        assert (p2.neighbors4 ==\\n', '        assert p2.neighbors8 == (p2.neighbors4 |\\n', '        assert p3.z == 133.2\\n', '        assert p3.to3 == p3\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        assert scv1.type_id == UnitTypeId.SCV\\n', '        assert scv1._type_data == self._game_data.units[UnitTypeId.SCV.value]\\n', '        assert scv1.alliance == Alliance.Self.value\\n', '        assert scv1.is_mine == True\\n', '        assert isinstance(scv1.position, Point2)\\n', '        assert isinstance(scv1.position3d, Point3)\\n', '        assert scv1.health == 45\\n', '        assert scv1.health_max == 45\\n', '        assert scv1.health_percentage == 45/45\\n', '        assert scv1.energy == 0\\n', '        assert scv1.energy_max == 0\\n', '        assert scv1.energy_percentage == 0\\n', '        assert not scv1.target_in_range(self.workers.tags_not_in({scv1.tag}).furthest_to(scv1.position))\\n', '        assert scv1.target_in_range(scv1)\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        scv_group = self.workers.tags_in({scv1.tag, scv2.tag, scv3.tag})\\n', '        empty_group = self.workers & []\\n', '        assert scv_group.amount == 3\\n', '        assert empty_group.amount == 0\\n', '        assert not scv_group.empty\\n', '        assert empty_group.empty\\n', '        assert scv_group.exists\\n', '        assert not empty_group.exists\\n', '        assert scv_group.find_by_tag(scv1.tag) == scv1\\n', '        assert scv_group.find_by_tag(1337) is None\\n', '        assert scv_group.random in [scv1, scv2, scv3]\\n', '        test_point = scv1.position.offset(Point2((0.01, 0.01)))\\n', '        assert abs(scv_group.closest_distance_to(test_point) - (0.01**2 + 0.01**2)**0.5) < 0.01\\n', '        assert scv_group.closest_to(test_point) == scv1\\n', '        assert scv_group.furthest_to(test_point) != scv1\\n', '        assert scv_group.furthest_to(test_point) in [scv2, scv3]\\n', '        assert scv_group.closer_than(0.02, test_point) == self.workers.tags_in({scv1.tag})\\n', '        assert scv_group.closer_than(30, test_point) == scv_group\\n', '        assert scv_group.further_than(0.02, test_point) == self.workers.tags_in({scv2.tag, scv3.tag})\\n', '        assert scv_group.closer_than(50, test_point).further_than(0.00001, test_point).of_type(UnitTypeId.SCV) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.SCV}) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.MARINE}) == empty_group\\n', '        assert scv_group.tags == {u.tag for u in scv_group}\\n', '        assert scv_group.owned == scv_group\\n', '        assert scv_group.enemy == empty_group\\n']",
  "context": "  async def test_units(self):\n        scv1, scv2, scv3 = self.workers[:3]\n        scv_group = self.workers.tags_in({scv1.tag"
 },
 "76": {
  "name": "empty_group",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/test/autotest_bot.py",
  "lineno": "275",
  "column": "8",
  "slicing": "['        for loc in self.enemy_start_locations:\\n', '            assert isinstance(loc, Point2), loc\\n', '            assert loc.distance_to(self.start_location) > 20, (loc, self.start_location)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.move(center))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        center = self._game_info.map_center\\n', '        scvs = self.workers\\n', '        scvs1 = scvs[:6]\\n', '        scvs2 = scvs[6:]\\n', '        for scv in scvs1:\\n', '            combined_actions.append(scv.move(center))\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in scvs2:\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        combined_actions = []\\n', '        mf = self.state.mineral_field.closest_to(self.townhalls.random)\\n', '        for scv in self.units(UnitTypeId.SCV):\\n', '            combined_actions.append(scv.gather(mf))\\n', '        await self.do_actions(combined_actions)\\n', '        p1 = Pointlike((2.3, 2.7))\\n', '        p2 = Point2((-5.3, -7.9))\\n', '        p3 = Point3((-2.7, 5.4, 133.2))\\n', '        assert p1 == Pointlike((2.3, 2.7))\\n', '        assert p1.rounded == Pointlike((2, 3))\\n', '        assert p1.position == p1\\n', '        assert p1.distance_to(Pointlike((-0.7, 6.7))) == 5\\n', '        assert p1.closest([\\n', '        assert p1.furthest([\\n', '        assert p1.offset(Pointlike((-1, -1))) == Pointlike((1.3, 1.7))\\n', '        assert p1.offset(Pointlike((-1, 1))) == Pointlike((1.3, 3.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), 5) == Pointlike((2.3, 7.7))\\n', '        assert p1.towards(Pointlike((2.3, 50)), -5) == Pointlike((2.3, -2.3))\\n', '        assert p2.x == -5.3\\n', '        assert p2.y == -7.9\\n', '        assert p2.to2 == p2\\n', '        assert p2.to3 == Point3((-5.3, -7.9, 0))\\n', '        assert (p2.neighbors4 ==\\n', '        assert p2.neighbors8 == (p2.neighbors4 |\\n', '        assert p3.z == 133.2\\n', '        assert p3.to3 == p3\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        assert scv1.type_id == UnitTypeId.SCV\\n', '        assert scv1._type_data == self._game_data.units[UnitTypeId.SCV.value]\\n', '        assert scv1.alliance == Alliance.Self.value\\n', '        assert scv1.is_mine == True\\n', '        assert isinstance(scv1.position, Point2)\\n', '        assert isinstance(scv1.position3d, Point3)\\n', '        assert scv1.health == 45\\n', '        assert scv1.health_max == 45\\n', '        assert scv1.health_percentage == 45/45\\n', '        assert scv1.energy == 0\\n', '        assert scv1.energy_max == 0\\n', '        assert scv1.energy_percentage == 0\\n', '        assert not scv1.target_in_range(self.workers.tags_not_in({scv1.tag}).furthest_to(scv1.position))\\n', '        assert scv1.target_in_range(scv1)\\n', '        scv1, scv2, scv3 = self.workers[:3]\\n', '        scv_group = self.workers.tags_in({scv1.tag, scv2.tag, scv3.tag})\\n', '        empty_group = self.workers & []\\n', '        assert scv_group.amount == 3\\n', '        assert empty_group.amount == 0\\n', '        assert not scv_group.empty\\n', '        assert empty_group.empty\\n', '        assert scv_group.exists\\n', '        assert not empty_group.exists\\n', '        assert scv_group.find_by_tag(scv1.tag) == scv1\\n', '        assert scv_group.find_by_tag(1337) is None\\n', '        assert scv_group.random in [scv1, scv2, scv3]\\n', '        test_point = scv1.position.offset(Point2((0.01, 0.01)))\\n', '        assert abs(scv_group.closest_distance_to(test_point) - (0.01**2 + 0.01**2)**0.5) < 0.01\\n', '        assert scv_group.closest_to(test_point) == scv1\\n', '        assert scv_group.furthest_to(test_point) != scv1\\n', '        assert scv_group.furthest_to(test_point) in [scv2, scv3]\\n', '        assert scv_group.closer_than(0.02, test_point) == self.workers.tags_in({scv1.tag})\\n', '        assert scv_group.closer_than(30, test_point) == scv_group\\n', '        assert scv_group.further_than(0.02, test_point) == self.workers.tags_in({scv2.tag, scv3.tag})\\n', '        assert scv_group.closer_than(50, test_point).further_than(0.00001, test_point).of_type(UnitTypeId.SCV) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.SCV}) == scv_group\\n', '        assert scv_group.of_type({UnitTypeId.MARINE}) == empty_group\\n', '        assert scv_group.tags == {u.tag for u in scv_group}\\n', '        assert scv_group.owned == scv_group\\n', '        assert scv_group.enemy == empty_group\\n']",
  "context": "s.tags_in({scv1.tag, scv2.tag, scv3.tag})\n        empty_group = self.workers & []\n\n        assert scv_group.amount == 3\n        asse"
 },
 "77": {
  "name": "t0",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "23",
  "column": "4",
  "slicing": "['    t0 = time.time()\\n', '    print(\"Game took {} real time seconds\".format(round(time.time() - t0, 1)))\\n']",
  "context": "empt to run process with retries and timeouts\n    t0 = time.time()\n    process, result = None, None\n    for i in rang"
 },
 "78": {
  "name": "process",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "24",
  "column": "4",
  "slicing": "['retries = 2\\n', 'timeout_time = 3*60 # My maxout bot took 110 - 140 real seconds for 7 minutes in game time\\n', '    process, result = None, None\\n', '    for i in range(retries):\\n', '        process = subprocess.Popen([\"python\", sys.argv[1]], stdout=subprocess.PIPE)\\n', '            result = process.communicate(timeout=timeout_time)\\n', '        out, err = result\\n', '        result = out.decode(\"utf-8\")\\n', '    if process.returncode is not None:\\n', '        print_output: str = result\\n', '        linebreaks = [\\n', '            [\"\\\\r\\\\n\", print_output.count(\"\\\\r\\\\n\")],\\n', '            [\"\\\\r\", print_output.count(\"\\\\r\")],\\n', '            [\"\\\\n\", print_output.count(\"\\\\n\")],\\n', '        most_linebreaks_type = max(linebreaks, key=lambda x: x[1])\\n', '        linebreak_type, linebreak_count = most_linebreaks_type\\n', '        output_as_list = print_output.split(linebreak_type)\\n', '        print(\"Travis test script, bot output:\\\\r\\\\n{}\".format(\"\\\\r\\\\n\".join(output_as_list)))\\n', '    if process.returncode is None or process.returncode != 0:\\n', '        print(\"Exiting with exit code 5, error: Attempted to launch script {} timed out after {} seconds. Retries completed: {}\".format(sys.argv[1], timeout_time, retries))\\n', '    print(\"Returncode: {}\".format(process.returncode))\\n', '    if process is not None and process.returncode == 0:\\n', '        for line in output_as_list:\\n', '            if \"Traceback \" in line:\\n']",
  "context": "ith retries and timeouts\n    t0 = time.time()\n    process, result = None, None\n    for i in range(retries):\n        t0 = time.tim"
 },
 "79": {
  "name": "result",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "24",
  "column": "13",
  "slicing": "['retries = 2\\n', 'timeout_time = 3*60 # My maxout bot took 110 - 140 real seconds for 7 minutes in game time\\n', '    process, result = None, None\\n', '    for i in range(retries):\\n', '        process = subprocess.Popen([\"python\", sys.argv[1]], stdout=subprocess.PIPE)\\n', '            result = process.communicate(timeout=timeout_time)\\n', '        out, err = result\\n', '        result = out.decode(\"utf-8\")\\n', '    if process.returncode is not None:\\n', '        print_output: str = result\\n', '        linebreaks = [\\n', '            [\"\\\\r\\\\n\", print_output.count(\"\\\\r\\\\n\")],\\n', '            [\"\\\\r\", print_output.count(\"\\\\r\")],\\n', '            [\"\\\\n\", print_output.count(\"\\\\n\")],\\n', '        most_linebreaks_type = max(linebreaks, key=lambda x: x[1])\\n', '        linebreak_type, linebreak_count = most_linebreaks_type\\n', '        output_as_list = print_output.split(linebreak_type)\\n', '        print(\"Travis test script, bot output:\\\\r\\\\n{}\".format(\"\\\\r\\\\n\".join(output_as_list)))\\n', '    if process.returncode is None or process.returncode != 0:\\n', '        print(\"Exiting with exit code 5, error: Attempted to launch script {} timed out after {} seconds. Retries completed: {}\".format(sys.argv[1], timeout_time, retries))\\n', '    print(\"Returncode: {}\".format(process.returncode))\\n', '    if process is not None and process.returncode == 0:\\n', '        for line in output_as_list:\\n', '            if \"Traceback \" in line:\\n']",
  "context": "es and timeouts\n    t0 = time.time()\n    process, result = None, None\n    for i in range(retries):\n        t0 = time.tim"
 },
 "80": {
  "name": "t0",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "26",
  "column": "8",
  "slicing": "['retries = 2\\n', '    for i in range(retries):\\n', '        t0 = time.time()\\n', '        print(\"Exiting with exit code 5, error: Attempted to launch script {} timed out after {} seconds. Retries completed: {}\".format(sys.argv[1], timeout_time, retries))\\n', '    print(\"Game took {} real time seconds\".format(round(time.time() - t0, 1)))\\n']",
  "context": "= None, None\n    for i in range(retries):\n        t0 = time.time()\n\n        process = subprocess.Popen([\"python\", sys"
 },
 "81": {
  "name": "out",
  "type": "result",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "34",
  "column": "8",
  "slicing": "['retries = 2\\n', 'timeout_time = 3*60 # My maxout bot took 110 - 140 real seconds for 7 minutes in game time\\n', '    process, result = None, None\\n', '    for i in range(retries):\\n', '        process = subprocess.Popen([\"python\", sys.argv[1]], stdout=subprocess.PIPE)\\n', '            result = process.communicate(timeout=timeout_time)\\n', '        out, err = result\\n', '        result = out.decode(\"utf-8\")\\n', '    if process.returncode is not None:\\n', '        print_output: str = result\\n', '        linebreaks = [\\n', '            [\"\\\\r\\\\n\", print_output.count(\"\\\\r\\\\n\")],\\n', '            [\"\\\\r\", print_output.count(\"\\\\r\")],\\n', '            [\"\\\\n\", print_output.count(\"\\\\n\")],\\n', '        most_linebreaks_type = max(linebreaks, key=lambda x: x[1])\\n', '        linebreak_type, linebreak_count = most_linebreaks_type\\n', '        output_as_list = print_output.split(linebreak_type)\\n', '        print(\"Travis test script, bot output:\\\\r\\\\n{}\".format(\"\\\\r\\\\n\".join(output_as_list)))\\n', '    if process.returncode is None or process.returncode != 0:\\n', '        print(\"Exiting with exit code 5, error: Attempted to launch script {} timed out after {} seconds. Retries completed: {}\".format(sys.argv[1], timeout_time, retries))\\n', '    print(\"Returncode: {}\".format(process.returncode))\\n', '    if process is not None and process.returncode == 0:\\n', '        for line in output_as_list:\\n', '            if \"Traceback \" in line:\\n']",
  "context": "cess.TimeoutExpired:\n            continue\n        out, err = result\n        result = out.decode(\"utf-8\")\n\n        # Br"
 },
 "82": {
  "name": "err",
  "type": "result",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "34",
  "column": "13",
  "slicing": "['        out, err = result\\n']",
  "context": "TimeoutExpired:\n            continue\n        out, err = result\n        result = out.decode(\"utf-8\")\n\n        # Br"
 },
 "83": {
  "name": "print_output",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "42",
  "column": "8",
  "slicing": "['retries = 2\\n', 'timeout_time = 3*60 # My maxout bot took 110 - 140 real seconds for 7 minutes in game time\\n', '    process, result = None, None\\n', '    for i in range(retries):\\n', '        process = subprocess.Popen([\"python\", sys.argv[1]], stdout=subprocess.PIPE)\\n', '            result = process.communicate(timeout=timeout_time)\\n', '        out, err = result\\n', '        result = out.decode(\"utf-8\")\\n', '    if process.returncode is not None:\\n', '        print_output: str = result\\n', '        linebreaks = [\\n', '            [\"\\\\r\\\\n\", print_output.count(\"\\\\r\\\\n\")],\\n', '            [\"\\\\r\", print_output.count(\"\\\\r\")],\\n', '            [\"\\\\n\", print_output.count(\"\\\\n\")],\\n', '        most_linebreaks_type = max(linebreaks, key=lambda x: x[1])\\n', '        linebreak_type, linebreak_count = most_linebreaks_type\\n', '        output_as_list = print_output.split(linebreak_type)\\n', '        print(\"Travis test script, bot output:\\\\r\\\\n{}\".format(\"\\\\r\\\\n\".join(output_as_list)))\\n', '    if process.returncode is None or process.returncode != 0:\\n', '        print(\"Exiting with exit code 5, error: Attempted to launch script {} timed out after {} seconds. Retries completed: {}\".format(sys.argv[1], timeout_time, retries))\\n', '    print(\"Returncode: {}\".format(process.returncode))\\n', '    if process is not None and process.returncode == 0:\\n', '        for line in output_as_list:\\n', '            if \"Traceback \" in line:\\n']",
  "context": "        # Reformat the output into a list\n        print_output: str = result\n        linebreaks = [\n            [\"\\r\\n\", print_"
 },
 "84": {
  "name": "linebreaks",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "43",
  "column": "8",
  "slicing": "['retries = 2\\n', 'timeout_time = 3*60 # My maxout bot took 110 - 140 real seconds for 7 minutes in game time\\n', '    process, result = None, None\\n', '    for i in range(retries):\\n', '        process = subprocess.Popen([\"python\", sys.argv[1]], stdout=subprocess.PIPE)\\n', '            result = process.communicate(timeout=timeout_time)\\n', '        out, err = result\\n', '        result = out.decode(\"utf-8\")\\n', '    if process.returncode is not None:\\n', '        print_output: str = result\\n', '        linebreaks = [\\n', '            [\"\\\\r\\\\n\", print_output.count(\"\\\\r\\\\n\")],\\n', '            [\"\\\\r\", print_output.count(\"\\\\r\")],\\n', '            [\"\\\\n\", print_output.count(\"\\\\n\")],\\n', '        most_linebreaks_type = max(linebreaks, key=lambda x: x[1])\\n', '        linebreak_type, linebreak_count = most_linebreaks_type\\n', '        output_as_list = print_output.split(linebreak_type)\\n', '        print(\"Travis test script, bot output:\\\\r\\\\n{}\".format(\"\\\\r\\\\n\".join(output_as_list)))\\n', '    if process.returncode is None or process.returncode != 0:\\n', '        print(\"Exiting with exit code 5, error: Attempted to launch script {} timed out after {} seconds. Retries completed: {}\".format(sys.argv[1], timeout_time, retries))\\n', '    print(\"Returncode: {}\".format(process.returncode))\\n', '    if process is not None and process.returncode == 0:\\n', '        for line in output_as_list:\\n', '            if \"Traceback \" in line:\\n']",
  "context": "a list\n        print_output: str = result\n        linebreaks = [\n            [\"\\r\\n\", print_output.count(\"\\r\\n\")],\n"
 },
 "85": {
  "name": "most_linebreaks_type",
  "type": "max",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "48",
  "column": "8",
  "slicing": "['retries = 2\\n', 'timeout_time = 3*60 # My maxout bot took 110 - 140 real seconds for 7 minutes in game time\\n', '    process, result = None, None\\n', '    for i in range(retries):\\n', '        process = subprocess.Popen([\"python\", sys.argv[1]], stdout=subprocess.PIPE)\\n', '            result = process.communicate(timeout=timeout_time)\\n', '        out, err = result\\n', '        result = out.decode(\"utf-8\")\\n', '    if process.returncode is not None:\\n', '        print_output: str = result\\n', '        linebreaks = [\\n', '            [\"\\\\r\\\\n\", print_output.count(\"\\\\r\\\\n\")],\\n', '            [\"\\\\r\", print_output.count(\"\\\\r\")],\\n', '            [\"\\\\n\", print_output.count(\"\\\\n\")],\\n', '        most_linebreaks_type = max(linebreaks, key=lambda x: x[1])\\n', '        linebreak_type, linebreak_count = most_linebreaks_type\\n', '        output_as_list = print_output.split(linebreak_type)\\n', '        print(\"Travis test script, bot output:\\\\r\\\\n{}\".format(\"\\\\r\\\\n\".join(output_as_list)))\\n', '    if process.returncode is None or process.returncode != 0:\\n', '        print(\"Exiting with exit code 5, error: Attempted to launch script {} timed out after {} seconds. Retries completed: {}\".format(sys.argv[1], timeout_time, retries))\\n', '    print(\"Returncode: {}\".format(process.returncode))\\n', '    if process is not None and process.returncode == 0:\\n', '        for line in output_as_list:\\n', '            if \"Traceback \" in line:\\n']",
  "context": "\\n\", print_output.count(\"\\n\")],\n        ]\n        most_linebreaks_type = max(linebreaks, key=lambda x: x[1])\n        linebreak_type, linebreak_count = most_lin"
 },
 "86": {
  "name": "linebreak_type",
  "type": "most_linebreaks_type",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "49",
  "column": "8",
  "slicing": "['retries = 2\\n', 'timeout_time = 3*60 # My maxout bot took 110 - 140 real seconds for 7 minutes in game time\\n', '    process, result = None, None\\n', '    for i in range(retries):\\n', '        process = subprocess.Popen([\"python\", sys.argv[1]], stdout=subprocess.PIPE)\\n', '            result = process.communicate(timeout=timeout_time)\\n', '        out, err = result\\n', '        result = out.decode(\"utf-8\")\\n', '    if process.returncode is not None:\\n', '        print_output: str = result\\n', '        linebreaks = [\\n', '            [\"\\\\r\\\\n\", print_output.count(\"\\\\r\\\\n\")],\\n', '            [\"\\\\r\", print_output.count(\"\\\\r\")],\\n', '            [\"\\\\n\", print_output.count(\"\\\\n\")],\\n', '        most_linebreaks_type = max(linebreaks, key=lambda x: x[1])\\n', '        linebreak_type, linebreak_count = most_linebreaks_type\\n', '        output_as_list = print_output.split(linebreak_type)\\n', '        print(\"Travis test script, bot output:\\\\r\\\\n{}\".format(\"\\\\r\\\\n\".join(output_as_list)))\\n', '    if process.returncode is None or process.returncode != 0:\\n', '        print(\"Exiting with exit code 5, error: Attempted to launch script {} timed out after {} seconds. Retries completed: {}\".format(sys.argv[1], timeout_time, retries))\\n', '    print(\"Returncode: {}\".format(process.returncode))\\n', '    if process is not None and process.returncode == 0:\\n', '        for line in output_as_list:\\n', '            if \"Traceback \" in line:\\n']",
  "context": "ype = max(linebreaks, key=lambda x: x[1])\n        linebreak_type, linebreak_count = most_linebreaks_type\n        output_as_list = print_output.split(linebr"
 },
 "87": {
  "name": "linebreak_count",
  "type": "most_linebreaks_type",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/test/travis_test_script.py",
  "lineno": "49",
  "column": "24",
  "slicing": "['        linebreak_type, linebreak_count = most_linebreaks_type\\n']",
  "context": "eaks, key=lambda x: x[1])\n        linebreak_type, linebreak_count = most_linebreaks_type\n        output_as_list = print_output.split(linebr"
 },
 "88": {
  "name": "stw",
  "type": "sc2.main.SlidingTimeWindow",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/test/test_sliding_window.py",
  "lineno": "4",
  "column": "4",
  "slicing": "['    stw = SlidingTimeWindow(5)\\n', '    stw.push(1.0)\\n', '    assert stw.sum == 1.0\\n', '    stw.push(1.0)\\n', '    assert stw.sum == 2.0\\n', '    stw.push(2.0)\\n', '    assert stw.sum == 4.0\\n', '    stw.push(2.0)\\n', '    assert stw.sum == 6.0\\n', '    stw.push(4.0)\\n', '    assert stw.sum == 10.0\\n', '    stw.push(4.0)\\n', '    assert stw.sum == 13.0\\n', '    stw.push(4.0)\\n', '    assert stw.sum == 16.0\\n', '    stw.push(4.0)\\n', '    assert stw.sum == 18.0\\n']",
  "context": "ngTimeWindow\n\ndef test_sliding_time_window():\n    stw = SlidingTimeWindow(5)\n\n    stw.push(1.0)\n    assert stw.sum == 1.0\n\n    "
 },
 "89": {
  "name": "bot",
  "type": "examples.zerg.zerg_rush.ZergRushBot",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/test/test_examples.py",
  "lineno": "14",
  "column": "30",
  "slicing": "['def run_example(caplog, race, bot):\\n', '        Bot(race, bot),\\n']",
  "context": "mport BroodlordBot\n\ndef run_example(caplog, race, bot):\n    result = sc2.run_game(sc2.maps.get(\"Sequencer "
 },
 "90": {
  "name": "player_config",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/host_external_norestart.py",
  "lineno": "16",
  "column": "4",
  "slicing": "['    player_config = [\\n', '        player_config,\\n']",
  "context": "g.Portconfig()\n    print(portconfig.as_json)\n\n    player_config = [\n        Bot(Race.Zerg, ZergRushBot()),\n        Bot"
 },
 "91": {
  "name": "player_config",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/fastreload.py",
  "lineno": "14",
  "column": "4",
  "slicing": "['    player_config = [\\n', '        player_config,\\n', '        player_config[0].ai = zerg_rush.ZergRushBot()\\n', '        gen.send(player_config)\\n']",
  "context": "uter\n\nfrom zerg import zerg_rush\n\ndef main():\n    player_config = [\n        Bot(Race.Zerg, zerg_rush.ZergRushBot()),\n "
 },
 "92": {
  "name": "r",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/fastreload.py",
  "lineno": "26",
  "column": "8",
  "slicing": "['    player_config = [\\n', '    gen = sc2.main._host_game_iter(\\n', '        player_config,\\n', '        r = next(gen)\\n', '        player_config[0].ai = zerg_rush.ZergRushBot()\\n', '        gen.send(player_config)\\n']",
  "context": "    realtime=False\n    )\n\n    while True:\n        r = next(gen)\n\n        input(\"Press enter to reload \")\n\n        "
 },
 "93": {
  "name": "target",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/worker_rush.py",
  "lineno": "13",
  "column": "12",
  "slicing": "['            target = self.enemy_start_locations[0]\\n', '                self.actions.append(worker.attack(target))\\n']",
  "context": "ions = []\n\n        if iteration == 0:\n            target = self.enemy_start_locations[0]\n\n            for worker in self.workers:\n         "
 },
 "94": {
  "name": "actions",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "43",
  "column": "8",
  "slicing": "['        actions = []\\n', '                            actions.append(unit(AbilityId.EFFECT_STIM))\\n', '                        actions.append(unit.attack(lowest_hp_enemy_in_range))\\n', '                        actions.append(unit.attack(closest_enemy))\\n', '                        actions.append(unit.move(retreat_position))\\n', '        await self.do_actions(actions)\\n']",
  "context": "         await self.on_first_iteration()\n\n        actions = []\n\n        # do marine micro vs zerglings\n        fo"
 },
 "95": {
  "name": "lowest_hp_enemy_in_range",
  "type": "min",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "67",
  "column": "24",
  "slicing": "['        actions = []\\n', '        for unit in self.units(UnitTypeId.MARINE):\\n', '                if unit.weapon_cooldown <= self._client.game_step / 2:\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u))\\n', '                    if enemies_in_range:\\n', '                        if self.already_pending_upgrade(UpgradeId.STIMPACK) == 1 and not unit.has_buff(BuffId.STIMPACK) and unit.health > 10:\\n', '                            actions.append(unit(AbilityId.EFFECT_STIM))\\n', '                        filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.BANELING)\\n', '                        if not filtered_enemies_in_range:\\n', '                            filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.ZERGLING)\\n', '                        lowest_hp_enemy_in_range = min(filtered_enemies_in_range, key=lambda u: u.health)\\n', '                        actions.append(unit.attack(lowest_hp_enemy_in_range))\\n', '                        closest_enemy = self.known_enemy_units.closest_to(unit)\\n', '                        actions.append(unit.attack(closest_enemy))\\n', '                    stutter_step_positions = self.position_around_unit(unit, distance=4)\\n', '                    stutter_step_positions = {p for p in stutter_step_positions if self.in_pathing_grid(p)}\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u, -0.5))\\n', '                    if stutter_step_positions and enemies_in_range:\\n', '                        retreat_position = max(stutter_step_positions, key=lambda x: x.distance_to(enemies_in_range.center) - x.distance_to(unit))\\n', '                        actions.append(unit.move(retreat_position))\\n', '                        print(\"No retreat positions detected for unit {} at {}.\".format(unit, unit.position.rounded))\\n', '        await self.do_actions(actions)\\n', '        pos = pos.position.to2.rounded\\n', '        positions = {pos.offset(Point2((x, y)))\\n', '                     for x in range(-distance, distance+1, step_size)\\n', '                     for y in range(-distance, distance+1, step_size)\\n', '                     if (x, y) != (0, 0)}\\n', '            positions = {p for p in positions if 0 <= p[0] < self._game_info.pathing_grid.width and 0 <= p[1] < self._game_info.pathing_grid.height}\\n', '        return positions\\n']",
  "context": "  # attack lowest hp unit\n                        lowest_hp_enemy_in_range = min(filtered_enemies_in_range, key=lambda u: u.health)\n                        actions.append(unit.attack"
 },
 "96": {
  "name": "stutter_step_positions",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "78",
  "column": "20",
  "slicing": "['        actions = []\\n', '        for unit in self.units(UnitTypeId.MARINE):\\n', '                if unit.weapon_cooldown <= self._client.game_step / 2:\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u))\\n', '                    if enemies_in_range:\\n', '                        if self.already_pending_upgrade(UpgradeId.STIMPACK) == 1 and not unit.has_buff(BuffId.STIMPACK) and unit.health > 10:\\n', '                            actions.append(unit(AbilityId.EFFECT_STIM))\\n', '                        filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.BANELING)\\n', '                        if not filtered_enemies_in_range:\\n', '                            filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.ZERGLING)\\n', '                        lowest_hp_enemy_in_range = min(filtered_enemies_in_range, key=lambda u: u.health)\\n', '                        actions.append(unit.attack(lowest_hp_enemy_in_range))\\n', '                        closest_enemy = self.known_enemy_units.closest_to(unit)\\n', '                        actions.append(unit.attack(closest_enemy))\\n', '                    stutter_step_positions = self.position_around_unit(unit, distance=4)\\n', '                    stutter_step_positions = {p for p in stutter_step_positions if self.in_pathing_grid(p)}\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u, -0.5))\\n', '                    if stutter_step_positions and enemies_in_range:\\n', '                        retreat_position = max(stutter_step_positions, key=lambda x: x.distance_to(enemies_in_range.center) - x.distance_to(unit))\\n', '                        actions.append(unit.move(retreat_position))\\n', '                        print(\"No retreat positions detected for unit {} at {}.\".format(unit, unit.position.rounded))\\n', '        await self.do_actions(actions)\\n', '        pos = pos.position.to2.rounded\\n', '        positions = {pos.offset(Point2((x, y)))\\n', '                     for x in range(-distance, distance+1, step_size)\\n', '                     for y in range(-distance, distance+1, step_size)\\n', '                     if (x, y) != (0, 0)}\\n', '            positions = {p for p in positions if 0 <= p[0] < self._game_info.pathing_grid.width and 0 <= p[1] < self._game_info.pathing_grid.height}\\n', '        return positions\\n']",
  "context": "nelings\n                else:\n                    stutter_step_positions = self.position_around_unit(unit, distance=4)\n\n                    # filter in pathing grid\n    "
 },
 "97": {
  "name": "stutter_step_positions",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "81",
  "column": "20",
  "slicing": "['        actions = []\\n', '        for unit in self.units(UnitTypeId.MARINE):\\n', '                if unit.weapon_cooldown <= self._client.game_step / 2:\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u))\\n', '                    if enemies_in_range:\\n', '                        if self.already_pending_upgrade(UpgradeId.STIMPACK) == 1 and not unit.has_buff(BuffId.STIMPACK) and unit.health > 10:\\n', '                            actions.append(unit(AbilityId.EFFECT_STIM))\\n', '                        filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.BANELING)\\n', '                        if not filtered_enemies_in_range:\\n', '                            filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.ZERGLING)\\n', '                        lowest_hp_enemy_in_range = min(filtered_enemies_in_range, key=lambda u: u.health)\\n', '                        actions.append(unit.attack(lowest_hp_enemy_in_range))\\n', '                        closest_enemy = self.known_enemy_units.closest_to(unit)\\n', '                        actions.append(unit.attack(closest_enemy))\\n', '                    stutter_step_positions = self.position_around_unit(unit, distance=4)\\n', '                    stutter_step_positions = {p for p in stutter_step_positions if self.in_pathing_grid(p)}\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u, -0.5))\\n', '                    if stutter_step_positions and enemies_in_range:\\n', '                        retreat_position = max(stutter_step_positions, key=lambda x: x.distance_to(enemies_in_range.center) - x.distance_to(unit))\\n', '                        actions.append(unit.move(retreat_position))\\n', '                        print(\"No retreat positions detected for unit {} at {}.\".format(unit, unit.position.rounded))\\n', '        await self.do_actions(actions)\\n', '        pos = pos.position.to2.rounded\\n', '        positions = {pos.offset(Point2((x, y)))\\n', '                     for x in range(-distance, distance+1, step_size)\\n', '                     for y in range(-distance, distance+1, step_size)\\n', '                     if (x, y) != (0, 0)}\\n', '            positions = {p for p in positions if 0 <= p[0] < self._game_info.pathing_grid.width and 0 <= p[1] < self._game_info.pathing_grid.height}\\n', '        return positions\\n']",
  "context": "     # filter in pathing grid\n                    stutter_step_positions = {p for p in stutter_step_positions if self.in_pathing_grid(p)}\n\n                    # find position furthest away"
 },
 "98": {
  "name": "retreat_position",
  "type": "max",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "87",
  "column": "24",
  "slicing": "['        actions = []\\n', '        for unit in self.units(UnitTypeId.MARINE):\\n', '                if unit.weapon_cooldown <= self._client.game_step / 2:\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u))\\n', '                    if enemies_in_range:\\n', '                        if self.already_pending_upgrade(UpgradeId.STIMPACK) == 1 and not unit.has_buff(BuffId.STIMPACK) and unit.health > 10:\\n', '                            actions.append(unit(AbilityId.EFFECT_STIM))\\n', '                        filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.BANELING)\\n', '                        if not filtered_enemies_in_range:\\n', '                            filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.ZERGLING)\\n', '                        lowest_hp_enemy_in_range = min(filtered_enemies_in_range, key=lambda u: u.health)\\n', '                        actions.append(unit.attack(lowest_hp_enemy_in_range))\\n', '                        closest_enemy = self.known_enemy_units.closest_to(unit)\\n', '                        actions.append(unit.attack(closest_enemy))\\n', '                    stutter_step_positions = self.position_around_unit(unit, distance=4)\\n', '                    stutter_step_positions = {p for p in stutter_step_positions if self.in_pathing_grid(p)}\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u, -0.5))\\n', '                    if stutter_step_positions and enemies_in_range:\\n', '                        retreat_position = max(stutter_step_positions, key=lambda x: x.distance_to(enemies_in_range.center) - x.distance_to(unit))\\n', '                        actions.append(unit.move(retreat_position))\\n', '                        print(\"No retreat positions detected for unit {} at {}.\".format(unit, unit.position.rounded))\\n', '        await self.do_actions(actions)\\n', '        pos = pos.position.to2.rounded\\n', '        positions = {pos.offset(Point2((x, y)))\\n', '                     for x in range(-distance, distance+1, step_size)\\n', '                     for y in range(-distance, distance+1, step_size)\\n', '                     if (x, y) != (0, 0)}\\n', '            positions = {p for p in positions if 0 <= p[0] < self._game_info.pathing_grid.width and 0 <= p[1] < self._game_info.pathing_grid.height}\\n', '        return positions\\n']",
  "context": "ons and enemies_in_range:\n                        retreat_position = max(stutter_step_positions, key=lambda x: x.distance_to(enemies_in_range.center) - x.distance_to(unit))\n                        actions.append(unit.move(r"
 },
 "99": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "103",
  "column": "35",
  "slicing": "['    def position_around_unit(self, pos: Union[Unit, Point2, Point3], distance: int=1, step_size: int=1, exclude_out_of_bounds: bool=True):\\n']",
  "context": "f every 8th\n\n\n\n    def position_around_unit(self, pos: Union[Unit, Point2, Point3], distance: int=1, step_size: int=1, exclude_out_of_bounds: bool=True):\n        pos = pos.position.to2.rounded\n        pos"
 },
 "100": {
  "name": "distance",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "103",
  "column": "69",
  "slicing": "['    def position_around_unit(self, pos: Union[Unit, Point2, Point3], distance: int=1, step_size: int=1, exclude_out_of_bounds: bool=True):\\n']",
  "context": "ound_unit(self, pos: Union[Unit, Point2, Point3], distance: int=1, step_size: int=1, exclude_out_of_bounds: bool=True):\n        pos = pos.position.to2.rounded\n        pos"
 },
 "101": {
  "name": "step_size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "103",
  "column": "86",
  "slicing": "['    def position_around_unit(self, pos: Union[Unit, Point2, Point3], distance: int=1, step_size: int=1, exclude_out_of_bounds: bool=True):\\n']",
  "context": "os: Union[Unit, Point2, Point3], distance: int=1, step_size: int=1, exclude_out_of_bounds: bool=True):\n        pos = pos.position.to2.rounded\n        pos"
 },
 "102": {
  "name": "exclude_out_of_bounds",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "103",
  "column": "104",
  "slicing": "['    def position_around_unit(self, pos: Union[Unit, Point2, Point3], distance: int=1, step_size: int=1, exclude_out_of_bounds: bool=True):\\n']",
  "context": "int2, Point3], distance: int=1, step_size: int=1, exclude_out_of_bounds: bool=True):\n        pos = pos.position.to2.rounded\n        pos"
 },
 "103": {
  "name": "positions",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "105",
  "column": "8",
  "slicing": "['        actions = []\\n', '        for unit in self.units(UnitTypeId.MARINE):\\n', '                if unit.weapon_cooldown <= self._client.game_step / 2:\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u))\\n', '                    if enemies_in_range:\\n', '                        if self.already_pending_upgrade(UpgradeId.STIMPACK) == 1 and not unit.has_buff(BuffId.STIMPACK) and unit.health > 10:\\n', '                            actions.append(unit(AbilityId.EFFECT_STIM))\\n', '                        filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.BANELING)\\n', '                        if not filtered_enemies_in_range:\\n', '                            filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.ZERGLING)\\n', '                        lowest_hp_enemy_in_range = min(filtered_enemies_in_range, key=lambda u: u.health)\\n', '                        actions.append(unit.attack(lowest_hp_enemy_in_range))\\n', '                        closest_enemy = self.known_enemy_units.closest_to(unit)\\n', '                        actions.append(unit.attack(closest_enemy))\\n', '                    stutter_step_positions = self.position_around_unit(unit, distance=4)\\n', '                    stutter_step_positions = {p for p in stutter_step_positions if self.in_pathing_grid(p)}\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u, -0.5))\\n', '                    if stutter_step_positions and enemies_in_range:\\n', '                        retreat_position = max(stutter_step_positions, key=lambda x: x.distance_to(enemies_in_range.center) - x.distance_to(unit))\\n', '                        actions.append(unit.move(retreat_position))\\n', '                        print(\"No retreat positions detected for unit {} at {}.\".format(unit, unit.position.rounded))\\n', '        await self.do_actions(actions)\\n', '        pos = pos.position.to2.rounded\\n', '        positions = {pos.offset(Point2((x, y)))\\n', '                     for x in range(-distance, distance+1, step_size)\\n', '                     for y in range(-distance, distance+1, step_size)\\n', '                     if (x, y) != (0, 0)}\\n', '            positions = {p for p in positions if 0 <= p[0] < self._game_info.pathing_grid.width and 0 <= p[1] < self._game_info.pathing_grid.height}\\n', '        return positions\\n']",
  "context": "):\n        pos = pos.position.to2.rounded\n        positions = {pos.offset(Point2((x, y)))\n                     for x in range(-distance, dis"
 },
 "104": {
  "name": "positions",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/arcade_bot.py",
  "lineno": "111",
  "column": "12",
  "slicing": "['        actions = []\\n', '        for unit in self.units(UnitTypeId.MARINE):\\n', '                if unit.weapon_cooldown <= self._client.game_step / 2:\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u))\\n', '                    if enemies_in_range:\\n', '                        if self.already_pending_upgrade(UpgradeId.STIMPACK) == 1 and not unit.has_buff(BuffId.STIMPACK) and unit.health > 10:\\n', '                            actions.append(unit(AbilityId.EFFECT_STIM))\\n', '                        filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.BANELING)\\n', '                        if not filtered_enemies_in_range:\\n', '                            filtered_enemies_in_range = enemies_in_range.of_type(UnitTypeId.ZERGLING)\\n', '                        lowest_hp_enemy_in_range = min(filtered_enemies_in_range, key=lambda u: u.health)\\n', '                        actions.append(unit.attack(lowest_hp_enemy_in_range))\\n', '                        closest_enemy = self.known_enemy_units.closest_to(unit)\\n', '                        actions.append(unit.attack(closest_enemy))\\n', '                    stutter_step_positions = self.position_around_unit(unit, distance=4)\\n', '                    stutter_step_positions = {p for p in stutter_step_positions if self.in_pathing_grid(p)}\\n', '                    enemies_in_range = self.known_enemy_units.filter(lambda u: unit.target_in_range(u, -0.5))\\n', '                    if stutter_step_positions and enemies_in_range:\\n', '                        retreat_position = max(stutter_step_positions, key=lambda x: x.distance_to(enemies_in_range.center) - x.distance_to(unit))\\n', '                        actions.append(unit.move(retreat_position))\\n', '                        print(\"No retreat positions detected for unit {} at {}.\".format(unit, unit.position.rounded))\\n', '        await self.do_actions(actions)\\n', '        pos = pos.position.to2.rounded\\n', '        positions = {pos.offset(Point2((x, y)))\\n', '                     for x in range(-distance, distance+1, step_size)\\n', '                     for y in range(-distance, distance+1, step_size)\\n', '                     if (x, y) != (0, 0)}\\n', '            positions = {p for p in positions if 0 <= p[0] < self._game_info.pathing_grid.width and 0 <= p[1] < self._game_info.pathing_grid.height}\\n', '        return positions\\n']",
  "context": "ize\n        if exclude_out_of_bounds:\n            positions = {p for p in positions if 0 <= p[0] < self._game_info.pathing_grid.width and 0 <= p[1] < self._game_info.pathing_grid.height}\n        return positions\n\n\ndef main():\n    sc2.run"
 },
 "105": {
  "name": "__all__",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/__init__.py",
  "lineno": "2",
  "column": "0",
  "slicing": "['__all__ = [p.stem for p in Path().iterdir() if p.is_file() and p.suffix == \".py\" and p.stem != \"__init__\"]\\n']",
  "context": "from pathlib import Path\n__all__ = [p.stem for p in Path().iterdir() if p.is_file() and p.suffix == \".py\" and p.stem != \"__init__\"]\n"
 },
 "106": {
  "name": "player_config",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/run_external.py",
  "lineno": "20",
  "column": "4",
  "slicing": "['    player_config = [\\n', '    player_config[0 if is_host else 1].ai = ZergRushBot()\\n', '            player_config,\\n', '            player_config,\\n']",
  "context": "rtconfig()\n        print(portconfig.as_json)\n\n    player_config = [\n        Bot(Race.Zerg, None),\n        Bot(Race.Zer"
 },
 "107": {
  "name": "m",
  "type": "sc2.units.Units",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/zerg/zerg_rush.py",
  "lineno": "48",
  "column": "20",
  "slicing": "['            for unit in self.workers | self.units(ZERGLING) | self.units(QUEEN):\\n', '                await self.do(unit.attack(self.enemy_start_locations[0]))\\n', '        hatchery = self.units(HATCHERY).ready.first\\n', '        larvae = self.units(LARVA)\\n', '        target = self.known_enemy_structures.random_or(self.enemy_start_locations[0]).position\\n', '        for zl in self.units(ZERGLING).idle:\\n', '            await self.do(zl.attack(target))\\n', '        for queen in self.units(QUEEN).idle:\\n', '            abilities = await self.get_available_abilities(queen)\\n', '            if AbilityId.EFFECT_INJECTLARVA in abilities:\\n', '                await self.do(queen(EFFECT_INJECTLARVA, hatchery))\\n', '            sp = self.units(SPAWNINGPOOL).ready\\n', '            if sp.exists and self.minerals >= 100 and not self.mboost_started:\\n', '                await self.do(sp.first(RESEARCH_ZERGLINGMETABOLICBOOST))\\n', '                for drone in self.workers:\\n', '                    m = self.state.mineral_field.closer_than(10, drone.position)\\n', '                    await self.do(drone.gather(m.random, queue=True))\\n', '            if self.can_afford(OVERLORD) and larvae.exists:\\n', '                await self.do(larvae.random.train(OVERLORD))\\n', '            if larvae.exists and self.can_afford(ZERGLING):\\n', '                await self.do(larvae.random.train(ZERGLING))\\n', '            extractor = self.units(EXTRACTOR).first\\n', '            for drone in self.workers.random_group_of(3):\\n', '                await self.do(drone.gather(extractor))\\n', '            for d in range(4, 15):\\n', '                pos = hatchery.position.to2.towards(self.game_info.map_center, d)\\n', '                if await self.can_place(HATCHERY, pos):\\n', '                    await self.do(self.workers.random.build(HATCHERY, pos))\\n', '                await self.do(larvae.random.train(DRONE))\\n', '                drone = self.workers.random\\n', '                target = self.state.vespene_geyser.closest_to(drone.position)\\n', '                err = await self.do(drone.build(EXTRACTOR, target))\\n', '                if not err:\\n', '                for d in range(4, 15):\\n', '                    pos = hatchery.position.to2.towards(self.game_info.map_center, d)\\n', '                    if await self.can_place(SPAWNINGPOOL, pos):\\n', '                        drone = self.workers.closest_to(pos)\\n', '                        err = await self.do(drone.build(SPAWNINGPOOL, pos))\\n', '                        if not err:\\n', '                r = await self.do(hatchery.train(QUEEN))\\n', '                if not r:\\n']",
  "context": "   for drone in self.workers:\n                    m = self.state.mineral_field.closer_than(10, drone.position)\n                    await self.do(drone.gather(m.r"
 },
 "108": {
  "name": "__all__",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/zerg/__init__.py",
  "lineno": "2",
  "column": "0",
  "slicing": "['__all__ = [p.stem for p in Path().iterdir() if p.is_file() and p.suffix == \".py\" and p.stem != \"__init__\"]\\n']",
  "context": "from pathlib import Path\n__all__ = [p.stem for p in Path().iterdir() if p.is_file() and p.suffix == \".py\" and p.stem != \"__init__\"]\n"
 },
 "109": {
  "name": "placement",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/protoss/warpgate_push.py",
  "lineno": "23",
  "column": "16",
  "slicing": "['        for warpgate in self.units(WARPGATE).ready:\\n', '            abilities = await self.get_available_abilities(warpgate)\\n', '            if AbilityId.WARPGATETRAIN_ZEALOT in abilities:\\n', '                pos = proxy.position.to2.random_on_distance(4)\\n', '                placement = await self.find_placement(AbilityId.WARPGATETRAIN_STALKER, pos, placement_step=1)\\n', '                if placement is None:\\n', '                await self.do(warpgate.warp_in(STALKER, placement))\\n', '            if AbilityId.MORPH_WARPGATE in abilities and self.can_afford(AbilityId.MORPH_WARPGATE):\\n', '                if AbilityId.EFFECT_CHRONOBOOSTENERGYCOST in abilities:\\n', '                if AbilityId.EFFECT_CHRONOBOOSTENERGYCOST in abilities:\\n']",
  "context": "osition.to2.random_on_distance(4)\n                placement = await self.find_placement(AbilityId.WARPGATETRAIN_STALKER, pos, placement_step=1)\n                if placement is None:\n            "
 },
 "110": {
  "name": "__all__",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/protoss/__init__.py",
  "lineno": "2",
  "column": "0",
  "slicing": "['__all__ = [p.stem for p in Path().iterdir() if p.is_file() and p.suffix == \".py\" and p.stem != \"__init__\"]\\n']",
  "context": "from pathlib import Path\n__all__ = [p.stem for p in Path().iterdir() if p.is_file() and p.suffix == \".py\" and p.stem != \"__init__\"]\n"
 },
 "111": {
  "name": "retreatPoints",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "113",
  "column": "16",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "2/5 and enemyThreatsClose.exists:\n                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\n                # filter points that are pathable\n"
 },
 "112": {
  "name": "retreatPoints",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "115",
  "column": "16",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "# filter points that are pathable\n                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\n                if retreatPoints:\n                "
 },
 "113": {
  "name": "closestEnemy",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "126",
  "column": "16",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "orted(lambda x: x.distance_to(r))\n                closestEnemy = enemyGroundUnits[0]\n                self.combinedActions.append(r.atta"
 },
 "114": {
  "name": "furthestEnemy",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "137",
  "column": "16",
  "slicing": "['                furthestEnemy = None\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n']",
  "context": ": x.distance_to(r), reverse=True)\n                furthestEnemy = None\n                for enemy in enemyGroundUnitsInGre"
 },
 "115": {
  "name": "furthestEnemy",
  "type": "enemy",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "140",
  "column": "24",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "ities_of_unit=abilities):\n                        furthestEnemy = enemy\n                        break\n                if f"
 },
 "116": {
  "name": "retreatPoints",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "150",
  "column": "16",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "and enemyThreatsVeryClose.exists:\n                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \n                # filter points that are pathable "
 },
 "117": {
  "name": "retreatPoints",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "152",
  "column": "16",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "nts that are pathable by a reaper\n                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\n                if retreatPoints:\n                "
 },
 "118": {
  "name": "retreatPoint",
  "type": "max",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "155",
  "column": "20",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "hreatsVeryClose.closest_to(r)\n                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\n                    # retreatPoint = closestEnemy."
 },
 "119": {
  "name": "mf",
  "type": "max",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "183",
  "column": "16",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "_than(10, oc)\n            if mfs:\n                mf = max(mfs, key=lambda x:x.mineral_contents)\n                self.combinedActions.append(oc(Abi"
 },
 "120": {
  "name": "p",
  "type": "position",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "204",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "f neighbors4(self, position, distance=1):\n        p = position\n        d = distance\n        return {\n            "
 },
 "121": {
  "name": "d",
  "type": "distance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "205",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "sition, distance=1):\n        p = position\n        d = distance\n        return {\n            Point2((p.x - d, p.y)"
 },
 "122": {
  "name": "p",
  "type": "position",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "215",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "f neighbors8(self, position, distance=1):\n        p = position\n        d = distance\n        return self.neighbors"
 },
 "123": {
  "name": "d",
  "type": "distance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "216",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "sition, distance=1):\n        p = position\n        d = distance\n        return self.neighbors4(position, distance)"
 },
 "124": {
  "name": "mineralTags",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "253",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "wned_expansions = self.owned_expansions\n\n\n        mineralTags = [x.tag for x in self.state.units.mineral_field]\n        # gasTags = [x.tag for x in self.state.uni"
 },
 "125": {
  "name": "geyserTags",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "255",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "for x in self.state.units.vespene_geyser]\n        geyserTags = [x.tag for x in self.geysers]\n\n        workerPool = self.units & []\n        work"
 },
 "126": {
  "name": "workerPool",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "257",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "yserTags = [x.tag for x in self.geysers]\n\n        workerPool = self.units & []\n        workerPoolTags = set()\n\n        # find all"
 },
 "127": {
  "name": "workerPoolTags",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "258",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "rs]\n\n        workerPool = self.units & []\n        workerPoolTags = set()\n\n        # find all geysers that have surplus or d"
 },
 "128": {
  "name": "deficitGeysers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "261",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": " all geysers that have surplus or deficit\n        deficitGeysers = {}\n        surplusGeysers = {}\n        for g in self."
 },
 "129": {
  "name": "surplusGeysers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "262",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "us or deficit\n        deficitGeysers = {}\n        surplusGeysers = {}\n        for g in self.geysers.filter(lambda x:x.ve"
 },
 "130": {
  "name": "deficitTownhalls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "279",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "ll townhalls that have surplus or deficit\n        deficitTownhalls = {}\n        surplusTownhalls = {}\n        if not onlyS"
 },
 "131": {
  "name": "surplusTownhalls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "280",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": " or deficit\n        deficitTownhalls = {}\n        surplusTownhalls = {}\n        if not onlySaturateGas:\n            for th"
 },
 "132": {
  "name": "deficitGasCount",
  "type": "sum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "301",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "grab some more workers from surplus bases\n        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\n        surplusCount = sum(-gasInfo[\"deficit\"] for"
 },
 "133": {
  "name": "surplusCount",
  "type": "sum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "302",
  "column": "8",
  "slicing": "['            ws = self.workers.gathering\\n', '            if ws: # if workers found\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.SUPPLYDEPOT, w.position, placement_step=3)\\n', '                if loc: # if a placement location was found\\n', '                    self.combinedActions.append(w.build(UnitTypeId.SUPPLYDEPOT, loc))\\n', '        for depot in self.units(UnitTypeId.SUPPLYDEPOT).ready:\\n', '            self.combinedActions.append(depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER))\\n', '            for cc in self.units(UnitTypeId.COMMANDCENTER).idle: # .idle filters idle command centers\\n', '                self.combinedActions.append(cc(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND))\\n', '            next_expo = await self.get_next_expansion()\\n', '            location = await self.find_placement(UnitTypeId.COMMANDCENTER, next_expo, placement_step=1)\\n', '            if location:\\n', '                w = self.select_build_worker(location)\\n', '                if w and self.can_afford(UnitTypeId.COMMANDCENTER):\\n', '                    error = await self.do(w.build(UnitTypeId.COMMANDCENTER, location))\\n', '                    if error:\\n', '                        print(error)\\n', '            ws = self.workers.gathering\\n', '            if ws and self.townhalls.exists: # need to check if townhalls.amount > 0 because placement is based on townhall location\\n', '                w = ws.furthest_to(ws.center)\\n', '                loc = await self.find_placement(UnitTypeId.BARRACKS, self.townhalls.random.position, placement_step=4)\\n', '                if loc:\\n', '                    self.combinedActions.append(w.build(UnitTypeId.BARRACKS, loc))\\n', '            for th in self.townhalls:\\n', '                vgs = self.state.vespene_geyser.closer_than(10, th)\\n', '                for vg in vgs:\\n', '                    if await self.can_place(UnitTypeId.REFINERY, vg.position) and self.can_afford(UnitTypeId.REFINERY):\\n', '                        ws = self.workers.gathering\\n', '                        if ws.exists: # same condition as above\\n', '                            w = ws.closest_to(vg)\\n', '                            self.combinedActions.append(w.build(UnitTypeId.REFINERY, vg))\\n', '            for th in self.townhalls.idle:\\n', '                self.combinedActions.append(th.train(UnitTypeId.SCV))\\n', '            for rax in self.units(UnitTypeId.BARRACKS).idle:\\n', '                self.combinedActions.append(rax.train(UnitTypeId.REAPER))\\n', '        for r in self.units(UnitTypeId.REAPER):\\n', '            enemyThreatsClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(15, r) # threats that can attack the reaper\\n', '            if r.health_percentage < 2/5 and enemyThreatsClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)\\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsClose.closest_to(r)\\n', '                    retreatPoint = closestEnemy.position.furthest(retreatPoints)\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            enemyGroundUnits = self.known_enemy_units.not_flying.closer_than(5, r) # hardcoded attackrange of 5\\n', '            if r.weapon_cooldown == 0 and enemyGroundUnits.exists:\\n', '                enemyGroundUnits = enemyGroundUnits.sorted(lambda x: x.distance_to(r))\\n', '                closestEnemy = enemyGroundUnits[0]\\n', '                self.combinedActions.append(r.attack(closestEnemy))\\n', '            reaperGrenadeRange = self._game_data.abilities[AbilityId.KD8CHARGE_KD8CHARGE.value]._proto.cast_range\\n', '            enemyGroundUnitsInGrenadeRange = self.known_enemy_units.not_structure.not_flying.exclude_type([UnitTypeId.LARVA, UnitTypeId.EGG]).closer_than(reaperGrenadeRange, r)\\n', '            if enemyGroundUnitsInGrenadeRange.exists and (r.is_attacking or r.is_moving):\\n', '                abilities = (await self.get_available_abilities(r))\\n', '                enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange.sorted(lambda x: x.distance_to(r), reverse=True)\\n', '                furthestEnemy = None\\n', '                for enemy in enemyGroundUnitsInGrenadeRange:\\n', '                    if await self.can_cast(r, AbilityId.KD8CHARGE_KD8CHARGE, enemy, cached_abilities_of_unit=abilities):\\n', '                        furthestEnemy = enemy\\n', '                if furthestEnemy:\\n', '                    self.combinedActions.append(r(AbilityId.KD8CHARGE_KD8CHARGE, furthestEnemy))\\n', '            enemyThreatsVeryClose = self.known_enemy_units.filter(lambda x: x.can_attack_ground).closer_than(4.5, r) # hardcoded attackrange minus 0.5\\n', '            if r.weapon_cooldown != 0 and enemyThreatsVeryClose.exists:\\n', '                retreatPoints = self.neighbors8(r.position, distance=2) | self.neighbors8(r.position, distance=4)               \\n', '                retreatPoints = {x for x in retreatPoints if self.inPathingGrid(x)}\\n', '                if retreatPoints:\\n', '                    closestEnemy = enemyThreatsVeryClose.closest_to(r)\\n', '                    retreatPoint = max(retreatPoints, key=lambda x: x.distance_to(closestEnemy) - x.distance_to(r))\\n', '                    self.combinedActions.append(r.move(retreatPoint))\\n', '            allEnemyGroundUnits = self.known_enemy_units.not_flying\\n', '            if allEnemyGroundUnits.exists:\\n', '                closestEnemy = allEnemyGroundUnits.closest_to(r)\\n', '                self.combinedActions.append(r.move(closestEnemy))\\n', '            self.combinedActions.append(r.move(random.choice(self.enemy_start_locations)))\\n', '            for w in self.workers.idle:\\n', '                th = self.townhalls.closest_to(w)\\n', '                mfs = self.state.mineral_field.closer_than(10, th)\\n', '                if mfs:\\n', '                    mf = mfs.closest_to(w)\\n', '                    self.combinedActions.append(w.gather(mf))\\n', '        for oc in self.units(UnitTypeId.ORBITALCOMMAND).filter(lambda x: x.energy >= 50):\\n', '            mfs = self.state.mineral_field.closer_than(10, oc)\\n', '            if mfs:\\n', '                mf = max(mfs, key=lambda x:x.mineral_contents)\\n', '                self.combinedActions.append(oc(AbilityId.CALLDOWNMULE_CALLDOWNMULE, mf))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[(pos)] != 0\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y)),\\n', '            Point2((p.x + d, p.y)),\\n', '            Point2((p.x, p.y - d)),\\n', '            Point2((p.x, p.y + d)),\\n', '        p = position\\n', '        d = distance\\n', '            Point2((p.x - d, p.y - d)),\\n', '            Point2((p.x - d, p.y + d)),\\n', '            Point2((p.x + d, p.y - d)),\\n', '            Point2((p.x + d, p.y + d)),\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        unitAttributes = self._game_data.units[unit_type.value].attributes\\n', '        buildings_in_construction = self.units.structure(unit_type).not_ready  \\n', '        if 8 not in unitAttributes and any(o.ability == ability for w in (self.units.not_structure) for o in w.orders): \\n', '            return sum([o.ability == ability for w in (self.units - self.workers) for o in w.orders])\\n', '        elif any(o.ability.id == ability.id for w in (self.units.structure) for o in w.orders):\\n', '            return sum([o.ability.id == ability.id for w in (self.units.structure) for o in w.orders])\\n', '        elif any(o.ability == ability for w in self.workers for o in w.orders):\\n', '            return sum([o.ability == ability for w in self.workers for o in w.orders]) \\\\\\n', '                - buildings_in_construction.amount\\n', '        elif any(egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)):\\n', '            return sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        mineralTags = [x.tag for x in self.state.units.mineral_field]\\n', '        geyserTags = [x.tag for x in self.geysers]\\n', '        workerPool = self.units & []\\n', '        workerPoolTags = set()\\n', '        deficitGeysers = {}\\n', '        surplusGeysers = {}\\n', '        for g in self.geysers.filter(lambda x:x.vespene_contents > 0):\\n', '            deficit = g.ideal_harvesters - g.assigned_harvesters\\n', '            if deficit > 0:\\n', '                deficitGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '            elif deficit < 0:\\n', '                surplusWorkers = self.workers.closer_than(10, g).filter(lambda w:w not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in geyserTags)\\n', '                for i in range(-deficit):\\n', '                    if surplusWorkers.amount > 0:\\n', '                        w = surplusWorkers.pop()\\n', '                        workerPool.append(w)\\n', '                        workerPoolTags.add(w.tag)\\n', '                surplusGeysers[g.tag] = {\"unit\": g, \"deficit\": deficit}\\n', '        deficitTownhalls = {}\\n', '        surplusTownhalls = {}\\n', '            for th in self.townhalls:\\n', '                deficit = th.ideal_harvesters - th.assigned_harvesters\\n', '                if deficit > 0:\\n', '                    deficitTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '                elif deficit < 0:\\n', '                    surplusWorkers = self.workers.closer_than(10, th).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                    for i in range(-deficit):\\n', '                        if surplusWorkers.amount > 0:\\n', '                            w = surplusWorkers.pop()\\n', '                            workerPool.append(w)\\n', '                            workerPoolTags.add(w.tag)\\n', '                    surplusTownhalls[th.tag] = {\"unit\": th, \"deficit\": deficit}\\n', '            if all([len(deficitGeysers) == 0, len(surplusGeysers) == 0, len(surplusTownhalls) == 0 or deficitTownhalls == 0]):\\n', '        deficitGasCount = sum(gasInfo[\"deficit\"] for gasTag, gasInfo in deficitGeysers.items() if gasInfo[\"deficit\"] > 0)\\n', '        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\\n', '        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n', '            for gTag, gInfo in deficitGeysers.items():\\n', '                if workerPool.amount >= deficitGasCount:\\n', '                workersNearGas = self.workers.closer_than(10, gInfo[\"unit\"]).filter(lambda w:w.tag not in workerPoolTags and len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_GATHER] and w.orders[0].target in mineralTags)\\n', '                while workersNearGas.amount > 0 and workerPool.amount < deficitGasCount:\\n', '                    w = workersNearGas.pop()\\n', '                    workerPool.append(w)\\n', '                    workerPoolTags.add(w.tag)\\n', '        for gTag, gInfo in deficitGeysers.items():\\n', '                workerPool.sort(key=lambda x:x.distance_to(gInfo[\"unit\"]), reverse=True)\\n', '            for i in range(gInfo[\"deficit\"]):\\n', '                if workerPool.amount > 0:\\n', '                    w = workerPool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"], queue=True))\\n', '                        self.combinedActions.append(w.gather(gInfo[\"unit\"]))\\n', '            for thTag, thInfo in deficitTownhalls.items():\\n', '                    workerPool.sort(key=lambda x:x.distance_to(thInfo[\"unit\"]), reverse=True)\\n', '                for i in range(thInfo[\"deficit\"]):\\n', '                    if workerPool.amount > 0:\\n', '                        w = workerPool.pop()\\n', '                        mf = self.state.mineral_field.closer_than(10, thInfo[\"unit\"]).closest_to(w)\\n', '                        if len(w.orders) == 1 and w.orders[0].ability.id in [AbilityId.HARVEST_RETURN]:\\n', '                            self.combinedActions.append(w.gather(mf, queue=True))\\n', '                            self.combinedActions.append(w.gather(mf))\\n']",
  "context": "eysers.items() if gasInfo[\"deficit\"] > 0)\n        surplusCount = sum(-gasInfo[\"deficit\"] for gasTag, gasInfo in surplusGeysers.items() if gasInfo[\"deficit\"] < 0)\n        surplusCount += sum(-thInfo[\"deficit\"] for"
 },
 "134": {
  "name": "surplusCount",
  "type": "sum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/mass_reaper.py",
  "lineno": "303",
  "column": "8",
  "slicing": "['        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\\n', '        if deficitGasCount - surplusCount > 0:\\n']",
  "context": "eysers.items() if gasInfo[\"deficit\"] < 0)\n        surplusCount += sum(-thInfo[\"deficit\"] for thTag, thInfo in surplusTownhalls.items() if thInfo[\"deficit\"] < 0)\n\n        if deficitGasCount - surplusCount > 0:\n  "
 },
 "135": {
  "name": "cg",
  "type": "sc2.helpers.ControlGroup",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/proxy_rax.py",
  "lineno": "24",
  "column": "12",
  "slicing": "['        cc = self.units(COMMANDCENTER)\\n', '        if not cc.exists:\\n', '            target = self.known_enemy_structures.random_or(self.enemy_start_locations[0]).position\\n', '            for unit in self.workers | self.units(MARINE):\\n', '                await self.do(unit.attack(target))\\n', '            cc = cc.first\\n', '            cg = ControlGroup(self.units(MARINE).idle)\\n', '            self.attack_groups.add(cg)\\n', '        if self.can_afford(SCV) and self.workers.amount < 16 and cc.noqueue:\\n', '            await self.do(cc.train(SCV))\\n', '                await self.build(SUPPLYDEPOT, near=cc.position.towards(self.game_info.map_center, 5))\\n', '            await self.do(scv.gather(self.state.mineral_field.closest_to(cc)))\\n', '                    await self.do(marine.attack(target))\\n']",
  "context": ".amount > 15 and iteration % 50 == 1:\n            cg = ControlGroup(self.units(MARINE).idle)\n            self.attack_groups.add(cg)\n\n        if"
 },
 "136": {
  "name": "__all__",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/__init__.py",
  "lineno": "2",
  "column": "0",
  "slicing": "['__all__ = [p.stem for p in Path().iterdir() if p.is_file() and p.suffix == \".py\" and p.stem != \"__init__\"]\\n']",
  "context": "from pathlib import Path\n__all__ = [p.stem for p in Path().iterdir() if p.is_file() and p.suffix == \".py\" and p.stem != \"__init__\"]\n"
 },
 "137": {
  "name": "barracks_placement_position",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/examples/terran/ramp_wall.py",
  "lineno": "41",
  "column": "8",
  "slicing": "['        barracks_placement_position = None\\n', '            if ws and barracks_placement_position: # if workers were found\\n', '                await self.do(w.build(BARRACKS, barracks_placement_position))\\n']",
  "context": " | {self.main_base_ramp.depot_in_middle}\n\n        barracks_placement_position = None\n        barracks_placement_position = self.main_ba"
 },
 "138": {
  "name": "depot_placement_positions",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/examples/terran/ramp_wall.py",
  "lineno": "50",
  "column": "12",
  "slicing": "['        cc = self.units(COMMANDCENTER)\\n', '        if not cc.exists:\\n', '            cc = cc.first\\n', '        if self.can_afford(SCV) and self.workers.amount < 16 and cc.noqueue:\\n', '            await self.do(cc.train(SCV))\\n', '        for depo in self.units(SUPPLYDEPOT).ready:\\n', '            for unit in self.known_enemy_units.not_structure:\\n', '                if unit.position.to2.distance_to(depo.position.to2) < 15:\\n', '                await self.do(depo(MORPH_SUPPLYDEPOT_LOWER))\\n', '        for depo in self.units(SUPPLYDEPOTLOWERED).ready:\\n', '            for unit in self.known_enemy_units.not_structure:\\n', '                if unit.position.to2.distance_to(depo.position.to2) < 10:\\n', '                    await self.do(depo(MORPH_SUPPLYDEPOT_RAISE))\\n', '        depot_placement_positions = self.main_base_ramp.corner_depots\\n', '        depots = self.units(SUPPLYDEPOT) | self.units(SUPPLYDEPOTLOWERED)\\n', '        if depots:\\n', '            depot_placement_positions = {d for d in depot_placement_positions if depots.closest_distance_to(d) > 1}\\n', '            if len(depot_placement_positions) == 0:\\n', '            target_depot_location = depot_placement_positions.pop()\\n', '                await self.do(w.build(SUPPLYDEPOT, target_depot_location))\\n', '        if depots.ready.exists and self.can_afford(BARRACKS) and not self.already_pending(BARRACKS):\\n']",
  "context": "shed supply depots\n        if depots:\n            depot_placement_positions = {d for d in depot_placement_positions if depots.closest_distance_to(d) > 1}\n\n        # Build depots\n        if self.can_afford"
 },
 "139": {
  "name": "race_worker",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/data.py",
  "lineno": "43",
  "column": "0",
  "slicing": "['race_worker: Dict[Race, UnitTypeId] = {\\n']",
  "context": "m(\"ActionResult\", error_pb.ActionResult.items())\n\nrace_worker: Dict[Race, UnitTypeId] = {\n    Race.Protoss: UnitTypeId.PROBE,\n    Race.Terra"
 },
 "140": {
  "name": "race_townhalls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/data.py",
  "lineno": "49",
  "column": "0",
  "slicing": "['race_townhalls: Dict[Race, Set[UnitTypeId]] = {\\n']",
  "context": "nitTypeId.SCV,\n    Race.Zerg: UnitTypeId.DRONE\n}\n\nrace_townhalls: Dict[Race, Set[UnitTypeId]] = {\n    Race.Protoss: {UnitTypeId.NEXUS},\n    Race.Ter"
 },
 "141": {
  "name": "warpgate_abilities",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/data.py",
  "lineno": "55",
  "column": "0",
  "slicing": "['warpgate_abilities: Dict[AbilityId, AbilityId] = {\\n']",
  "context": "Id.HATCHERY, UnitTypeId.LAIR, UnitTypeId.HIVE}\n}\n\nwarpgate_abilities: Dict[AbilityId, AbilityId] = {\n    AbilityId.GATEWAYTRAIN_ZEALOT: AbilityId.WARPG"
 },
 "142": {
  "name": "race_gas",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/data.py",
  "lineno": "64",
  "column": "0",
  "slicing": "['race_gas: Dict[Race, UnitTypeId] = {\\n']",
  "context": "ilityId.TRAIN_ADEPT: AbilityId.TRAINWARP_ADEPT\n}\n\nrace_gas: Dict[Race, UnitTypeId] = {\n    Race.Protoss: UnitTypeId.ASSIMILATOR,\n    Race"
 },
 "143": {
  "name": "client",
  "type": "Client",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/renderer.py",
  "lineno": "12",
  "column": "23",
  "slicing": "['    def __init__(self, client, map_size, minimap_size) -> None:\\n']",
  "context": "\n\nclass Renderer(object):\n\n    def __init__(self, client, map_size, minimap_size) -> None:\n        self._client = client\n\n        self._windo"
 },
 "144": {
  "name": "map_width",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/renderer.py",
  "lineno": "35",
  "column": "8",
  "slicing": "['        render_data = observation.observation.render_data\\n', '        map_size = render_data.map.size\\n', '        map_data = render_data.map.data\\n', '        minimap_size = render_data.minimap.size\\n', '        minimap_data = render_data.minimap.data\\n', '        map_width, map_height = map_size.x, map_size.y\\n', '        map_pitch = -map_width * 3\\n', '        minimap_width, minimap_height = minimap_size.x, minimap_size.y\\n', '        minimap_pitch = -minimap_width * 3\\n', '            self._window = Window(width=map_width, height=map_height)\\n', \"            self._map_image = ImageData(map_width, map_height, 'RGB', map_data, map_pitch)\\n\", \"            self._minimap_image = ImageData(minimap_width, minimap_height, 'RGB', minimap_data,\\n\", '                                            minimap_pitch)\\n', \"            self._map_image.set_data('RGB', map_pitch, map_data)\\n\", \"            self._minimap_image.set_data('RGB', minimap_pitch, minimap_data)\\n\"]",
  "context": " minimap_data = render_data.minimap.data\n\n        map_width, map_height = map_size.x, map_size.y\n        map_pitch = -map_width * 3\n\n        minima"
 },
 "145": {
  "name": "map_height",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/renderer.py",
  "lineno": "35",
  "column": "19",
  "slicing": "['        map_width, map_height = map_size.x, map_size.y\\n', '            self._window = Window(width=map_width, height=map_height)\\n', \"            self._map_image = ImageData(map_width, map_height, 'RGB', map_data, map_pitch)\\n\"]",
  "context": "ta = render_data.minimap.data\n\n        map_width, map_height = map_size.x, map_size.y\n        map_pitch = -map_width * 3\n\n        minima"
 },
 "146": {
  "name": "minimap_width",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/renderer.py",
  "lineno": "38",
  "column": "8",
  "slicing": "['        render_data = observation.observation.render_data\\n', '        map_size = render_data.map.size\\n', '        map_data = render_data.map.data\\n', '        minimap_size = render_data.minimap.size\\n', '        minimap_data = render_data.minimap.data\\n', '        map_width, map_height = map_size.x, map_size.y\\n', '        map_pitch = -map_width * 3\\n', '        minimap_width, minimap_height = minimap_size.x, minimap_size.y\\n', '        minimap_pitch = -minimap_width * 3\\n', '            self._window = Window(width=map_width, height=map_height)\\n', \"            self._map_image = ImageData(map_width, map_height, 'RGB', map_data, map_pitch)\\n\", \"            self._minimap_image = ImageData(minimap_width, minimap_height, 'RGB', minimap_data,\\n\", '                                            minimap_pitch)\\n', \"            self._map_image.set_data('RGB', map_pitch, map_data)\\n\", \"            self._minimap_image.set_data('RGB', minimap_pitch, minimap_data)\\n\"]",
  "context": "ize.y\n        map_pitch = -map_width * 3\n\n        minimap_width, minimap_height = minimap_size.x, minimap_size.y\n        minimap_pitch = -minimap_width * 3\n\n      "
 },
 "147": {
  "name": "minimap_height",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/renderer.py",
  "lineno": "38",
  "column": "23",
  "slicing": "['        minimap_width, minimap_height = minimap_size.x, minimap_size.y\\n', \"            self._minimap_image = ImageData(minimap_width, minimap_height, 'RGB', minimap_data,\\n\"]",
  "context": "ap_pitch = -map_width * 3\n\n        minimap_width, minimap_height = minimap_size.x, minimap_size.y\n        minimap_pitch = -minimap_width * 3\n\n      "
 },
 "148": {
  "name": "p",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "25",
  "column": "26",
  "slicing": "['    def distance_to(self, p: Union[\"Unit\", \"Point2\", \"Point3\"]) -> Union[int, float]:\\n']",
  "context": "\":\n        return self\n\n    def distance_to(self, p: Union[\"Unit\", \"Point2\", \"Point3\"]) -> Union[int, float]:\n        p = p.position\n        assert isinstance(p"
 },
 "149": {
  "name": "ps",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "40",
  "column": "31",
  "slicing": "['    def sort_by_distance(self, ps: Union[\"Units\", List[\"Point2\"]]) -> List[\"Point2\"]:\\n']",
  "context": "[1] - p2[1]) ** 2\n\n    def sort_by_distance(self, ps: Union[\"Units\", List[\"Point2\"]]) -> List[\"Point2\"]:\n        \"\"\" This returns the target points sorted "
 },
 "150": {
  "name": "ps",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "49",
  "column": "22",
  "slicing": "['    def closest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[\"Unit\", \"Point2\"]:\\n']",
  "context": "tance_squared(p.position))\n\n    def closest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[\"Unit\", \"Point2\"]:\n        \"\"\" This function assumes the 2d distance "
 },
 "151": {
  "name": "p2pos",
  "type": "p2",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "56",
  "column": "12",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "ared = math.inf\n        for p2 in ps:\n            p2pos = p2\n            if not isinstance(p2pos, Point2):\n    "
 },
 "152": {
  "name": "closest_distance_squared",
  "type": "distance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "61",
  "column": "16",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "tance < closest_distance_squared:\n                closest_distance_squared = distance\n                closest_element = p2\n        retur"
 },
 "153": {
  "name": "closest_element",
  "type": "p2",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "62",
  "column": "16",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "osest_distance_squared = distance\n                closest_element = p2\n        return closest_element\n\n    def distance_t"
 },
 "154": {
  "name": "ps",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "65",
  "column": "34",
  "slicing": "['    def distance_to_closest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[int, float]:\\n']",
  "context": "losest_element\n\n    def distance_to_closest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[int, float]:\n        \"\"\" This function assumes the 2d distance "
 },
 "155": {
  "name": "closest_distance_squared",
  "type": "distance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "74",
  "column": "16",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "tance < closest_distance_squared:\n                closest_distance_squared = distance\n        return closest_distance_squared ** 0.5\n\n  "
 },
 "156": {
  "name": "ps",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "77",
  "column": "23",
  "slicing": "['    def furthest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[\"Unit\", \"Pointlike\"]:\\n']",
  "context": "t_distance_squared ** 0.5\n\n    def furthest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[\"Unit\", \"Pointlike\"]:\n        \"\"\" This function assumes the 2d distance "
 },
 "157": {
  "name": "p2pos",
  "type": "p2",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "84",
  "column": "12",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "red = -math.inf\n        for p2 in ps:\n            p2pos = p2\n            if not isinstance(p2pos, Point2):\n    "
 },
 "158": {
  "name": "furthest_distance_squared",
  "type": "distance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "89",
  "column": "16",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "hest_distance_squared < distance:\n                furthest_distance_squared = distance\n                furthest_element = p2\n        retu"
 },
 "159": {
  "name": "furthest_element",
  "type": "p2",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "90",
  "column": "16",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "thest_distance_squared = distance\n                furthest_element = p2\n        return furthest_element\n\n    def distance_"
 },
 "160": {
  "name": "ps",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "93",
  "column": "35",
  "slicing": "['    def distance_to_furthest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[int, float]:\\n']",
  "context": "thest_element\n\n    def distance_to_furthest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[int, float]:\n        \"\"\" This function assumes the 2d distance "
 },
 "161": {
  "name": "furthest_distance_squared",
  "type": "distance",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "102",
  "column": "16",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "hest_distance_squared < distance:\n                furthest_distance_squared = distance\n        return furthest_distance_squared ** 0.5\n\n "
 },
 "162": {
  "name": "p",
  "type": "sc2.position.Pointlike",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "105",
  "column": "21",
  "slicing": "['    def offset(self, p) -> \"Pointlike\":\\n']",
  "context": "est_distance_squared ** 0.5\n\n    def offset(self, p) -> \"Pointlike\":\n        return self.__class__(a + b for a, b in it"
 },
 "163": {
  "name": "p",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "112",
  "column": "14",
  "slicing": "['        self, p: Union[\"Unit\", \"Pointlike\"], distance: Union[int, float] = 1, limit: bool = False\\n']",
  "context": ")], fillvalue=0))\n\n    def towards(\n        self, p: Union[\"Unit\", \"Pointlike\"], distance: Union[int, float] = 1, limit: bool = False\n    ) -> \"Pointlike\":\n        p = p.position\n     "
 },
 "164": {
  "name": "distance",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "112",
  "column": "45",
  "slicing": "['        self, p: Union[\"Unit\", \"Pointlike\"], distance: Union[int, float] = 1, limit: bool = False\\n']",
  "context": "rds(\n        self, p: Union[\"Unit\", \"Pointlike\"], distance: Union[int, float] = 1, limit: bool = False\n    ) -> \"Pointlike\":\n        p = p.position\n     "
 },
 "165": {
  "name": "limit",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "112",
  "column": "78",
  "slicing": "['        self, p: Union[\"Unit\", \"Pointlike\"], distance: Union[int, float] = 1, limit: bool = False\\n']",
  "context": "\", \"Pointlike\"], distance: Union[int, float] = 1, limit: bool = False\n    ) -> \"Pointlike\":\n        p = p.position\n     "
 },
 "166": {
  "name": "d",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "120",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "        return self\n        # end of test\n        d = self.distance_to(p)\n        if limit:\n            distance = min(d, di"
 },
 "167": {
  "name": "distance",
  "type": "min",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "122",
  "column": "12",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "self.distance_to(p)\n        if limit:\n            distance = min(d, distance)\n        return self.__class__(\n            a + (b "
 },
 "168": {
  "name": "other",
  "type": "sc2.position.Pointlike",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "127",
  "column": "21",
  "slicing": "['    def __eq__(self, other):\\n']",
  "context": "f)], fillvalue=0)\n        )\n\n    def __eq__(self, other):\n        if not isinstance(other, tuple):\n         "
 },
 "169": {
  "name": "cls",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "138",
  "column": "19",
  "slicing": "['    def from_proto(cls, data):\\n']",
  "context": "2(Pointlike):\n    @classmethod\n    def from_proto(cls, data):\n        return cls((data.x, data.y))\n\n    @propert"
 },
 "170": {
  "name": "distance",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "164",
  "column": "12",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "distance, (tuple, list)):  # interval\n            distance = distance[0] + random.random() * (distance[1] - distance[0])\n\n        assert distance > 0\n        angle = rando"
 },
 "171": {
  "name": "dx",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "169",
  "column": "8",
  "slicing": "['        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n']",
  "context": "   angle = random.random() * 2 * math.pi\n\n        dx, dy = math.cos(angle), math.sin(angle)\n        return Point2((self.x + dx * distance, sel"
 },
 "172": {
  "name": "dy",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "169",
  "column": "12",
  "slicing": "['        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n']",
  "context": "ngle = random.random() * 2 * math.pi\n\n        dx, dy = math.cos(angle), math.sin(angle)\n        return Point2((self.x + dx * distance, sel"
 },
 "173": {
  "name": "p",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "174",
  "column": "8",
  "slicing": "['        p: Union[\"Point2\", \"Point3\"],\\n']",
  "context": " towards_with_random_angle(\n        self,\n        p: Union[\"Point2\", \"Point3\"],\n        distance: Union[int, float] = 1,\n        m"
 },
 "174": {
  "name": "distance",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "175",
  "column": "8",
  "slicing": "['        distance: Union[int, float] = 1,\\n']",
  "context": "lf,\n        p: Union[\"Point2\", \"Point3\"],\n        distance: Union[int, float] = 1,\n        max_difference: Union[int, float] = (math."
 },
 "175": {
  "name": "max_difference",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "176",
  "column": "8",
  "slicing": "['        max_difference: Union[int, float] = (math.pi / 4),\\n']",
  "context": "\n        distance: Union[int, float] = 1,\n        max_difference: Union[int, float] = (math.pi / 4),\n    ) -> \"Point2\":\n        tx, ty = self.to2.towar"
 },
 "176": {
  "name": "angle",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "179",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "      tx, ty = self.to2.towards(p.to2, 1)\n        angle = math.atan2(ty - self.y, tx - self.x)\n        angle = (angle - max_difference) + max_dif"
 },
 "177": {
  "name": "angle",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "180",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "le = math.atan2(ty - self.y, tx - self.x)\n        angle = (angle - max_difference) + max_difference * 2 * random.random()\n        return Point2((self.x + math.cos(angle) * "
 },
 "178": {
  "name": "r",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "183",
  "column": "47",
  "slicing": "['    def circle_intersection(self, p: \"Point2\", r: Union[int, float]) -> Set[\"Point2\"]:\\n']",
  "context": ")\n\n    def circle_intersection(self, p: \"Point2\", r: Union[int, float]) -> Set[\"Point2\"]:\n        \"\"\" self is point1, p is point2, r is the "
 },
 "179": {
  "name": "distanceBetweenPoints",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "187",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "ramp finding \"\"\"\n        assert self != p\n        distanceBetweenPoints = self.distance_to(p)\n        assert r > distanceBetweenPoints / 2\n     "
 },
 "180": {
  "name": "offsetToCenter",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "192",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "2) ** 0.5\n        # center of both points\n        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\n        center = self.offset(offsetToCenter)\n\n    "
 },
 "181": {
  "name": "v",
  "type": "offsetToCenter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "197",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "eFromCenter / (distanceBetweenPoints / 2)\n        v = offsetToCenter\n        offsetToCenterStretched = Point2((v.x * ve"
 },
 "182": {
  "name": "offsetToCenterStretched",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "198",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "eenPoints / 2)\n        v = offsetToCenter\n        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\n\n        # rotate vector by 90 and -90\n        v"
 },
 "183": {
  "name": "vectorRotated1",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "201",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "\n\n        # rotate vector by 90 and -90\n        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\n        vectorRotated2 = Point2((-offsetToCenterSt"
 },
 "184": {
  "name": "vectorRotated2",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "202",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": "Stretched.y, -offsetToCenterStretched.x))\n        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\n        intersect1 = center.offset(vectorRotated1)"
 },
 "185": {
  "name": "other",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "243",
  "column": "22",
  "slicing": "['    def __mul__(self, other: Union[int, float, \"Point2\"]) -> \"Point2\":\\n']",
  "context": "self.x != 0 or self.y != 0\n\n    def __mul__(self, other: Union[int, float, \"Point2\"]) -> \"Point2\":\n        if isinstance(other, self.__class__):\n    "
 },
 "186": {
  "name": "other",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "248",
  "column": "23",
  "slicing": "['    def __rmul__(self, other: Union[int, float, \"Point2\"]) -> \"Point2\":\\n']",
  "context": "* other, self.y * other))\n\n    def __rmul__(self, other: Union[int, float, \"Point2\"]) -> \"Point2\":\n        return self.__mul__(other)\n\n    def __true"
 },
 "187": {
  "name": "other",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "251",
  "column": "26",
  "slicing": "['    def __truediv__(self, other: Union[int, float, \"Point2\"]) -> \"Point2\":\\n']",
  "context": "rn self.__mul__(other)\n\n    def __truediv__(self, other: Union[int, float, \"Point2\"]) -> \"Point2\":\n        if isinstance(other, self.__class__):\n    "
 },
 "188": {
  "name": "a",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "267",
  "column": "15",
  "slicing": "['    def center(a: Union[Set[\"Point2\"], List[\"Point2\"]]) -> \"Point2\":\\n']",
  "context": "her.y - self.y)\n\n    @staticmethod\n    def center(a: Union[Set[\"Point2\"], List[\"Point2\"]]) -> \"Point2\":\n        \"\"\" Returns the central point for points i"
 },
 "189": {
  "name": "s",
  "type": "sc2.position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "269",
  "column": "8",
  "slicing": "['FLOAT_DIGITS = 8\\n', 'EPSILON = 10 ** (-FLOAT_DIGITS)\\n', 'def _sign(num):\\n', '    return 1 if num > 0 else -1\\n', '        return self.__class__(round(q) for q in self)\\n', '        p = p.position\\n', '        assert isinstance(p, Pointlike)\\n', '        if self == p:\\n', '        return (sum(self.__class__((b - a) ** 2 for a, b in itertools.zip_longest(self, p, fillvalue=0)))) ** 0.5\\n', '        return sorted(ps, key=lambda p: self._distance_squared(p.position))\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '                closest_element = p2\\n', '        return closest_element\\n', '        closest_distance_squared = math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if distance < closest_distance_squared:\\n', '                closest_distance_squared = distance\\n', '        return closest_distance_squared ** 0.5\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            p2pos = p2\\n', '            if not isinstance(p2pos, Point2):\\n', '                p2pos = p2.position\\n', '            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '                furthest_element = p2\\n', '        return furthest_element\\n', '        furthest_distance_squared = -math.inf\\n', '        for p2 in ps:\\n', '            if not isinstance(p2, Point2):\\n', '                p2 = p2.position\\n', '            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\\n', '            if furthest_distance_squared < distance:\\n', '                furthest_distance_squared = distance\\n', '        return furthest_distance_squared ** 0.5\\n', '        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0))\\n', '        p = p.position\\n', '        if self == p:\\n', '        d = self.distance_to(p)\\n', '            distance = min(d, distance)\\n', '            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[: len(self)], fillvalue=0)\\n', '        return all(abs(a - b) < EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\\n', '        return hash(tuple(int(c * FLOAT_DIGITS) for c in self))\\n', '        if isinstance(distance, (tuple, list)):  # interval\\n', '            distance = distance[0] + random.random() * (distance[1] - distance[0])\\n', '        assert distance > 0\\n', '        angle = random.random() * 2 * math.pi\\n', '        dx, dy = math.cos(angle), math.sin(angle)\\n', '        return Point2((self.x + dx * distance, self.y + dy * distance))\\n', '        tx, ty = self.to2.towards(p.to2, 1)\\n', '        angle = math.atan2(ty - self.y, tx - self.x)\\n', '        angle = (angle - max_difference) + max_difference * 2 * random.random()\\n', '        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\\n', '        assert self != p\\n', '        distanceBetweenPoints = self.distance_to(p)\\n', '        assert r > distanceBetweenPoints / 2\\n', '        remainingDistanceFromCenter = (r ** 2 - (distanceBetweenPoints / 2) ** 2) ** 0.5\\n', '        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\\n', '        center = self.offset(offsetToCenter)\\n', '        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\\n', '        v = offsetToCenter\\n', '        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\\n', '        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\\n', '        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\\n', '        intersect1 = center.offset(vectorRotated1)\\n', '        intersect2 = center.offset(vectorRotated2)\\n', '        return {intersect1, intersect2}\\n', '        return self.__class__(-a for a in self)\\n', '        s = Point2((0, 0))\\n', '        for p in a:\\n', '            s += p\\n', '        return s / len(a)\\n', '        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))\\n']",
  "context": " the central point for points in list \"\"\"\n        s = Point2((0, 0))\n        for p in a:\n            s += p\n        ret"
 },
 "190": {
  "name": "s",
  "type": "p",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/position.py",
  "lineno": "271",
  "column": "12",
  "slicing": "['            s += p\\n', '        return s / len(a)\\n']",
  "context": " = Point2((0, 0))\n        for p in a:\n            s += p\n        return s / len(a)\n\n\nclass Point3(Point2):\n"
 },
 "191": {
  "name": "cls",
  "type": "sc2.position.Point3",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "277",
  "column": "19",
  "slicing": "['    def from_proto(cls, data):\\n']",
  "context": "int3(Point2):\n    @classmethod\n    def from_proto(cls, data):\n        return cls((data.x, data.y, data.z))\n\n    "
 },
 "192": {
  "name": "cls",
  "type": "Rect",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/position.py",
  "lineno": "301",
  "column": "19",
  "slicing": "['    def from_proto(cls, data):\\n']",
  "context": " Rect(tuple):\n    @classmethod\n    def from_proto(cls, data):\n        assert data.p0.x < data.p1.x and data.p0.y"
 },
 "193": {
  "name": "FREE_MORPH_ABILITY_CATEGORIES",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "13",
  "column": "0",
  "slicing": "['FREE_MORPH_ABILITY_CATEGORIES = [\\n', '            if p in FREE_MORPH_ABILITY_CATEGORIES:\\n']",
  "context": "mport AbilityId\n\nfrom .constants import ZERGLING\n\nFREE_MORPH_ABILITY_CATEGORIES = [\n    \"Lower\", \"Raise\", # SUPPLYDEPOT\n    \"Land\",  \""
 },
 "194": {
  "name": "ids",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "28",
  "column": "8",
  "slicing": "['        ids = set(a.value for a in AbilityId if a.value != 0)\\n', '        self.abilities = {a.ability_id: AbilityData(self, a) for a in data.abilities if a.ability_id in ids}\\n']",
  "context": "s GameData:\n    def __init__(self, data):\n        ids = set(a.value for a in AbilityId if a.value != 0)\n        self.abilities = {a.ability_id: AbilityDat"
 },
 "195": {
  "name": "ability",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "37",
  "column": "12",
  "slicing": "['        ids = set(a.value for a in AbilityId if a.value != 0)\\n', '        self.abilities = {a.ability_id: AbilityData(self, a) for a in data.abilities if a.ability_id in ids}\\n', '        self.units = {u.unit_id: UnitTypeData(self, u) for u in data.units if u.available}\\n', '        self.upgrades = {u.upgrade_id: UpgradeData(self, u) for u in data.upgrades}\\n', '            ability = self.abilities[ability.value]\\n', '        elif isinstance(ability, UnitCommand):\\n', '            ability = self.abilities[ability.ability.value]\\n', '        assert isinstance(ability, AbilityData), f\"C: {ability}\"\\n', '            if unit.creation_ability == ability:\\n', '            if upgrade.research_ability == ability:\\n']",
  "context": "   if isinstance(ability, AbilityId):\n            ability = self.abilities[ability.value]\n        elif isinstance(ability, UnitCommand):\n   "
 },
 "196": {
  "name": "ability",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "39",
  "column": "12",
  "slicing": "['        ids = set(a.value for a in AbilityId if a.value != 0)\\n', '        self.abilities = {a.ability_id: AbilityData(self, a) for a in data.abilities if a.ability_id in ids}\\n', '        self.units = {u.unit_id: UnitTypeData(self, u) for u in data.units if u.available}\\n', '        self.upgrades = {u.upgrade_id: UpgradeData(self, u) for u in data.upgrades}\\n', '            ability = self.abilities[ability.value]\\n', '        elif isinstance(ability, UnitCommand):\\n', '            ability = self.abilities[ability.ability.value]\\n', '        assert isinstance(ability, AbilityData), f\"C: {ability}\"\\n', '            if unit.creation_ability == ability:\\n', '            if upgrade.research_ability == ability:\\n']",
  "context": "lif isinstance(ability, UnitCommand):\n            ability = self.abilities[ability.ability.value]\n\n        assert isinstance(ability, AbilityData), "
 },
 "197": {
  "name": "ability_ids",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "75",
  "column": "4",
  "slicing": "['    ability_ids: List[int] = []  # sorted list\\n', '        ability_ids.append(ability_id.value)\\n', '    ability_ids.remove(0)\\n', '    ability_ids.sort()\\n']",
  "context": "        return Cost(0, 0)\n\nclass AbilityData:\n    ability_ids: List[int] = []  # sorted list\n    for ability_id in AbilityId:  # 1000 items Enu"
 },
 "198": {
  "name": "cls",
  "type": "AbilityData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "82",
  "column": "18",
  "slicing": "['    def id_exists(cls, ability_id):\\n']",
  "context": "ty_ids.sort()\n\n    @classmethod\n    def id_exists(cls, ability_id):\n        assert isinstance(ability_id, int), f\"Wron"
 },
 "199": {
  "name": "i",
  "type": "bisect.bisect_left",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "86",
  "column": "8",
  "slicing": "['        ids = set(a.value for a in AbilityId if a.value != 0)\\n', '        self.abilities = {a.ability_id: AbilityData(self, a) for a in data.abilities if a.ability_id in ids}\\n', '        self.units = {u.unit_id: UnitTypeData(self, u) for u in data.units if u.available}\\n', '        self.upgrades = {u.upgrade_id: UpgradeData(self, u) for u in data.upgrades}\\n', '            ability = self.abilities[ability.value]\\n', '        elif isinstance(ability, UnitCommand):\\n', '            ability = self.abilities[ability.ability.value]\\n', '        assert isinstance(ability, AbilityData), f\"C: {ability}\"\\n', '        for unit in self.units.values():\\n', '            if unit.creation_ability is None:\\n', '            if not AbilityData.id_exists(unit.creation_ability.id.value):\\n', '            if unit.creation_ability.is_free_morph:\\n', '            if unit.creation_ability == ability:\\n', '                if unit.id == ZERGLING:\\n', '                        unit.cost.minerals * 2,\\n', '                        unit.cost.vespene * 2,\\n', '                        unit.cost.time\\n', '                morph_cost = unit.morph_cost\\n', '                if morph_cost: # can be None\\n', '                    return morph_cost\\n', '                return unit.cost_zerg_corrected\\n', '        for upgrade in self.upgrades.values():\\n', '            if upgrade.research_ability == ability:\\n', '                return upgrade.cost\\n', '    ability_ids: List[int] = []  # sorted list\\n', '    for ability_id in AbilityId:  # 1000 items Enum is slow\\n', '        ability_ids.append(ability_id.value)\\n', '    ability_ids.remove(0)\\n', '    ability_ids.sort()\\n', '        assert isinstance(ability_id, int), f\"Wrong type: {ability_id} is not int\"\\n', '        if ability_id == 0:\\n', '        i = bisect_left(cls.ability_ids, ability_id)  # quick binary search\\n', '        return i != len(cls.ability_ids) and cls.ability_ids[i] == ability_id\\n']",
  "context": "ability_id == 0:\n            return False\n        i = bisect_left(cls.ability_ids, ability_id)  # quick binary search\n        return i != len(cls.ability_ids) and cls.a"
 },
 "200": {
  "name": "game_data",
  "type": "GameData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "89",
  "column": "23",
  "slicing": "['    def __init__(self, game_data, proto):\\n']",
  "context": "lity_ids[i] == ability_id\n\n    def __init__(self, game_data, proto):\n        self._game_data = game_data\n        self._"
 },
 "201": {
  "name": "parts",
  "type": "split_camel_case",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "121",
  "column": "8",
  "slicing": "['def split_camel_case(text) -> list:\\n', '        text,\\n', '        ids = set(a.value for a in AbilityId if a.value != 0)\\n', '        self.abilities = {a.ability_id: AbilityData(self, a) for a in data.abilities if a.ability_id in ids}\\n', '        self.units = {u.unit_id: UnitTypeData(self, u) for u in data.units if u.available}\\n', '        self.upgrades = {u.upgrade_id: UpgradeData(self, u) for u in data.upgrades}\\n', '            ability = self.abilities[ability.value]\\n', '        elif isinstance(ability, UnitCommand):\\n', '            ability = self.abilities[ability.ability.value]\\n', '        assert isinstance(ability, AbilityData), f\"C: {ability}\"\\n', '        for unit in self.units.values():\\n', '            if unit.creation_ability is None:\\n', '            if not AbilityData.id_exists(unit.creation_ability.id.value):\\n', '            if unit.creation_ability.is_free_morph:\\n', '            if unit.creation_ability == ability:\\n', '                if unit.id == ZERGLING:\\n', '                        unit.cost.minerals * 2,\\n', '                        unit.cost.vespene * 2,\\n', '                        unit.cost.time\\n', '                morph_cost = unit.morph_cost\\n', '                if morph_cost: # can be None\\n', '                    return morph_cost\\n', '                return unit.cost_zerg_corrected\\n', '        for upgrade in self.upgrades.values():\\n', '            if upgrade.research_ability == ability:\\n', '                return upgrade.cost\\n', '    ability_ids: List[int] = []  # sorted list\\n', '    for ability_id in AbilityId:  # 1000 items Enum is slow\\n', '        ability_ids.append(ability_id.value)\\n', '    ability_ids.remove(0)\\n', '    ability_ids.sort()\\n', '        assert isinstance(ability_id, int), f\"Wrong type: {ability_id} is not int\"\\n', '        if ability_id == 0:\\n', '        i = bisect_left(cls.ability_ids, ability_id)  # quick binary search\\n', '        return i != len(cls.ability_ids) and cls.ability_ids[i] == ability_id\\n', '        parts = split_camel_case(self._proto.link_name)\\n', '        for p in parts:\\n', '            if p in FREE_MORPH_ABILITY_CATEGORIES:\\n']",
  "context": "erty\n    def is_free_morph(self) -> bool:\n        parts = split_camel_case(self._proto.link_name)\n        for p in parts:\n            if p in FREE_M"
 },
 "202": {
  "name": "game_data",
  "type": "GameData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "132",
  "column": "23",
  "slicing": "['    def __init__(self, game_data, proto):\\n']",
  "context": "f.id)\n\nclass UnitTypeData:\n    def __init__(self, game_data, proto):\n        self._game_data = game_data\n        self._"
 },
 "203": {
  "name": "return_list",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "189",
  "column": "8",
  "slicing": "['        return_list = []\\n', '                return_list.append(UnitTypeId(tech_alias))\\n', '        if return_list:\\n', '            return return_list\\n']",
  "context": "Hive is the same as Lair and Hatchery \"\"\"\n        return_list = []\n        for tech_alias in self._proto.tech_alias:\n"
 },
 "204": {
  "name": "tech_alias_cost_minerals",
  "type": "max",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "243",
  "column": "8",
  "slicing": "['FREE_MORPH_ABILITY_CATEGORIES = [\\n', 'def split_camel_case(text) -> list:\\n', '        text,\\n', '        ids = set(a.value for a in AbilityId if a.value != 0)\\n', '        self.abilities = {a.ability_id: AbilityData(self, a) for a in data.abilities if a.ability_id in ids}\\n', '        self.units = {u.unit_id: UnitTypeData(self, u) for u in data.units if u.available}\\n', '        self.upgrades = {u.upgrade_id: UpgradeData(self, u) for u in data.upgrades}\\n', '            ability = self.abilities[ability.value]\\n', '        elif isinstance(ability, UnitCommand):\\n', '            ability = self.abilities[ability.ability.value]\\n', '        assert isinstance(ability, AbilityData), f\"C: {ability}\"\\n', '        for unit in self.units.values():\\n', '            if unit.creation_ability is None:\\n', '            if not AbilityData.id_exists(unit.creation_ability.id.value):\\n', '            if unit.creation_ability.is_free_morph:\\n', '            if unit.creation_ability == ability:\\n', '                if unit.id == ZERGLING:\\n', '                        unit.cost.minerals * 2,\\n', '                        unit.cost.vespene * 2,\\n', '                        unit.cost.time\\n', '                morph_cost = unit.morph_cost\\n', '                if morph_cost: # can be None\\n', '                    return morph_cost\\n', '                return unit.cost_zerg_corrected\\n', '        for upgrade in self.upgrades.values():\\n', '            if upgrade.research_ability == ability:\\n', '                return upgrade.cost\\n', '    ability_ids: List[int] = []  # sorted list\\n', '    for ability_id in AbilityId:  # 1000 items Enum is slow\\n', '        ability_ids.append(ability_id.value)\\n', '    ability_ids.remove(0)\\n', '    ability_ids.sort()\\n', '        assert isinstance(ability_id, int), f\"Wrong type: {ability_id} is not int\"\\n', '        if ability_id == 0:\\n', '        i = bisect_left(cls.ability_ids, ability_id)  # quick binary search\\n', '        return i != len(cls.ability_ids) and cls.ability_ids[i] == ability_id\\n', '        parts = split_camel_case(self._proto.link_name)\\n', '        for p in parts:\\n', '            if p in FREE_MORPH_ABILITY_CATEGORIES:\\n', '        return_list = []\\n', '        for tech_alias in self._proto.tech_alias:\\n', '            if tech_alias in self._game_data.units:\\n', '                return_list.append(UnitTypeId(tech_alias))\\n', '        if return_list:\\n', '            return return_list\\n', '        tech_alias_cost_minerals = max([self._game_data.units[tech_alias.value].cost.minerals for tech_alias in self.tech_alias])\\n', '        tech_alias_cost_vespene = max([self._game_data.units[tech_alias.value].cost.vespene for tech_alias in self.tech_alias])\\n', '                self._proto.mineral_cost - tech_alias_cost_minerals,\\n', '                self._proto.vespene_cost - tech_alias_cost_vespene,\\n']",
  "context": "m LAIR cost instead of from HATCHERY cost\n        tech_alias_cost_minerals = max([self._game_data.units[tech_alias.value].cost.minerals for tech_alias in self.tech_alias])\n        tech_alias_cost_vespene = max([self._game_"
 },
 "205": {
  "name": "tech_alias_cost_vespene",
  "type": "max",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "244",
  "column": "8",
  "slicing": "['FREE_MORPH_ABILITY_CATEGORIES = [\\n', 'def split_camel_case(text) -> list:\\n', '        text,\\n', '        ids = set(a.value for a in AbilityId if a.value != 0)\\n', '        self.abilities = {a.ability_id: AbilityData(self, a) for a in data.abilities if a.ability_id in ids}\\n', '        self.units = {u.unit_id: UnitTypeData(self, u) for u in data.units if u.available}\\n', '        self.upgrades = {u.upgrade_id: UpgradeData(self, u) for u in data.upgrades}\\n', '            ability = self.abilities[ability.value]\\n', '        elif isinstance(ability, UnitCommand):\\n', '            ability = self.abilities[ability.ability.value]\\n', '        assert isinstance(ability, AbilityData), f\"C: {ability}\"\\n', '        for unit in self.units.values():\\n', '            if unit.creation_ability is None:\\n', '            if not AbilityData.id_exists(unit.creation_ability.id.value):\\n', '            if unit.creation_ability.is_free_morph:\\n', '            if unit.creation_ability == ability:\\n', '                if unit.id == ZERGLING:\\n', '                        unit.cost.minerals * 2,\\n', '                        unit.cost.vespene * 2,\\n', '                        unit.cost.time\\n', '                morph_cost = unit.morph_cost\\n', '                if morph_cost: # can be None\\n', '                    return morph_cost\\n', '                return unit.cost_zerg_corrected\\n', '        for upgrade in self.upgrades.values():\\n', '            if upgrade.research_ability == ability:\\n', '                return upgrade.cost\\n', '    ability_ids: List[int] = []  # sorted list\\n', '    for ability_id in AbilityId:  # 1000 items Enum is slow\\n', '        ability_ids.append(ability_id.value)\\n', '    ability_ids.remove(0)\\n', '    ability_ids.sort()\\n', '        assert isinstance(ability_id, int), f\"Wrong type: {ability_id} is not int\"\\n', '        if ability_id == 0:\\n', '        i = bisect_left(cls.ability_ids, ability_id)  # quick binary search\\n', '        return i != len(cls.ability_ids) and cls.ability_ids[i] == ability_id\\n', '        parts = split_camel_case(self._proto.link_name)\\n', '        for p in parts:\\n', '            if p in FREE_MORPH_ABILITY_CATEGORIES:\\n', '        return_list = []\\n', '        for tech_alias in self._proto.tech_alias:\\n', '            if tech_alias in self._game_data.units:\\n', '                return_list.append(UnitTypeId(tech_alias))\\n', '        if return_list:\\n', '            return return_list\\n', '        tech_alias_cost_minerals = max([self._game_data.units[tech_alias.value].cost.minerals for tech_alias in self.tech_alias])\\n', '        tech_alias_cost_vespene = max([self._game_data.units[tech_alias.value].cost.vespene for tech_alias in self.tech_alias])\\n', '                self._proto.mineral_cost - tech_alias_cost_minerals,\\n', '                self._proto.vespene_cost - tech_alias_cost_vespene,\\n']",
  "context": "erals for tech_alias in self.tech_alias])\n        tech_alias_cost_vespene = max([self._game_data.units[tech_alias.value].cost.vespene for tech_alias in self.tech_alias])\n        return Cost(\n                self._proto.m"
 },
 "206": {
  "name": "game_data",
  "type": "GameData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_data.py",
  "lineno": "253",
  "column": "23",
  "slicing": "['    def __init__(self, game_data, proto):\\n']",
  "context": "    )\n\n\nclass UpgradeData:\n    def __init__(self, game_data, proto):\n        self._game_data = game_data\n        self._"
 },
 "207": {
  "name": "resource_groups",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "93",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "rals together to form expansion locations\n        resource_groups = []\n        for mf in all_resources:\n            mf_he"
 },
 "208": {
  "name": "resource_groups",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "108",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "ter out bases with only one mineral field\n        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\n        # distance offsets from a gas geysir\n     "
 },
 "209": {
  "name": "offsets",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "110",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "     # distance offsets from a gas geysir\n        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\n        centers = {}\n        # for every resource "
 },
 "210": {
  "name": "centers",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "111",
  "column": "8",
  "slicing": "['        centers = {}\\n', '            centers[result] = resources\\n', '        return centers\\n']",
  "context": "e(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\n        centers = {}\n        # for every resource group:\n        for re"
 },
 "211": {
  "name": "possible_points",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "116",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": ") coordinates, just like an expansion\n            possible_points = (\n                Point2((offset[0] + resources[-1]."
 },
 "212": {
  "name": "possible_points",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "121",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "# filter out points that are too near\n            possible_points = [\n                point\n                for point in"
 },
 "213": {
  "name": "result",
  "type": "min",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "127",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "          # choose best fitting point\n            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\n            centers[result] = resources\n        \"\""
 },
 "214": {
  "name": "start_townhall_type",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "142",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "     # self.race is never Race.Random\n            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\n            building = start_townhall_type[self.ra"
 },
 "215": {
  "name": "building",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "143",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "NTER, Race.Zerg: UnitTypeId.HATCHERY}\n            building = start_townhall_type[self.race]\n\n        assert isinstance(building, UnitTypeId)\n\n"
 },
 "216": {
  "name": "closest",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "156",
  "column": "8",
  "slicing": "['        closest = None\\n', '        return closest\\n']",
  "context": "     \"\"\"Find next expansion location.\"\"\"\n\n        closest = None\n        distance = math.inf\n        for el in self"
 },
 "217": {
  "name": "distance",
  "type": "d",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "172",
  "column": "16",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "nue\n\n            if d < distance:\n                distance = d\n                closest = el\n\n        return close"
 },
 "218": {
  "name": "closest",
  "type": "el",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "173",
  "column": "16",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "nce:\n                distance = d\n                closest = el\n\n        return closest\n\n    async def distribute_"
 },
 "219": {
  "name": "worker_pool",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "187",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": " owned_expansions = self.owned_expansions\n        worker_pool = []\n        actions = []\n\n        for idle_worker in s"
 },
 "220": {
  "name": "actions",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "188",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "owned_expansions\n        worker_pool = []\n        actions = []\n\n        for idle_worker in self.workers.idle:\n   "
 },
 "221": {
  "name": "owned",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "247",
  "column": "8",
  "slicing": "['        owned = {}\\n', '                owned[el] = th\\n', '        return owned\\n']",
  "context": "st of expansions owned by the player.\"\"\"\n\n        owned = {}\n        for el in self.expansion_locations:\n      "
 },
 "222": {
  "name": "th",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "252",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "o(el) < self.EXPANSION_GAP_THRESHOLD\n\n            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\n            if th:\n                owned[el] = th\n"
 },
 "223": {
  "name": "unit_type",
  "type": "ids.unit_typeid.UnitTypeId",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "258",
  "column": "23",
  "slicing": "['    def can_feed(self, unit_type: UnitTypeId) -> bool:\\n']",
  "context": " th\n\n        return owned\n\n    def can_feed(self, unit_type: UnitTypeId) -> bool:\n        \"\"\" Checks if you have enough free supply "
 },
 "224": {
  "name": "item_id",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "263",
  "column": "25",
  "slicing": "['    def can_afford(self, item_id: Union[UnitTypeId, UpgradeId, AbilityId], check_supply_cost: bool=True) -> \"CanAffordWrapper\":\\n']",
  "context": "supply_left >= required\n\n    def can_afford(self, item_id: Union[UnitTypeId, UpgradeId, AbilityId], check_supply_cost: bool=True) -> \"CanAffordWrapper\":\n        \"\"\"Tests if the player has enough resource"
 },
 "225": {
  "name": "check_supply_cost",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "263",
  "column": "75",
  "slicing": "['    def can_afford(self, item_id: Union[UnitTypeId, UpgradeId, AbilityId], check_supply_cost: bool=True) -> \"CanAffordWrapper\":\\n']",
  "context": "item_id: Union[UnitTypeId, UpgradeId, AbilityId], check_supply_cost: bool=True) -> \"CanAffordWrapper\":\n        \"\"\"Tests if the player has enough resource"
 },
 "226": {
  "name": "enough_supply",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "265",
  "column": "8",
  "slicing": "['        enough_supply = True\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n']",
  "context": "es to build a unit or cast an ability.\"\"\"\n        enough_supply = True\n        if isinstance(item_id, UnitTypeId):\n      "
 },
 "227": {
  "name": "unit",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "267",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "  if isinstance(item_id, UnitTypeId):\n            unit = self._game_data.units[item_id.value]\n            cost = self._game_data.calculate_abili"
 },
 "228": {
  "name": "enough_supply",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "270",
  "column": "16",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "            if check_supply_cost:\n                enough_supply = self.can_feed(item_id)\n        elif isinstance(item_id, UpgradeId):\n     "
 },
 "229": {
  "name": "abilities",
  "type": "cached_abilities_of_unit",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "286",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "\n        if cached_abilities_of_unit:\n            abilities = cached_abilities_of_unit\n        else:\n            abilities = (await self."
 },
 "230": {
  "name": "abilities",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "288",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "ached_abilities_of_unit\n        else:\n            abilities = (await self.get_available_abilities([unit]))[0]\n\n        if ability_id in abilities:\n            i"
 },
 "231": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "306",
  "column": "34",
  "slicing": "['    def select_build_worker(self, pos: Union[Unit, Point2, Point3], force: bool=False) -> Optional[Unit]:\\n']",
  "context": "  return False\n\n    def select_build_worker(self, pos: Union[Unit, Point2, Point3], force: bool=False) -> Optional[Unit]:\n        \"\"\"Select a worker to build a bulding with"
 },
 "232": {
  "name": "force",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "306",
  "column": "68",
  "slicing": "['    def select_build_worker(self, pos: Union[Unit, Point2, Point3], force: bool=False) -> Optional[Unit]:\\n']",
  "context": "ld_worker(self, pos: Union[Unit, Point2, Point3], force: bool=False) -> Optional[Unit]:\n        \"\"\"Select a worker to build a bulding with"
 },
 "233": {
  "name": "workers",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "309",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "ect a worker to build a bulding with.\"\"\"\n\n        workers = self.workers.closer_than(20, pos) or self.workers\n        for worker in workers.prefer_close_to(pos)"
 },
 "234": {
  "name": "building",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "326",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "elif isinstance(building, AbilityId):\n            building = self._game_data.abilities[building.value]\n\n        r = await self._client.query_building_pla"
 },
 "235": {
  "name": "building",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "340",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "on_ability\n        else:  # AbilityId\n            building = self._game_data.abilities[building.value]\n\n        if await self.can_place(building, near):\n"
 },
 "236": {
  "name": "possible_positions",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "349",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "_step, max_distance, placement_step):\n            possible_positions = [Point2(p).offset(near).to2 for p in (\n                    [(dx, -distance) for dx in ran"
 },
 "237": {
  "name": "possible",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "356",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "acement(building, possible_positions)\n            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\n            if not possible:\n                conti"
 },
 "238": {
  "name": "upgrade_type",
  "type": "ids.upgrade_id.UpgradeId",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "366",
  "column": "38",
  "slicing": "['    def already_pending_upgrade(self, upgrade_type: UpgradeId) -> Union[int, float]:\\n']",
  "context": "eturn None\n\n    def already_pending_upgrade(self, upgrade_type: UpgradeId) -> Union[int, float]:\n        \"\"\" Check if an upgrade is being researche"
 },
 "239": {
  "name": "level",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "376",
  "column": "8",
  "slicing": "['        level = None\\n', '                    if level and order.ability.button_name[-1] != level:\\n']",
  "context": "self.state.upgrades:\n            return 1\n        level = None\n        if \"LEVEL\" in upgrade_type.name:\n         "
 },
 "240": {
  "name": "level",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "378",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "     if \"LEVEL\" in upgrade_type.name:\n            level = upgrade_type.name[-1]\n        creationAbilityID = self._game_data.upgrad"
 },
 "241": {
  "name": "unit_type",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "388",
  "column": "30",
  "slicing": "['    def already_pending(self, unit_type: Union[UpgradeId, UnitTypeId], all_units: bool=False) -> int:\\n']",
  "context": "s\n        return 0\n\n    def already_pending(self, unit_type: Union[UpgradeId, UnitTypeId], all_units: bool=False) -> int:\n        \"\"\"\n        Returns a number of buildings "
 },
 "242": {
  "name": "all_units",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "388",
  "column": "71",
  "slicing": "['    def already_pending(self, unit_type: Union[UpgradeId, UnitTypeId], all_units: bool=False) -> int:\\n']",
  "context": "ng(self, unit_type: Union[UpgradeId, UnitTypeId], all_units: bool=False) -> int:\n        \"\"\"\n        Returns a number of buildings "
 },
 "243": {
  "name": "amount",
  "type": "len",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "405",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": ".units[unit_type.value].creation_ability\n\n        amount = len(self.units(unit_type).not_ready)\n\n        if all_units:\n            amount += sum(["
 },
 "244": {
  "name": "amount",
  "type": "sum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "408",
  "column": "12",
  "slicing": "['            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '        return amount\\n']",
  "context": "pe).not_ready)\n\n        if all_units:\n            amount += sum([o.ability == ability for u in self.units for o in u.orders])\n        else:\n            amount += sum([o.ability"
 },
 "245": {
  "name": "amount",
  "type": "sum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "410",
  "column": "12",
  "slicing": "['            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '        return amount\\n']",
  "context": "its for o in u.orders])\n        else:\n            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\n            amount += sum([egg.orders[0].ability ="
 },
 "246": {
  "name": "amount",
  "type": "sum",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "411",
  "column": "12",
  "slicing": "['            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n']",
  "context": "w in self.workers for o in w.orders])\n            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\n\n        return amount\n\n    async def build(self, "
 },
 "247": {
  "name": "p",
  "type": "int",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "425",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "ear.to2\n        else:\n            return\n\n        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\n        if p is None:\n            return ActionRes"
 },
 "248": {
  "name": "unit",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "429",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "n ActionResult.CantFindPlacementLocation\n\n        unit = unit or self.select_build_worker(p)\n        if unit is None or not self.can_afford(bui"
 },
 "249": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "468",
  "column": "33",
  "slicing": "['    def get_terrain_height(self, pos: Union[Point2, Point3, Unit]) -> int:\\n']",
  "context": "of the map size.\n    def get_terrain_height(self, pos: Union[Point2, Point3, Unit]) -> int:\n        \"\"\" Returns terrain height at a position. "
 },
 "250": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "474",
  "column": "32",
  "slicing": "['    def in_placement_grid(self, pos: Union[Point2, Point3, Unit]) -> bool:\\n']",
  "context": "s] # returns int\n\n    def in_placement_grid(self, pos: Union[Point2, Point3, Unit]) -> bool:\n        \"\"\" Returns True if you can place somethin"
 },
 "251": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "482",
  "column": "30",
  "slicing": "['    def in_pathing_grid(self, pos: Union[Point2, Point3, Unit]) -> bool:\\n']",
  "context": "ent_grid[pos] != 0\n\n    def in_pathing_grid(self, pos: Union[Point2, Point3, Unit]) -> bool:\n        \"\"\" Returns True if a unit can pass throug"
 },
 "252": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "488",
  "column": "25",
  "slicing": "['    def is_visible(self, pos: Union[Point2, Point3, Unit]) -> bool:\\n']",
  "context": ".pathing_grid[pos] == 0\n\n    def is_visible(self, pos: Union[Point2, Point3, Unit]) -> bool:\n        \"\"\" Returns True if you have vision on a g"
 },
 "253": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "495",
  "column": "24",
  "slicing": "['    def has_creep(self, pos: Union[Point2, Point3, Unit]) -> bool:\\n']",
  "context": "ate.visibility[pos] == 2\n\n    def has_creep(self, pos: Union[Point2, Point3, Unit]) -> bool:\n        \"\"\" Returns True if there is creep on the "
 },
 "254": {
  "name": "client",
  "type": "Client",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "501",
  "column": "29",
  "slicing": "['    def _prepare_start(self, client, player_id, game_info, game_data):\\n']",
  "context": "ate.creep[pos] != 0\n\n    def _prepare_start(self, client, player_id, game_info, game_data):\n        \"\"\"Ran until game start to set game and pl"
 },
 "255": {
  "name": "game_info",
  "type": "GameInfo",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "501",
  "column": "48",
  "slicing": "['    def _prepare_start(self, client, player_id, game_info, game_data):\\n']",
  "context": "\n\n    def _prepare_start(self, client, player_id, game_info, game_data):\n        \"\"\"Ran until game start to set game and pl"
 },
 "256": {
  "name": "game_data",
  "type": "game_data.GameData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "501",
  "column": "59",
  "slicing": "['    def _prepare_start(self, client, player_id, game_info, game_data):\\n']",
  "context": "prepare_start(self, client, player_id, game_info, game_data):\n        \"\"\"Ran until game start to set game and pl"
 },
 "257": {
  "name": "state",
  "type": "game_state.GameState",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "518",
  "column": "28",
  "slicing": "['    def _prepare_step(self, state):\\n']",
  "context": "e_info._find_ramps()\n\n    def _prepare_step(self, state):\n        \"\"\"Set attributes from new state before on"
 },
 "258": {
  "name": "unit_prev",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "564",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        t = self.time\\n', '        return f\"{int(t // 60):02}:{int(t % 60):02}\"\\n', '            {ramp for ramp in self.game_info.map_ramps if len(ramp.upper2_for_ramp_wall) == 2},\\n', '        RESOURCE_SPREAD_THRESHOLD = 225\\n', '        geysers = self.state.vespene_geyser\\n', '        all_resources = self.state.resources\\n', '        resource_groups = []\\n', '        for mf in all_resources:\\n', '            mf_height = self.get_terrain_height(mf.position)\\n', '            for cluster in resource_groups:\\n', '                if len(cluster) == 10:\\n', '                if mf.position._distance_squared(\\n', '                    cluster[0].position\\n', '                ) < RESOURCE_SPREAD_THRESHOLD and mf_height == self.get_terrain_height(cluster[0].position):\\n', '                    cluster.append(mf)\\n', '                resource_groups.append([mf])\\n', '        resource_groups = [cluster for cluster in resource_groups if len(cluster) > 1]\\n', '        offsets = [(x, y) for x in range(-9, 10) for y in range(-9, 10) if 75 >= x ** 2 + y ** 2 >= 49]\\n', '        centers = {}\\n', '        for resources in resource_groups:\\n', '            possible_points = (\\n', '                Point2((offset[0] + resources[-1].position.x, offset[1] + resources[-1].position.y))\\n', '                for offset in offsets\\n', '            possible_points = [\\n', '                for point in possible_points\\n', '                if all(point.distance_to(resource) >= (7 if resource in geysers else 6) for resource in resources)\\n', '            result = min(possible_points, key=lambda p: sum(p.distance_to(resource) for resource in resources))\\n', '            centers[result] = resources\\n', '        return centers\\n', '            start_townhall_type = {Race.Protoss: UnitTypeId.NEXUS, Race.Terran: UnitTypeId.COMMANDCENTER, Race.Zerg: UnitTypeId.HATCHERY}\\n', '            building = start_townhall_type[self.race]\\n', '        assert isinstance(building, UnitTypeId)\\n', '            location = await self.get_next_expansion()\\n', '        if location:\\n', '            await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\\n', '        closest = None\\n', '        distance = math.inf\\n', '        for el in self.expansion_locations:\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            startp = self._game_info.player_start_location\\n', '            d = await self._client.query_pathing(startp, el)\\n', '            if d is None:\\n', '            if d < distance:\\n', '                distance = d\\n', '                closest = el\\n', '        return closest\\n', '        owned_expansions = self.owned_expansions\\n', '        worker_pool = []\\n', '        actions = []\\n', '        for idle_worker in self.workers.idle:\\n', '            mf = self.state.mineral_field.closest_to(idle_worker)\\n', '            actions.append(idle_worker.gather(mf))\\n', '        for location, townhall in owned_expansions.items():\\n', '            workers = self.workers.closer_than(20, location)\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            workers = self.workers.closer_than(5, g)\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            excess = actual - ideal\\n', '            if actual > ideal:\\n', '                worker_pool.extend(workers.random_group_of(min(excess, len(workers))))\\n', '        for g in self.geysers:\\n', '            actual = g.assigned_harvesters\\n', '            ideal = g.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for _ in range(deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(g))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(g))\\n', '        for location, townhall in owned_expansions.items():\\n', '            actual = townhall.assigned_harvesters\\n', '            ideal = townhall.ideal_harvesters\\n', '            deficit = ideal - actual\\n', '            for x in range(0, deficit):\\n', '                if worker_pool:\\n', '                    w = worker_pool.pop()\\n', '                    mf = self.state.mineral_field.closest_to(townhall)\\n', '                    if len(w.orders) == 1 and w.orders[0].ability.id is AbilityId.HARVEST_RETURN:\\n', '                        actions.append(w.move(townhall))\\n', '                        actions.append(w.return_resource(queue=True))\\n', '                        actions.append(w.gather(mf, queue=True))\\n', '                        actions.append(w.gather(mf))\\n', '        await self.do_actions(actions)\\n', '        owned = {}\\n', '        for el in self.expansion_locations:\\n', '            def is_near_to_expansion(t):\\n', '                return t.position.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\\n', '            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\\n', '            if th:\\n', '                owned[el] = th\\n', '        return owned\\n', '        required = self._game_data.units[unit_type.value]._proto.food_required\\n', '        return required == 0 or self.supply_left >= required\\n', '        enough_supply = True\\n', '            unit = self._game_data.units[item_id.value]\\n', '            cost = self._game_data.calculate_ability_cost(unit.creation_ability)\\n', '                enough_supply = self.can_feed(item_id)\\n', '            cost = self._game_data.upgrades[item_id.value].cost\\n', '            cost = self._game_data.calculate_ability_cost(item_id)\\n', '        return CanAffordWrapper(cost.minerals <= self.minerals, cost.vespene <= self.vespene, enough_supply)\\n', '        assert isinstance(unit, Unit)\\n', '            abilities = cached_abilities_of_unit\\n', '            abilities = (await self.get_available_abilities([unit]))[0]\\n', '        if ability_id in abilities:\\n', '            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\\n', '            ability_target = self._game_data.abilities[ability_id.value]._proto.target\\n', '            if ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range: # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\\n', '            elif ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit) and unit.distance_to(target) <= cast_range:\\n', '            elif ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, (Point2, Point3)) and unit.distance_to(target) <= cast_range:\\n', '        workers = self.workers.closer_than(20, pos) or self.workers\\n', '        for worker in workers.prefer_close_to(pos).prefer_idle:\\n', '            if not worker.orders or len(worker.orders) == 1 and worker.orders[0].ability.id in {AbilityId.MOVE,\\n', '                return worker\\n', '        return workers.random if force else None\\n', '        assert isinstance(building, (AbilityData, AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '        elif isinstance(building, AbilityId):\\n', '            building = self._game_data.abilities[building.value]\\n', '        r = await self._client.query_building_placement(building, [position])\\n', '        return r[0] == ActionResult.Success\\n', '        assert isinstance(building, (AbilityId, UnitTypeId))\\n', '        if isinstance(building, UnitTypeId):\\n', '            building = self._game_data.units[building.value].creation_ability\\n', '            building = self._game_data.abilities[building.value]\\n', '        if await self.can_place(building, near):\\n', '        for distance in range(placement_step, max_distance, placement_step):\\n', '            possible_positions = [Point2(p).offset(near).to2 for p in (\\n', '                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\\n', '                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\\n', '                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\\n', '            res = await self._client.query_building_placement(building, possible_positions)\\n', '            possible = [p for r, p in zip(res, possible_positions) if r == ActionResult.Success]\\n', '            if not possible:\\n', '                return random.choice(possible)\\n', '                return min(possible, key=lambda p: p.distance_to(near))\\n', '        level = None\\n', '            level = upgrade_type.name[-1]\\n', '        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.id\\n', '        for structure in self.units.structure.ready:\\n', '            for order in structure.orders:\\n', '                if order.ability.id is creationAbilityID:\\n', '                    if level and order.ability.button_name[-1] != level:\\n', '                    return order.progress\\n', '        ability = self._game_data.units[unit_type.value].creation_ability\\n', '        amount = len(self.units(unit_type).not_ready)\\n', '            amount += sum([o.ability == ability for u in self.units for o in u.orders])\\n', '            amount += sum([o.ability == ability for w in self.workers for o in w.orders])\\n', '            amount += sum([egg.orders[0].ability == ability for egg in self.units(UnitTypeId.EGG)])\\n', '        return amount\\n', '            near = near.position.to2\\n', '        elif near is not None:\\n', '            near = near.to2\\n', '        p = await self.find_placement(building, near.rounded, max_distance, random_alternative, placement_step)\\n', '        if p is None:\\n', '        unit = unit or self.select_build_worker(p)\\n', '        if unit is None or not self.can_afford(building):\\n', '        return await self.do(unit.build(building, p))\\n', '            logger.warning(f\"Cannot afford action {action}\")\\n', '        r = await self._client.actions(action, game_data=self._game_data)\\n', '        if not r:  # success\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '            logger.error(f\"Error: {r} (action: {action})\")\\n', '        return r\\n', '        if not actions:\\n', '        for action in actions:\\n', '            cost = self._game_data.calculate_ability_cost(action.ability)\\n', '            self.minerals -= cost.minerals\\n', '            self.vespene -= cost.vespene\\n', '        r = await self._client.actions(actions, game_data=self._game_data)\\n', '        return r\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.terrain_height[pos] # returns int\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.placement_grid[pos] != 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self._game_info.pathing_grid[pos] == 0\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.visibility[pos] == 2\\n', '        assert isinstance(pos, (Point2, Point3, Unit))\\n', '        pos = pos.position.to2.rounded\\n', '        return self.state.creep[pos] != 0\\n', '        for unit in self.units:\\n', '            self._units_previous_map[unit.tag] = unit\\n', '        for unit in self.units.structure:\\n', '            await self._issue_building_complete_event(unit)\\n', '        for unit in self.units.not_structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_unit_created(unit)\\n', '        for unit in self.units.structure:\\n', '            if unit.tag not in self._units_previous_map:\\n', '                await self.on_building_construction_started(unit)\\n', '        if unit.build_progress < 1:\\n', '        if unit.tag not in self._units_previous_map:\\n', '        unit_prev = self._units_previous_map[unit.tag]\\n', '        if unit_prev.build_progress < 1:\\n', '            await self.on_building_construction_complete(unit)\\n']",
  "context": "f._units_previous_map:\n            return\n        unit_prev = self._units_previous_map[unit.tag]\n        if unit_prev.build_progress < 1:\n         "
 },
 "259": {
  "name": "game_result",
  "type": "data.Result",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "598",
  "column": "21",
  "slicing": "['    def on_end(self, game_result: Result):\\n']",
  "context": "  raise NotImplementedError\n\n    def on_end(self, game_result: Result):\n        \"\"\"Ran at the end of a game.\"\"\"\n        pa"
 },
 "260": {
  "name": "can_afford_minerals",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "604",
  "column": "23",
  "slicing": "['    def __init__(self, can_afford_minerals, can_afford_vespene, have_enough_supply):\\n']",
  "context": "\n\n\nclass CanAffordWrapper:\n    def __init__(self, can_afford_minerals, can_afford_vespene, have_enough_supply):\n        self.can_afford_minerals = can_afford_mine"
 },
 "261": {
  "name": "can_afford_vespene",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "604",
  "column": "44",
  "slicing": "['    def __init__(self, can_afford_minerals, can_afford_vespene, have_enough_supply):\\n']",
  "context": "pper:\n    def __init__(self, can_afford_minerals, can_afford_vespene, have_enough_supply):\n        self.can_afford_minerals = can_afford_mine"
 },
 "262": {
  "name": "have_enough_supply",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/bot_ai.py",
  "lineno": "604",
  "column": "64",
  "slicing": "['    def __init__(self, can_afford_minerals, can_afford_vespene, have_enough_supply):\\n']",
  "context": "__(self, can_afford_minerals, can_afford_vespene, have_enough_supply):\n        self.can_afford_minerals = can_afford_mine"
 },
 "263": {
  "name": "size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "17",
  "column": "23",
  "slicing": "['    def __init__(self, size: int):\\n']",
  "context": "\n\nclass SlidingTimeWindow:\n    def __init__(self, size: int):\n        assert size > 0\n\n        self.window_size "
 },
 "264": {
  "name": "value",
  "type": "float",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "23",
  "column": "19",
  "slicing": "['    def push(self, value: float):\\n']",
  "context": "size\n        self.window = []\n\n    def push(self, value: float):\n        self.window = (self.window + [value])[-sel"
 },
 "265": {
  "name": "time_limit",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "77",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                    time_window.push(step_time)\\n', '                            time_window.clear()\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "ldown = 0\n    if step_time_limit is None:\n        time_limit = None\n        time_window = None\n        time_penalty = "
 },
 "266": {
  "name": "time_window",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "78",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                    time_window.push(step_time)\\n', '                            time_window.clear()\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "_limit is None:\n        time_limit = None\n        time_window = None\n        time_penalty = None\n    elif isinstance(st"
 },
 "267": {
  "name": "time_penalty",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "79",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "e_limit = None\n        time_window = None\n        time_penalty = None\n    elif isinstance(step_time_limit, (int, float))"
 },
 "268": {
  "name": "time_limit",
  "type": "float",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "81",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                    time_window.push(step_time)\\n', '                            time_window.clear()\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "sinstance(step_time_limit, (int, float)):\n        time_limit = float(step_time_limit)\n        time_window = SlidingTimeWindow(1)\n       "
 },
 "269": {
  "name": "time_window",
  "type": "sc2.main.SlidingTimeWindow",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "82",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                    time_window.push(step_time)\\n', '                            time_window.clear()\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "      time_limit = float(step_time_limit)\n        time_window = SlidingTimeWindow(1)\n        time_penalty = \"resign\"\n    else:\n        "
 },
 "270": {
  "name": "time_window",
  "type": "sc2.main.SlidingTimeWindow",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "87",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                    time_window.push(step_time)\\n', '                            time_window.clear()\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "ty = step_time_limit.get(\"penalty\", None)\n        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\n        time_limit = float(step_time_limit.get(\"ti"
 },
 "271": {
  "name": "time_limit",
  "type": "float",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "88",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                    time_window.push(step_time)\\n', '                            time_window.clear()\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "t(step_time_limit.get(\"window_size\", 1)))\n        time_limit = float(step_time_limit.get(\"time_limit\", None))\n\n\n    game_data = await client.get_game_data()\n   "
 },
 "272": {
  "name": "game_data",
  "type": "game_data.GameData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/main.py",
  "lineno": "91",
  "column": "4",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                            logger.warning(\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "at(step_time_limit.get(\"time_limit\", None))\n\n\n    game_data = await client.get_game_data()\n    game_info = await client.get_game_info()\n\n    "
 },
 "273": {
  "name": "game_info",
  "type": "GameInfo",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/main.py",
  "lineno": "92",
  "column": "4",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                            logger.warning(\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "\n    game_data = await client.get_game_data()\n    game_info = await client.get_game_info()\n\n    ai._prepare_start(client, player_id, game_inf"
 },
 "274": {
  "name": "gs",
  "type": "game_state.GameState",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "112",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                            logger.warning(\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "   return client._game_result[player_id]\n\n        gs = GameState(state.observation, game_data)\n\n        if game_time_limit and (gs.game_loop * 0."
 },
 "275": {
  "name": "out_of_budget",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "137",
  "column": "20",
  "slicing": "['                    out_of_budget = False\\n', '                    if out_of_budget and time_penalty != None:\\n']",
  "context": "ration)\n                else:\n                    out_of_budget = False\n                    budget = time_limit - time_win"
 },
 "276": {
  "name": "out_of_budget",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "146",
  "column": "24",
  "slicing": "['                        out_of_budget = True\\n', '                    if out_of_budget and time_penalty != None:\\n']",
  "context": "          step_time = 0.0\n                        out_of_budget = True\n                    else:\n                        "
 },
 "277": {
  "name": "out_of_budget",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "159",
  "column": "28",
  "slicing": "['                            out_of_budget = True\\n', '                    if out_of_budget and time_penalty != None:\\n']",
  "context": "                    )\n                            out_of_budget = True\n                        step_time = time.monotonic"
 },
 "278": {
  "name": "time_penalty_cooldown",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "168",
  "column": "28",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '        logger.critical(err)\\n']",
  "context": "                else:\n                            time_penalty_cooldown = int(time_penalty)\n                            time_window.clear()\n  "
 },
 "279": {
  "name": "result",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "174",
  "column": "16",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": ":\n                    return None\n                result = client._game_result[player_id]\n                if result is None:\n               "
 },
 "280": {
  "name": "err",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/main.py",
  "lineno": "214",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": ")\n    if r.create_game.HasField(\"error\"):\n        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\n        if r.create_game.HasField(\"error_details\")"
 },
 "281": {
  "name": "err",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/main.py",
  "lineno": "216",
  "column": "12",
  "slicing": "['            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n']",
  "context": "reate_game.HasField(\"error_details\"):\n            err += f\": {r.create_game.error_details}\"\n        logger.critical(err)\n        raise Runtime"
 },
 "282": {
  "name": "client",
  "type": "client.Client",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/main.py",
  "lineno": "232",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": ") as server:\n        await server.ping()\n\n        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\n\n        try:\n            result = await _play_gam"
 },
 "283": {
  "name": "client",
  "type": "client.Client",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/main.py",
  "lineno": "255",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": "rue:\n            await server.ping()\n\n            client = await _setup_host_game(server, map_settings, players, realtime)\n\n            try:\n                result = await _"
 },
 "284": {
  "name": "new_players",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/main.py",
  "lineno": "267",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": " game ended\")\n                return\n\n            new_players = yield result\n            if new_players is not None:\n          "
 },
 "285": {
  "name": "players",
  "type": "new_players",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "269",
  "column": "16",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": "      if new_players is not None:\n                players = new_players\n\ndef _host_game_iter(*args, **kwargs):\n    game = "
 },
 "286": {
  "name": "game",
  "type": "_host_game_aiter",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "272",
  "column": "4",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": "layers\n\ndef _host_game_iter(*args, **kwargs):\n    game = _host_game_aiter(*args, **kwargs)\n    new_playerconfig = None\n    while True:\n      "
 },
 "287": {
  "name": "new_playerconfig",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "273",
  "column": "4",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": "\n    game = _host_game_aiter(*args, **kwargs)\n    new_playerconfig = None\n    while True:\n        new_playerconfig = yield a"
 },
 "288": {
  "name": "new_playerconfig",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/main.py",
  "lineno": "275",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": "  new_playerconfig = None\n    while True:\n        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\n\n\nasync def _join_game(players, realtime, portconf"
 },
 "289": {
  "name": "client",
  "type": "client.Client",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "282",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": ") as server:\n        await server.ping()\n\n        client = Client(server._ws)\n\n        try:\n            result = await _play_gam"
 },
 "290": {
  "name": "players",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/main.py",
  "lineno": "296",
  "column": "27",
  "slicing": "['def run_game(map_settings, players, **kwargs):\\n']",
  "context": "        return result\n\ndef run_game(map_settings, players, **kwargs):\n    if sum(isinstance(p, (Human, Bot)) for p in pl"
 },
 "291": {
  "name": "host_only_args",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "298",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '        host_only_args = [\"save_replay_as\", \"rgb_render_config\", \"random_seed\"]\\n', '        join_kwargs = {k: v for k, v in kwargs.items() if k not in host_only_args}\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": "e(p, (Human, Bot)) for p in players) > 1:\n        host_only_args = [\"save_replay_as\", \"rgb_render_config\", \"random_seed\"]\n        join_kwargs = {k: v for k, v in kwargs.ite"
 },
 "292": {
  "name": "join_kwargs",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "299",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '        host_only_args = [\"save_replay_as\", \"rgb_render_config\", \"random_seed\"]\\n', '        join_kwargs = {k: v for k, v in kwargs.items() if k not in host_only_args}\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": "_as\", \"rgb_render_config\", \"random_seed\"]\n        join_kwargs = {k: v for k, v in kwargs.items() if k not in host_only_args}\n\n        portconfig = Portconfig()\n        result "
 },
 "293": {
  "name": "portconfig",
  "type": "portconfig.Portconfig",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/main.py",
  "lineno": "301",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '    def sum(self) -> float:\\n', '        return sum(self.window[1:])\\n', '        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])\\n', 'async def _play_game_human(client, player_id, realtime, game_time_limit):\\n', '        state = await client.observation()\\n', '        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '            print(state.observation.game_loop, state.observation.game_loop * 0.14)\\n', 'async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\\n', '    time_penalty_cooldown = 0\\n', '        time_limit = None\\n', '        time_window = None\\n', '        time_penalty = None\\n', '        time_limit = float(step_time_limit)\\n', '        time_window = SlidingTimeWindow(1)\\n', '        time_penalty = \"resign\"\\n', '        time_penalty = step_time_limit.get(\"penalty\", None)\\n', '        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\\n', '        time_limit = float(step_time_limit.get(\"time_limit\", None))\\n', '    game_data = await client.get_game_data()\\n', '    game_info = await client.get_game_info()\\n', '    ai._prepare_start(client, player_id, game_info, game_data)\\n', '        logger.exception(f\"AI on_start threw an error\")\\n', '        logger.error(f\"resigning due to previous error\")\\n', '    iteration = 0\\n', '        state = await client.observation()\\n', '        logger.debug(f\"Score: {state.observation.observation.score.score}\")\\n', '        gs = GameState(state.observation, game_data)\\n', '        if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\\n', '        ai._prepare_step(gs)\\n', '        if iteration == 0:\\n', '        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\\n', '                await ai.on_step(iteration)\\n', '                if time_penalty_cooldown > 0:\\n', '                    time_penalty_cooldown -= 1\\n', '                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\\n', '                    iteration -= 1 # Do not increment the iteration on this round\\n', '                elif time_limit is None:\\n', '                    await ai.on_step(iteration)\\n', '                    out_of_budget = False\\n', '                    budget = time_limit - time_window.available\\n', '                    ai.time_budget_available = budget\\n', '                    if budget < 0:\\n', '                        logger.warning(f\"Running AI step: out of budget before step\")\\n', '                        step_time = 0.0\\n', '                        out_of_budget = True\\n', '                        step_start = time.monotonic()\\n', '                            async with async_timeout.timeout(budget):\\n', '                                await ai.on_step(iteration)\\n', '                            step_time = time.monotonic() - step_start\\n', '                            logger.warning(\\n', '                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\\n', '                                f\"window={time_window.available_fmt}\"\\n', '                            out_of_budget = True\\n', '                        step_time = time.monotonic() - step_start\\n', '                    time_window.push(step_time)\\n', '                    if out_of_budget and time_penalty != None:\\n', '                        if time_penalty == \"resign\":\\n', '                            time_penalty_cooldown = int(time_penalty)\\n', '                            time_window.clear()\\n', '                result = client._game_result[player_id]\\n', '                if result is None:\\n', '                return result\\n', '            logger.exception(f\"AI step threw an error\") # DO NOT EDIT!\\n', '            logger.error(f\"resigning due to previous error\")\\n', '        logger.debug(f\"Running AI step: done\")\\n', '                ai.on_end(client._game_result[player_id])\\n', '        iteration += 1\\n', 'async def _play_game(player, client, realtime, portconfig, step_time_limit=None, game_time_limit=None, rgb_render_config=None):\\n', '    player_id = await client.join_game(player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config)\\n', '    logging.info(f\"Player id: {player_id} ({player.name})\")\\n', '        result = await _play_game_human(client, player_id, realtime, game_time_limit)\\n', '        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\\n', '    logging.info(f\"Result for player id: {player_id}: {result}\")\\n', '    return result\\n', 'async def _setup_host_game(server, map_settings, players, realtime, random_seed=None):\\n', '    r = await server.create_game(map_settings, players, realtime, random_seed)\\n', '    if r.create_game.HasField(\"error\"):\\n', '        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\\n', '        if r.create_game.HasField(\"error_details\"):\\n', '            err += f\": {r.create_game.error_details}\"\\n', '        logger.critical(err)\\n', '        raise RuntimeError(err)\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process(render=rgb_render_config is not None) as server:\\n', '        await server.ping()\\n', '        client = await _setup_host_game(server, map_settings, players, realtime, random_seed)\\n', '            result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', 'async def _host_game_aiter(map_settings, players, realtime, portconfig=None, save_replay_as=None, step_time_limit=None, game_time_limit=None):\\n', '    assert players, \"Can\\'t create a game without players\"\\n', '    assert any(isinstance(p, (Human, Bot)) for p in players)\\n', '    async with SC2Process() as server:\\n', '            await server.ping()\\n', '            client = await _setup_host_game(server, map_settings, players, realtime)\\n', '                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                    await client.save_replay(save_replay_as)\\n', '                await client.leave()\\n', '            new_players = yield result\\n', '            if new_players is not None:\\n', '                players = new_players\\n', '    game = _host_game_aiter(*args, **kwargs)\\n', '    new_playerconfig = None\\n', '        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))\\n', '    async with SC2Process() as server:\\n', '        await server.ping()\\n', '        client = Client(server._ws)\\n', '            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\\n', '                await client.save_replay(save_replay_as)\\n', '            await client.leave()\\n', '            await client.quit()\\n', '        return result\\n', '    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\\n', '        host_only_args = [\"save_replay_as\", \"rgb_render_config\", \"random_seed\"]\\n', '        join_kwargs = {k: v for k, v in kwargs.items() if k not in host_only_args}\\n', '        portconfig = Portconfig()\\n', '            _host_game(map_settings, players, **kwargs, portconfig=portconfig),\\n', '            _join_game(players, **join_kwargs, portconfig=portconfig)\\n', '            _host_game(map_settings, players, **kwargs)\\n', '    return result\\n']",
  "context": "args.items() if k not in host_only_args}\n\n        portconfig = Portconfig()\n        result = asyncio.get_event_loop().run_unti"
 },
 "294": {
  "name": "ability",
  "type": "key",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/action.py",
  "lineno": "9",
  "column": "8",
  "slicing": "['        ability, target, queue = key\\n', '                ability_id=ability.value,\\n', '                ability_id=ability.value,\\n', '                ability_id=ability.value,\\n']",
  "context": "n_iter, key=lambda a: a.combining_tuple):\n        ability, target, queue = key\n\n        if target is None:\n            cmd = raw_"
 },
 "295": {
  "name": "target",
  "type": "key",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/action.py",
  "lineno": "9",
  "column": "17",
  "slicing": "['        ability, target, queue = key\\n', '        if target is None:\\n', '        elif isinstance(target, Point2):\\n', '                target_world_space_pos=common_pb.Point2D(x=target.x, y=target.y)\\n', '        elif isinstance(target, Unit):\\n', '                target_unit_tag=target.tag\\n', '            raise RuntimeError(f\"Must target an unit or a point or None, found \\'{target !r}\\'\")\\n']",
  "context": "ey=lambda a: a.combining_tuple):\n        ability, target, queue = key\n\n        if target is None:\n            cmd = raw_"
 },
 "296": {
  "name": "queue",
  "type": "key",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/action.py",
  "lineno": "9",
  "column": "25",
  "slicing": "['        ability, target, queue = key\\n', '                queue_command=queue\\n', '                queue_command=queue,\\n', '                queue_command=queue,\\n']",
  "context": "a a: a.combining_tuple):\n        ability, target, queue = key\n\n        if target is None:\n            cmd = raw_"
 },
 "297": {
  "name": "new_status",
  "type": "data.Status",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/protocol.py",
  "lineno": "67",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        logger.debug(f\"Sending request: {request !r}\")\\n', '        logger.debug(f\"Request sent\")\\n', '        response = sc_pb.Response()\\n', '            response_bytes = await self._ws.receive_bytes()\\n', '        response.ParseFromString(response_bytes)\\n', '        logger.debug(f\"Response received\")\\n', '        return response\\n', '        request = sc_pb.Request(**kwargs)\\n', '        response = await self.__request(request)\\n', '        new_status = Status(response.status)\\n', '        if new_status != self._status:\\n', '            logger.info(f\"Client status changed to {new_status} (was {self._status})\")\\n', '        self._status = new_status\\n', '        if response.error:\\n', '            logger.debug(f\"Response contained an error: {response.error}\")\\n', '            raise ProtocolError(f\"{response.error}\")\\n', '        return response\\n']",
  "context": "response = await self.__request(request)\n\n        new_status = Status(response.status)\n        if new_status != self._status:\n           "
 },
 "298": {
  "name": "ATTRIBUTES",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_state.py",
  "lineno": "56",
  "column": "4",
  "slicing": "['    ATTRIBUTES = [\\n']",
  "context": "3.from_proto(self._proto.pos)\n\n\nclass Common:\n    ATTRIBUTES = [\n        \"player_id\",\n        \"minerals\", \"vespene\""
 },
 "299": {
  "name": "game_data",
  "type": "game_data.GameData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_state.py",
  "lineno": "87",
  "column": "45",
  "slicing": "['    def __init__(self, response_observation, game_data):\\n']",
  "context": "ate:\n    def __init__(self, response_observation, game_data):\n        self.actions = response_observation.action"
 },
 "300": {
  "name": "visibleUnits",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_state.py",
  "lineno": "108",
  "column": "8",
  "slicing": "['        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\\n', '                visibleUnits.append(unit)\\n', '        self.units: Units = Units.from_proto(visibleUnits, game_data)\\n']",
  "context": "nit information than normal visible units\n        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\n\n        for unit in self.observation.raw_data.uni"
 },
 "301": {
  "name": "hiddenUnits",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_state.py",
  "lineno": "108",
  "column": "22",
  "slicing": "['        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\\n', '                hiddenUnits.append(unit)\\n', '        self.blips: Set[Blip] = {Blip(unit) for unit in hiddenUnits}\\n']",
  "context": "n than normal visible units\n        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\n\n        for unit in self.observation.raw_data.uni"
 },
 "302": {
  "name": "minerals",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_state.py",
  "lineno": "108",
  "column": "35",
  "slicing": "['        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\\n', '                        minerals.append(unit)\\n', '        self.mineral_field: Units = Units.from_proto(minerals, game_data)\\n', '        self.resources: Units = Units.from_proto(minerals + geysers, game_data)\\n']",
  "context": " visible units\n        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\n\n        for unit in self.observation.raw_data.uni"
 },
 "303": {
  "name": "geysers",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_state.py",
  "lineno": "108",
  "column": "45",
  "slicing": "['        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\\n', '                        geysers.append(unit)\\n', '        self.vespene_geyser: Units = Units.from_proto(geysers, game_data)\\n', '        self.resources: Units = Units.from_proto(minerals + geysers, game_data)\\n']",
  "context": "nits\n        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\n\n        for unit in self.observation.raw_data.uni"
 },
 "304": {
  "name": "destructables",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_state.py",
  "lineno": "108",
  "column": "54",
  "slicing": "['        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\\n', '                    destructables.append(unit)\\n', '        self.destructables: Units = Units.from_proto(destructables, game_data)\\n']",
  "context": "    visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\n\n        for unit in self.observation.raw_data.uni"
 },
 "305": {
  "name": "enemy",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_state.py",
  "lineno": "108",
  "column": "69",
  "slicing": "['        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\\n', '                    enemy.append(unit)\\n', '        self.enemy_units: Units = Units.from_proto(enemy, game_data)\\n']",
  "context": "s, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\n\n        for unit in self.observation.raw_data.uni"
 },
 "306": {
  "name": "own",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_state.py",
  "lineno": "108",
  "column": "76",
  "slicing": "['        visibleUnits, hiddenUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\\n', '                    own.append(unit)\\n', '        self.own_units: Units = Units.from_proto(own, game_data)\\n']",
  "context": "enUnits, minerals, geysers, destructables, enemy, own = ([] for _ in range(7))\n\n        for unit in self.observation.raw_data.uni"
 },
 "307": {
  "name": "cls",
  "type": "units.Units",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/units.py",
  "lineno": "13",
  "column": "19",
  "slicing": "['    def from_proto(cls, units, game_data):\\n']",
  "context": "electors.\"\"\"\n\n    @classmethod\n    def from_proto(cls, units, game_data):\n        return cls((Unit(u, game_data) for u in un"
 },
 "308": {
  "name": "units",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/units.py",
  "lineno": "13",
  "column": "24",
  "slicing": "['    def from_proto(cls, units, game_data):\\n']",
  "context": "ors.\"\"\"\n\n    @classmethod\n    def from_proto(cls, units, game_data):\n        return cls((Unit(u, game_data) for u in un"
 },
 "309": {
  "name": "game_data",
  "type": "game_data.GameData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/units.py",
  "lineno": "13",
  "column": "31",
  "slicing": "['    def from_proto(cls, units, game_data):\\n']",
  "context": "\n\n    @classmethod\n    def from_proto(cls, units, game_data):\n        return cls((Unit(u, game_data) for u in un"
 },
 "310": {
  "name": "units",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/units.py",
  "lineno": "16",
  "column": "23",
  "slicing": "['    def __init__(self, units, game_data):\\n']",
  "context": "r u in units), game_data)\n\n    def __init__(self, units, game_data):\n        super().__init__(units)\n        self.game_"
 },
 "311": {
  "name": "game_data",
  "type": "game_data.GameData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/units.py",
  "lineno": "16",
  "column": "30",
  "slicing": "['    def __init__(self, units, game_data):\\n']",
  "context": "units), game_data)\n\n    def __init__(self, units, game_data):\n        super().__init__(units)\n        self.game_"
 },
 "312": {
  "name": "tags",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/units.py",
  "lineno": "34",
  "column": "8",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            [u.position for u in self]\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "if other is None:\n            return self\n        tags = {unit.tag for unit in self}\n        units = self + [unit for unit in other if "
 },
 "313": {
  "name": "tags",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/units.py",
  "lineno": "43",
  "column": "8",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            [u.position for u in self]\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "if other is None:\n            return self\n        tags = {unit.tag for unit in self}\n        units = [unit for unit in other if unit.ta"
 },
 "314": {
  "name": "units",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "44",
  "column": "8",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            [u.position for u in self]\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "       tags = {unit.tag for unit in self}\n        units = [unit for unit in other if unit.tag in tags]\n        return Units(units, self.game_data)\n\n    d"
 },
 "315": {
  "name": "tags",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/units.py",
  "lineno": "52",
  "column": "8",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            [u.position for u in self]\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "if other is None:\n            return self\n        tags = {unit.tag for unit in other}\n        units = [unit for unit in self if unit.tag"
 },
 "316": {
  "name": "units",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "53",
  "column": "8",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            [u.position for u in self]\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "      tags = {unit.tag for unit in other}\n        units = [unit for unit in self if unit.tag not in tags]\n        return Units(units, self.game_data)\n\n    d"
 },
 "317": {
  "name": "n",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "88",
  "column": "19",
  "slicing": "['    def take(self, n: int, require_all: bool = True) -> \"Units\":\\n']",
  "context": "t self\n        return self[0]\n\n    def take(self, n: int, require_all: bool = True) -> \"Units\":\n        assert (not require_all) or len(self) >= n"
 },
 "318": {
  "name": "require_all",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "88",
  "column": "27",
  "slicing": "['    def take(self, n: int, require_all: bool = True) -> \"Units\":\\n']",
  "context": "       return self[0]\n\n    def take(self, n: int, require_all: bool = True) -> \"Units\":\n        assert (not require_all) or len(self) >= n"
 },
 "319": {
  "name": "other",
  "type": "any",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "97",
  "column": "24",
  "slicing": "['    def random_or(self, other: any) -> Unit:\\n']",
  "context": "turn random.choice(self)\n\n    def random_or(self, other: any) -> Unit:\n        if self.exists:\n            return random."
 },
 "320": {
  "name": "unit",
  "type": "unit.Unit",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "113",
  "column": "33",
  "slicing": "['    def in_attack_range_of(self, unit: Unit, bonus_distance: Union[int, float] = 0) -> \"Units\":\\n']",
  "context": "ample(self, n))\n\n    def in_attack_range_of(self, unit: Unit, bonus_distance: Union[int, float] = 0) -> \"Units\":\n        \"\"\" Filters units that are in attack range"
 },
 "321": {
  "name": "bonus_distance",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "113",
  "column": "45",
  "slicing": "['    def in_attack_range_of(self, unit: Unit, bonus_distance: Union[int, float] = 0) -> \"Units\":\\n']",
  "context": "n))\n\n    def in_attack_range_of(self, unit: Unit, bonus_distance: Union[int, float] = 0) -> \"Units\":\n        \"\"\" Filters units that are in attack range"
 },
 "322": {
  "name": "position",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "117",
  "column": "34",
  "slicing": "['    def closest_distance_to(self, position: Union[Unit, Point2, Point3]) -> Union[int, float]:\\n']",
  "context": "nus_distance))\n\n    def closest_distance_to(self, position: Union[Unit, Point2, Point3]) -> Union[int, float]:\n        \"\"\" Returns the distance between the close"
 },
 "323": {
  "name": "position",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "126",
  "column": "35",
  "slicing": "['    def furthest_distance_to(self, position: Union[Unit, Point2, Point3]) -> Union[int, float]:\\n']",
  "context": "comprehension\n\n    def furthest_distance_to(self, position: Union[Unit, Point2, Point3]) -> Union[int, float]:\n        \"\"\" Returns the distance between the furth"
 },
 "324": {
  "name": "position",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "133",
  "column": "25",
  "slicing": "['    def closest_to(self, position: Union[Unit, Point2, Point3]) -> Unit:\\n']",
  "context": "osition for u in self])\n\n    def closest_to(self, position: Union[Unit, Point2, Point3]) -> Unit:\n        assert self.exists\n        if isinstance(p"
 },
 "325": {
  "name": "position",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "139",
  "column": "26",
  "slicing": "['    def furthest_to(self, position: Union[Unit, Point2, Point3]) -> Unit:\\n']",
  "context": "position.closest(self)\n\n    def furthest_to(self, position: Union[Unit, Point2, Point3]) -> Unit:\n        assert self.exists\n        if isinstance(p"
 },
 "326": {
  "name": "distance",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "145",
  "column": "26",
  "slicing": "['    def closer_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> \"Units\":\\n']",
  "context": "osition.furthest(self)\n\n    def closer_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> \"Units\":\n        if isinstance(position, Unit):\n           "
 },
 "327": {
  "name": "position",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "145",
  "column": "55",
  "slicing": "['    def closer_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> \"Units\":\\n']",
  "context": "ef closer_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> \"Units\":\n        if isinstance(position, Unit):\n           "
 },
 "328": {
  "name": "distance",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "151",
  "column": "27",
  "slicing": "['    def further_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> \"Units\":\\n']",
  "context": ") < distance_squared)\n\n    def further_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> \"Units\":\n        if isinstance(position, Unit):\n           "
 },
 "329": {
  "name": "position",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "151",
  "column": "56",
  "slicing": "['    def further_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> \"Units\":\\n']",
  "context": "f further_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> \"Units\":\n        if isinstance(position, Unit):\n           "
 },
 "330": {
  "name": "units",
  "type": "units.Units",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/units.py",
  "lineno": "157",
  "column": "23",
  "slicing": "['    def subgroup(self, units):\\n']",
  "context": ".to2) > distance_squared)\n\n    def subgroup(self, units):\n        return Units(list(units), self.game_data)\n"
 },
 "331": {
  "name": "pred",
  "type": "callable",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "160",
  "column": "21",
  "slicing": "['    def filter(self, pred: callable) -> \"Units\":\\n']",
  "context": "ist(units), self.game_data)\n\n    def filter(self, pred: callable) -> \"Units\":\n        return self.subgroup(filter(pred, self))\n\n"
 },
 "332": {
  "name": "keyfn",
  "type": "callable",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "163",
  "column": "21",
  "slicing": "['    def sorted(self, keyfn: callable, reverse: bool = False) -> \"Units\":\\n']",
  "context": "ubgroup(filter(pred, self))\n\n    def sorted(self, keyfn: callable, reverse: bool = False) -> \"Units\":\n        if len(self) in {0, 1}:\n            return"
 },
 "333": {
  "name": "reverse",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "163",
  "column": "38",
  "slicing": "['    def sorted(self, keyfn: callable, reverse: bool = False) -> \"Units\":\\n']",
  "context": "ed, self))\n\n    def sorted(self, keyfn: callable, reverse: bool = False) -> \"Units\":\n        if len(self) in {0, 1}:\n            return"
 },
 "334": {
  "name": "position",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "168",
  "column": "36",
  "slicing": "['    def sorted_by_distance_to(self, position: Union[Unit, Point2], reverse: bool = False) -> \"Units\":\\n']",
  "context": "se=reverse))\n\n    def sorted_by_distance_to(self, position: Union[Unit, Point2], reverse: bool = False) -> \"Units\":\n        \"\"\" This function should be a bit faster t"
 },
 "335": {
  "name": "reverse",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "168",
  "column": "67",
  "slicing": "['    def sorted_by_distance_to(self, position: Union[Unit, Point2], reverse: bool = False) -> \"Units\":\\n']",
  "context": "_distance_to(self, position: Union[Unit, Point2], reverse: bool = False) -> \"Units\":\n        \"\"\" This function should be a bit faster t"
 },
 "336": {
  "name": "other",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "175",
  "column": "22",
  "slicing": "['    def tags_in(self, other: Union[Set[int], List[int], Dict[int, Any]]) -> \"Units\":\\n']",
  "context": "osition), reverse=reverse)\n\n    def tags_in(self, other: Union[Set[int], List[int], Dict[int, Any]]) -> \"Units\":\n        \"\"\" Filters all units that have their tags"
 },
 "337": {
  "name": "other",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "179",
  "column": "12",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": ")\n        if isinstance(other, list):\n            other = set(other)\n        return self.filter(lambda unit: unit.tag i"
 },
 "338": {
  "name": "other",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "182",
  "column": "26",
  "slicing": "['    def tags_not_in(self, other: Union[Set[int], List[int], Dict[int, Any]]) -> \"Units\":\\n']",
  "context": "it: unit.tag in other)\n\n    def tags_not_in(self, other: Union[Set[int], List[int], Dict[int, Any]]) -> \"Units\":\n        \"\"\" Filters all units that have their tags"
 },
 "339": {
  "name": "other",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "186",
  "column": "12",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": ")\n        if isinstance(other, list):\n            other = set(other)\n        return self.filter(lambda unit: unit.tag n"
 },
 "340": {
  "name": "other",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "189",
  "column": "22",
  "slicing": "['    def of_type(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> \"Units\":\\n']",
  "context": "it: unit.tag not in other)\n\n    def of_type(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> \"Units\":\n        \"\"\" Filters all units that are of a specif"
 },
 "341": {
  "name": "other",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "193",
  "column": "12",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "    if isinstance(other, UnitTypeId):\n            other = {other}\n        if isinstance(other, list):\n            ot"
 },
 "342": {
  "name": "other",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "195",
  "column": "12",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "}\n        if isinstance(other, list):\n            other = set(other)\n        return self.filter(lambda unit: unit.type_"
 },
 "343": {
  "name": "other",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "199",
  "column": "14",
  "slicing": "['        self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]\\n']",
  "context": "id in other)\n\n    def exclude_type(\n        self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]\n    ) -> \"Units\":\n        \"\"\" Filters all units th"
 },
 "344": {
  "name": "other",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "204",
  "column": "12",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "    if isinstance(other, UnitTypeId):\n            other = {other}\n        if isinstance(other, list):\n            ot"
 },
 "345": {
  "name": "other",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "206",
  "column": "12",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "}\n        if isinstance(other, list):\n            other = set(other)\n        return self.filter(lambda unit: unit.type_"
 },
 "346": {
  "name": "other",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "209",
  "column": "24",
  "slicing": "['    def same_tech(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> \"Units\":\\n']",
  "context": "it.type_id not in other)\n\n    def same_tech(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> \"Units\":\n        \"\"\" Usage:\n        'self.units.same_tech(U"
 },
 "347": {
  "name": "other",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "217",
  "column": "12",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "    if isinstance(other, UnitTypeId):\n            other = {other}\n        tech_alias_types = set(other)\n        for "
 },
 "348": {
  "name": "tech_alias_types",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "218",
  "column": "8",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": " UnitTypeId):\n            other = {other}\n        tech_alias_types = set(other)\n        for unitType in other:\n            tech_al"
 },
 "349": {
  "name": "other",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "230",
  "column": "24",
  "slicing": "['    def same_unit(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> \"Units\":\\n']",
  "context": "ta.tech_alias)\n        )\n\n    def same_unit(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> \"Units\":\n        \"\"\" Usage:\n        'self.units.same_tech(U"
 },
 "350": {
  "name": "other",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "240",
  "column": "12",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "    if isinstance(other, UnitTypeId):\n            other = {other}\n        unit_alias_types = set(other)\n        for "
 },
 "351": {
  "name": "unit_alias_types",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "241",
  "column": "8",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": " UnitTypeId):\n            other = {other}\n        unit_alias_types = set(other)\n        for unitType in other:\n            unit_al"
 },
 "352": {
  "name": "pos",
  "type": "position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "256",
  "column": "8",
  "slicing": "['        return cls((Unit(u, game_data) for u in units), game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = self + [unit for unit in other if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in self}\\n', '        units = [unit for unit in other if unit.tag in tags]\\n', '        return Units(units, self.game_data)\\n', '        tags = {unit.tag for unit in other}\\n', '        units = [unit for unit in self if unit.tag not in tags]\\n', '        return Units(units, self.game_data)\\n', '        return hash(unit.tag for unit in self)\\n', '        for unit in self:\\n', '            if unit.tag == tag:\\n', '                return unit\\n', '        unit = self.find_by_tag(tag)\\n', '        if unit is None:\\n', '        return unit\\n', '        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\\n', '            position = position.position\\n', '        return position.distance_to_closest(\\n', '            [u.position for u in self]\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.distance_to_furthest([u.position for u in self])\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.closest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        return position.furthest(self)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) < distance_squared)\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '        distance_squared = distance ** 2\\n', '        return self.filter(lambda unit: unit.position._distance_squared(position.to2) > distance_squared)\\n', '        return Units(list(units), self.game_data)\\n', '        position = position.position\\n', '        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag in other)\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.tag not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        if isinstance(other, list):\\n', '            other = set(other)\\n', '        return self.filter(lambda unit: unit.type_id not in other)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        tech_alias_types = set(other)\\n', '        for unitType in other:\\n', '            tech_alias = self.game_data.units[unitType.value].tech_alias\\n', '            if tech_alias:\\n', '                for same in tech_alias:\\n', '                    tech_alias_types.add(same)\\n', '            lambda unit: unit.type_id in tech_alias_types\\n', '            or unit._type_data.tech_alias is not None\\n', '            and any(same in tech_alias_types for same in unit._type_data.tech_alias)\\n', '        if isinstance(other, UnitTypeId):\\n', '            other = {other}\\n', '        unit_alias_types = set(other)\\n', '        for unitType in other:\\n', '            unit_alias = self.game_data.units[unitType.value].unit_alias\\n', '            if unit_alias:\\n', '                unit_alias_types.add(unit_alias)\\n', '            lambda unit: unit.type_id in unit_alias_types\\n', '            or unit._type_data.unit_alias is not None\\n', '            and unit._type_data.unit_alias in unit_alias_types\\n', '        pos = Point2(\\n', '                sum([unit.position.x for unit in self]) / self.amount,\\n', '                sum([unit.position.y for unit in self]) / self.amount,\\n', '        return pos\\n', '        return self.filter(lambda unit: unit.is_selected)\\n', '        return {unit.tag for unit in self}\\n', '        return self.filter(lambda unit: unit.is_ready)\\n', '        return self.filter(lambda unit: not unit.is_ready)\\n', '        return self.filter(lambda unit: unit.noqueue)\\n', '        return self.filter(lambda unit: unit.is_idle)\\n', '        return self.filter(lambda unit: unit.is_mine)\\n', '        return self.filter(lambda unit: unit.is_enemy)\\n', '        return self.filter(lambda unit: unit.is_flying)\\n', '        return self.filter(lambda unit: not unit.is_flying)\\n', '        return self.filter(lambda unit: unit.is_structure)\\n', '        return self.filter(lambda unit: not unit.is_structure)\\n', '        return self.filter(lambda unit: unit.is_gathering)\\n', '        return self.filter(lambda unit: unit.is_returning)\\n', '        return self.filter(lambda unit: unit.is_collecting)\\n', '        return self.filter(lambda unit: unit.is_visible)\\n', '        return self.filter(lambda unit: unit.is_mineral_field)\\n', '        return self.filter(lambda unit: unit.is_vespene_geyser)\\n', '        return self.sorted(lambda unit: unit.is_idle, reverse=True)\\n', '        super().__init__([u for u in parent if self.matches(u)], parent.game_data)\\n', '            return unit.type_id in self.unit_type_id\\n', '            return self.unit_type_id == unit.type_id\\n']",
  "context": "nits in this list \"\"\"\n        assert self\n        pos = Point2(\n            (\n                sum([unit.position.x"
 },
 "353": {
  "name": "p",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/units.py",
  "lineno": "340",
  "column": "30",
  "slicing": "['    def prefer_close_to(self, p: Union[Unit, Point2, Point3]) -> \"Units\":\\n']",
  "context": "dle, reverse=True)\n\n    def prefer_close_to(self, p: Union[Unit, Point2, Point3]) -> \"Units\":\n        # TODO redundant?\n        return self.sort"
 },
 "354": {
  "name": "maps",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/maps.py",
  "lineno": "7",
  "column": "4",
  "slicing": "['    maps = []\\n', '                    maps.append(Map(mapfile))\\n', '                maps.append(Map(mapdir))\\n', '        return maps\\n', '    for m in maps:\\n', '        if m.matches(name):\\n', '            return m\\n']",
  "context": "ging.getLogger(__name__)\n\ndef get(name=None):\n    maps = []\n    for mapdir in (p for p in Paths.MAPS.iterdir()"
 },
 "355": {
  "name": "points",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "10",
  "column": "23",
  "slicing": "['    def __init__(self, points: Set[Point2], game_info: \"GameInfo\"):\\n']",
  "context": ", Rect, Size\n\n\nclass Ramp:\n    def __init__(self, points: Set[Point2], game_info: \"GameInfo\"):\n        self._points: Set[Point2] = points\n       "
 },
 "356": {
  "name": "game_info",
  "type": "GameInfo",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "10",
  "column": "44",
  "slicing": "['    def __init__(self, points: Set[Point2], game_info: \"GameInfo\"):\\n']",
  "context": "Ramp:\n    def __init__(self, points: Set[Point2], game_info: \"GameInfo\"):\n        self._points: Set[Point2] = points\n       "
 },
 "357": {
  "name": "p",
  "type": "position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "29",
  "column": "24",
  "slicing": "['    def height_at(self, p: Point2) -> int:\\n']",
  "context": "return len(self._points)\n\n    def height_at(self, p: Point2) -> int:\n        return self._height_map[p]\n\n    @property\n"
 },
 "358": {
  "name": "max_height",
  "type": "max",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "39",
  "column": "8",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "\" Returns the upper points of a ramp. \"\"\"\n        max_height = max([self.height_at(p) for p in self._points])\n        return {p for p in self._points if self.he"
 },
 "359": {
  "name": "upper2",
  "type": "sorted",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "50",
  "column": "8",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "k for now\n            # FIXME: please do\n\n        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\n        while len(upper2) > 2:\n            upper2."
 },
 "360": {
  "name": "pos",
  "type": "position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "57",
  "column": "8",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "perty\n    def top_center(self) -> Point2:\n        pos = Point2(\n            (sum([p.x for p in self.upper]) / len("
 },
 "361": {
  "name": "min_height",
  "type": "min",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "64",
  "column": "8",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "perty\n    def lower(self) -> Set[Point2]:\n        min_height = min([self.height_at(p) for p in self._points])\n        return {p for p in self._points if self.he"
 },
 "362": {
  "name": "pos",
  "type": "position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "69",
  "column": "8",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "ty\n    def bottom_center(self) -> Point2:\n        pos = Point2(\n            (sum([p.x for p in self.lower]) / len("
 },
 "363": {
  "name": "anyLowerPoint",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "83",
  "column": "12",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": " p1.circle_intersection(p2, 5 ** 0.5)\n            anyLowerPoint = next(iter(self.lower))\n            return max(intersects, key=lambda p: p"
 },
 "364": {
  "name": "anyLowerPoint",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "96",
  "column": "12",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "1.circle_intersection(p2, 2.5 ** 0.5)\n            anyLowerPoint = next(iter(self.lower))\n            return max(intersects, key=lambda p: p"
 },
 "365": {
  "name": "rampDict",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "160",
  "column": "8",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": " then find ramps by comparing heights.\"\"\"\n        rampDict = {\n            Point2((x, y)): self.pathing_grid[(x, "
 },
 "366": {
  "name": "rampPoints",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "166",
  "column": "8",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "ange(self.pathing_grid.height)\n        }\n\n        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\n        rampGroups = self._find_groups(rampPoints)"
 },
 "367": {
  "name": "rampGroups",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "167",
  "column": "8",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "ct[p]}  # filter only points part of ramp\n        rampGroups = self._find_groups(rampPoints)\n        return [Ramp(group, self) for group in ram"
 },
 "368": {
  "name": "points",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "171",
  "column": "14",
  "slicing": "['        self, points: Set[Point2], minimum_points_per_group: int = 8, max_distance_between_points: int = 2\\n']",
  "context": " rampGroups]\n\n    def _find_groups(\n        self, points: Set[Point2], minimum_points_per_group: int = 8, max_distance_between_points: int = 2\n    ) -> List[Set[Point2]]:\n        \"\"\" From a set"
 },
 "369": {
  "name": "minimum_points_per_group",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "171",
  "column": "35",
  "slicing": "['        self, points: Set[Point2], minimum_points_per_group: int = 8, max_distance_between_points: int = 2\\n']",
  "context": " _find_groups(\n        self, points: Set[Point2], minimum_points_per_group: int = 8, max_distance_between_points: int = 2\n    ) -> List[Set[Point2]]:\n        \"\"\" From a set"
 },
 "370": {
  "name": "max_distance_between_points",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "171",
  "column": "70",
  "slicing": "['        self, points: Set[Point2], minimum_points_per_group: int = 8, max_distance_between_points: int = 2\\n']",
  "context": ": Set[Point2], minimum_points_per_group: int = 8, max_distance_between_points: int = 2\n    ) -> List[Set[Point2]]:\n        \"\"\" From a set"
 },
 "371": {
  "name": "currentColor",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "177",
  "column": "8",
  "slicing": "['        currentColor: int = NOT_COLORED_YET\\n', '            picture[pt.y][pt.x] = currentColor\\n']",
  "context": "ERESTED = -2\n        NOT_COLORED_YET = -1\n        currentColor: int = NOT_COLORED_YET\n        picture: List[List[int]] = [\n            ["
 },
 "372": {
  "name": "picture",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "178",
  "column": "8",
  "slicing": "['        picture: List[List[int]] = [\\n', '            picture[pt.y][pt.x] = currentColor\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n']",
  "context": "      currentColor: int = NOT_COLORED_YET\n        picture: List[List[int]] = [\n            [NOT_INTERESTED for j in range(self.pa"
 },
 "373": {
  "name": "pt",
  "type": "position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "182",
  "column": "18",
  "slicing": "['        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '            paint(point)\\n', '                paint(start)\\n', '                    paint(point)\\n']",
  "context": "pathing_grid.height)\n        ]\n\n        def paint(pt: Point2) -> None:\n            picture[pt.y][pt.x] = currentColor\n\n  "
 },
 "374": {
  "name": "nearby",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "185",
  "column": "8",
  "slicing": "['        nearby: Set[Point2] = set()\\n', '                    nearby.add(Point2((dx, dy)))\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "      picture[pt.y][pt.x] = currentColor\n\n        nearby: Set[Point2] = set()\n        for dx in range(-max_distance_between_poin"
 },
 "375": {
  "name": "remaining",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "194",
  "column": "8",
  "slicing": "['        max_height = max([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == max_height}\\n', '        upper2 = sorted(list(self.upper), key=lambda x: x.distance_to(self.bottom_center), reverse=True)\\n', '        while len(upper2) > 2:\\n', '            upper2.pop()\\n', '        return set(upper2)\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.upper]) / len(self.upper), sum([p.y for p in self.upper]) / len(self.upper))\\n', '        return pos\\n', '        min_height = min([self.height_at(p) for p in self._points])\\n', '        return {p for p in self._points if self.height_at(p) == min_height}\\n', '        pos = Point2(\\n', '            (sum([p.x for p in self.lower]) / len(self.lower), sum([p.y for p in self.lower]) / len(self.lower))\\n', '        return pos\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            intersects = p1.circle_intersection(p2, 2.5 ** 0.5)\\n', '            anyLowerPoint = next(iter(self.lower))\\n', '            return max(intersects, key=lambda p: p.distance_to(anyLowerPoint))\\n', '            points = self.upper2_for_ramp_wall\\n', '            p1 = points.pop().offset((self.x_offset, self.y_offset))  # still an error with pixelmap?\\n', '            p2 = points.pop().offset((self.x_offset, self.y_offset))\\n', '            center = p1.towards(p2, p1.distance_to(p2) / 2)\\n', '            depotPosition = self.depot_in_middle\\n', '            intersects = center.circle_intersection(depotPosition, 5 ** 0.5)\\n', '            return intersects\\n', '        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\\n', '            p.player_id: p.race_actual or p.race_requested for p in self._proto.player_info\\n', '        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\\n', '        rampDict = {\\n', '            for x in range(self.pathing_grid.width)\\n', '            for y in range(self.pathing_grid.height)\\n', '        rampPoints = {p for p in rampDict if rampDict[p]}  # filter only points part of ramp\\n', '        rampGroups = self._find_groups(rampPoints)\\n', '        return [Ramp(group, self) for group in rampGroups]\\n', '        NOT_INTERESTED = -2\\n', '        NOT_COLORED_YET = -1\\n', '        currentColor: int = NOT_COLORED_YET\\n', '        picture: List[List[int]] = [\\n', '            [NOT_INTERESTED for j in range(self.pathing_grid.width)] for i in range(self.pathing_grid.height)\\n', '        def paint(pt: Point2) -> None:\\n', '            picture[pt.y][pt.x] = currentColor\\n', '        nearby: Set[Point2] = set()\\n', '        for dx in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '            for dy in range(-max_distance_between_points, max_distance_between_points + 1):\\n', '                if abs(dx) + abs(dy) <= max_distance_between_points:\\n', '                    nearby.add(Point2((dx, dy)))\\n', '        for point in points:\\n', '            paint(point)\\n', '        remaining: Set[Point2] = set(points)\\n', '        queue: Deque[Point2] = deque()\\n', '        while remaining:\\n', '            if not queue:\\n', '                currentColor += 1\\n', '                start = remaining.pop()\\n', '                paint(start)\\n', '                queue.append(start)\\n', '                currentGroup.add(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                for offset in nearby:\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "oint in points:\n            paint(point)\n\n        remaining: Set[Point2] = set(points)\n        queue: Deque[Point2] = deque()\n        fou"
 },
 "376": {
  "name": "queue",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "195",
  "column": "8",
  "slicing": "['        queue: Deque[Point2] = deque()\\n', '            if not queue:\\n', '                queue.append(start)\\n', '            while queue:\\n', '                base: Point2 = queue.popleft()\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "     remaining: Set[Point2] = set(points)\n        queue: Deque[Point2] = deque()\n        foundGroups: List[Set[Point2]] = []\n      "
 },
 "377": {
  "name": "foundGroups",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "196",
  "column": "8",
  "slicing": "['        foundGroups: List[Set[Point2]] = []\\n', '                foundGroups.append(currentGroup)\\n', '        return foundGroups\\n']",
  "context": "s)\n        queue: Deque[Point2] = deque()\n        foundGroups: List[Set[Point2]] = []\n        while remaining:\n            currentGroup:"
 },
 "378": {
  "name": "currentGroup",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "198",
  "column": "12",
  "slicing": "['            currentGroup: Set[Point2] = set()\\n', '                currentGroup.add(start)\\n', '                    currentGroup.add(point)\\n', '            if len(currentGroup) >= minimum_points_per_group:\\n', '                foundGroups.append(currentGroup)\\n']",
  "context": "oint2]] = []\n        while remaining:\n            currentGroup: Set[Point2] = set()\n            if not queue:\n                currentC"
 },
 "379": {
  "name": "base",
  "type": "position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "206",
  "column": "16",
  "slicing": "['                base: Point2 = queue.popleft()\\n', '                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "d(start)\n            while queue:\n                base: Point2 = queue.popleft()\n                for offset in nearby:\n            "
 },
 "380": {
  "name": "px",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "208",
  "column": "20",
  "slicing": "['                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "        for offset in nearby:\n                    px, py = base.x + offset.x, base.y + offset.y\n                    if px < 0 or py < 0 or px >= s"
 },
 "381": {
  "name": "py",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "208",
  "column": "24",
  "slicing": "['                    px, py = base.x + offset.x, base.y + offset.y\\n', '                    if px < 0 or py < 0 or px >= self.pathing_grid.width or py >= self.pathing_grid.height:\\n', '                    if picture[py][px] != NOT_COLORED_YET:\\n', '                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "    for offset in nearby:\n                    px, py = base.x + offset.x, base.y + offset.y\n                    if px < 0 or py < 0 or px >= s"
 },
 "382": {
  "name": "point",
  "type": "position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/game_info.py",
  "lineno": "213",
  "column": "20",
  "slicing": "['                    point: Point2 = Point2((px, py))\\n', '                    remaining.remove(point)\\n', '                    paint(point)\\n', '                    queue.append(point)\\n', '                    currentGroup.add(point)\\n']",
  "context": "                     continue\n                    point: Point2 = Point2((px, py))\n                    remaining.remove(point)\n      "
 },
 "383": {
  "name": "process",
  "type": "sc2process.SC2Process",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/controller.py",
  "lineno": "9",
  "column": "27",
  "slicing": "['    def __init__(self, ws, process):\\n']",
  "context": " Controller(Protocol):\n    def __init__(self, ws, process):\n        super().__init__(ws)\n        self.__proces"
 },
 "384": {
  "name": "game_data",
  "type": "game_data.GameData",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "15",
  "column": "35",
  "slicing": "['    def __init__(self, proto_data, game_data):\\n']",
  "context": "PassengerUnit:\n    def __init__(self, proto_data, game_data):\n        assert isinstance(game_data, GameData)\n   "
 },
 "385": {
  "name": "weapon",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "101",
  "column": "12",
  "slicing": "['        unit_type = self._proto.unit_type\\n', '        if unit_type not in self._game_data.unit_types:\\n', '            self._game_data.unit_types[unit_type] = UnitTypeId(unit_type)\\n', '        return self._game_data.unit_types[unit_type]\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            for weapon in self._weapons:\\n', '                if weapon.damage_bonus:\\n', '                    b = weapon.damage_bonus[0]\\n', '                    return b.bonus, b.attribute\\n']",
  "context": "f) -> bool:\n        if self._weapons:\n            weapon = next(\n                (weapon for weapon in self._weapon"
 },
 "386": {
  "name": "weapon",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "112",
  "column": "12",
  "slicing": "['        unit_type = self._proto.unit_type\\n', '        if unit_type not in self._game_data.unit_types:\\n', '            self._game_data.unit_types[unit_type] = UnitTypeId(unit_type)\\n', '        return self._game_data.unit_types[unit_type]\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            for weapon in self._weapons:\\n', '                if weapon.damage_bonus:\\n', '                    b = weapon.damage_bonus[0]\\n', '                    return b.bonus, b.attribute\\n']",
  "context": "pgrades \"\"\"\n        if self._weapons:\n            weapon = next(\n                (weapon for weapon in self._weapon"
 },
 "387": {
  "name": "weapon",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "124",
  "column": "12",
  "slicing": "['        unit_type = self._proto.unit_type\\n', '        if unit_type not in self._game_data.unit_types:\\n', '            self._game_data.unit_types[unit_type] = UnitTypeId(unit_type)\\n', '        return self._game_data.unit_types[unit_type]\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            for weapon in self._weapons:\\n', '                if weapon.damage_bonus:\\n', '                    b = weapon.damage_bonus[0]\\n', '                    return b.bonus, b.attribute\\n']",
  "context": "pgrades \"\"\"\n        if self._weapons:\n            weapon = next(\n                (weapon for weapon in self._weapon"
 },
 "388": {
  "name": "weapon",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "136",
  "column": "12",
  "slicing": "['        unit_type = self._proto.unit_type\\n', '        if unit_type not in self._game_data.unit_types:\\n', '            self._game_data.unit_types[unit_type] = UnitTypeId(unit_type)\\n', '        return self._game_data.unit_types[unit_type]\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            for weapon in self._weapons:\\n', '                if weapon.damage_bonus:\\n', '                    b = weapon.damage_bonus[0]\\n', '                    return b.bonus, b.attribute\\n']",
  "context": "pgrades \"\"\"\n        if self._weapons:\n            weapon = next(\n                (weapon for weapon in self._weapon"
 },
 "389": {
  "name": "weapon",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "147",
  "column": "12",
  "slicing": "['        unit_type = self._proto.unit_type\\n', '        if unit_type not in self._game_data.unit_types:\\n', '            self._game_data.unit_types[unit_type] = UnitTypeId(unit_type)\\n', '        return self._game_data.unit_types[unit_type]\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            for weapon in self._weapons:\\n', '                if weapon.damage_bonus:\\n', '                    b = weapon.damage_bonus[0]\\n', '                    return b.bonus, b.attribute\\n']",
  "context": "pgrades \"\"\"\n        if self._weapons:\n            weapon = next(\n                (weapon for weapon in self._weapon"
 },
 "390": {
  "name": "weapon",
  "type": "next",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "159",
  "column": "12",
  "slicing": "['        unit_type = self._proto.unit_type\\n', '        if unit_type not in self._game_data.unit_types:\\n', '            self._game_data.unit_types[unit_type] = UnitTypeId(unit_type)\\n', '        return self._game_data.unit_types[unit_type]\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            for weapon in self._weapons:\\n', '                if weapon.damage_bonus:\\n', '                    b = weapon.damage_bonus[0]\\n', '                    return b.bonus, b.attribute\\n']",
  "context": "pgrades \"\"\"\n        if self._weapons:\n            weapon = next(\n                (weapon for weapon in self._weapon"
 },
 "391": {
  "name": "b",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "176",
  "column": "20",
  "slicing": "['        unit_type = self._proto.unit_type\\n', '        if unit_type not in self._game_data.unit_types:\\n', '            self._game_data.unit_types[unit_type] = UnitTypeId(unit_type)\\n', '        return self._game_data.unit_types[unit_type]\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Ground.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            return weapon is not None\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return (weapon.damage * weapon.attacks) / weapon.speed\\n', '            weapon = next(\\n', '                (weapon for weapon in self._weapons if weapon.type in {TargetType.Air.value, TargetType.Any.value}),\\n', '            if weapon:\\n', '                return weapon.range\\n', '            for weapon in self._weapons:\\n', '                if weapon.damage_bonus:\\n', '                    b = weapon.damage_bonus[0]\\n', '                    return b.bonus, b.attribute\\n']",
  "context": "      if weapon.damage_bonus:\n                    b = weapon.damage_bonus[0]\n                    return b.bonus, b.attribute\n\n "
 },
 "392": {
  "name": "p",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "273",
  "column": "26",
  "slicing": "['    def distance_to(self, p: Union[\"Unit\", Point2, Point3], bot: \"BotAI\" = None) -> Union[int, float]:\\n']",
  "context": "proto(self._proto.pos)\n\n    def distance_to(self, p: Union[\"Unit\", Point2, Point3], bot: \"BotAI\" = None) -> Union[int, float]:\n        \"\"\" Using the 2d distance between self and"
 },
 "393": {
  "name": "bonus_distance",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "418",
  "column": "46",
  "slicing": "['    def target_in_range(self, target: \"Unit\", bonus_distance: Union[int, float] = 0) -> bool:\\n']",
  "context": "s}\n\n    def target_in_range(self, target: \"Unit\", bonus_distance: Union[int, float] = 0) -> bool:\n        \"\"\" Includes the target's radius when calc"
 },
 "394": {
  "name": "cls",
  "type": "UnitOrder",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/unit.py",
  "lineno": "628",
  "column": "19",
  "slicing": "['    def from_proto(cls, proto, game_data):\\n']",
  "context": "ss UnitOrder:\n    @classmethod\n    def from_proto(cls, proto, game_data):\n        return cls(\n            game_data.abilitie"
 },
 "395": {
  "name": "__all__",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/__init__.py",
  "lineno": "10",
  "column": "0",
  "slicing": "['def is_submodule(path):\\n', '        return (path / \"__init__.py\").exists()\\n', '__all__ = [p.stem for p in Path(__file__).parent.iterdir() if is_submodule(p)]\\n']",
  "context": "(path / \"__init__.py\").exists()\n    return False\n\n__all__ = [p.stem for p in Path(__file__).parent.iterdir() if is_submodule(p)]\n\nimport sys, logging\nlogging.basicConfig(stream=sy"
 },
 "396": {
  "name": "x",
  "type": "pos",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "30",
  "column": "8",
  "slicing": "['        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        data = self.data[start : start + self.bytes_per_pixel]\\n', '        return int.from_bytes(data, byteorder=\"little\", signed=False)\\n', '        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        self.data[start : start + self.bytes_per_pixel] = val\\n', '        nodes: Set[Point2] = set()\\n', '        queue: List[Point2] = [start_point]\\n', '        while queue:\\n', '            x, y = queue.pop()\\n', '            if not (0 <= x < self.width and 0 <= y < self.height):\\n', '            if Point2((x, y)) in nodes:\\n', '            if pred(self[x, y]):\\n', '                nodes.add(Point2((x, y)))\\n', '                for a in [-1, 0, 1]:\\n', '                    for b in [-1, 0, 1]:\\n', '                        if not (a == 0 and b == 0):\\n', '                            queue.append(Point2((x + a, y + b)))\\n', '        return nodes\\n', '        groups: Set[FrozenSet[Point2]] = set()\\n', '        for x in range(self.width):\\n', '            for y in range(self.height):\\n', '                if any((x, y) in g for g in groups):\\n', '                if pred(self[x, y]):\\n', '                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\\n', '        return groups\\n', '        for y in range(self.height):\\n', '            for x in range(self.width):\\n', '                print(\"#\" if self.is_set((x, y)) else \" \", end=(\" \" if wide else \"\"))\\n', '        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\\n', '        im.putdata(data)\\n']",
  "context": "xel // 8\n\n    def __getitem__(self, pos):\n        x, y = pos\n\n        assert 0 <= x < self.width, f\"x is {x}, s"
 },
 "397": {
  "name": "y",
  "type": "pos",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "30",
  "column": "11",
  "slicing": "['        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        data = self.data[start : start + self.bytes_per_pixel]\\n', '        return int.from_bytes(data, byteorder=\"little\", signed=False)\\n', '        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        self.data[start : start + self.bytes_per_pixel] = val\\n', '        nodes: Set[Point2] = set()\\n', '        queue: List[Point2] = [start_point]\\n', '        while queue:\\n', '            x, y = queue.pop()\\n', '            if not (0 <= x < self.width and 0 <= y < self.height):\\n', '            if Point2((x, y)) in nodes:\\n', '            if pred(self[x, y]):\\n', '                nodes.add(Point2((x, y)))\\n', '                for a in [-1, 0, 1]:\\n', '                    for b in [-1, 0, 1]:\\n', '                        if not (a == 0 and b == 0):\\n', '                            queue.append(Point2((x + a, y + b)))\\n', '        return nodes\\n', '        groups: Set[FrozenSet[Point2]] = set()\\n', '        for x in range(self.width):\\n', '            for y in range(self.height):\\n', '                if any((x, y) in g for g in groups):\\n', '                if pred(self[x, y]):\\n', '                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\\n', '        return groups\\n', '        for y in range(self.height):\\n', '            for x in range(self.width):\\n', '                print(\"#\" if self.is_set((x, y)) else \" \", end=(\" \" if wide else \"\"))\\n', '        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\\n', '        im.putdata(data)\\n']",
  "context": " // 8\n\n    def __getitem__(self, pos):\n        x, y = pos\n\n        assert 0 <= x < self.width, f\"x is {x}, s"
 },
 "398": {
  "name": "data",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "38",
  "column": "8",
  "slicing": "['        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        data = self.data[start : start + self.bytes_per_pixel]\\n', '        return int.from_bytes(data, byteorder=\"little\", signed=False)\\n', '        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        self.data[start : start + self.bytes_per_pixel] = val\\n', '        nodes: Set[Point2] = set()\\n', '        queue: List[Point2] = [start_point]\\n', '        while queue:\\n', '            x, y = queue.pop()\\n', '            if not (0 <= x < self.width and 0 <= y < self.height):\\n', '            if Point2((x, y)) in nodes:\\n', '            if pred(self[x, y]):\\n', '                nodes.add(Point2((x, y)))\\n', '                for a in [-1, 0, 1]:\\n', '                    for b in [-1, 0, 1]:\\n', '                        if not (a == 0 and b == 0):\\n', '                            queue.append(Point2((x + a, y + b)))\\n', '        return nodes\\n', '        groups: Set[FrozenSet[Point2]] = set()\\n', '        for x in range(self.width):\\n', '            for y in range(self.height):\\n', '                if any((x, y) in g for g in groups):\\n', '                if pred(self[x, y]):\\n', '                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\\n', '        return groups\\n', '        for y in range(self.height):\\n', '            for x in range(self.width):\\n', '                print(\"#\" if self.is_set((x, y)) else \" \", end=(\" \" if wide else \"\"))\\n', '        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\\n', '        im.putdata(data)\\n']",
  "context": "     start = index * self.bytes_per_pixel\n        data = self.data[start : start + self.bytes_per_pixel]\n        return int.from_bytes(data, byteorder=\"lit"
 },
 "399": {
  "name": "x",
  "type": "pos",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "43",
  "column": "8",
  "slicing": "['        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        data = self.data[start : start + self.bytes_per_pixel]\\n', '        return int.from_bytes(data, byteorder=\"little\", signed=False)\\n', '        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        self.data[start : start + self.bytes_per_pixel] = val\\n', '        nodes: Set[Point2] = set()\\n', '        queue: List[Point2] = [start_point]\\n', '        while queue:\\n', '            x, y = queue.pop()\\n', '            if not (0 <= x < self.width and 0 <= y < self.height):\\n', '            if Point2((x, y)) in nodes:\\n', '            if pred(self[x, y]):\\n', '                nodes.add(Point2((x, y)))\\n', '                for a in [-1, 0, 1]:\\n', '                    for b in [-1, 0, 1]:\\n', '                        if not (a == 0 and b == 0):\\n', '                            queue.append(Point2((x + a, y + b)))\\n', '        return nodes\\n', '        groups: Set[FrozenSet[Point2]] = set()\\n', '        for x in range(self.width):\\n', '            for y in range(self.height):\\n', '                if any((x, y) in g for g in groups):\\n', '                if pred(self[x, y]):\\n', '                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\\n', '        return groups\\n', '        for y in range(self.height):\\n', '            for x in range(self.width):\\n', '                print(\"#\" if self.is_set((x, y)) else \" \", end=(\" \" if wide else \"\"))\\n', '        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\\n', '        im.putdata(data)\\n']",
  "context": "athing_grid[Point2((20, 20))] = [255] \"\"\"\n        x, y = pos\n\n        assert 0 <= x < self.width, f\"x is {x}, s"
 },
 "400": {
  "name": "y",
  "type": "pos",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "43",
  "column": "11",
  "slicing": "['        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        data = self.data[start : start + self.bytes_per_pixel]\\n', '        return int.from_bytes(data, byteorder=\"little\", signed=False)\\n', '        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        self.data[start : start + self.bytes_per_pixel] = val\\n', '        nodes: Set[Point2] = set()\\n', '        queue: List[Point2] = [start_point]\\n', '        while queue:\\n', '            x, y = queue.pop()\\n', '            if not (0 <= x < self.width and 0 <= y < self.height):\\n', '            if Point2((x, y)) in nodes:\\n', '            if pred(self[x, y]):\\n', '                nodes.add(Point2((x, y)))\\n', '                for a in [-1, 0, 1]:\\n', '                    for b in [-1, 0, 1]:\\n', '                        if not (a == 0 and b == 0):\\n', '                            queue.append(Point2((x + a, y + b)))\\n', '        return nodes\\n', '        groups: Set[FrozenSet[Point2]] = set()\\n', '        for x in range(self.width):\\n', '            for y in range(self.height):\\n', '                if any((x, y) in g for g in groups):\\n', '                if pred(self[x, y]):\\n', '                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\\n', '        return groups\\n', '        for y in range(self.height):\\n', '            for x in range(self.width):\\n', '                print(\"#\" if self.is_set((x, y)) else \" \", end=(\" \" if wide else \"\"))\\n', '        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\\n', '        im.putdata(data)\\n']",
  "context": "ing_grid[Point2((20, 20))] = [255] \"\"\"\n        x, y = pos\n\n        assert 0 <= x < self.width, f\"x is {x}, s"
 },
 "401": {
  "name": "start_point",
  "type": "position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "61",
  "column": "25",
  "slicing": "['    def flood_fill(self, start_point: Point2, pred: Callable[[int], bool]) -> Set[Point2]:\\n']",
  "context": "ise NotImplementedError\n\n    def flood_fill(self, start_point: Point2, pred: Callable[[int], bool]) -> Set[Point2]:\n        nodes: Set[Point2] = set()\n        queue: "
 },
 "402": {
  "name": "pred",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "61",
  "column": "46",
  "slicing": "['    def flood_fill(self, start_point: Point2, pred: Callable[[int], bool]) -> Set[Point2]:\\n']",
  "context": "or\n\n    def flood_fill(self, start_point: Point2, pred: Callable[[int], bool]) -> Set[Point2]:\n        nodes: Set[Point2] = set()\n        queue: "
 },
 "403": {
  "name": "nodes",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "62",
  "column": "8",
  "slicing": "['        nodes: Set[Point2] = set()\\n', '            if Point2((x, y)) in nodes:\\n', '                nodes.add(Point2((x, y)))\\n', '        return nodes\\n']",
  "context": "d: Callable[[int], bool]) -> Set[Point2]:\n        nodes: Set[Point2] = set()\n        queue: List[Point2] = [start_point]\n\n     "
 },
 "404": {
  "name": "queue",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "63",
  "column": "8",
  "slicing": "['        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        data = self.data[start : start + self.bytes_per_pixel]\\n', '        return int.from_bytes(data, byteorder=\"little\", signed=False)\\n', '        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        self.data[start : start + self.bytes_per_pixel] = val\\n', '        nodes: Set[Point2] = set()\\n', '        queue: List[Point2] = [start_point]\\n', '        while queue:\\n', '            x, y = queue.pop()\\n', '            if not (0 <= x < self.width and 0 <= y < self.height):\\n', '            if Point2((x, y)) in nodes:\\n', '            if pred(self[x, y]):\\n', '                nodes.add(Point2((x, y)))\\n', '                for a in [-1, 0, 1]:\\n', '                    for b in [-1, 0, 1]:\\n', '                        if not (a == 0 and b == 0):\\n', '                            queue.append(Point2((x + a, y + b)))\\n', '        return nodes\\n', '        groups: Set[FrozenSet[Point2]] = set()\\n', '        for x in range(self.width):\\n', '            for y in range(self.height):\\n', '                if any((x, y) in g for g in groups):\\n', '                if pred(self[x, y]):\\n', '                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\\n', '        return groups\\n', '        for y in range(self.height):\\n', '            for x in range(self.width):\\n', '                print(\"#\" if self.is_set((x, y)) else \" \", end=(\" \" if wide else \"\"))\\n', '        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\\n', '        im.putdata(data)\\n']",
  "context": "int2]:\n        nodes: Set[Point2] = set()\n        queue: List[Point2] = [start_point]\n\n        while queue:\n            x, y = queue.pop"
 },
 "405": {
  "name": "pred",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "83",
  "column": "29",
  "slicing": "['    def flood_fill_all(self, pred: Callable[[int], bool]) -> Set[FrozenSet[Point2]]:\\n']",
  "context": "       return nodes\n\n    def flood_fill_all(self, pred: Callable[[int], bool]) -> Set[FrozenSet[Point2]]:\n        groups: Set[FrozenSet[Point2]] = set()\n\n  "
 },
 "406": {
  "name": "groups",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "84",
  "column": "8",
  "slicing": "['        groups: Set[FrozenSet[Point2]] = set()\\n', '                if any((x, y) in g for g in groups):\\n', '                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\\n', '        return groups\\n']",
  "context": "[[int], bool]) -> Set[FrozenSet[Point2]]:\n        groups: Set[FrozenSet[Point2]] = set()\n\n        for x in range(self.width):\n            f"
 },
 "407": {
  "name": "data",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/pixel_map.py",
  "lineno": "103",
  "column": "8",
  "slicing": "['        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        data = self.data[start : start + self.bytes_per_pixel]\\n', '        return int.from_bytes(data, byteorder=\"little\", signed=False)\\n', '        x, y = pos\\n', '        assert 0 <= x < self.width, f\"x is {x}, self.width is {self.width}\"\\n', '        assert 0 <= y < self.height, f\"y is {y}, self.height is {self.height}\"\\n', '        index = -self.width * y + x\\n', '        start = index * self.bytes_per_pixel\\n', '        self.data[start : start + self.bytes_per_pixel] = val\\n', '        nodes: Set[Point2] = set()\\n', '        queue: List[Point2] = [start_point]\\n', '        while queue:\\n', '            x, y = queue.pop()\\n', '            if not (0 <= x < self.width and 0 <= y < self.height):\\n', '            if Point2((x, y)) in nodes:\\n', '            if pred(self[x, y]):\\n', '                nodes.add(Point2((x, y)))\\n', '                for a in [-1, 0, 1]:\\n', '                    for b in [-1, 0, 1]:\\n', '                        if not (a == 0 and b == 0):\\n', '                            queue.append(Point2((x + a, y + b)))\\n', '        return nodes\\n', '        groups: Set[FrozenSet[Point2]] = set()\\n', '        for x in range(self.width):\\n', '            for y in range(self.height):\\n', '                if any((x, y) in g for g in groups):\\n', '                if pred(self[x, y]):\\n', '                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\\n', '        return groups\\n', '        for y in range(self.height):\\n', '            for x in range(self.width):\\n', '                print(\"#\" if self.is_set((x, y)) else \" \", end=(\" \" if wide else \"\"))\\n', '        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\\n', '        im.putdata(data)\\n']",
  "context": "(\"\")\n\n    def save_image(self, filename):\n        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\n        from PIL import Image\n\n        im = Image."
 },
 "408": {
  "name": "mineral_ids",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/constants.py",
  "lineno": "7",
  "column": "0",
  "slicing": "['mineral_ids = {\\n']",
  "context": "it_typeid import *\nfrom .ids.upgrade_id import *\n\nmineral_ids = {\n    RICHMINERALFIELD.value,\n    RICHMINERALFIELD75"
 },
 "409": {
  "name": "geyser_ids",
  "type": "set",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/constants.py",
  "lineno": "21",
  "column": "0",
  "slicing": "['geyser_ids = {\\n']",
  "context": ".value,\n    BATTLESTATIONMINERALFIELD750.value,\n}\ngeyser_ids = {\n    VESPENEGEYSER.value,\n    SPACEPLATFORMGEYSER.v"
 },
 "410": {
  "name": "cls",
  "type": "PowerSource",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/power_source.py",
  "lineno": "5",
  "column": "19",
  "slicing": "['    def from_proto(cls, proto):\\n']",
  "context": " PowerSource:\n    @classmethod\n    def from_proto(cls, proto):\n        return cls(\n            Point2.from_proto("
 },
 "411": {
  "name": "position",
  "type": "position.Point2",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/power_source.py",
  "lineno": "12",
  "column": "23",
  "slicing": "['    def __init__(self, position, radius, unit_tag):\\n']",
  "context": "      proto.tag\n        )\n\n    def __init__(self, position, radius, unit_tag):\n        assert isinstance(position, Point2)\n      "
 },
 "412": {
  "name": "cls",
  "type": "power_source.PsionicMatrix",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/power_source.py",
  "lineno": "27",
  "column": "19",
  "slicing": "['    def from_proto(cls, proto):\\n']",
  "context": "sionicMatrix:\n    @classmethod\n    def from_proto(cls, proto):\n        return cls([PowerSource.from_proto(p) for "
 },
 "413": {
  "name": "sources",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/power_source.py",
  "lineno": "30",
  "column": "23",
  "slicing": "['    def __init__(self, sources):\\n']",
  "context": "proto(p) for p in proto])\n\n    def __init__(self, sources):\n        self.sources = sources\n\n    def covers(sel"
 },
 "414": {
  "name": "_to_kill",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/sc2process.py",
  "lineno": "21",
  "column": "4",
  "slicing": "['    _to_kill: List[Any] = []\\n']",
  "context": "troller import Controller\n\nclass kill_switch:\n    _to_kill: List[Any] = []\n\n    @classmethod\n    def add(cls, value):\n       "
 },
 "415": {
  "name": "cls",
  "type": "kill_switch",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/sc2process.py",
  "lineno": "24",
  "column": "12",
  "slicing": "['    def add(cls, value):\\n']",
  "context": "ill: List[Any] = []\n\n    @classmethod\n    def add(cls, value):\n        logger.debug(\"kill_switch: Add switch\")\n  "
 },
 "416": {
  "name": "value",
  "type": "sc2process.SC2Process",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/sc2process.py",
  "lineno": "24",
  "column": "17",
  "slicing": "['    def add(cls, value):\\n']",
  "context": "List[Any] = []\n\n    @classmethod\n    def add(cls, value):\n        logger.debug(\"kill_switch: Add switch\")\n  "
 },
 "417": {
  "name": "cls",
  "type": "kill_switch",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/sc2process.py",
  "lineno": "29",
  "column": "17",
  "slicing": "['    def kill_all(cls):\\n']",
  "context": ".append(value)\n\n    @classmethod\n    def kill_all(cls):\n        logger.info(\"kill_switch: Process cleanup\""
 },
 "418": {
  "name": "host",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/sc2process.py",
  "lineno": "35",
  "column": "23",
  "slicing": "['    def __init__(self, host: str = \"127.0.0.1\", port: Optional[int] = None, fullscreen: bool = False,\\n']",
  "context": "clean()\n\nclass SC2Process:\n    def __init__(self, host: str = \"127.0.0.1\", port: Optional[int] = None, fullscreen: bool = False,\n                 render: bool = False) -> None:\n  "
 },
 "419": {
  "name": "port",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/sc2process.py",
  "lineno": "35",
  "column": "48",
  "slicing": "['    def __init__(self, host: str = \"127.0.0.1\", port: Optional[int] = None, fullscreen: bool = False,\\n']",
  "context": ":\n    def __init__(self, host: str = \"127.0.0.1\", port: Optional[int] = None, fullscreen: bool = False,\n                 render: bool = False) -> None:\n  "
 },
 "420": {
  "name": "fullscreen",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/sc2process.py",
  "lineno": "35",
  "column": "76",
  "slicing": "['    def __init__(self, host: str = \"127.0.0.1\", port: Optional[int] = None, fullscreen: bool = False,\\n']",
  "context": "t: str = \"127.0.0.1\", port: Optional[int] = None, fullscreen: bool = False,\n                 render: bool = False) -> None:\n  "
 },
 "421": {
  "name": "render",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/sc2process.py",
  "lineno": "36",
  "column": "17",
  "slicing": "['                 render: bool = False) -> None:\\n']",
  "context": " None, fullscreen: bool = False,\n                 render: bool = False) -> None:\n        assert isinstance(host, str)\n        asser"
 },
 "422": {
  "name": "args",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/sc2process.py",
  "lineno": "79",
  "column": "8",
  "slicing": "['        args = [\\n', '            args.extend([\"-eglpath\", \"libEGL.so\"])\\n', '            args.append(\"-verbose\")\\n', '        return subprocess.Popen(args,\\n']",
  "context": "lf._port}/sc2api\"\n\n    def _launch(self):\n        args = [\n            str(Paths.EXECUTABLE),\n            \"-l"
 },
 "423": {
  "name": "BASEDIR",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "8",
  "column": "0",
  "slicing": "['logger = logging.getLogger(__name__)\\n', 'BASEDIR = {\\n', 'USERPATH = {\\n', 'BINPATH = {\\n', 'PF = os.environ.get(\"SC2PF\", platform.system())\\n', '    latest = max((int(p.name[4:]), p) for p in versions_dir.iterdir() if p.is_dir() and p.name.startswith(\"Base\"))\\n', '    version, path = latest\\n', '    if version < 55958:\\n', '        logger.critical(f\"Your SC2 binary is too old. Upgrade to 3.16.1 or newer.\")\\n', '    return path / BINPATH[PF]\\n', '        if PF not in BASEDIR:\\n', '            logger.critical(f\"Unsupported platform \\'{PF}\\'\")\\n', '            base = os.environ.get(\"SC2PATH\")\\n', '            if base is None and USERPATH[PF] is not None:\\n', '                einfo = str(Path.home().expanduser()) + USERPATH[PF]\\n', '                if os.path.isfile(einfo):\\n', '                    with open(einfo) as f:\\n', '                        content = f.read()\\n', '                    if content:\\n', '                        base = re.search(r\" = (.*)Versions\", content).group(1)\\n', '                        if not os.path.exists(base):\\n', '                            base = None\\n', '            if base is None:\\n', '                base = BASEDIR[PF]\\n', '            self.BASE = Path(base).expanduser()\\n', '            self.CWD = self.BASE / CWD[PF] if CWD[PF] else None\\n', '            logger.critical(f\"SC2 installation not found: File \\'{e.filename}\\' does not exist.\")\\n']",
  "context": "ort logging\nlogger = logging.getLogger(__name__)\n\nBASEDIR = {\n    \"Windows\": \"C:/Program Files (x86)/StarCraft I"
 },
 "424": {
  "name": "USERPATH",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "15",
  "column": "0",
  "slicing": "['logger = logging.getLogger(__name__)\\n', 'BASEDIR = {\\n', 'USERPATH = {\\n', 'BINPATH = {\\n', 'PF = os.environ.get(\"SC2PF\", platform.system())\\n', '    latest = max((int(p.name[4:]), p) for p in versions_dir.iterdir() if p.is_dir() and p.name.startswith(\"Base\"))\\n', '    version, path = latest\\n', '    if version < 55958:\\n', '        logger.critical(f\"Your SC2 binary is too old. Upgrade to 3.16.1 or newer.\")\\n', '    return path / BINPATH[PF]\\n', '        if PF not in BASEDIR:\\n', '            logger.critical(f\"Unsupported platform \\'{PF}\\'\")\\n', '            base = os.environ.get(\"SC2PATH\")\\n', '            if base is None and USERPATH[PF] is not None:\\n', '                einfo = str(Path.home().expanduser()) + USERPATH[PF]\\n', '                if os.path.isfile(einfo):\\n', '                    with open(einfo) as f:\\n', '                        content = f.read()\\n', '                    if content:\\n', '                        base = re.search(r\" = (.*)Versions\", content).group(1)\\n', '                        if not os.path.exists(base):\\n', '                            base = None\\n', '            if base is None:\\n', '                base = BASEDIR[PF]\\n', '            self.BASE = Path(base).expanduser()\\n', '            self.CWD = self.BASE / CWD[PF] if CWD[PF] else None\\n', '            logger.critical(f\"SC2 installation not found: File \\'{e.filename}\\' does not exist.\")\\n']",
  "context": "ine/drive_c/Program Files (x86)/StarCraft II\",\n}\n\nUSERPATH = {\n    \"Windows\": \"\\\\Documents\\\\StarCraft II\\\\Execute"
 },
 "425": {
  "name": "BINPATH",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "22",
  "column": "0",
  "slicing": "['BINPATH = {\\n', '    return path / BINPATH[PF]\\n']",
  "context": "xt\",\n    \"Linux\": None,\n    \"WineLinux\": None,\n}\n\nBINPATH = {\n    \"Windows\": \"SC2_x64.exe\",\n    \"Darwin\": \"SC2.a"
 },
 "426": {
  "name": "CWD",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "29",
  "column": "0",
  "slicing": "['CWD = {\\n', '            self.CWD = self.BASE / CWD[PF] if CWD[PF] else None\\n']",
  "context": "x\": \"SC2_x64\",\n    \"WineLinux\": \"SC2_x64.exe\",\n}\n\nCWD = {\n    \"Windows\": \"Support64\",\n    \"Darwin\": None,\n  "
 },
 "427": {
  "name": "latest",
  "type": "max",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "43",
  "column": "4",
  "slicing": "['    latest = max((int(p.name[4:]), p) for p in versions_dir.iterdir() if p.is_dir() and p.name.startswith(\"Base\"))\\n', '    version, path = latest\\n', '    if version < 55958:\\n', '    return path / BINPATH[PF]\\n']",
  "context": "rn None\n\ndef latest_executeble(versions_dir):\n    latest = max((int(p.name[4:]), p) for p in versions_dir.iterdir() if p.is_dir() and p.name.startswith(\"Base\"))\n    version, path = latest\n    if version < 55958:"
 },
 "428": {
  "name": "version",
  "type": "latest",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "44",
  "column": "4",
  "slicing": "['    version, path = latest\\n', '    if version < 55958:\\n']",
  "context": " if p.is_dir() and p.name.startswith(\"Base\"))\n    version, path = latest\n    if version < 55958:\n        logger.critical(f\""
 },
 "429": {
  "name": "path",
  "type": "latest",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "44",
  "column": "13",
  "slicing": "['    version, path = latest\\n', '    return path / BINPATH[PF]\\n']",
  "context": "dir() and p.name.startswith(\"Base\"))\n    version, path = latest\n    if version < 55958:\n        logger.critical(f\""
 },
 "430": {
  "name": "content",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "64",
  "column": "24",
  "slicing": "['logger = logging.getLogger(__name__)\\n', 'BASEDIR = {\\n', 'USERPATH = {\\n', 'BINPATH = {\\n', 'PF = os.environ.get(\"SC2PF\", platform.system())\\n', '    latest = max((int(p.name[4:]), p) for p in versions_dir.iterdir() if p.is_dir() and p.name.startswith(\"Base\"))\\n', '    version, path = latest\\n', '    if version < 55958:\\n', '        logger.critical(f\"Your SC2 binary is too old. Upgrade to 3.16.1 or newer.\")\\n', '    return path / BINPATH[PF]\\n', '        if PF not in BASEDIR:\\n', '            logger.critical(f\"Unsupported platform \\'{PF}\\'\")\\n', '            base = os.environ.get(\"SC2PATH\")\\n', '            if base is None and USERPATH[PF] is not None:\\n', '                einfo = str(Path.home().expanduser()) + USERPATH[PF]\\n', '                if os.path.isfile(einfo):\\n', '                    with open(einfo) as f:\\n', '                        content = f.read()\\n', '                    if content:\\n', '                        base = re.search(r\" = (.*)Versions\", content).group(1)\\n', '                        if not os.path.exists(base):\\n', '                            base = None\\n', '            if base is None:\\n', '                base = BASEDIR[PF]\\n', '            self.BASE = Path(base).expanduser()\\n', '            self.CWD = self.BASE / CWD[PF] if CWD[PF] else None\\n', '            logger.critical(f\"SC2 installation not found: File \\'{e.filename}\\' does not exist.\")\\n']",
  "context": "   with open(einfo) as f:\n                        content = f.read()\n                    if content:\n                  "
 },
 "431": {
  "name": "base",
  "type": "None",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "68",
  "column": "28",
  "slicing": "['                            base = None\\n', '            if base is None:\\n', '            self.BASE = Path(base).expanduser()\\n']",
  "context": "os.path.exists(base):\n                            base = None\n            if base is None:\n                base "
 },
 "432": {
  "name": "base",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/paths.py",
  "lineno": "70",
  "column": "16",
  "slicing": "['logger = logging.getLogger(__name__)\\n', 'BASEDIR = {\\n', 'USERPATH = {\\n', 'BINPATH = {\\n', 'PF = os.environ.get(\"SC2PF\", platform.system())\\n', '    latest = max((int(p.name[4:]), p) for p in versions_dir.iterdir() if p.is_dir() and p.name.startswith(\"Base\"))\\n', '    version, path = latest\\n', '    if version < 55958:\\n', '        logger.critical(f\"Your SC2 binary is too old. Upgrade to 3.16.1 or newer.\")\\n', '    return path / BINPATH[PF]\\n', '        if PF not in BASEDIR:\\n', '            logger.critical(f\"Unsupported platform \\'{PF}\\'\")\\n', '            base = os.environ.get(\"SC2PATH\")\\n', '            if base is None and USERPATH[PF] is not None:\\n', '                einfo = str(Path.home().expanduser()) + USERPATH[PF]\\n', '                if os.path.isfile(einfo):\\n', '                    with open(einfo) as f:\\n', '                        content = f.read()\\n', '                    if content:\\n', '                        base = re.search(r\" = (.*)Versions\", content).group(1)\\n', '                        if not os.path.exists(base):\\n', '                            base = None\\n', '            if base is None:\\n', '                base = BASEDIR[PF]\\n', '            self.BASE = Path(base).expanduser()\\n', '            self.CWD = self.BASE / CWD[PF] if CWD[PF] else None\\n', '            logger.critical(f\"SC2 installation not found: File \\'{e.filename}\\' does not exist.\")\\n']",
  "context": "None\n            if base is None:\n                base = BASEDIR[PF]\n            self.BASE = Path(base).expanduser()\n  "
 },
 "433": {
  "name": "cls",
  "type": "portconfig.Portconfig",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/portconfig.py",
  "lineno": "22",
  "column": "18",
  "slicing": "['    def from_json(cls, json_data):\\n']",
  "context": "rs\n        })\n\n    @classmethod\n    def from_json(cls, json_data):\n        self = cls.__new__(cls)\n        data = jso"
 },
 "434": {
  "name": "ai",
  "type": "zerg.zerg_rush.ZergRushBot",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/player.py",
  "lineno": "39",
  "column": "29",
  "slicing": "['    def __init__(self, race, ai, name=None):\\n']",
  "context": "Bot(AbstractPlayer):\n    def __init__(self, race, ai, name=None):\n        \"\"\"\n        AI can be None if this player "
 },
 "435": {
  "name": "cls",
  "type": "player.Player",
  "class": "customized",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/player.py",
  "lineno": "70",
  "column": "19",
  "slicing": "['    def from_proto(cls, proto):\\n']",
  "context": "tractPlayer):\n    @classmethod\n    def from_proto(cls, proto):\n        if PlayerType(proto.type) == PlayerType.Ob"
 },
 "436": {
  "name": "window_size",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "52",
  "column": "12",
  "slicing": "[\"            window_size = rgb_render_config['window_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n']",
  "context": "d 'minimap_size' in rgb_render_config\n            window_size = rgb_render_config['window_size']\n            minimap_size = rgb_render_config['mini"
 },
 "437": {
  "name": "minimap_size",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "53",
  "column": "12",
  "slicing": "[\"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n']",
  "context": "ze = rgb_render_config['window_size']\n            minimap_size = rgb_render_config['minimap_size']\n            self._renderer = Renderer(self, window"
 },
 "438": {
  "name": "map_width",
  "type": "window_size",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "55",
  "column": "12",
  "slicing": "['            map_width, map_height = window_size\\n', '            ifopts.render.resolution.x = map_width\\n']",
  "context": "erer(self, window_size, minimap_size)\n            map_width, map_height = window_size\n            minimap_width, minimap_height = minima"
 },
 "439": {
  "name": "map_height",
  "type": "window_size",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "55",
  "column": "23",
  "slicing": "['            map_width, map_height = window_size\\n', '            ifopts.render.resolution.y = map_height\\n']",
  "context": "window_size, minimap_size)\n            map_width, map_height = window_size\n            minimap_width, minimap_height = minima"
 },
 "440": {
  "name": "minimap_width",
  "type": "minimap_size",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "56",
  "column": "12",
  "slicing": "['            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n']",
  "context": "  map_width, map_height = window_size\n            minimap_width, minimap_height = minimap_size\n\n            ifopts.render.resolution.x = map_widt"
 },
 "441": {
  "name": "minimap_height",
  "type": "minimap_size",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "56",
  "column": "27",
  "slicing": "['            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n']",
  "context": "p_height = window_size\n            minimap_width, minimap_height = minimap_size\n\n            ifopts.render.resolution.x = map_widt"
 },
 "442": {
  "name": "is_resign",
  "type": "bool",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "sc2/sc2/client.py",
  "lineno": "92",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            if max(r, g, b) <= 1:\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n']",
  "context": "ent.leave()' to surrender midst game. \"\"\"\n        is_resign = self._game_result is None\n\n        if is_resign:\n            # For all clien"
 },
 "443": {
  "name": "player_id_to_result",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "125",
  "column": "12",
  "slicing": "['            player_id_to_result = {}\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n']",
  "context": "ert result.observation.player_result\n\n            player_id_to_result = {}\n            for pr in result.observation.player_re"
 },
 "444": {
  "name": "actions",
  "type": "action.combine_actions",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "157",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            if max(r, g, b) <= 1:\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n']",
  "context": "            return None\n        else:\n            actions = combine_actions(actions)\n\n            res = await self._execute(action=sc_p"
 },
 "445": {
  "name": "res",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "161",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            if max(r, g, b) <= 1:\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n']",
  "context": "on(action_raw=a) for a in actions]))\n\n            res = [ActionResult(r) for r in res.action.result]\n            if return_successes:\n                r"
 },
 "446": {
  "name": "distance",
  "type": "float",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "192",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            if max(r, g, b) <= 1:\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n']",
  "context": "        ]\n                )\n            )\n        distance = float(result.query.pathing[0].distance)\n        if distance <= 0.0:\n            return Non"
 },
 "447": {
  "name": "results",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "229",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '            results = await self._execute(\\n', '                        for p1, p2 in zipped_list\\n', '            results = await self._execute(\\n', '                        query_pb.RequestQueryPathing(unit_tag=p1.tag, end_pos=common_pb.Point2D(x=p2.x, y=p2.y))\\n', '                        for p1, p2 in zipped_list\\n', '        results = [float(d.distance) for d in results.query.pathing]\\n', '        return results\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '                line=debug_pb.Line(p0=self.to_debug_point(p0), p1=self.to_debug_point(p1)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            if max(r, g, b) <= 1:\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n']",
  "context": "        ]\n                )\n            )\n        results = [float(d.distance) for d in results.query.pathing]\n        return results\n\n    async def query_buildi"
 },
 "448": {
  "name": "units",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "256",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '            results = await self._execute(\\n', '                        for p1, p2 in zipped_list\\n', '            results = await self._execute(\\n', '                        query_pb.RequestQueryPathing(unit_tag=p1.tag, end_pos=common_pb.Point2D(x=p2.x, y=p2.y))\\n', '                        for p1, p2 in zipped_list\\n', '        results = [float(d.distance) for d in results.query.pathing]\\n', '        return results\\n', '        result = await self._execute(\\n', '                    for position in positions\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            units = [units]\\n', '            input_was_a_list = False\\n', '            input_was_a_list = True\\n', '        assert units\\n', '        result = await self._execute(\\n', '                abilities=[query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units],\\n', '        if not input_was_a_list:\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '        ch = ChatChannel.Team if team_only else ChatChannel.Broadcast\\n', '                actions=[sc_pb.Action(action_chat=sc_pb.ActionChat(channel=ch.value, message=message))]\\n', '                            pos=common_pb.Point2D(x=position.x, y=position.y),\\n', '                    for unit_type, amount_of_units, position, owner_id in unit_spawn_commands\\n', '            unit_tags = unit_tags.tags\\n', '        assert unit_tags\\n', '            debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(kill_unit=debug_pb.DebugKillUnit(tag=unit_tags))])\\n', '        assert isinstance(position, (Unit, Point2, Point3))\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '                                center_world_space=common_pb.Point(x=position.x, y=position.y)\\n', '        assert isinstance(position, (Point2, Point3))\\n', '                    center_minimap=common_pb.PointI(x=position.x, y=position.y)\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '                line=debug_pb.Line(p0=self.to_debug_point(p0), p1=self.to_debug_point(p1)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            if max(r, g, b) <= 1:\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n']",
  "context": "       assert isinstance(units, Unit)\n            units = [units]\n            input_was_a_list = False\n        else:"
 },
 "449": {
  "name": "input_was_a_list",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "257",
  "column": "12",
  "slicing": "['            input_was_a_list = False\\n', '        if not input_was_a_list:\\n']",
  "context": "ts, Unit)\n            units = [units]\n            input_was_a_list = False\n        else:\n            input_was_a_list = True\n"
 },
 "450": {
  "name": "input_was_a_list",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "259",
  "column": "12",
  "slicing": "['            input_was_a_list = True\\n', '        if not input_was_a_list:\\n']",
  "context": "nput_was_a_list = False\n        else:\n            input_was_a_list = True\n        assert units\n        result = await self._"
 },
 "451": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "382",
  "column": "32",
  "slicing": "['    def debug_text_simple(self, text: str):\\n']",
  "context": "sitions], color)\n\n    def debug_text_simple(self, text: str):\n        \"\"\" Draws a text in the top left corner of"
 },
 "452": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "386",
  "column": "32",
  "slicing": "['    def debug_text_screen(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\\n']",
  "context": "g_message(text))\n\n    def debug_text_screen(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\n        \"\"\" Draws a text on the screen with coordi"
 },
 "453": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "386",
  "column": "43",
  "slicing": "['    def debug_text_screen(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\\n']",
  "context": "ext))\n\n    def debug_text_screen(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\n        \"\"\" Draws a text on the screen with coordi"
 },
 "454": {
  "name": "size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "386",
  "column": "96",
  "slicing": "['    def debug_text_screen(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\\n']",
  "context": ": Union[Point2, Point3, tuple, list], color=None, size: int = 8):\n        \"\"\" Draws a text on the screen with coordi"
 },
 "455": {
  "name": "pos",
  "type": "position.Point2",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "391",
  "column": "8",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '            results = await self._execute(\\n', '                        for p1, p2 in zipped_list\\n', '            results = await self._execute(\\n', '                        query_pb.RequestQueryPathing(unit_tag=p1.tag, end_pos=common_pb.Point2D(x=p2.x, y=p2.y))\\n', '                        for p1, p2 in zipped_list\\n', '        results = [float(d.distance) for d in results.query.pathing]\\n', '        return results\\n', '        result = await self._execute(\\n', '                    for position in positions\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            units = [units]\\n', '            input_was_a_list = False\\n', '            input_was_a_list = True\\n', '        assert units\\n', '        result = await self._execute(\\n', '                abilities=[query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units],\\n', '        if not input_was_a_list:\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '        ch = ChatChannel.Team if team_only else ChatChannel.Broadcast\\n', '                actions=[sc_pb.Action(action_chat=sc_pb.ActionChat(channel=ch.value, message=message))]\\n', '                            pos=common_pb.Point2D(x=position.x, y=position.y),\\n', '                    for unit_type, amount_of_units, position, owner_id in unit_spawn_commands\\n', '            unit_tags = unit_tags.tags\\n', '        assert unit_tags\\n', '            debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(kill_unit=debug_pb.DebugKillUnit(tag=unit_tags))])\\n', '        assert isinstance(position, (Unit, Point2, Point3))\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '                                center_world_space=common_pb.Point(x=position.x, y=position.y)\\n', '        assert isinstance(position, (Point2, Point3))\\n', '        action = sc_pb.Action(\\n', '                    center_minimap=common_pb.PointI(x=position.x, y=position.y)\\n', '        await self._execute(action=sc_pb.RequestAction(actions=[action]))\\n', '                texts = [texts] * len(positions)\\n', '            assert len(texts) == len(positions)\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '                                    for t, p in zip(texts, positions)\\n', '            await self.debug_text([texts], [positions], color)\\n', '        pos = Point2((pos[0], pos[1]))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_screen(text, pos, color, size)\\n', '        if isinstance(pos, Point2) and not isinstance(pos, Point3):  # a Point3 is also a Point2\\n', '            pos = Point3((pos.x, pos.y, 0))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_world(text, pos, color, size)\\n', '                line=debug_pb.Line(p0=self.to_debug_point(p0), p1=self.to_debug_point(p1)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            r = getattr(color, \"r\", getattr(color, \"x\", 255))\\n', '            g = getattr(color, \"g\", getattr(color, \"y\", 255))\\n', '            b = getattr(color, \"b\", getattr(color, \"z\", 255))\\n', '            if max(r, g, b) <= 1:\\n', '                r *= 255\\n', '                g *= 255\\n', '                b *= 255\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n', '            point = point.position3d\\n', '        return common_pb.Point(x=point.x, y=point.y, z=getattr(point, \"z\", 0))\\n', '        color = self.to_debug_color(color)\\n', '        pt3d = self.to_debug_point(pos) if isinstance(pos, Point3) else None\\n', '        virtual_pos = self.to_debug_point(pos) if not isinstance(pos, Point3) else None\\n', '        return debug_pb.DebugText(color=color, text=text, virtual_pos=virtual_pos, world_pos=pt3d, size=size)\\n']",
  "context": "s[0] <= 1\n        assert 0 <= pos[1] <= 1\n        pos = Point2((pos[0], pos[1]))\n        self._debug_texts.append(self.to_debug_mes"
 },
 "456": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "394",
  "column": "28",
  "slicing": "['    def debug_text_2d(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\\n']",
  "context": ", color, pos, size))\n\n    def debug_text_2d(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\n        return self.debug_text_screen(text, pos, c"
 },
 "457": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "394",
  "column": "39",
  "slicing": "['    def debug_text_2d(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\\n']",
  "context": "s, size))\n\n    def debug_text_2d(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\n        return self.debug_text_screen(text, pos, c"
 },
 "458": {
  "name": "size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "394",
  "column": "92",
  "slicing": "['    def debug_text_2d(self, text: str, pos: Union[Point2, Point3, tuple, list], color=None, size: int = 8):\\n']",
  "context": ": Union[Point2, Point3, tuple, list], color=None, size: int = 8):\n        return self.debug_text_screen(text, pos, c"
 },
 "459": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "397",
  "column": "31",
  "slicing": "['    def debug_text_world(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\\n']",
  "context": "pos, color, size)\n\n    def debug_text_world(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\n        \"\"\" Draws a text at Point3 position. Don't"
 },
 "460": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "397",
  "column": "42",
  "slicing": "['    def debug_text_world(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\\n']",
  "context": " size)\n\n    def debug_text_world(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\n        \"\"\" Draws a text at Point3 position. Don't"
 },
 "461": {
  "name": "size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "397",
  "column": "88",
  "slicing": "['    def debug_text_world(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\\n']",
  "context": "tr, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\n        \"\"\" Draws a text at Point3 position. Don't"
 },
 "462": {
  "name": "pos",
  "type": "position.Point3",
  "class": "customized",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "403",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '            results = await self._execute(\\n', '                        for p1, p2 in zipped_list\\n', '            results = await self._execute(\\n', '                        query_pb.RequestQueryPathing(unit_tag=p1.tag, end_pos=common_pb.Point2D(x=p2.x, y=p2.y))\\n', '                        for p1, p2 in zipped_list\\n', '        results = [float(d.distance) for d in results.query.pathing]\\n', '        return results\\n', '        result = await self._execute(\\n', '                    for position in positions\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            units = [units]\\n', '            input_was_a_list = False\\n', '            input_was_a_list = True\\n', '        assert units\\n', '        result = await self._execute(\\n', '                abilities=[query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units],\\n', '        if not input_was_a_list:\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '        ch = ChatChannel.Team if team_only else ChatChannel.Broadcast\\n', '                actions=[sc_pb.Action(action_chat=sc_pb.ActionChat(channel=ch.value, message=message))]\\n', '                            pos=common_pb.Point2D(x=position.x, y=position.y),\\n', '                    for unit_type, amount_of_units, position, owner_id in unit_spawn_commands\\n', '            unit_tags = unit_tags.tags\\n', '        assert unit_tags\\n', '            debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(kill_unit=debug_pb.DebugKillUnit(tag=unit_tags))])\\n', '        assert isinstance(position, (Unit, Point2, Point3))\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '                                center_world_space=common_pb.Point(x=position.x, y=position.y)\\n', '        assert isinstance(position, (Point2, Point3))\\n', '        action = sc_pb.Action(\\n', '                    center_minimap=common_pb.PointI(x=position.x, y=position.y)\\n', '        await self._execute(action=sc_pb.RequestAction(actions=[action]))\\n', '                texts = [texts] * len(positions)\\n', '            assert len(texts) == len(positions)\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '                                    for t, p in zip(texts, positions)\\n', '            await self.debug_text([texts], [positions], color)\\n', '        pos = Point2((pos[0], pos[1]))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_screen(text, pos, color, size)\\n', '        if isinstance(pos, Point2) and not isinstance(pos, Point3):  # a Point3 is also a Point2\\n', '            pos = Point3((pos.x, pos.y, 0))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_world(text, pos, color, size)\\n', '                line=debug_pb.Line(p0=self.to_debug_point(p0), p1=self.to_debug_point(p1)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            r = getattr(color, \"r\", getattr(color, \"x\", 255))\\n', '            g = getattr(color, \"g\", getattr(color, \"y\", 255))\\n', '            b = getattr(color, \"b\", getattr(color, \"z\", 255))\\n', '            if max(r, g, b) <= 1:\\n', '                r *= 255\\n', '                g *= 255\\n', '                b *= 255\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n', '            point = point.position3d\\n', '        return common_pb.Point(x=point.x, y=point.y, z=getattr(point, \"z\", 0))\\n', '        color = self.to_debug_color(color)\\n', '        pt3d = self.to_debug_point(pos) if isinstance(pos, Point3) else None\\n', '        virtual_pos = self.to_debug_point(pos) if not isinstance(pos, Point3) else None\\n', '        return debug_pb.DebugText(color=color, text=text, virtual_pos=virtual_pos, world_pos=pt3d, size=size)\\n']",
  "context": "Point3):  # a Point3 is also a Point2\n            pos = Point3((pos.x, pos.y, 0))\n        self._debug_texts.append(self.to_debug_mes"
 },
 "463": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "406",
  "column": "28",
  "slicing": "['    def debug_text_3d(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\\n']",
  "context": ", color, pos, size))\n\n    def debug_text_3d(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\n        return self.debug_text_world(text, pos, co"
 },
 "464": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "406",
  "column": "39",
  "slicing": "['    def debug_text_3d(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\\n']",
  "context": "s, size))\n\n    def debug_text_3d(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\n        return self.debug_text_world(text, pos, co"
 },
 "465": {
  "name": "size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "406",
  "column": "85",
  "slicing": "['    def debug_text_3d(self, text: str, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\\n']",
  "context": "tr, pos: Union[Unit, Point2, Point3], color=None, size: int = 8):\n        return self.debug_text_world(text, pos, co"
 },
 "466": {
  "name": "p0",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "409",
  "column": "29",
  "slicing": "['    def debug_line_out(self, p0: Union[Unit, Point2, Point3], p1: Union[Unit, Point2, Point3], color=None):\\n']",
  "context": ", pos, color, size)\n\n    def debug_line_out(self, p0: Union[Unit, Point2, Point3], p1: Union[Unit, Point2, Point3], color=None):\n        \"\"\" Draws a line from p0 to p1. Don't forg"
 },
 "467": {
  "name": "p1",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "409",
  "column": "62",
  "slicing": "['    def debug_line_out(self, p0: Union[Unit, Point2, Point3], p1: Union[Unit, Point2, Point3], color=None):\\n']",
  "context": "g_line_out(self, p0: Union[Unit, Point2, Point3], p1: Union[Unit, Point2, Point3], color=None):\n        \"\"\" Draws a line from p0 to p1. Don't forg"
 },
 "468": {
  "name": "p_min",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "418",
  "column": "28",
  "slicing": "['    def debug_box_out(self, p_min: Union[Unit, Point2, Point3], p_max: Union[Unit, Point2, Point3], color=None):\\n']",
  "context": "         )\n        )\n\n    def debug_box_out(self, p_min: Union[Unit, Point2, Point3], p_max: Union[Unit, Point2, Point3], color=None):\n        \"\"\" Draws a box with p_min and p_max as co"
 },
 "469": {
  "name": "p_max",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "418",
  "column": "64",
  "slicing": "['    def debug_box_out(self, p_min: Union[Unit, Point2, Point3], p_max: Union[Unit, Point2, Point3], color=None):\\n']",
  "context": "box_out(self, p_min: Union[Unit, Point2, Point3], p_max: Union[Unit, Point2, Point3], color=None):\n        \"\"\" Draws a box with p_min and p_max as co"
 },
 "470": {
  "name": "p",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "426",
  "column": "31",
  "slicing": "['    def debug_sphere_out(self, p: Union[Unit, Point2, Point3], r: Union[int, float], color=None):\\n']",
  "context": "      )\n        )\n\n    def debug_sphere_out(self, p: Union[Unit, Point2, Point3], r: Union[int, float], color=None):\n        \"\"\" Draws a sphere at point p with radius "
 },
 "471": {
  "name": "r",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "426",
  "column": "63",
  "slicing": "['    def debug_sphere_out(self, p: Union[Unit, Point2, Point3], r: Union[int, float], color=None):\\n']",
  "context": "_sphere_out(self, p: Union[Unit, Point2, Point3], r: Union[int, float], color=None):\n        \"\"\" Draws a sphere at point p with radius "
 },
 "472": {
  "name": "r",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "458",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '            results = await self._execute(\\n', '                        for p1, p2 in zipped_list\\n', '            results = await self._execute(\\n', '                        query_pb.RequestQueryPathing(unit_tag=p1.tag, end_pos=common_pb.Point2D(x=p2.x, y=p2.y))\\n', '                        for p1, p2 in zipped_list\\n', '        results = [float(d.distance) for d in results.query.pathing]\\n', '        return results\\n', '        result = await self._execute(\\n', '                    for position in positions\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            units = [units]\\n', '            input_was_a_list = False\\n', '            input_was_a_list = True\\n', '        assert units\\n', '        result = await self._execute(\\n', '                abilities=[query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units],\\n', '        if not input_was_a_list:\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '        ch = ChatChannel.Team if team_only else ChatChannel.Broadcast\\n', '                actions=[sc_pb.Action(action_chat=sc_pb.ActionChat(channel=ch.value, message=message))]\\n', '                            pos=common_pb.Point2D(x=position.x, y=position.y),\\n', '                    for unit_type, amount_of_units, position, owner_id in unit_spawn_commands\\n', '            unit_tags = unit_tags.tags\\n', '        assert unit_tags\\n', '            debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(kill_unit=debug_pb.DebugKillUnit(tag=unit_tags))])\\n', '        assert isinstance(position, (Unit, Point2, Point3))\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '                                center_world_space=common_pb.Point(x=position.x, y=position.y)\\n', '        assert isinstance(position, (Point2, Point3))\\n', '        action = sc_pb.Action(\\n', '                    center_minimap=common_pb.PointI(x=position.x, y=position.y)\\n', '        await self._execute(action=sc_pb.RequestAction(actions=[action]))\\n', '                texts = [texts] * len(positions)\\n', '            assert len(texts) == len(positions)\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '                                    for t, p in zip(texts, positions)\\n', '            await self.debug_text([texts], [positions], color)\\n', '        pos = Point2((pos[0], pos[1]))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_screen(text, pos, color, size)\\n', '        if isinstance(pos, Point2) and not isinstance(pos, Point3):  # a Point3 is also a Point2\\n', '            pos = Point3((pos.x, pos.y, 0))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_world(text, pos, color, size)\\n', '                line=debug_pb.Line(p0=self.to_debug_point(p0), p1=self.to_debug_point(p1)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            r = getattr(color, \"r\", getattr(color, \"x\", 255))\\n', '            g = getattr(color, \"g\", getattr(color, \"y\", 255))\\n', '            b = getattr(color, \"b\", getattr(color, \"z\", 255))\\n', '            if max(r, g, b) <= 1:\\n', '                r *= 255\\n', '                g *= 255\\n', '                b *= 255\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n', '            point = point.position3d\\n', '        return common_pb.Point(x=point.x, y=point.y, z=getattr(point, \"z\", 0))\\n', '        color = self.to_debug_color(color)\\n', '        pt3d = self.to_debug_point(pos) if isinstance(pos, Point3) else None\\n', '        virtual_pos = self.to_debug_point(pos) if not isinstance(pos, Point3) else None\\n', '        return debug_pb.DebugText(color=color, text=text, virtual_pos=virtual_pos, world_pos=pt3d, size=size)\\n']",
  "context": "or(r=255, g=255, b=255)\n        else:\n            r = getattr(color, \"r\", getattr(color, \"x\", 255))\n            g = getattr(color, \"g\", getattr(color,"
 },
 "473": {
  "name": "g",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "459",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '            results = await self._execute(\\n', '                        for p1, p2 in zipped_list\\n', '            results = await self._execute(\\n', '                        query_pb.RequestQueryPathing(unit_tag=p1.tag, end_pos=common_pb.Point2D(x=p2.x, y=p2.y))\\n', '                        for p1, p2 in zipped_list\\n', '        results = [float(d.distance) for d in results.query.pathing]\\n', '        return results\\n', '        result = await self._execute(\\n', '                    for position in positions\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            units = [units]\\n', '            input_was_a_list = False\\n', '            input_was_a_list = True\\n', '        assert units\\n', '        result = await self._execute(\\n', '                abilities=[query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units],\\n', '        if not input_was_a_list:\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '        ch = ChatChannel.Team if team_only else ChatChannel.Broadcast\\n', '                actions=[sc_pb.Action(action_chat=sc_pb.ActionChat(channel=ch.value, message=message))]\\n', '                            pos=common_pb.Point2D(x=position.x, y=position.y),\\n', '                    for unit_type, amount_of_units, position, owner_id in unit_spawn_commands\\n', '            unit_tags = unit_tags.tags\\n', '        assert unit_tags\\n', '            debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(kill_unit=debug_pb.DebugKillUnit(tag=unit_tags))])\\n', '        assert isinstance(position, (Unit, Point2, Point3))\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '                                center_world_space=common_pb.Point(x=position.x, y=position.y)\\n', '        assert isinstance(position, (Point2, Point3))\\n', '        action = sc_pb.Action(\\n', '                    center_minimap=common_pb.PointI(x=position.x, y=position.y)\\n', '        await self._execute(action=sc_pb.RequestAction(actions=[action]))\\n', '                texts = [texts] * len(positions)\\n', '            assert len(texts) == len(positions)\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '                                    for t, p in zip(texts, positions)\\n', '            await self.debug_text([texts], [positions], color)\\n', '        pos = Point2((pos[0], pos[1]))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_screen(text, pos, color, size)\\n', '        if isinstance(pos, Point2) and not isinstance(pos, Point3):  # a Point3 is also a Point2\\n', '            pos = Point3((pos.x, pos.y, 0))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_world(text, pos, color, size)\\n', '                line=debug_pb.Line(p0=self.to_debug_point(p0), p1=self.to_debug_point(p1)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            r = getattr(color, \"r\", getattr(color, \"x\", 255))\\n', '            g = getattr(color, \"g\", getattr(color, \"y\", 255))\\n', '            b = getattr(color, \"b\", getattr(color, \"z\", 255))\\n', '            if max(r, g, b) <= 1:\\n', '                r *= 255\\n', '                g *= 255\\n', '                b *= 255\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n', '            point = point.position3d\\n', '        return common_pb.Point(x=point.x, y=point.y, z=getattr(point, \"z\", 0))\\n', '        color = self.to_debug_color(color)\\n', '        pt3d = self.to_debug_point(pos) if isinstance(pos, Point3) else None\\n', '        virtual_pos = self.to_debug_point(pos) if not isinstance(pos, Point3) else None\\n', '        return debug_pb.DebugText(color=color, text=text, virtual_pos=virtual_pos, world_pos=pt3d, size=size)\\n']",
  "context": "color, \"r\", getattr(color, \"x\", 255))\n            g = getattr(color, \"g\", getattr(color, \"y\", 255))\n            b = getattr(color, \"b\", getattr(color,"
 },
 "474": {
  "name": "b",
  "type": "getattr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "460",
  "column": "12",
  "slicing": "['logger = logging.getLogger(__name__)\\n', '        ifopts = sc_pb.InterfaceOptions(raw=True, score=True)\\n', \"            window_size = rgb_render_config['window_size']\\n\", \"            minimap_size = rgb_render_config['minimap_size']\\n\", '            self._renderer = Renderer(self, window_size, minimap_size)\\n', '            map_width, map_height = window_size\\n', '            minimap_width, minimap_height = minimap_size\\n', '            ifopts.render.resolution.x = map_width\\n', '            ifopts.render.resolution.y = map_height\\n', '            ifopts.render.minimap_resolution.x = minimap_width\\n', '            ifopts.render.minimap_resolution.y = minimap_height\\n', '            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\\n', '            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\\n', '            req.shared_port = portconfig.shared\\n', '            req.server_ports.game_port = portconfig.server[0]\\n', '            req.server_ports.base_port = portconfig.server[1]\\n', '            for ppc in portconfig.players:\\n', '                p = req.client_ports.add()\\n', '                p.game_port = ppc[0]\\n', '                p.base_port = ppc[1]\\n', '            req.player_name = name\\n', '        result = await self._execute(join_game=req)\\n', '        self._player_id = result.join_game.player_id\\n', '        return result.join_game.player_id\\n', '        is_resign = self._game_result is None\\n', '        if is_resign:\\n', '            if is_resign:\\n', '        logger.debug(f\"Requesting replay from server\")\\n', '        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\\n', '        with open(path, \"wb\") as f:\\n', '            f.write(result.save_replay.data)\\n', '        logger.info(f\"Saved replay to {path}\")\\n', '        result = await self._execute(observation=sc_pb.RequestObservation())\\n', '        assert result.HasField(\"observation\")\\n', '        if not self.in_game or result.observation.player_result:\\n', '            if not result.observation.player_result:\\n', '                result = await self._execute(observation=sc_pb.RequestObservation())\\n', '                assert result.observation.player_result\\n', '            player_id_to_result = {}\\n', '            for pr in result.observation.player_result:\\n', '                player_id_to_result[pr.player_id] = Result(pr.result)\\n', '            self._game_result = player_id_to_result\\n', \"        if self._renderer and result.observation.observation.HasField('render_data'):\\n\", '            await self._renderer.render(result.observation)\\n', '        return result\\n', '        result = await self._execute(step=sc_pb.RequestStep(count=self.game_step))\\n', '        return result\\n', '        result = await self._execute(data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True))\\n', '        return GameData(result.data)\\n', '        result = await self._execute(game_info=sc_pb.RequestGameInfo())\\n', '        return GameInfo(result.game_info)\\n', '            res = await self.actions([actions], game_data, return_successes)\\n', '            if res:\\n', '                return res[0]\\n', '            actions = combine_actions(actions)\\n', '            res = await self._execute(action=sc_pb.RequestAction(actions=[sc_pb.Action(action_raw=a) for a in actions]))\\n', '            res = [ActionResult(r) for r in res.action.result]\\n', '                return res\\n', '                return [r for r in res if r != ActionResult.Success]\\n', '            result = await self._execute(\\n', '            result = await self._execute(\\n', '        distance = float(result.query.pathing[0].distance)\\n', '        if distance <= 0.0:\\n', '        return distance\\n', '            results = await self._execute(\\n', '                        for p1, p2 in zipped_list\\n', '            results = await self._execute(\\n', '                        query_pb.RequestQueryPathing(unit_tag=p1.tag, end_pos=common_pb.Point2D(x=p2.x, y=p2.y))\\n', '                        for p1, p2 in zipped_list\\n', '        results = [float(d.distance) for d in results.query.pathing]\\n', '        return results\\n', '        result = await self._execute(\\n', '                    for position in positions\\n', '        return [ActionResult(p.result) for p in result.query.placements]\\n', '            units = [units]\\n', '            input_was_a_list = False\\n', '            input_was_a_list = True\\n', '        assert units\\n', '        result = await self._execute(\\n', '                abilities=[query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units],\\n', '        if not input_was_a_list:\\n', '            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\\n', '        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\\n', '        ch = ChatChannel.Team if team_only else ChatChannel.Broadcast\\n', '                actions=[sc_pb.Action(action_chat=sc_pb.ActionChat(channel=ch.value, message=message))]\\n', '                            pos=common_pb.Point2D(x=position.x, y=position.y),\\n', '                    for unit_type, amount_of_units, position, owner_id in unit_spawn_commands\\n', '            unit_tags = unit_tags.tags\\n', '        assert unit_tags\\n', '            debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(kill_unit=debug_pb.DebugKillUnit(tag=unit_tags))])\\n', '        assert isinstance(position, (Unit, Point2, Point3))\\n', '        if isinstance(position, Unit):\\n', '            position = position.position\\n', '                                center_world_space=common_pb.Point(x=position.x, y=position.y)\\n', '        assert isinstance(position, (Point2, Point3))\\n', '        action = sc_pb.Action(\\n', '                    center_minimap=common_pb.PointI(x=position.x, y=position.y)\\n', '        await self._execute(action=sc_pb.RequestAction(actions=[action]))\\n', '                texts = [texts] * len(positions)\\n', '            assert len(texts) == len(positions)\\n', '                                        world_pos=common_pb.Point(x=p.x, y=p.y, z=getattr(p, \"z\", 10)),\\n', '                                    for t, p in zip(texts, positions)\\n', '            await self.debug_text([texts], [positions], color)\\n', '        pos = Point2((pos[0], pos[1]))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_screen(text, pos, color, size)\\n', '        if isinstance(pos, Point2) and not isinstance(pos, Point3):  # a Point3 is also a Point2\\n', '            pos = Point3((pos.x, pos.y, 0))\\n', '        self._debug_texts.append(self.to_debug_message(text, color, pos, size))\\n', '        return self.debug_text_world(text, pos, color, size)\\n', '                line=debug_pb.Line(p0=self.to_debug_point(p0), p1=self.to_debug_point(p1)),\\n', '            debug_pb.DebugSphere(p=self.to_debug_point(p), r=r, color=self.to_debug_color(color))\\n', '            r = getattr(color, \"r\", getattr(color, \"x\", 255))\\n', '            g = getattr(color, \"g\", getattr(color, \"y\", 255))\\n', '            b = getattr(color, \"b\", getattr(color, \"z\", 255))\\n', '            if max(r, g, b) <= 1:\\n', '                r *= 255\\n', '                g *= 255\\n', '                b *= 255\\n', '            return debug_pb.Color(r=int(r), g=int(g), b=int(b))\\n', '            point = point.position3d\\n', '        return common_pb.Point(x=point.x, y=point.y, z=getattr(point, \"z\", 0))\\n', '        color = self.to_debug_color(color)\\n', '        pt3d = self.to_debug_point(pos) if isinstance(pos, Point3) else None\\n', '        virtual_pos = self.to_debug_point(pos) if not isinstance(pos, Point3) else None\\n', '        return debug_pb.DebugText(color=color, text=text, virtual_pos=virtual_pos, world_pos=pt3d, size=size)\\n']",
  "context": "color, \"g\", getattr(color, \"y\", 255))\n            b = getattr(color, \"b\", getattr(color, \"z\", 255))\n            if max(r, g, b) <= 1:\n                "
 },
 "475": {
  "name": "point",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "468",
  "column": "29",
  "slicing": "['    def to_debug_point(self, point: Union[Unit, Point2, Point3]) -> common_pb.Point:\\n']",
  "context": "g=int(g), b=int(b))\n\n    def to_debug_point(self, point: Union[Unit, Point2, Point3]) -> common_pb.Point:\n        \"\"\" Helper function for point conversion \""
 },
 "476": {
  "name": "text",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "475",
  "column": "14",
  "slicing": "['        self, text: str, color=None, pos: Optional[Union[Point2, Point3]] = None, size: int = 8\\n']",
  "context": "\"z\", 0))\n\n    def to_debug_message(\n        self, text: str, color=None, pos: Optional[Union[Point2, Point3]] = None, size: int = 8\n    ) -> debug_pb.DebugText:\n        \"\"\" Helper fu"
 },
 "477": {
  "name": "pos",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "475",
  "column": "37",
  "slicing": "['        self, text: str, color=None, pos: Optional[Union[Point2, Point3]] = None, size: int = 8\\n']",
  "context": "bug_message(\n        self, text: str, color=None, pos: Optional[Union[Point2, Point3]] = None, size: int = 8\n    ) -> debug_pb.DebugText:\n        \"\"\" Helper fu"
 },
 "478": {
  "name": "size",
  "type": "int",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/client.py",
  "lineno": "475",
  "column": "82",
  "slicing": "['        self, text: str, color=None, pos: Optional[Union[Point2, Point3]] = None, size: int = 8\\n']",
  "context": "one, pos: Optional[Union[Point2, Point3]] = None, size: int = 8\n    ) -> debug_pb.DebugText:\n        \"\"\" Helper fu"
 },
 "479": {
  "name": "__all__",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/ids/__init__.py",
  "lineno": "4",
  "column": "0",
  "slicing": "[\"__all__ = ['unit_typeid', 'ability_id', 'upgrade_id', 'buff_id', 'effect_id']\\n\"]",
  "context": "ated by \"generate_id_constants_from_stableid.py\"\n\n__all__ = ['unit_typeid', 'ability_id', 'upgrade_id', 'buff_id', 'effect_id']\n"
 },
 "480": {
  "name": "__all__",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "sc2/sc2/helpers/__init__.py",
  "lineno": "10",
  "column": "0",
  "slicing": "['def is_submodule(path):\\n', '        return (path / \"__init__.py\").exists()\\n', '__all__ = [p.stem for p in Path(__file__).parent.iterdir() if is_submodule(p)]\\n']",
  "context": "(path / \"__init__.py\").exists()\n    return False\n\n__all__ = [p.stem for p in Path(__file__).parent.iterdir() if is_submodule(p)]\n\nfrom .control_group import ControlGroup\n"
 }
}